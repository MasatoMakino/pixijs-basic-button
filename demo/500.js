"use strict";(self.webpackChunk_masatomakino_pixijs_basic_button=self.webpackChunk_masatomakino_pixijs_basic_button||[]).push([[500],{1660:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(4240);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/app/ResizePlugin.mjs\n\n\n"use strict";\nclass ResizePlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @static\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    Object.defineProperty(\n      this,\n      "resizeTo",\n      /**\n       * The HTML element or window to automatically resize the\n       * renderer\'s view element to match width and height.\n       * @member {Window|HTMLElement}\n       * @name resizeTo\n       * @memberof app.Application#\n       */\n      {\n        set(dom) {\n          globalThis.removeEventListener("resize", this.queueResize);\n          this._resizeTo = dom;\n          if (dom) {\n            globalThis.addEventListener("resize", this.queueResize);\n            this.resize();\n          }\n        },\n        get() {\n          return this._resizeTo;\n        }\n      }\n    );\n    this.queueResize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      this._resizeId = requestAnimationFrame(() => this.resize());\n    };\n    this._cancelResize = () => {\n      if (this._resizeId) {\n        cancelAnimationFrame(this._resizeId);\n        this._resizeId = null;\n      }\n    };\n    this.resize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      let width;\n      let height;\n      if (this._resizeTo === globalThis.window) {\n        width = globalThis.innerWidth;\n        height = globalThis.innerHeight;\n      } else {\n        const { clientWidth, clientHeight } = this._resizeTo;\n        width = clientWidth;\n        height = clientHeight;\n      }\n      this.renderer.resize(width, height);\n      this.render();\n    };\n    this._resizeId = null;\n    this._resizeTo = null;\n    this.resizeTo = options.resizeTo || null;\n  }\n  /**\n   * Clean up the ticker, scoped to application\n   * @static\n   * @private\n   */\n  static destroy() {\n    globalThis.removeEventListener("resize", this.queueResize);\n    this._cancelResize();\n    this._cancelResize = null;\n    this.queueResize = null;\n    this.resizeTo = null;\n    this.resize = null;\n  }\n}\n/** @ignore */\nResizePlugin.extension = Extensions/* ExtensionType */.y6.Application;\n\n\n//# sourceMappingURL=ResizePlugin.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/ticker/const.mjs\nvar ticker_const = __webpack_require__(8044);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/ticker/Ticker.mjs + 1 modules\nvar Ticker = __webpack_require__(8816);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/app/TickerPlugin.mjs\n\n\n\n\n"use strict";\nclass TickerPlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @static\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    options = Object.assign({\n      autoStart: true,\n      sharedTicker: false\n    }, options);\n    Object.defineProperty(\n      this,\n      "ticker",\n      {\n        set(ticker) {\n          if (this._ticker) {\n            this._ticker.remove(this.render, this);\n          }\n          this._ticker = ticker;\n          if (ticker) {\n            ticker.add(this.render, this, ticker_const/* UPDATE_PRIORITY */.c.LOW);\n          }\n        },\n        get() {\n          return this._ticker;\n        }\n      }\n    );\n    this.stop = () => {\n      this._ticker.stop();\n    };\n    this.start = () => {\n      this._ticker.start();\n    };\n    this._ticker = null;\n    this.ticker = options.sharedTicker ? Ticker/* Ticker */.g.shared : new Ticker/* Ticker */.g();\n    if (options.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Clean up the ticker, scoped to application.\n   * @static\n   * @private\n   */\n  static destroy() {\n    if (this._ticker) {\n      const oldTicker = this._ticker;\n      this.ticker = null;\n      oldTicker.destroy();\n    }\n  }\n}\n/** @ignore */\nTickerPlugin.extension = Extensions/* ExtensionType */.y6.Application;\n\n\n//# sourceMappingURL=TickerPlugin.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/app/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Yt.add(ResizePlugin);\nExtensions/* extensions */.Yt.add(TickerPlugin);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY2MC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQTZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGdCQUFnQiw0QkFBNEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWE7O0FBRWQ7QUFDeEI7Ozs7Ozs7QUN4RjZEO0FBQ1A7QUFDUjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbUNBQWU7QUFDekQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG9CQUFNLGNBQWMsb0JBQU07QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFhOztBQUVkO0FBQ3hCOzs7QUNoRTBEO0FBQ1I7QUFDQTs7QUFFbEQ7QUFDQSw2QkFBVSxLQUFLLFlBQVk7QUFDM0IsNkJBQVUsS0FBSyxZQUFZO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2FwcC9SZXNpemVQbHVnaW4ubWpzPzEwMGEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2FwcC9UaWNrZXJQbHVnaW4ubWpzP2FmMzMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL2FwcC9pbml0Lm1qcz83MmUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBSZXNpemVQbHVnaW4ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgcGx1Z2luIHdpdGggc2NvcGUgb2YgYXBwbGljYXRpb24gaW5zdGFuY2VcbiAgICogQHN0YXRpY1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gU2VlIGFwcGxpY2F0aW9uIG9wdGlvbnNcbiAgICovXG4gIHN0YXRpYyBpbml0KG9wdGlvbnMpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICB0aGlzLFxuICAgICAgXCJyZXNpemVUb1wiLFxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgSFRNTCBlbGVtZW50IG9yIHdpbmRvdyB0byBhdXRvbWF0aWNhbGx5IHJlc2l6ZSB0aGVcbiAgICAgICAqIHJlbmRlcmVyJ3MgdmlldyBlbGVtZW50IHRvIG1hdGNoIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICAgKiBAbWVtYmVyIHtXaW5kb3d8SFRNTEVsZW1lbnR9XG4gICAgICAgKiBAbmFtZSByZXNpemVUb1xuICAgICAgICogQG1lbWJlcm9mIGFwcC5BcHBsaWNhdGlvbiNcbiAgICAgICAqL1xuICAgICAge1xuICAgICAgICBzZXQoZG9tKSB7XG4gICAgICAgICAgZ2xvYmFsVGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMucXVldWVSZXNpemUpO1xuICAgICAgICAgIHRoaXMuX3Jlc2l6ZVRvID0gZG9tO1xuICAgICAgICAgIGlmIChkb20pIHtcbiAgICAgICAgICAgIGdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLnF1ZXVlUmVzaXplKTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc2l6ZVRvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLnF1ZXVlUmVzaXplID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9yZXNpemVUbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9jYW5jZWxSZXNpemUoKTtcbiAgICAgIHRoaXMuX3Jlc2l6ZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMucmVzaXplKCkpO1xuICAgIH07XG4gICAgdGhpcy5fY2FuY2VsUmVzaXplID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3Jlc2l6ZUlkKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3Jlc2l6ZUlkKTtcbiAgICAgICAgdGhpcy5fcmVzaXplSWQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5yZXNpemUgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX3Jlc2l6ZVRvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhbmNlbFJlc2l6ZSgpO1xuICAgICAgbGV0IHdpZHRoO1xuICAgICAgbGV0IGhlaWdodDtcbiAgICAgIGlmICh0aGlzLl9yZXNpemVUbyA9PT0gZ2xvYmFsVGhpcy53aW5kb3cpIHtcbiAgICAgICAgd2lkdGggPSBnbG9iYWxUaGlzLmlubmVyV2lkdGg7XG4gICAgICAgIGhlaWdodCA9IGdsb2JhbFRoaXMuaW5uZXJIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IGNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQgfSA9IHRoaXMuX3Jlc2l6ZVRvO1xuICAgICAgICB3aWR0aCA9IGNsaWVudFdpZHRoO1xuICAgICAgICBoZWlnaHQgPSBjbGllbnRIZWlnaHQ7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlcmVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfTtcbiAgICB0aGlzLl9yZXNpemVJZCA9IG51bGw7XG4gICAgdGhpcy5fcmVzaXplVG8gPSBudWxsO1xuICAgIHRoaXMucmVzaXplVG8gPSBvcHRpb25zLnJlc2l6ZVRvIHx8IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFuIHVwIHRoZSB0aWNrZXIsIHNjb3BlZCB0byBhcHBsaWNhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgZGVzdHJveSgpIHtcbiAgICBnbG9iYWxUaGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5xdWV1ZVJlc2l6ZSk7XG4gICAgdGhpcy5fY2FuY2VsUmVzaXplKCk7XG4gICAgdGhpcy5fY2FuY2VsUmVzaXplID0gbnVsbDtcbiAgICB0aGlzLnF1ZXVlUmVzaXplID0gbnVsbDtcbiAgICB0aGlzLnJlc2l6ZVRvID0gbnVsbDtcbiAgICB0aGlzLnJlc2l6ZSA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5SZXNpemVQbHVnaW4uZXh0ZW5zaW9uID0gRXh0ZW5zaW9uVHlwZS5BcHBsaWNhdGlvbjtcblxuZXhwb3J0IHsgUmVzaXplUGx1Z2luIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXNpemVQbHVnaW4ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgVVBEQVRFX1BSSU9SSVRZIH0gZnJvbSAnLi4vdGlja2VyL2NvbnN0Lm1qcyc7XG5pbXBvcnQgeyBUaWNrZXIgfSBmcm9tICcuLi90aWNrZXIvVGlja2VyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgVGlja2VyUGx1Z2luIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIHBsdWdpbiB3aXRoIHNjb3BlIG9mIGFwcGxpY2F0aW9uIGluc3RhbmNlXG4gICAqIEBzdGF0aWNcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIFNlZSBhcHBsaWNhdGlvbiBvcHRpb25zXG4gICAqL1xuICBzdGF0aWMgaW5pdChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgYXV0b1N0YXJ0OiB0cnVlLFxuICAgICAgc2hhcmVkVGlja2VyOiBmYWxzZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgIHRoaXMsXG4gICAgICBcInRpY2tlclwiLFxuICAgICAge1xuICAgICAgICBzZXQodGlja2VyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3RpY2tlcikge1xuICAgICAgICAgICAgdGhpcy5fdGlja2VyLnJlbW92ZSh0aGlzLnJlbmRlciwgdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3RpY2tlciA9IHRpY2tlcjtcbiAgICAgICAgICBpZiAodGlja2VyKSB7XG4gICAgICAgICAgICB0aWNrZXIuYWRkKHRoaXMucmVuZGVyLCB0aGlzLCBVUERBVEVfUFJJT1JJVFkuTE9XKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdGlja2VyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLnN0b3AgPSAoKSA9PiB7XG4gICAgICB0aGlzLl90aWNrZXIuc3RvcCgpO1xuICAgIH07XG4gICAgdGhpcy5zdGFydCA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3RpY2tlci5zdGFydCgpO1xuICAgIH07XG4gICAgdGhpcy5fdGlja2VyID0gbnVsbDtcbiAgICB0aGlzLnRpY2tlciA9IG9wdGlvbnMuc2hhcmVkVGlja2VyID8gVGlja2VyLnNoYXJlZCA6IG5ldyBUaWNrZXIoKTtcbiAgICBpZiAob3B0aW9ucy5hdXRvU3RhcnQpIHtcbiAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENsZWFuIHVwIHRoZSB0aWNrZXIsIHNjb3BlZCB0byBhcHBsaWNhdGlvbi5cbiAgICogQHN0YXRpY1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX3RpY2tlcikge1xuICAgICAgY29uc3Qgb2xkVGlja2VyID0gdGhpcy5fdGlja2VyO1xuICAgICAgdGhpcy50aWNrZXIgPSBudWxsO1xuICAgICAgb2xkVGlja2VyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5UaWNrZXJQbHVnaW4uZXh0ZW5zaW9uID0gRXh0ZW5zaW9uVHlwZS5BcHBsaWNhdGlvbjtcblxuZXhwb3J0IHsgVGlja2VyUGx1Z2luIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWNrZXJQbHVnaW4ubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgUmVzaXplUGx1Z2luIH0gZnJvbSAnLi9SZXNpemVQbHVnaW4ubWpzJztcbmltcG9ydCB7IFRpY2tlclBsdWdpbiB9IGZyb20gJy4vVGlja2VyUGx1Z2luLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZXh0ZW5zaW9ucy5hZGQoUmVzaXplUGx1Z2luKTtcbmV4dGVuc2lvbnMuYWRkKFRpY2tlclBsdWdpbik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1660\n')},5752:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(4240);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/filters/FilterPipe.mjs\n\n\n"use strict";\nclass FilterPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  push(filterEffect, container, instructionSet) {\n    const renderPipes = this._renderer.renderPipes;\n    renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: "filter",\n      canBundle: false,\n      action: "pushFilter",\n      container,\n      filterEffect\n    });\n  }\n  pop(_filterEffect, _container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: "filter",\n      action: "popFilter",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    if (instruction.action === "pushFilter") {\n      this._renderer.filter.push(instruction);\n    } else if (instruction.action === "popFilter") {\n      this._renderer.filter.pop();\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nFilterPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.y6.WebGLPipes,\n    Extensions/* ExtensionType */.y6.WebGPUPipes,\n    Extensions/* ExtensionType */.y6.CanvasPipes\n  ],\n  name: "filter"\n};\n\n\n//# sourceMappingURL=FilterPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(328);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/point/Point.mjs\nvar Point = __webpack_require__(1154);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs\nvar BindGroup = __webpack_require__(8384);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs + 2 modules\nvar Geometry = __webpack_require__(5364);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 2 modules\nvar UniformGroup = __webpack_require__(5596);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(8518);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs\nvar TexturePool = __webpack_require__(6899);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/types.mjs\nvar types = __webpack_require__(8640);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs\nvar Bounds = __webpack_require__(5008);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs\nvar matrixAndBoundsPool = __webpack_require__(5408);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.mjs\n\n\n\n"use strict";\nconst tempMatrix = new Matrix/* Matrix */.W();\nfunction getFastGlobalBounds(target, bounds) {\n  bounds.clear();\n  _getGlobalBoundsRecursive(target, bounds);\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  if (!target.renderGroup) {\n    bounds.applyMatrix(target.parentRenderGroup.worldTransform);\n  } else {\n    bounds.applyMatrix(target.renderGroup.localTransform);\n  }\n  return bounds;\n}\nfunction _getGlobalBoundsRecursive(target, bounds) {\n  if (target.localDisplayStatus !== 7 || !target.measurable) {\n    return;\n  }\n  const manageEffects = !!target.effects.length;\n  let localBounds = bounds;\n  if (target.renderGroup || manageEffects) {\n    localBounds = matrixAndBoundsPool/* boundsPool */.M.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, target.worldTransform);\n  } else {\n    if (target.renderPipeId) {\n      const viewBounds = target.bounds;\n      localBounds.addFrame(\n        viewBounds.minX,\n        viewBounds.minY,\n        viewBounds.maxX,\n        viewBounds.maxY,\n        target.groupTransform\n      );\n    }\n    const children = target.children;\n    for (let i = 0; i < children.length; i++) {\n      _getGlobalBoundsRecursive(children[i], localBounds);\n    }\n  }\n  if (manageEffects) {\n    let advanced = false;\n    for (let i = 0; i < target.effects.length; i++) {\n      if (target.effects[i].addBounds) {\n        if (!advanced) {\n          advanced = true;\n          localBounds.applyMatrix(target.parentRenderGroup.worldTransform);\n        }\n        target.effects[i].addBounds(localBounds, true);\n      }\n    }\n    if (advanced) {\n      localBounds.applyMatrix(target.parentRenderGroup.worldTransform.copyTo(tempMatrix).invert());\n      bounds.addBounds(localBounds, target.relativeGroupTransform);\n    }\n    bounds.addBounds(localBounds);\n    matrixAndBoundsPool/* boundsPool */.M.return(localBounds);\n  } else if (target.renderGroup) {\n    bounds.addBounds(localBounds, target.relativeGroupTransform);\n    matrixAndBoundsPool/* boundsPool */.M.return(localBounds);\n  }\n}\n\n\n//# sourceMappingURL=getFastGlobalBounds.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs\n\nfunction getGlobalRenderableBounds(renderables, bounds) {\n  bounds.clear();\n  const tempMatrix = bounds.matrix;\n  for (let i = 0; i < renderables.length; i++) {\n    const renderable = renderables[i];\n    if (renderable.globalDisplayStatus < 7) {\n      continue;\n    }\n    bounds.matrix = renderable.worldTransform;\n    renderable.addBounds(bounds);\n  }\n  bounds.matrix = tempMatrix;\n  return bounds;\n}\n\n\n//# sourceMappingURL=getRenderableBounds.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(8796);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/filters/FilterSystem.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst quadGeometry = new Geometry/* Geometry */.K({\n  attributes: {\n    aPosition: {\n      buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      location: 0,\n      format: "float32x2",\n      stride: 2 * 4,\n      offset: 0\n    }\n  },\n  indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])\n});\nclass FilterSystem {\n  constructor(renderer) {\n    this._filterStackIndex = 0;\n    this._filterStack = [];\n    this._filterGlobalUniforms = new UniformGroup/* UniformGroup */.W({\n      uInputSize: { value: new Float32Array(4), type: "vec4<f32>" },\n      uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" },\n      uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" },\n      uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" },\n      uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" },\n      uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" }\n    });\n    this._globalFilterBindGroup = new BindGroup/* BindGroup */.w({});\n    this.renderer = renderer;\n  }\n  /**\n   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n   * @readonly\n   */\n  get activeBackTexture() {\n    return this._activeFilterData?.backTexture;\n  }\n  push(instruction) {\n    const renderer = this.renderer;\n    const filters = instruction.filterEffect.filters;\n    if (!this._filterStack[this._filterStackIndex]) {\n      this._filterStack[this._filterStackIndex] = this._getFilterData();\n    }\n    const filterData = this._filterStack[this._filterStackIndex];\n    this._filterStackIndex++;\n    if (filters.length === 0) {\n      filterData.skip = true;\n      return;\n    }\n    const bounds = filterData.bounds;\n    if (instruction.renderables) {\n      getGlobalRenderableBounds(instruction.renderables, bounds);\n    } else if (instruction.filterEffect.filterArea) {\n      bounds.clear();\n      bounds.addRect(instruction.filterEffect.filterArea);\n      bounds.applyMatrix(instruction.container.worldTransform);\n    } else {\n      getFastGlobalBounds(instruction.container, bounds);\n    }\n    const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n    let resolution = Infinity;\n    let padding = 0;\n    let antialias = true;\n    let blendRequired = false;\n    let enabled = false;\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n      resolution = Math.min(resolution, filter.resolution === "inherit" ? colorTextureSource._resolution : filter.resolution);\n      padding += filter.padding;\n      if (filter.antialias === "off") {\n        antialias = false;\n      } else if (filter.antialias === "inherit") {\n        antialias && (antialias = colorTextureSource.antialias);\n      }\n      const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n      if (!isCompatible) {\n        enabled = false;\n        break;\n      }\n      if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {\n        (0,warn/* warn */.m)("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.");\n        enabled = false;\n        break;\n      }\n      enabled = filter.enabled || enabled;\n      blendRequired = blendRequired || filter.blendRequired;\n    }\n    if (!enabled) {\n      filterData.skip = true;\n      return;\n    }\n    const viewPort = renderer.renderTarget.rootViewPort;\n    bounds.scale(resolution).fitBounds(0, viewPort.width, 0, viewPort.height).scale(1 / resolution).pad(padding).ceil();\n    if (!bounds.isPositive) {\n      filterData.skip = true;\n      return;\n    }\n    filterData.skip = false;\n    filterData.bounds = bounds;\n    filterData.blendRequired = blendRequired;\n    filterData.container = instruction.container;\n    filterData.filterEffect = instruction.filterEffect;\n    filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n    filterData.inputTexture = TexturePool/* TexturePool */.W.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      resolution,\n      antialias\n    );\n    renderer.renderTarget.bind(filterData.inputTexture, true);\n    renderer.globalUniforms.push({\n      offset: bounds\n    });\n  }\n  pop() {\n    const renderer = this.renderer;\n    this._filterStackIndex--;\n    const filterData = this._filterStack[this._filterStackIndex];\n    if (filterData.skip) {\n      return;\n    }\n    this._activeFilterData = filterData;\n    const inputTexture = filterData.inputTexture;\n    const bounds = filterData.bounds;\n    let backTexture = Texture/* Texture */.w.EMPTY;\n    renderer.renderTarget.finishRenderPass();\n    if (filterData.blendRequired) {\n      const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n      const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n      backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n    }\n    filterData.backTexture = backTexture;\n    const filters = filterData.filterEffect.filters;\n    this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n    this._globalFilterBindGroup.setResource(backTexture.source, 3);\n    renderer.globalUniforms.pop();\n    if (filters.length === 1) {\n      filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n      TexturePool/* TexturePool */.W.returnTexture(inputTexture);\n    } else {\n      let flip = filterData.inputTexture;\n      let flop = TexturePool/* TexturePool */.W.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        flip.source._resolution,\n        false\n      );\n      let i = 0;\n      for (i = 0; i < filters.length - 1; ++i) {\n        const filter = filters[i];\n        filter.apply(this, flip, flop, true);\n        const t = flip;\n        flip = flop;\n        flop = t;\n      }\n      filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n      TexturePool/* TexturePool */.W.returnTexture(flip);\n      TexturePool/* TexturePool */.W.returnTexture(flop);\n    }\n    if (filterData.blendRequired) {\n      TexturePool/* TexturePool */.W.returnTexture(backTexture);\n    }\n  }\n  getBackTexture(lastRenderSurface, bounds, previousBounds) {\n    const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n    const backTexture = TexturePool/* TexturePool */.W.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      backgroundResolution,\n      false\n    );\n    let x = bounds.minX;\n    let y = bounds.minY;\n    if (previousBounds) {\n      x -= previousBounds.minX;\n      y -= previousBounds.minY;\n    }\n    x = Math.floor(x * backgroundResolution);\n    y = Math.floor(y * backgroundResolution);\n    const width = Math.ceil(bounds.width * backgroundResolution);\n    const height = Math.ceil(bounds.height * backgroundResolution);\n    this.renderer.renderTarget.copyToTexture(\n      lastRenderSurface,\n      backTexture,\n      { x, y },\n      { width, height },\n      { x: 0, y: 0 }\n    );\n    return backTexture;\n  }\n  applyFilter(filter, input, output, clear) {\n    const renderer = this.renderer;\n    const filterData = this._filterStack[this._filterStackIndex];\n    const bounds = filterData.bounds;\n    const offset = Point/* Point */.w.shared;\n    const previousRenderSurface = filterData.previousRenderSurface;\n    const isFinalTarget = previousRenderSurface === output;\n    let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n    let currentIndex = this._filterStackIndex - 1;\n    while (currentIndex > 0 && this._filterStack[currentIndex].skip) {\n      --currentIndex;\n    }\n    if (currentIndex > 0) {\n      resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n    }\n    const filterUniforms = this._filterGlobalUniforms;\n    const uniforms = filterUniforms.uniforms;\n    const outputFrame = uniforms.uOutputFrame;\n    const inputSize = uniforms.uInputSize;\n    const inputPixel = uniforms.uInputPixel;\n    const inputClamp = uniforms.uInputClamp;\n    const globalFrame = uniforms.uGlobalFrame;\n    const outputTexture = uniforms.uOutputTexture;\n    if (isFinalTarget) {\n      let lastIndex = this._filterStackIndex;\n      while (lastIndex > 0) {\n        lastIndex--;\n        const filterData2 = this._filterStack[this._filterStackIndex - 1];\n        if (!filterData2.skip) {\n          offset.x = filterData2.bounds.minX;\n          offset.y = filterData2.bounds.minY;\n          break;\n        }\n      }\n      outputFrame[0] = bounds.minX - offset.x;\n      outputFrame[1] = bounds.minY - offset.y;\n    } else {\n      outputFrame[0] = 0;\n      outputFrame[1] = 0;\n    }\n    outputFrame[2] = input.frame.width;\n    outputFrame[3] = input.frame.height;\n    inputSize[0] = input.source.width;\n    inputSize[1] = input.source.height;\n    inputSize[2] = 1 / inputSize[0];\n    inputSize[3] = 1 / inputSize[1];\n    inputPixel[0] = input.source.pixelWidth;\n    inputPixel[1] = input.source.pixelHeight;\n    inputPixel[2] = 1 / inputPixel[0];\n    inputPixel[3] = 1 / inputPixel[1];\n    inputClamp[0] = 0.5 * inputPixel[2];\n    inputClamp[1] = 0.5 * inputPixel[3];\n    inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];\n    inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];\n    const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n    globalFrame[0] = offset.x * resolution;\n    globalFrame[1] = offset.y * resolution;\n    globalFrame[2] = rootTexture.source.width * resolution;\n    globalFrame[3] = rootTexture.source.height * resolution;\n    const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n    renderer.renderTarget.bind(output, !!clear);\n    if (output instanceof Texture/* Texture */.w) {\n      outputTexture[0] = output.frame.width;\n      outputTexture[1] = output.frame.height;\n    } else {\n      outputTexture[0] = renderTarget.width;\n      outputTexture[1] = renderTarget.height;\n    }\n    outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n    filterUniforms.update();\n    if (renderer.renderPipes.uniformBatch) {\n      const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);\n      this._globalFilterBindGroup.setResource(batchUniforms, 0);\n    } else {\n      this._globalFilterBindGroup.setResource(filterUniforms, 0);\n    }\n    this._globalFilterBindGroup.setResource(input.source, 1);\n    this._globalFilterBindGroup.setResource(input.source.style, 2);\n    filter.groups[0] = this._globalFilterBindGroup;\n    renderer.encoder.draw({\n      geometry: quadGeometry,\n      shader: filter,\n      state: filter._state,\n      topology: "triangle-list"\n    });\n    if (renderer.type === types/* RendererType */.G.WEBGL) {\n      renderer.renderTarget.finishRenderPass();\n    }\n  }\n  _getFilterData() {\n    return {\n      skip: false,\n      inputTexture: null,\n      bounds: new Bounds/* Bounds */.Q(),\n      container: null,\n      filterEffect: null,\n      blendRequired: false,\n      previousRenderSurface: null\n    };\n  }\n  /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const data = this._activeFilterData;\n    const mappedMatrix = outputMatrix.set(\n      data.inputTexture._source.width,\n      0,\n      0,\n      data.inputTexture._source.height,\n      data.bounds.minX,\n      data.bounds.minY\n    );\n    const worldTransform = sprite.worldTransform.copyTo(Matrix/* Matrix */.W.shared);\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(\n      1 / sprite.texture.frame.width,\n      1 / sprite.texture.frame.height\n    );\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n    return mappedMatrix;\n  }\n}\n/** @ignore */\nFilterSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.y6.WebGLSystem,\n    Extensions/* ExtensionType */.y6.WebGPUSystem\n  ],\n  name: "filter"\n};\n\n\n//# sourceMappingURL=FilterSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/filters/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Yt.add(FilterSystem);\nExtensions/* extensions */.Yt.add(FilterPipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwwQkFBMEIseUJBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsb0JBQU07QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakI7QUFDQTtBQUNBOztBQUV3QjtBQUN4Qjs7O0FDclYwRDtBQUNaO0FBQ0k7O0FBRWxEO0FBQ0EsNkJBQVUsS0FBSyxZQUFZO0FBQzNCLDZCQUFVLEtBQUssVUFBVTtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9maWx0ZXJzL0ZpbHRlclBpcGUubWpzPzViMTciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvZ2V0RmFzdEdsb2JhbEJvdW5kcy5tanM/ODY5MCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvY29udGFpbmVyL2JvdW5kcy9nZXRSZW5kZXJhYmxlQm91bmRzLm1qcz9jYjhhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9maWx0ZXJzL0ZpbHRlclN5c3RlbS5tanM/Yzg5NCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZmlsdGVycy9pbml0Lm1qcz83MDg1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBGaWx0ZXJQaXBlIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIHB1c2goZmlsdGVyRWZmZWN0LCBjb250YWluZXIsIGluc3RydWN0aW9uU2V0KSB7XG4gICAgY29uc3QgcmVuZGVyUGlwZXMgPSB0aGlzLl9yZW5kZXJlci5yZW5kZXJQaXBlcztcbiAgICByZW5kZXJQaXBlcy5iYXRjaC5icmVhayhpbnN0cnVjdGlvblNldCk7XG4gICAgaW5zdHJ1Y3Rpb25TZXQuYWRkKHtcbiAgICAgIHJlbmRlclBpcGVJZDogXCJmaWx0ZXJcIixcbiAgICAgIGNhbkJ1bmRsZTogZmFsc2UsXG4gICAgICBhY3Rpb246IFwicHVzaEZpbHRlclwiLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgZmlsdGVyRWZmZWN0XG4gICAgfSk7XG4gIH1cbiAgcG9wKF9maWx0ZXJFZmZlY3QsIF9jb250YWluZXIsIGluc3RydWN0aW9uU2V0KSB7XG4gICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2guYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpO1xuICAgIGluc3RydWN0aW9uU2V0LmFkZCh7XG4gICAgICByZW5kZXJQaXBlSWQ6IFwiZmlsdGVyXCIsXG4gICAgICBhY3Rpb246IFwicG9wRmlsdGVyXCIsXG4gICAgICBjYW5CdW5kbGU6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgZXhlY3V0ZShpbnN0cnVjdGlvbikge1xuICAgIGlmIChpbnN0cnVjdGlvbi5hY3Rpb24gPT09IFwicHVzaEZpbHRlclwiKSB7XG4gICAgICB0aGlzLl9yZW5kZXJlci5maWx0ZXIucHVzaChpbnN0cnVjdGlvbik7XG4gICAgfSBlbHNlIGlmIChpbnN0cnVjdGlvbi5hY3Rpb24gPT09IFwicG9wRmlsdGVyXCIpIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLmZpbHRlci5wb3AoKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbkZpbHRlclBpcGUuZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHTFBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuV2ViR1BVUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNQaXBlc1xuICBdLFxuICBuYW1lOiBcImZpbHRlclwiXG59O1xuXG5leHBvcnQgeyBGaWx0ZXJQaXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWx0ZXJQaXBlLm1qcy5tYXBcbiIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IGJvdW5kc1Bvb2wgfSBmcm9tICcuL3V0aWxzL21hdHJpeEFuZEJvdW5kc1Bvb2wubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB0ZW1wTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuZnVuY3Rpb24gZ2V0RmFzdEdsb2JhbEJvdW5kcyh0YXJnZXQsIGJvdW5kcykge1xuICBib3VuZHMuY2xlYXIoKTtcbiAgX2dldEdsb2JhbEJvdW5kc1JlY3Vyc2l2ZSh0YXJnZXQsIGJvdW5kcyk7XG4gIGlmICghYm91bmRzLmlzVmFsaWQpIHtcbiAgICBib3VuZHMuc2V0KDAsIDAsIDAsIDApO1xuICB9XG4gIGlmICghdGFyZ2V0LnJlbmRlckdyb3VwKSB7XG4gICAgYm91bmRzLmFwcGx5TWF0cml4KHRhcmdldC5wYXJlbnRSZW5kZXJHcm91cC53b3JsZFRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgYm91bmRzLmFwcGx5TWF0cml4KHRhcmdldC5yZW5kZXJHcm91cC5sb2NhbFRyYW5zZm9ybSk7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcztcbn1cbmZ1bmN0aW9uIF9nZXRHbG9iYWxCb3VuZHNSZWN1cnNpdmUodGFyZ2V0LCBib3VuZHMpIHtcbiAgaWYgKHRhcmdldC5sb2NhbERpc3BsYXlTdGF0dXMgIT09IDcgfHwgIXRhcmdldC5tZWFzdXJhYmxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG1hbmFnZUVmZmVjdHMgPSAhIXRhcmdldC5lZmZlY3RzLmxlbmd0aDtcbiAgbGV0IGxvY2FsQm91bmRzID0gYm91bmRzO1xuICBpZiAodGFyZ2V0LnJlbmRlckdyb3VwIHx8IG1hbmFnZUVmZmVjdHMpIHtcbiAgICBsb2NhbEJvdW5kcyA9IGJvdW5kc1Bvb2wuZ2V0KCkuY2xlYXIoKTtcbiAgfVxuICBpZiAodGFyZ2V0LmJvdW5kc0FyZWEpIHtcbiAgICBib3VuZHMuYWRkUmVjdCh0YXJnZXQuYm91bmRzQXJlYSwgdGFyZ2V0LndvcmxkVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodGFyZ2V0LnJlbmRlclBpcGVJZCkge1xuICAgICAgY29uc3Qgdmlld0JvdW5kcyA9IHRhcmdldC5ib3VuZHM7XG4gICAgICBsb2NhbEJvdW5kcy5hZGRGcmFtZShcbiAgICAgICAgdmlld0JvdW5kcy5taW5YLFxuICAgICAgICB2aWV3Qm91bmRzLm1pblksXG4gICAgICAgIHZpZXdCb3VuZHMubWF4WCxcbiAgICAgICAgdmlld0JvdW5kcy5tYXhZLFxuICAgICAgICB0YXJnZXQuZ3JvdXBUcmFuc2Zvcm1cbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gdGFyZ2V0LmNoaWxkcmVuO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIF9nZXRHbG9iYWxCb3VuZHNSZWN1cnNpdmUoY2hpbGRyZW5baV0sIGxvY2FsQm91bmRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1hbmFnZUVmZmVjdHMpIHtcbiAgICBsZXQgYWR2YW5jZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldC5lZmZlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGFyZ2V0LmVmZmVjdHNbaV0uYWRkQm91bmRzKSB7XG4gICAgICAgIGlmICghYWR2YW5jZWQpIHtcbiAgICAgICAgICBhZHZhbmNlZCA9IHRydWU7XG4gICAgICAgICAgbG9jYWxCb3VuZHMuYXBwbHlNYXRyaXgodGFyZ2V0LnBhcmVudFJlbmRlckdyb3VwLndvcmxkVHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuZWZmZWN0c1tpXS5hZGRCb3VuZHMobG9jYWxCb3VuZHMsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWR2YW5jZWQpIHtcbiAgICAgIGxvY2FsQm91bmRzLmFwcGx5TWF0cml4KHRhcmdldC5wYXJlbnRSZW5kZXJHcm91cC53b3JsZFRyYW5zZm9ybS5jb3B5VG8odGVtcE1hdHJpeCkuaW52ZXJ0KCkpO1xuICAgICAgYm91bmRzLmFkZEJvdW5kcyhsb2NhbEJvdW5kcywgdGFyZ2V0LnJlbGF0aXZlR3JvdXBUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBib3VuZHMuYWRkQm91bmRzKGxvY2FsQm91bmRzKTtcbiAgICBib3VuZHNQb29sLnJldHVybihsb2NhbEJvdW5kcyk7XG4gIH0gZWxzZSBpZiAodGFyZ2V0LnJlbmRlckdyb3VwKSB7XG4gICAgYm91bmRzLmFkZEJvdW5kcyhsb2NhbEJvdW5kcywgdGFyZ2V0LnJlbGF0aXZlR3JvdXBUcmFuc2Zvcm0pO1xuICAgIGJvdW5kc1Bvb2wucmV0dXJuKGxvY2FsQm91bmRzKTtcbiAgfVxufVxuXG5leHBvcnQgeyBfZ2V0R2xvYmFsQm91bmRzUmVjdXJzaXZlLCBnZXRGYXN0R2xvYmFsQm91bmRzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRGYXN0R2xvYmFsQm91bmRzLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZ2V0R2xvYmFsUmVuZGVyYWJsZUJvdW5kcyhyZW5kZXJhYmxlcywgYm91bmRzKSB7XG4gIGJvdW5kcy5jbGVhcigpO1xuICBjb25zdCB0ZW1wTWF0cml4ID0gYm91bmRzLm1hdHJpeDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHJlbmRlcmFibGUgPSByZW5kZXJhYmxlc1tpXTtcbiAgICBpZiAocmVuZGVyYWJsZS5nbG9iYWxEaXNwbGF5U3RhdHVzIDwgNykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGJvdW5kcy5tYXRyaXggPSByZW5kZXJhYmxlLndvcmxkVHJhbnNmb3JtO1xuICAgIHJlbmRlcmFibGUuYWRkQm91bmRzKGJvdW5kcyk7XG4gIH1cbiAgYm91bmRzLm1hdHJpeCA9IHRlbXBNYXRyaXg7XG4gIHJldHVybiBib3VuZHM7XG59XG5cbmV4cG9ydCB7IGdldEdsb2JhbFJlbmRlcmFibGVCb3VuZHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFJlbmRlcmFibGVCb3VuZHMubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi9tYXRocy9wb2ludC9Qb2ludC5tanMnO1xuaW1wb3J0IHsgQmluZEdyb3VwIH0gZnJvbSAnLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL0JpbmRHcm91cC5tanMnO1xuaW1wb3J0IHsgR2VvbWV0cnkgfSBmcm9tICcuLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9nZW9tZXRyeS9HZW9tZXRyeS5tanMnO1xuaW1wb3J0IHsgVW5pZm9ybUdyb3VwIH0gZnJvbSAnLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc2hhZGVyL1VuaWZvcm1Hcm91cC5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZVBvb2wgfSBmcm9tICcuLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmVQb29sLm1qcyc7XG5pbXBvcnQgeyBSZW5kZXJlclR5cGUgfSBmcm9tICcuLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3R5cGVzLm1qcyc7XG5pbXBvcnQgeyBCb3VuZHMgfSBmcm9tICcuLi9zY2VuZS9jb250YWluZXIvYm91bmRzL0JvdW5kcy5tanMnO1xuaW1wb3J0IHsgZ2V0RmFzdEdsb2JhbEJvdW5kcyB9IGZyb20gJy4uL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvZ2V0RmFzdEdsb2JhbEJvdW5kcy5tanMnO1xuaW1wb3J0IHsgZ2V0R2xvYmFsUmVuZGVyYWJsZUJvdW5kcyB9IGZyb20gJy4uL3NjZW5lL2NvbnRhaW5lci9ib3VuZHMvZ2V0UmVuZGVyYWJsZUJvdW5kcy5tanMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uL3V0aWxzL2xvZ2dpbmcvd2Fybi5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHF1YWRHZW9tZXRyeSA9IG5ldyBHZW9tZXRyeSh7XG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBhUG9zaXRpb246IHtcbiAgICAgIGJ1ZmZlcjogbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMSwgMCwgMSwgMSwgMCwgMV0pLFxuICAgICAgbG9jYXRpb246IDAsXG4gICAgICBmb3JtYXQ6IFwiZmxvYXQzMngyXCIsXG4gICAgICBzdHJpZGU6IDIgKiA0LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfVxuICB9LFxuICBpbmRleEJ1ZmZlcjogbmV3IFVpbnQzMkFycmF5KFswLCAxLCAyLCAwLCAyLCAzXSlcbn0pO1xuY2xhc3MgRmlsdGVyU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9maWx0ZXJTdGFja0luZGV4ID0gMDtcbiAgICB0aGlzLl9maWx0ZXJTdGFjayA9IFtdO1xuICAgIHRoaXMuX2ZpbHRlckdsb2JhbFVuaWZvcm1zID0gbmV3IFVuaWZvcm1Hcm91cCh7XG4gICAgICB1SW5wdXRTaXplOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDQpLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH0sXG4gICAgICB1SW5wdXRQaXhlbDogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSg0KSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9LFxuICAgICAgdUlucHV0Q2xhbXA6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoNCksIHR5cGU6IFwidmVjNDxmMzI+XCIgfSxcbiAgICAgIHVPdXRwdXRGcmFtZTogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSg0KSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9LFxuICAgICAgdUdsb2JhbEZyYW1lOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDQpLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH0sXG4gICAgICB1T3V0cHV0VGV4dHVyZTogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSg0KSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9XG4gICAgfSk7XG4gICAgdGhpcy5fZ2xvYmFsRmlsdGVyQmluZEdyb3VwID0gbmV3IEJpbmRHcm91cCh7fSk7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgYmFjayB0ZXh0dXJlIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIGZpbHRlci4gUmVxdWlyZXMgdGhlIGZpbHRlciB0byBoYXZlIGBibGVuZFJlcXVpcmVkYCBzZXQgdG8gdHJ1ZS5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgYWN0aXZlQmFja1RleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUZpbHRlckRhdGE/LmJhY2tUZXh0dXJlO1xuICB9XG4gIHB1c2goaW5zdHJ1Y3Rpb24pIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgY29uc3QgZmlsdGVycyA9IGluc3RydWN0aW9uLmZpbHRlckVmZmVjdC5maWx0ZXJzO1xuICAgIGlmICghdGhpcy5fZmlsdGVyU3RhY2tbdGhpcy5fZmlsdGVyU3RhY2tJbmRleF0pIHtcbiAgICAgIHRoaXMuX2ZpbHRlclN0YWNrW3RoaXMuX2ZpbHRlclN0YWNrSW5kZXhdID0gdGhpcy5fZ2V0RmlsdGVyRGF0YSgpO1xuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJEYXRhID0gdGhpcy5fZmlsdGVyU3RhY2tbdGhpcy5fZmlsdGVyU3RhY2tJbmRleF07XG4gICAgdGhpcy5fZmlsdGVyU3RhY2tJbmRleCsrO1xuICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZmlsdGVyRGF0YS5za2lwID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYm91bmRzID0gZmlsdGVyRGF0YS5ib3VuZHM7XG4gICAgaWYgKGluc3RydWN0aW9uLnJlbmRlcmFibGVzKSB7XG4gICAgICBnZXRHbG9iYWxSZW5kZXJhYmxlQm91bmRzKGluc3RydWN0aW9uLnJlbmRlcmFibGVzLCBib3VuZHMpO1xuICAgIH0gZWxzZSBpZiAoaW5zdHJ1Y3Rpb24uZmlsdGVyRWZmZWN0LmZpbHRlckFyZWEpIHtcbiAgICAgIGJvdW5kcy5jbGVhcigpO1xuICAgICAgYm91bmRzLmFkZFJlY3QoaW5zdHJ1Y3Rpb24uZmlsdGVyRWZmZWN0LmZpbHRlckFyZWEpO1xuICAgICAgYm91bmRzLmFwcGx5TWF0cml4KGluc3RydWN0aW9uLmNvbnRhaW5lci53b3JsZFRyYW5zZm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdldEZhc3RHbG9iYWxCb3VuZHMoaW5zdHJ1Y3Rpb24uY29udGFpbmVyLCBib3VuZHMpO1xuICAgIH1cbiAgICBjb25zdCBjb2xvclRleHR1cmVTb3VyY2UgPSByZW5kZXJlci5yZW5kZXJUYXJnZXQucmVuZGVyVGFyZ2V0LmNvbG9yVGV4dHVyZS5zb3VyY2U7XG4gICAgbGV0IHJlc29sdXRpb24gPSBJbmZpbml0eTtcbiAgICBsZXQgcGFkZGluZyA9IDA7XG4gICAgbGV0IGFudGlhbGlhcyA9IHRydWU7XG4gICAgbGV0IGJsZW5kUmVxdWlyZWQgPSBmYWxzZTtcbiAgICBsZXQgZW5hYmxlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZmlsdGVyID0gZmlsdGVyc1tpXTtcbiAgICAgIHJlc29sdXRpb24gPSBNYXRoLm1pbihyZXNvbHV0aW9uLCBmaWx0ZXIucmVzb2x1dGlvbiA9PT0gXCJpbmhlcml0XCIgPyBjb2xvclRleHR1cmVTb3VyY2UuX3Jlc29sdXRpb24gOiBmaWx0ZXIucmVzb2x1dGlvbik7XG4gICAgICBwYWRkaW5nICs9IGZpbHRlci5wYWRkaW5nO1xuICAgICAgaWYgKGZpbHRlci5hbnRpYWxpYXMgPT09IFwib2ZmXCIpIHtcbiAgICAgICAgYW50aWFsaWFzID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGZpbHRlci5hbnRpYWxpYXMgPT09IFwiaW5oZXJpdFwiKSB7XG4gICAgICAgIGFudGlhbGlhcyAmJiAoYW50aWFsaWFzID0gY29sb3JUZXh0dXJlU291cmNlLmFudGlhbGlhcyk7XG4gICAgICB9XG4gICAgICBjb25zdCBpc0NvbXBhdGlibGUgPSAhIShmaWx0ZXIuY29tcGF0aWJsZVJlbmRlcmVycyAmIHJlbmRlcmVyLnR5cGUpO1xuICAgICAgaWYgKCFpc0NvbXBhdGlibGUpIHtcbiAgICAgICAgZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChmaWx0ZXIuYmxlbmRSZXF1aXJlZCAmJiAhKHJlbmRlcmVyLmJhY2tCdWZmZXI/LnVzZUJhY2tCdWZmZXIgPz8gdHJ1ZSkpIHtcbiAgICAgICAgd2FybihcIkJsZW5kIGZpbHRlciByZXF1aXJlcyBiYWNrQnVmZmVyIG9uIFdlYkdMIHJlbmRlcmVyIHRvIGJlIGVuYWJsZWQuIFNldCBgdXNlQmFja0J1ZmZlcjogdHJ1ZWAgaW4gdGhlIHJlbmRlcmVyIG9wdGlvbnMuXCIpO1xuICAgICAgICBlbmFibGVkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZW5hYmxlZCA9IGZpbHRlci5lbmFibGVkIHx8IGVuYWJsZWQ7XG4gICAgICBibGVuZFJlcXVpcmVkID0gYmxlbmRSZXF1aXJlZCB8fCBmaWx0ZXIuYmxlbmRSZXF1aXJlZDtcbiAgICB9XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICBmaWx0ZXJEYXRhLnNraXAgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2aWV3UG9ydCA9IHJlbmRlcmVyLnJlbmRlclRhcmdldC5yb290Vmlld1BvcnQ7XG4gICAgYm91bmRzLnNjYWxlKHJlc29sdXRpb24pLmZpdEJvdW5kcygwLCB2aWV3UG9ydC53aWR0aCwgMCwgdmlld1BvcnQuaGVpZ2h0KS5zY2FsZSgxIC8gcmVzb2x1dGlvbikucGFkKHBhZGRpbmcpLmNlaWwoKTtcbiAgICBpZiAoIWJvdW5kcy5pc1Bvc2l0aXZlKSB7XG4gICAgICBmaWx0ZXJEYXRhLnNraXAgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWx0ZXJEYXRhLnNraXAgPSBmYWxzZTtcbiAgICBmaWx0ZXJEYXRhLmJvdW5kcyA9IGJvdW5kcztcbiAgICBmaWx0ZXJEYXRhLmJsZW5kUmVxdWlyZWQgPSBibGVuZFJlcXVpcmVkO1xuICAgIGZpbHRlckRhdGEuY29udGFpbmVyID0gaW5zdHJ1Y3Rpb24uY29udGFpbmVyO1xuICAgIGZpbHRlckRhdGEuZmlsdGVyRWZmZWN0ID0gaW5zdHJ1Y3Rpb24uZmlsdGVyRWZmZWN0O1xuICAgIGZpbHRlckRhdGEucHJldmlvdXNSZW5kZXJTdXJmYWNlID0gcmVuZGVyZXIucmVuZGVyVGFyZ2V0LnJlbmRlclN1cmZhY2U7XG4gICAgZmlsdGVyRGF0YS5pbnB1dFRleHR1cmUgPSBUZXh0dXJlUG9vbC5nZXRPcHRpbWFsVGV4dHVyZShcbiAgICAgIGJvdW5kcy53aWR0aCxcbiAgICAgIGJvdW5kcy5oZWlnaHQsXG4gICAgICByZXNvbHV0aW9uLFxuICAgICAgYW50aWFsaWFzXG4gICAgKTtcbiAgICByZW5kZXJlci5yZW5kZXJUYXJnZXQuYmluZChmaWx0ZXJEYXRhLmlucHV0VGV4dHVyZSwgdHJ1ZSk7XG4gICAgcmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMucHVzaCh7XG4gICAgICBvZmZzZXQ6IGJvdW5kc1xuICAgIH0pO1xuICB9XG4gIHBvcCgpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgdGhpcy5fZmlsdGVyU3RhY2tJbmRleC0tO1xuICAgIGNvbnN0IGZpbHRlckRhdGEgPSB0aGlzLl9maWx0ZXJTdGFja1t0aGlzLl9maWx0ZXJTdGFja0luZGV4XTtcbiAgICBpZiAoZmlsdGVyRGF0YS5za2lwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZUZpbHRlckRhdGEgPSBmaWx0ZXJEYXRhO1xuICAgIGNvbnN0IGlucHV0VGV4dHVyZSA9IGZpbHRlckRhdGEuaW5wdXRUZXh0dXJlO1xuICAgIGNvbnN0IGJvdW5kcyA9IGZpbHRlckRhdGEuYm91bmRzO1xuICAgIGxldCBiYWNrVGV4dHVyZSA9IFRleHR1cmUuRU1QVFk7XG4gICAgcmVuZGVyZXIucmVuZGVyVGFyZ2V0LmZpbmlzaFJlbmRlclBhc3MoKTtcbiAgICBpZiAoZmlsdGVyRGF0YS5ibGVuZFJlcXVpcmVkKSB7XG4gICAgICBjb25zdCBwcmV2aW91c0JvdW5kcyA9IHRoaXMuX2ZpbHRlclN0YWNrSW5kZXggPiAwID8gdGhpcy5fZmlsdGVyU3RhY2tbdGhpcy5fZmlsdGVyU3RhY2tJbmRleCAtIDFdLmJvdW5kcyA6IG51bGw7XG4gICAgICBjb25zdCByZW5kZXJUYXJnZXQgPSByZW5kZXJlci5yZW5kZXJUYXJnZXQuZ2V0UmVuZGVyVGFyZ2V0KGZpbHRlckRhdGEucHJldmlvdXNSZW5kZXJTdXJmYWNlKTtcbiAgICAgIGJhY2tUZXh0dXJlID0gdGhpcy5nZXRCYWNrVGV4dHVyZShyZW5kZXJUYXJnZXQsIGJvdW5kcywgcHJldmlvdXNCb3VuZHMpO1xuICAgIH1cbiAgICBmaWx0ZXJEYXRhLmJhY2tUZXh0dXJlID0gYmFja1RleHR1cmU7XG4gICAgY29uc3QgZmlsdGVycyA9IGZpbHRlckRhdGEuZmlsdGVyRWZmZWN0LmZpbHRlcnM7XG4gICAgdGhpcy5fZ2xvYmFsRmlsdGVyQmluZEdyb3VwLnNldFJlc291cmNlKGlucHV0VGV4dHVyZS5zb3VyY2Uuc3R5bGUsIDIpO1xuICAgIHRoaXMuX2dsb2JhbEZpbHRlckJpbmRHcm91cC5zZXRSZXNvdXJjZShiYWNrVGV4dHVyZS5zb3VyY2UsIDMpO1xuICAgIHJlbmRlcmVyLmdsb2JhbFVuaWZvcm1zLnBvcCgpO1xuICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZmlsdGVyc1swXS5hcHBseSh0aGlzLCBpbnB1dFRleHR1cmUsIGZpbHRlckRhdGEucHJldmlvdXNSZW5kZXJTdXJmYWNlLCBmYWxzZSk7XG4gICAgICBUZXh0dXJlUG9vbC5yZXR1cm5UZXh0dXJlKGlucHV0VGV4dHVyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBmbGlwID0gZmlsdGVyRGF0YS5pbnB1dFRleHR1cmU7XG4gICAgICBsZXQgZmxvcCA9IFRleHR1cmVQb29sLmdldE9wdGltYWxUZXh0dXJlKFxuICAgICAgICBib3VuZHMud2lkdGgsXG4gICAgICAgIGJvdW5kcy5oZWlnaHQsXG4gICAgICAgIGZsaXAuc291cmNlLl9yZXNvbHV0aW9uLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSBmaWx0ZXJzW2ldO1xuICAgICAgICBmaWx0ZXIuYXBwbHkodGhpcywgZmxpcCwgZmxvcCwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHQgPSBmbGlwO1xuICAgICAgICBmbGlwID0gZmxvcDtcbiAgICAgICAgZmxvcCA9IHQ7XG4gICAgICB9XG4gICAgICBmaWx0ZXJzW2ldLmFwcGx5KHRoaXMsIGZsaXAsIGZpbHRlckRhdGEucHJldmlvdXNSZW5kZXJTdXJmYWNlLCBmYWxzZSk7XG4gICAgICBUZXh0dXJlUG9vbC5yZXR1cm5UZXh0dXJlKGZsaXApO1xuICAgICAgVGV4dHVyZVBvb2wucmV0dXJuVGV4dHVyZShmbG9wKTtcbiAgICB9XG4gICAgaWYgKGZpbHRlckRhdGEuYmxlbmRSZXF1aXJlZCkge1xuICAgICAgVGV4dHVyZVBvb2wucmV0dXJuVGV4dHVyZShiYWNrVGV4dHVyZSk7XG4gICAgfVxuICB9XG4gIGdldEJhY2tUZXh0dXJlKGxhc3RSZW5kZXJTdXJmYWNlLCBib3VuZHMsIHByZXZpb3VzQm91bmRzKSB7XG4gICAgY29uc3QgYmFja2dyb3VuZFJlc29sdXRpb24gPSBsYXN0UmVuZGVyU3VyZmFjZS5jb2xvclRleHR1cmUuc291cmNlLl9yZXNvbHV0aW9uO1xuICAgIGNvbnN0IGJhY2tUZXh0dXJlID0gVGV4dHVyZVBvb2wuZ2V0T3B0aW1hbFRleHR1cmUoXG4gICAgICBib3VuZHMud2lkdGgsXG4gICAgICBib3VuZHMuaGVpZ2h0LFxuICAgICAgYmFja2dyb3VuZFJlc29sdXRpb24sXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgbGV0IHggPSBib3VuZHMubWluWDtcbiAgICBsZXQgeSA9IGJvdW5kcy5taW5ZO1xuICAgIGlmIChwcmV2aW91c0JvdW5kcykge1xuICAgICAgeCAtPSBwcmV2aW91c0JvdW5kcy5taW5YO1xuICAgICAgeSAtPSBwcmV2aW91c0JvdW5kcy5taW5ZO1xuICAgIH1cbiAgICB4ID0gTWF0aC5mbG9vcih4ICogYmFja2dyb3VuZFJlc29sdXRpb24pO1xuICAgIHkgPSBNYXRoLmZsb29yKHkgKiBiYWNrZ3JvdW5kUmVzb2x1dGlvbik7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLmNlaWwoYm91bmRzLndpZHRoICogYmFja2dyb3VuZFJlc29sdXRpb24pO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGguY2VpbChib3VuZHMuaGVpZ2h0ICogYmFja2dyb3VuZFJlc29sdXRpb24pO1xuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyVGFyZ2V0LmNvcHlUb1RleHR1cmUoXG4gICAgICBsYXN0UmVuZGVyU3VyZmFjZSxcbiAgICAgIGJhY2tUZXh0dXJlLFxuICAgICAgeyB4LCB5IH0sXG4gICAgICB7IHdpZHRoLCBoZWlnaHQgfSxcbiAgICAgIHsgeDogMCwgeTogMCB9XG4gICAgKTtcbiAgICByZXR1cm4gYmFja1RleHR1cmU7XG4gIH1cbiAgYXBwbHlGaWx0ZXIoZmlsdGVyLCBpbnB1dCwgb3V0cHV0LCBjbGVhcikge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBjb25zdCBmaWx0ZXJEYXRhID0gdGhpcy5fZmlsdGVyU3RhY2tbdGhpcy5fZmlsdGVyU3RhY2tJbmRleF07XG4gICAgY29uc3QgYm91bmRzID0gZmlsdGVyRGF0YS5ib3VuZHM7XG4gICAgY29uc3Qgb2Zmc2V0ID0gUG9pbnQuc2hhcmVkO1xuICAgIGNvbnN0IHByZXZpb3VzUmVuZGVyU3VyZmFjZSA9IGZpbHRlckRhdGEucHJldmlvdXNSZW5kZXJTdXJmYWNlO1xuICAgIGNvbnN0IGlzRmluYWxUYXJnZXQgPSBwcmV2aW91c1JlbmRlclN1cmZhY2UgPT09IG91dHB1dDtcbiAgICBsZXQgcmVzb2x1dGlvbiA9IHRoaXMucmVuZGVyZXIucmVuZGVyVGFyZ2V0LnJvb3RSZW5kZXJUYXJnZXQuY29sb3JUZXh0dXJlLnNvdXJjZS5fcmVzb2x1dGlvbjtcbiAgICBsZXQgY3VycmVudEluZGV4ID0gdGhpcy5fZmlsdGVyU3RhY2tJbmRleCAtIDE7XG4gICAgd2hpbGUgKGN1cnJlbnRJbmRleCA+IDAgJiYgdGhpcy5fZmlsdGVyU3RhY2tbY3VycmVudEluZGV4XS5za2lwKSB7XG4gICAgICAtLWN1cnJlbnRJbmRleDtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRJbmRleCA+IDApIHtcbiAgICAgIHJlc29sdXRpb24gPSB0aGlzLl9maWx0ZXJTdGFja1tjdXJyZW50SW5kZXhdLmlucHV0VGV4dHVyZS5zb3VyY2UuX3Jlc29sdXRpb247XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlclVuaWZvcm1zID0gdGhpcy5fZmlsdGVyR2xvYmFsVW5pZm9ybXM7XG4gICAgY29uc3QgdW5pZm9ybXMgPSBmaWx0ZXJVbmlmb3Jtcy51bmlmb3JtcztcbiAgICBjb25zdCBvdXRwdXRGcmFtZSA9IHVuaWZvcm1zLnVPdXRwdXRGcmFtZTtcbiAgICBjb25zdCBpbnB1dFNpemUgPSB1bmlmb3Jtcy51SW5wdXRTaXplO1xuICAgIGNvbnN0IGlucHV0UGl4ZWwgPSB1bmlmb3Jtcy51SW5wdXRQaXhlbDtcbiAgICBjb25zdCBpbnB1dENsYW1wID0gdW5pZm9ybXMudUlucHV0Q2xhbXA7XG4gICAgY29uc3QgZ2xvYmFsRnJhbWUgPSB1bmlmb3Jtcy51R2xvYmFsRnJhbWU7XG4gICAgY29uc3Qgb3V0cHV0VGV4dHVyZSA9IHVuaWZvcm1zLnVPdXRwdXRUZXh0dXJlO1xuICAgIGlmIChpc0ZpbmFsVGFyZ2V0KSB7XG4gICAgICBsZXQgbGFzdEluZGV4ID0gdGhpcy5fZmlsdGVyU3RhY2tJbmRleDtcbiAgICAgIHdoaWxlIChsYXN0SW5kZXggPiAwKSB7XG4gICAgICAgIGxhc3RJbmRleC0tO1xuICAgICAgICBjb25zdCBmaWx0ZXJEYXRhMiA9IHRoaXMuX2ZpbHRlclN0YWNrW3RoaXMuX2ZpbHRlclN0YWNrSW5kZXggLSAxXTtcbiAgICAgICAgaWYgKCFmaWx0ZXJEYXRhMi5za2lwKSB7XG4gICAgICAgICAgb2Zmc2V0LnggPSBmaWx0ZXJEYXRhMi5ib3VuZHMubWluWDtcbiAgICAgICAgICBvZmZzZXQueSA9IGZpbHRlckRhdGEyLmJvdW5kcy5taW5ZO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvdXRwdXRGcmFtZVswXSA9IGJvdW5kcy5taW5YIC0gb2Zmc2V0Lng7XG4gICAgICBvdXRwdXRGcmFtZVsxXSA9IGJvdW5kcy5taW5ZIC0gb2Zmc2V0Lnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dEZyYW1lWzBdID0gMDtcbiAgICAgIG91dHB1dEZyYW1lWzFdID0gMDtcbiAgICB9XG4gICAgb3V0cHV0RnJhbWVbMl0gPSBpbnB1dC5mcmFtZS53aWR0aDtcbiAgICBvdXRwdXRGcmFtZVszXSA9IGlucHV0LmZyYW1lLmhlaWdodDtcbiAgICBpbnB1dFNpemVbMF0gPSBpbnB1dC5zb3VyY2Uud2lkdGg7XG4gICAgaW5wdXRTaXplWzFdID0gaW5wdXQuc291cmNlLmhlaWdodDtcbiAgICBpbnB1dFNpemVbMl0gPSAxIC8gaW5wdXRTaXplWzBdO1xuICAgIGlucHV0U2l6ZVszXSA9IDEgLyBpbnB1dFNpemVbMV07XG4gICAgaW5wdXRQaXhlbFswXSA9IGlucHV0LnNvdXJjZS5waXhlbFdpZHRoO1xuICAgIGlucHV0UGl4ZWxbMV0gPSBpbnB1dC5zb3VyY2UucGl4ZWxIZWlnaHQ7XG4gICAgaW5wdXRQaXhlbFsyXSA9IDEgLyBpbnB1dFBpeGVsWzBdO1xuICAgIGlucHV0UGl4ZWxbM10gPSAxIC8gaW5wdXRQaXhlbFsxXTtcbiAgICBpbnB1dENsYW1wWzBdID0gMC41ICogaW5wdXRQaXhlbFsyXTtcbiAgICBpbnB1dENsYW1wWzFdID0gMC41ICogaW5wdXRQaXhlbFszXTtcbiAgICBpbnB1dENsYW1wWzJdID0gaW5wdXQuZnJhbWUud2lkdGggKiBpbnB1dFNpemVbMl0gLSAwLjUgKiBpbnB1dFBpeGVsWzJdO1xuICAgIGlucHV0Q2xhbXBbM10gPSBpbnB1dC5mcmFtZS5oZWlnaHQgKiBpbnB1dFNpemVbM10gLSAwLjUgKiBpbnB1dFBpeGVsWzNdO1xuICAgIGNvbnN0IHJvb3RUZXh0dXJlID0gdGhpcy5yZW5kZXJlci5yZW5kZXJUYXJnZXQucm9vdFJlbmRlclRhcmdldC5jb2xvclRleHR1cmU7XG4gICAgZ2xvYmFsRnJhbWVbMF0gPSBvZmZzZXQueCAqIHJlc29sdXRpb247XG4gICAgZ2xvYmFsRnJhbWVbMV0gPSBvZmZzZXQueSAqIHJlc29sdXRpb247XG4gICAgZ2xvYmFsRnJhbWVbMl0gPSByb290VGV4dHVyZS5zb3VyY2Uud2lkdGggKiByZXNvbHV0aW9uO1xuICAgIGdsb2JhbEZyYW1lWzNdID0gcm9vdFRleHR1cmUuc291cmNlLmhlaWdodCAqIHJlc29sdXRpb247XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJlci5yZW5kZXJUYXJnZXQuZ2V0UmVuZGVyVGFyZ2V0KG91dHB1dCk7XG4gICAgcmVuZGVyZXIucmVuZGVyVGFyZ2V0LmJpbmQob3V0cHV0LCAhIWNsZWFyKTtcbiAgICBpZiAob3V0cHV0IGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgb3V0cHV0VGV4dHVyZVswXSA9IG91dHB1dC5mcmFtZS53aWR0aDtcbiAgICAgIG91dHB1dFRleHR1cmVbMV0gPSBvdXRwdXQuZnJhbWUuaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXRUZXh0dXJlWzBdID0gcmVuZGVyVGFyZ2V0LndpZHRoO1xuICAgICAgb3V0cHV0VGV4dHVyZVsxXSA9IHJlbmRlclRhcmdldC5oZWlnaHQ7XG4gICAgfVxuICAgIG91dHB1dFRleHR1cmVbMl0gPSByZW5kZXJUYXJnZXQuaXNSb290ID8gLTEgOiAxO1xuICAgIGZpbHRlclVuaWZvcm1zLnVwZGF0ZSgpO1xuICAgIGlmIChyZW5kZXJlci5yZW5kZXJQaXBlcy51bmlmb3JtQmF0Y2gpIHtcbiAgICAgIGNvbnN0IGJhdGNoVW5pZm9ybXMgPSByZW5kZXJlci5yZW5kZXJQaXBlcy51bmlmb3JtQmF0Y2guZ2V0VWJvUmVzb3VyY2UoZmlsdGVyVW5pZm9ybXMpO1xuICAgICAgdGhpcy5fZ2xvYmFsRmlsdGVyQmluZEdyb3VwLnNldFJlc291cmNlKGJhdGNoVW5pZm9ybXMsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9nbG9iYWxGaWx0ZXJCaW5kR3JvdXAuc2V0UmVzb3VyY2UoZmlsdGVyVW5pZm9ybXMsIDApO1xuICAgIH1cbiAgICB0aGlzLl9nbG9iYWxGaWx0ZXJCaW5kR3JvdXAuc2V0UmVzb3VyY2UoaW5wdXQuc291cmNlLCAxKTtcbiAgICB0aGlzLl9nbG9iYWxGaWx0ZXJCaW5kR3JvdXAuc2V0UmVzb3VyY2UoaW5wdXQuc291cmNlLnN0eWxlLCAyKTtcbiAgICBmaWx0ZXIuZ3JvdXBzWzBdID0gdGhpcy5fZ2xvYmFsRmlsdGVyQmluZEdyb3VwO1xuICAgIHJlbmRlcmVyLmVuY29kZXIuZHJhdyh7XG4gICAgICBnZW9tZXRyeTogcXVhZEdlb21ldHJ5LFxuICAgICAgc2hhZGVyOiBmaWx0ZXIsXG4gICAgICBzdGF0ZTogZmlsdGVyLl9zdGF0ZSxcbiAgICAgIHRvcG9sb2d5OiBcInRyaWFuZ2xlLWxpc3RcIlxuICAgIH0pO1xuICAgIGlmIChyZW5kZXJlci50eXBlID09PSBSZW5kZXJlclR5cGUuV0VCR0wpIHtcbiAgICAgIHJlbmRlcmVyLnJlbmRlclRhcmdldC5maW5pc2hSZW5kZXJQYXNzKCk7XG4gICAgfVxuICB9XG4gIF9nZXRGaWx0ZXJEYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBza2lwOiBmYWxzZSxcbiAgICAgIGlucHV0VGV4dHVyZTogbnVsbCxcbiAgICAgIGJvdW5kczogbmV3IEJvdW5kcygpLFxuICAgICAgY29udGFpbmVyOiBudWxsLFxuICAgICAgZmlsdGVyRWZmZWN0OiBudWxsLFxuICAgICAgYmxlbmRSZXF1aXJlZDogZmFsc2UsXG4gICAgICBwcmV2aW91c1JlbmRlclN1cmZhY2U6IG51bGxcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBNdWx0aXBseSBfaW5wdXQgbm9ybWFsaXplZCBjb29yZGluYXRlc18gdG8gdGhpcyBtYXRyaXggdG8gZ2V0IF9zcHJpdGUgdGV4dHVyZSBub3JtYWxpemVkIGNvb3JkaW5hdGVzXy5cbiAgICpcbiAgICogVXNlIGBvdXRwdXRNYXRyaXggKiB2VGV4dHVyZUNvb3JkYCBpbiB0aGUgc2hhZGVyLlxuICAgKiBAcGFyYW0gb3V0cHV0TWF0cml4IC0gVGhlIG1hdHJpeCB0byBvdXRwdXQgdG8uXG4gICAqIEBwYXJhbSB7U3ByaXRlfSBzcHJpdGUgLSBUaGUgc3ByaXRlIHRvIG1hcCB0by5cbiAgICogQHJldHVybnMgVGhlIG1hcHBlZCBtYXRyaXguXG4gICAqL1xuICBjYWxjdWxhdGVTcHJpdGVNYXRyaXgob3V0cHV0TWF0cml4LCBzcHJpdGUpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fYWN0aXZlRmlsdGVyRGF0YTtcbiAgICBjb25zdCBtYXBwZWRNYXRyaXggPSBvdXRwdXRNYXRyaXguc2V0KFxuICAgICAgZGF0YS5pbnB1dFRleHR1cmUuX3NvdXJjZS53aWR0aCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgZGF0YS5pbnB1dFRleHR1cmUuX3NvdXJjZS5oZWlnaHQsXG4gICAgICBkYXRhLmJvdW5kcy5taW5YLFxuICAgICAgZGF0YS5ib3VuZHMubWluWVxuICAgICk7XG4gICAgY29uc3Qgd29ybGRUcmFuc2Zvcm0gPSBzcHJpdGUud29ybGRUcmFuc2Zvcm0uY29weVRvKE1hdHJpeC5zaGFyZWQpO1xuICAgIHdvcmxkVHJhbnNmb3JtLmludmVydCgpO1xuICAgIG1hcHBlZE1hdHJpeC5wcmVwZW5kKHdvcmxkVHJhbnNmb3JtKTtcbiAgICBtYXBwZWRNYXRyaXguc2NhbGUoXG4gICAgICAxIC8gc3ByaXRlLnRleHR1cmUuZnJhbWUud2lkdGgsXG4gICAgICAxIC8gc3ByaXRlLnRleHR1cmUuZnJhbWUuaGVpZ2h0XG4gICAgKTtcbiAgICBtYXBwZWRNYXRyaXgudHJhbnNsYXRlKHNwcml0ZS5hbmNob3IueCwgc3ByaXRlLmFuY2hvci55KTtcbiAgICByZXR1cm4gbWFwcGVkTWF0cml4O1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuRmlsdGVyU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJmaWx0ZXJcIlxufTtcblxuZXhwb3J0IHsgRmlsdGVyU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWx0ZXJTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgRmlsdGVyUGlwZSB9IGZyb20gJy4vRmlsdGVyUGlwZS5tanMnO1xuaW1wb3J0IHsgRmlsdGVyU3lzdGVtIH0gZnJvbSAnLi9GaWx0ZXJTeXN0ZW0ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5leHRlbnNpb25zLmFkZChGaWx0ZXJTeXN0ZW0pO1xuZXh0ZW5zaW9ucy5hZGQoRmlsdGVyUGlwZSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5752\n')},9208:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   q: () => (/* binding */ getBatchSamplersUniformGroup)\n/* harmony export */ });\n/* harmony import */ var _shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5596);\n\n\n"use strict";\nconst batchSamplersUniformGroupHash = {};\nfunction getBatchSamplersUniformGroup(maxTextures) {\n  let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];\n  if (batchSamplersUniformGroup)\n    return batchSamplersUniformGroup;\n  const sampleValues = new Int32Array(maxTextures);\n  for (let i = 0; i < maxTextures; i++) {\n    sampleValues[i] = i;\n  }\n  batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new _shared_shader_UniformGroup_mjs__WEBPACK_IMPORTED_MODULE_0__/* .UniformGroup */ .W({\n    uTextures: { value: sampleValues, type: `i32`, size: maxTextures }\n  }, { isStatic: true });\n  return batchSamplersUniformGroup;\n}\n\n\n//# sourceMappingURL=getBatchSamplersUniformGroup.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTIwOC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQW9FOztBQUVwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBLCtFQUErRSxrRkFBWTtBQUMzRixpQkFBaUI7QUFDakIsR0FBRyxJQUFJLGdCQUFnQjtBQUN2QjtBQUNBOztBQUV3QztBQUN4QyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9nZXRCYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwLm1qcz8xN2UyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFVuaWZvcm1Hcm91cCB9IGZyb20gJy4uLy4uL3NoYXJlZC9zaGFkZXIvVW5pZm9ybUdyb3VwLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgYmF0Y2hTYW1wbGVyc1VuaWZvcm1Hcm91cEhhc2ggPSB7fTtcbmZ1bmN0aW9uIGdldEJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXAobWF4VGV4dHVyZXMpIHtcbiAgbGV0IGJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXAgPSBiYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwSGFzaFttYXhUZXh0dXJlc107XG4gIGlmIChiYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwKVxuICAgIHJldHVybiBiYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwO1xuICBjb25zdCBzYW1wbGVWYWx1ZXMgPSBuZXcgSW50MzJBcnJheShtYXhUZXh0dXJlcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4VGV4dHVyZXM7IGkrKykge1xuICAgIHNhbXBsZVZhbHVlc1tpXSA9IGk7XG4gIH1cbiAgYmF0Y2hTYW1wbGVyc1VuaWZvcm1Hcm91cCA9IGJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXBIYXNoW21heFRleHR1cmVzXSA9IG5ldyBVbmlmb3JtR3JvdXAoe1xuICAgIHVUZXh0dXJlczogeyB2YWx1ZTogc2FtcGxlVmFsdWVzLCB0eXBlOiBgaTMyYCwgc2l6ZTogbWF4VGV4dHVyZXMgfVxuICB9LCB7IGlzU3RhdGljOiB0cnVlIH0pO1xuICByZXR1cm4gYmF0Y2hTYW1wbGVyc1VuaWZvcm1Hcm91cDtcbn1cblxuZXhwb3J0IHsgZ2V0QmF0Y2hTYW1wbGVyc1VuaWZvcm1Hcm91cCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0QmF0Y2hTYW1wbGVyc1VuaWZvcm1Hcm91cC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9208\n')},8168:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   G: () => (/* binding */ CanvasPool)\n/* harmony export */ });\n/* unused harmony export CanvasPoolClass */\n/* harmony import */ var _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(184);\n/* harmony import */ var _maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8152);\n\n\n\n"use strict";\nclass CanvasPoolClass {\n  constructor(canvasOptions) {\n    this._canvasPool = /* @__PURE__ */ Object.create(null);\n    this.canvasOptions = canvasOptions || {};\n    this.enableFullScreen = false;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   */\n  _createCanvasAndContext(pixelWidth, pixelHeight) {\n    const canvas = _environment_adapter_mjs__WEBPACK_IMPORTED_MODULE_0__/* .DOMAdapter */ .m.get().createCanvas();\n    canvas.width = pixelWidth;\n    canvas.height = pixelHeight;\n    const context = canvas.getContext("2d");\n    return { canvas, context };\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param minWidth - The minimum width of the render texture.\n   * @param minHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @returns The new render texture.\n   */\n  getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {\n    minWidth = Math.ceil(minWidth * resolution - 1e-6);\n    minHeight = Math.ceil(minHeight * resolution - 1e-6);\n    minWidth = (0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__/* .nextPow2 */ .W8)(minWidth);\n    minHeight = (0,_maths_misc_pow2_mjs__WEBPACK_IMPORTED_MODULE_1__/* .nextPow2 */ .W8)(minHeight);\n    const key = (minWidth << 17) + (minHeight << 1);\n    if (!this._canvasPool[key]) {\n      this._canvasPool[key] = [];\n    }\n    let canvasAndContext = this._canvasPool[key].pop();\n    if (!canvasAndContext) {\n      canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n    }\n    return canvasAndContext;\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param canvasAndContext\n   */\n  returnCanvasAndContext(canvasAndContext) {\n    const canvas = canvasAndContext.canvas;\n    const { width, height } = canvas;\n    const key = (width << 17) + (height << 1);\n    this._canvasPool[key].push(canvasAndContext);\n  }\n  clear() {\n    this._canvasPool = {};\n  }\n}\nconst CanvasPool = new CanvasPoolClass();\n\n\n//# sourceMappingURL=CanvasPool.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE2OC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBaUU7QUFDTjs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdFQUFRO0FBQ3ZCLGdCQUFnQix3RUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVDO0FBQ3ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvQ2FudmFzUG9vbC5tanM/ZTMxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBET01BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vZW52aXJvbm1lbnQvYWRhcHRlci5tanMnO1xuaW1wb3J0IHsgbmV4dFBvdzIgfSBmcm9tICcuLi8uLi8uLi8uLi9tYXRocy9taXNjL3BvdzIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBDYW52YXNQb29sQ2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjYW52YXNPcHRpb25zKSB7XG4gICAgdGhpcy5fY2FudmFzUG9vbCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuY2FudmFzT3B0aW9ucyA9IGNhbnZhc09wdGlvbnMgfHwge307XG4gICAgdGhpcy5lbmFibGVGdWxsU2NyZWVuID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGV4dHVyZSB3aXRoIHBhcmFtcyB0aGF0IHdlcmUgc3BlY2lmaWVkIGluIHBvb2wgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSBwaXhlbFdpZHRoIC0gV2lkdGggb2YgdGV4dHVyZSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSBwaXhlbEhlaWdodCAtIEhlaWdodCBvZiB0ZXh0dXJlIGluIHBpeGVscy5cbiAgICovXG4gIF9jcmVhdGVDYW52YXNBbmRDb250ZXh0KHBpeGVsV2lkdGgsIHBpeGVsSGVpZ2h0KSB7XG4gICAgY29uc3QgY2FudmFzID0gRE9NQWRhcHRlci5nZXQoKS5jcmVhdGVDYW52YXMoKTtcbiAgICBjYW52YXMud2lkdGggPSBwaXhlbFdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBwaXhlbEhlaWdodDtcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICByZXR1cm4geyBjYW52YXMsIGNvbnRleHQgfTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhIFBvd2VyLW9mLVR3byByZW5kZXIgdGV4dHVyZSBvciBmdWxsU2NyZWVuIHRleHR1cmVcbiAgICogQHBhcmFtIG1pbldpZHRoIC0gVGhlIG1pbmltdW0gd2lkdGggb2YgdGhlIHJlbmRlciB0ZXh0dXJlLlxuICAgKiBAcGFyYW0gbWluSGVpZ2h0IC0gVGhlIG1pbmltdW0gaGVpZ2h0IG9mIHRoZSByZW5kZXIgdGV4dHVyZS5cbiAgICogQHBhcmFtIHJlc29sdXRpb24gLSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgcmVuZGVyIHRleHR1cmUuXG4gICAqIEByZXR1cm5zIFRoZSBuZXcgcmVuZGVyIHRleHR1cmUuXG4gICAqL1xuICBnZXRPcHRpbWFsQ2FudmFzQW5kQ29udGV4dChtaW5XaWR0aCwgbWluSGVpZ2h0LCByZXNvbHV0aW9uID0gMSkge1xuICAgIG1pbldpZHRoID0gTWF0aC5jZWlsKG1pbldpZHRoICogcmVzb2x1dGlvbiAtIDFlLTYpO1xuICAgIG1pbkhlaWdodCA9IE1hdGguY2VpbChtaW5IZWlnaHQgKiByZXNvbHV0aW9uIC0gMWUtNik7XG4gICAgbWluV2lkdGggPSBuZXh0UG93MihtaW5XaWR0aCk7XG4gICAgbWluSGVpZ2h0ID0gbmV4dFBvdzIobWluSGVpZ2h0KTtcbiAgICBjb25zdCBrZXkgPSAobWluV2lkdGggPDwgMTcpICsgKG1pbkhlaWdodCA8PCAxKTtcbiAgICBpZiAoIXRoaXMuX2NhbnZhc1Bvb2xba2V5XSkge1xuICAgICAgdGhpcy5fY2FudmFzUG9vbFtrZXldID0gW107XG4gICAgfVxuICAgIGxldCBjYW52YXNBbmRDb250ZXh0ID0gdGhpcy5fY2FudmFzUG9vbFtrZXldLnBvcCgpO1xuICAgIGlmICghY2FudmFzQW5kQ29udGV4dCkge1xuICAgICAgY2FudmFzQW5kQ29udGV4dCA9IHRoaXMuX2NyZWF0ZUNhbnZhc0FuZENvbnRleHQobWluV2lkdGgsIG1pbkhlaWdodCk7XG4gICAgfVxuICAgIHJldHVybiBjYW52YXNBbmRDb250ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBQbGFjZSBhIHJlbmRlciB0ZXh0dXJlIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICogQHBhcmFtIGNhbnZhc0FuZENvbnRleHRcbiAgICovXG4gIHJldHVybkNhbnZhc0FuZENvbnRleHQoY2FudmFzQW5kQ29udGV4dCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc0FuZENvbnRleHQuY2FudmFzO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY2FudmFzO1xuICAgIGNvbnN0IGtleSA9ICh3aWR0aCA8PCAxNykgKyAoaGVpZ2h0IDw8IDEpO1xuICAgIHRoaXMuX2NhbnZhc1Bvb2xba2V5XS5wdXNoKGNhbnZhc0FuZENvbnRleHQpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX2NhbnZhc1Bvb2wgPSB7fTtcbiAgfVxufVxuY29uc3QgQ2FudmFzUG9vbCA9IG5ldyBDYW52YXNQb29sQ2xhc3MoKTtcblxuZXhwb3J0IHsgQ2FudmFzUG9vbCwgQ2FudmFzUG9vbENsYXNzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYW52YXNQb29sLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8168\n')},6676:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(4240);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs + 11 modules\nvar GraphicsContextSystem = __webpack_require__(808);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs\nvar State = __webpack_require__(9952);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(2540);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs\nvar colorToUniform = __webpack_require__(9652);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs + 1 modules\nvar BatchableGraphics = __webpack_require__(1496);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs\n\n\n\n\n\n\n"use strict";\nclass GraphicsPipe {\n  constructor(renderer, adaptor) {\n    this.state = State/* State */.A.for2d();\n    // batchable graphics list, used to render batches\n    this._graphicsBatchesHash = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init();\n  }\n  validateRenderable(graphics) {\n    const context = graphics.context;\n    const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n    if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(graphics, instructionSet) {\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    if (graphics._didGraphicsUpdate) {\n      graphics._didGraphicsUpdate = false;\n      this._rebuild(graphics);\n    }\n    if (gpuContext.isBatchable) {\n      this._addToBatcher(graphics);\n    } else {\n      this.renderer.renderPipes.batch.break(instructionSet);\n      instructionSet.add(graphics);\n    }\n  }\n  updateRenderable(graphics) {\n    const batches = this._graphicsBatchesHash[graphics.uid];\n    if (batches) {\n      for (let i = 0; i < batches.length; i++) {\n        const batch = batches[i];\n        batch.batcher.updateElement(batch);\n      }\n    }\n  }\n  destroyRenderable(graphics) {\n    if (this._graphicsBatchesHash[graphics.uid]) {\n      this._removeBatchForRenderable(graphics.uid);\n    }\n  }\n  execute(graphics) {\n    if (!graphics.isRenderable)\n      return;\n    const renderer = this.renderer;\n    const context = graphics.context;\n    const contextSystem = renderer.graphicsContext;\n    if (!contextSystem.getGpuContext(context).batches.length) {\n      return;\n    }\n    const shader = context.customShader || this._adaptor.shader;\n    this.state.blendMode = graphics.groupBlendMode;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = graphics.groupTransform;\n    localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n    (0,colorToUniform/* color32BitToUniform */.u)(\n      graphics.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, graphics);\n  }\n  _rebuild(graphics) {\n    const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    if (wasBatched) {\n      this._removeBatchForRenderable(graphics.uid);\n    }\n    if (gpuContext.isBatchable) {\n      this._initBatchesForRenderable(graphics);\n    }\n    graphics.batched = gpuContext.isBatchable;\n  }\n  _addToBatcher(graphics) {\n    const batchPipe = this.renderer.renderPipes.batch;\n    const batches = this._getBatchesForRenderable(graphics);\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batchPipe.addToBatch(batch);\n    }\n  }\n  _getBatchesForRenderable(graphics) {\n    return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);\n  }\n  _initBatchesForRenderable(graphics) {\n    const context = graphics.context;\n    const gpuContext = this.renderer.graphicsContext.getGpuContext(context);\n    const roundPixels = this.renderer._roundPixels | graphics._roundPixels;\n    const batches = gpuContext.batches.map((batch) => {\n      const batchClone = PoolGroup/* BigPool */.u.get(BatchableGraphics/* BatchableGraphics */.R);\n      batch.copyTo(batchClone);\n      batchClone.renderable = graphics;\n      batchClone.roundPixels = roundPixels;\n      return batchClone;\n    });\n    if (this._graphicsBatchesHash[graphics.uid] === void 0) {\n      graphics.on("destroyed", () => {\n        this.destroyRenderable(graphics);\n      });\n    }\n    this._graphicsBatchesHash[graphics.uid] = batches;\n    return batches;\n  }\n  _removeBatchForRenderable(graphicsUid) {\n    this._graphicsBatchesHash[graphicsUid].forEach((batch) => {\n      PoolGroup/* BigPool */.u.return(batch);\n    });\n    this._graphicsBatchesHash[graphicsUid] = null;\n  }\n  destroy() {\n    this.renderer = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.state = null;\n    for (const i in this._graphicsBatchesHash) {\n      this._removeBatchForRenderable(i);\n    }\n    this._graphicsBatchesHash = null;\n  }\n}\n/** @ignore */\nGraphicsPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.y6.WebGLPipes,\n    Extensions/* ExtensionType */.y6.WebGPUPipes,\n    Extensions/* ExtensionType */.y6.CanvasPipes\n  ],\n  name: "graphics"\n};\n\n\n//# sourceMappingURL=GraphicsPipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/graphics/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Yt.add(GraphicsPipe);\nExtensions/* extensions */.Yt.add(GraphicsContextSystem/* GraphicsContextSystem */.O);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjY3Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFtRTtBQUNTO0FBQ2hCO0FBQ0k7QUFDSjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFLO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNkNBQW1CO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3QkFBTyxLQUFLLDBDQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx3QkFBTztBQUNiLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFd0I7QUFDeEI7OztBQzlJNkQ7QUFDYztBQUNsQjs7QUFFekQ7QUFDQSw2QkFBVSxLQUFLLFlBQVk7QUFDM0IsNkJBQVUsS0FBSyxrREFBcUI7QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3Mvc2hhcmVkL0dyYXBoaWNzUGlwZS5tanM/YmQyNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvZ3JhcGhpY3MvaW5pdC5tanM/YzdkNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFeHRlbnNpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBTdGF0ZSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3N0YXRlL1N0YXRlLm1qcyc7XG5pbXBvcnQgeyBCaWdQb29sIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvcG9vbC9Qb29sR3JvdXAubWpzJztcbmltcG9ydCB7IGNvbG9yMzJCaXRUb1VuaWZvcm0gfSBmcm9tICcuLi9ncHUvY29sb3JUb1VuaWZvcm0ubWpzJztcbmltcG9ydCB7IEJhdGNoYWJsZUdyYXBoaWNzIH0gZnJvbSAnLi9CYXRjaGFibGVHcmFwaGljcy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEdyYXBoaWNzUGlwZSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCBhZGFwdG9yKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLmZvcjJkKCk7XG4gICAgLy8gYmF0Y2hhYmxlIGdyYXBoaWNzIGxpc3QsIHVzZWQgdG8gcmVuZGVyIGJhdGNoZXNcbiAgICB0aGlzLl9ncmFwaGljc0JhdGNoZXNIYXNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMuX2FkYXB0b3IgPSBhZGFwdG9yO1xuICAgIHRoaXMuX2FkYXB0b3IuaW5pdCgpO1xuICB9XG4gIHZhbGlkYXRlUmVuZGVyYWJsZShncmFwaGljcykge1xuICAgIGNvbnN0IGNvbnRleHQgPSBncmFwaGljcy5jb250ZXh0O1xuICAgIGNvbnN0IHdhc0JhdGNoZWQgPSAhIXRoaXMuX2dyYXBoaWNzQmF0Y2hlc0hhc2hbZ3JhcGhpY3MudWlkXTtcbiAgICBjb25zdCBncHVDb250ZXh0ID0gdGhpcy5yZW5kZXJlci5ncmFwaGljc0NvbnRleHQudXBkYXRlR3B1Q29udGV4dChjb250ZXh0KTtcbiAgICBpZiAoZ3B1Q29udGV4dC5pc0JhdGNoYWJsZSB8fCB3YXNCYXRjaGVkICE9PSBncHVDb250ZXh0LmlzQmF0Y2hhYmxlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFkZFJlbmRlcmFibGUoZ3JhcGhpY3MsIGluc3RydWN0aW9uU2V0KSB7XG4gICAgY29uc3QgZ3B1Q29udGV4dCA9IHRoaXMucmVuZGVyZXIuZ3JhcGhpY3NDb250ZXh0LnVwZGF0ZUdwdUNvbnRleHQoZ3JhcGhpY3MuY29udGV4dCk7XG4gICAgaWYgKGdyYXBoaWNzLl9kaWRHcmFwaGljc1VwZGF0ZSkge1xuICAgICAgZ3JhcGhpY3MuX2RpZEdyYXBoaWNzVXBkYXRlID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZWJ1aWxkKGdyYXBoaWNzKTtcbiAgICB9XG4gICAgaWYgKGdwdUNvbnRleHQuaXNCYXRjaGFibGUpIHtcbiAgICAgIHRoaXMuX2FkZFRvQmF0Y2hlcihncmFwaGljcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2guYnJlYWsoaW5zdHJ1Y3Rpb25TZXQpO1xuICAgICAgaW5zdHJ1Y3Rpb25TZXQuYWRkKGdyYXBoaWNzKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlUmVuZGVyYWJsZShncmFwaGljcykge1xuICAgIGNvbnN0IGJhdGNoZXMgPSB0aGlzLl9ncmFwaGljc0JhdGNoZXNIYXNoW2dyYXBoaWNzLnVpZF07XG4gICAgaWYgKGJhdGNoZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBiYXRjaCA9IGJhdGNoZXNbaV07XG4gICAgICAgIGJhdGNoLmJhdGNoZXIudXBkYXRlRWxlbWVudChiYXRjaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlc3Ryb3lSZW5kZXJhYmxlKGdyYXBoaWNzKSB7XG4gICAgaWYgKHRoaXMuX2dyYXBoaWNzQmF0Y2hlc0hhc2hbZ3JhcGhpY3MudWlkXSkge1xuICAgICAgdGhpcy5fcmVtb3ZlQmF0Y2hGb3JSZW5kZXJhYmxlKGdyYXBoaWNzLnVpZCk7XG4gICAgfVxuICB9XG4gIGV4ZWN1dGUoZ3JhcGhpY3MpIHtcbiAgICBpZiAoIWdyYXBoaWNzLmlzUmVuZGVyYWJsZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgY29uc3QgY29udGV4dCA9IGdyYXBoaWNzLmNvbnRleHQ7XG4gICAgY29uc3QgY29udGV4dFN5c3RlbSA9IHJlbmRlcmVyLmdyYXBoaWNzQ29udGV4dDtcbiAgICBpZiAoIWNvbnRleHRTeXN0ZW0uZ2V0R3B1Q29udGV4dChjb250ZXh0KS5iYXRjaGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaGFkZXIgPSBjb250ZXh0LmN1c3RvbVNoYWRlciB8fCB0aGlzLl9hZGFwdG9yLnNoYWRlcjtcbiAgICB0aGlzLnN0YXRlLmJsZW5kTW9kZSA9IGdyYXBoaWNzLmdyb3VwQmxlbmRNb2RlO1xuICAgIGNvbnN0IGxvY2FsVW5pZm9ybXMgPSBzaGFkZXIucmVzb3VyY2VzLmxvY2FsVW5pZm9ybXMudW5pZm9ybXM7XG4gICAgbG9jYWxVbmlmb3Jtcy51VHJhbnNmb3JtTWF0cml4ID0gZ3JhcGhpY3MuZ3JvdXBUcmFuc2Zvcm07XG4gICAgbG9jYWxVbmlmb3Jtcy51Um91bmQgPSByZW5kZXJlci5fcm91bmRQaXhlbHMgfCBncmFwaGljcy5fcm91bmRQaXhlbHM7XG4gICAgY29sb3IzMkJpdFRvVW5pZm9ybShcbiAgICAgIGdyYXBoaWNzLmdyb3VwQ29sb3JBbHBoYSxcbiAgICAgIGxvY2FsVW5pZm9ybXMudUNvbG9yLFxuICAgICAgMFxuICAgICk7XG4gICAgdGhpcy5fYWRhcHRvci5leGVjdXRlKHRoaXMsIGdyYXBoaWNzKTtcbiAgfVxuICBfcmVidWlsZChncmFwaGljcykge1xuICAgIGNvbnN0IHdhc0JhdGNoZWQgPSAhIXRoaXMuX2dyYXBoaWNzQmF0Y2hlc0hhc2hbZ3JhcGhpY3MudWlkXTtcbiAgICBjb25zdCBncHVDb250ZXh0ID0gdGhpcy5yZW5kZXJlci5ncmFwaGljc0NvbnRleHQudXBkYXRlR3B1Q29udGV4dChncmFwaGljcy5jb250ZXh0KTtcbiAgICBpZiAod2FzQmF0Y2hlZCkge1xuICAgICAgdGhpcy5fcmVtb3ZlQmF0Y2hGb3JSZW5kZXJhYmxlKGdyYXBoaWNzLnVpZCk7XG4gICAgfVxuICAgIGlmIChncHVDb250ZXh0LmlzQmF0Y2hhYmxlKSB7XG4gICAgICB0aGlzLl9pbml0QmF0Y2hlc0ZvclJlbmRlcmFibGUoZ3JhcGhpY3MpO1xuICAgIH1cbiAgICBncmFwaGljcy5iYXRjaGVkID0gZ3B1Q29udGV4dC5pc0JhdGNoYWJsZTtcbiAgfVxuICBfYWRkVG9CYXRjaGVyKGdyYXBoaWNzKSB7XG4gICAgY29uc3QgYmF0Y2hQaXBlID0gdGhpcy5yZW5kZXJlci5yZW5kZXJQaXBlcy5iYXRjaDtcbiAgICBjb25zdCBiYXRjaGVzID0gdGhpcy5fZ2V0QmF0Y2hlc0ZvclJlbmRlcmFibGUoZ3JhcGhpY3MpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYmF0Y2ggPSBiYXRjaGVzW2ldO1xuICAgICAgYmF0Y2hQaXBlLmFkZFRvQmF0Y2goYmF0Y2gpO1xuICAgIH1cbiAgfVxuICBfZ2V0QmF0Y2hlc0ZvclJlbmRlcmFibGUoZ3JhcGhpY3MpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3JhcGhpY3NCYXRjaGVzSGFzaFtncmFwaGljcy51aWRdIHx8IHRoaXMuX2luaXRCYXRjaGVzRm9yUmVuZGVyYWJsZShncmFwaGljcyk7XG4gIH1cbiAgX2luaXRCYXRjaGVzRm9yUmVuZGVyYWJsZShncmFwaGljcykge1xuICAgIGNvbnN0IGNvbnRleHQgPSBncmFwaGljcy5jb250ZXh0O1xuICAgIGNvbnN0IGdwdUNvbnRleHQgPSB0aGlzLnJlbmRlcmVyLmdyYXBoaWNzQ29udGV4dC5nZXRHcHVDb250ZXh0KGNvbnRleHQpO1xuICAgIGNvbnN0IHJvdW5kUGl4ZWxzID0gdGhpcy5yZW5kZXJlci5fcm91bmRQaXhlbHMgfCBncmFwaGljcy5fcm91bmRQaXhlbHM7XG4gICAgY29uc3QgYmF0Y2hlcyA9IGdwdUNvbnRleHQuYmF0Y2hlcy5tYXAoKGJhdGNoKSA9PiB7XG4gICAgICBjb25zdCBiYXRjaENsb25lID0gQmlnUG9vbC5nZXQoQmF0Y2hhYmxlR3JhcGhpY3MpO1xuICAgICAgYmF0Y2guY29weVRvKGJhdGNoQ2xvbmUpO1xuICAgICAgYmF0Y2hDbG9uZS5yZW5kZXJhYmxlID0gZ3JhcGhpY3M7XG4gICAgICBiYXRjaENsb25lLnJvdW5kUGl4ZWxzID0gcm91bmRQaXhlbHM7XG4gICAgICByZXR1cm4gYmF0Y2hDbG9uZTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5fZ3JhcGhpY3NCYXRjaGVzSGFzaFtncmFwaGljcy51aWRdID09PSB2b2lkIDApIHtcbiAgICAgIGdyYXBoaWNzLm9uKFwiZGVzdHJveWVkXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5kZXN0cm95UmVuZGVyYWJsZShncmFwaGljcyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fZ3JhcGhpY3NCYXRjaGVzSGFzaFtncmFwaGljcy51aWRdID0gYmF0Y2hlcztcbiAgICByZXR1cm4gYmF0Y2hlcztcbiAgfVxuICBfcmVtb3ZlQmF0Y2hGb3JSZW5kZXJhYmxlKGdyYXBoaWNzVWlkKSB7XG4gICAgdGhpcy5fZ3JhcGhpY3NCYXRjaGVzSGFzaFtncmFwaGljc1VpZF0uZm9yRWFjaCgoYmF0Y2gpID0+IHtcbiAgICAgIEJpZ1Bvb2wucmV0dXJuKGJhdGNoKTtcbiAgICB9KTtcbiAgICB0aGlzLl9ncmFwaGljc0JhdGNoZXNIYXNoW2dyYXBoaWNzVWlkXSA9IG51bGw7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLl9hZGFwdG9yLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9hZGFwdG9yID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5fZ3JhcGhpY3NCYXRjaGVzSGFzaCkge1xuICAgICAgdGhpcy5fcmVtb3ZlQmF0Y2hGb3JSZW5kZXJhYmxlKGkpO1xuICAgIH1cbiAgICB0aGlzLl9ncmFwaGljc0JhdGNoZXNIYXNoID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkdyYXBoaWNzUGlwZS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1BpcGVzXG4gIF0sXG4gIG5hbWU6IFwiZ3JhcGhpY3NcIlxufTtcblxuZXhwb3J0IHsgR3JhcGhpY3NQaXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaGljc1BpcGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgR3JhcGhpY3NDb250ZXh0U3lzdGVtIH0gZnJvbSAnLi9zaGFyZWQvR3JhcGhpY3NDb250ZXh0U3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBHcmFwaGljc1BpcGUgfSBmcm9tICcuL3NoYXJlZC9HcmFwaGljc1BpcGUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5leHRlbnNpb25zLmFkZChHcmFwaGljc1BpcGUpO1xuZXh0ZW5zaW9ucy5hZGQoR3JhcGhpY3NDb250ZXh0U3lzdGVtKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaXQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6676\n')},7632:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(4240);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(328);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs\nvar BindGroup = __webpack_require__(8384);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 2 modules\nvar UniformGroup = __webpack_require__(5596);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs\nvar getAdjustedBlendModeBlend = __webpack_require__(9316);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(2540);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs\nvar colorToUniform = __webpack_require__(9652);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs\nvar BatchableMesh = __webpack_require__(2828);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs\n\n\n\n\n\n\n\n\n\n"use strict";\nclass MeshPipe {\n  constructor(renderer, adaptor) {\n    this.localUniforms = new UniformGroup/* UniformGroup */.W({\n      uTransformMatrix: { value: new Matrix/* Matrix */.W(), type: "mat3x3<f32>" },\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },\n      uRound: { value: 0, type: "f32" }\n    });\n    this.localUniformsBindGroup = new BindGroup/* BindGroup */.w({\n      0: this.localUniforms\n    });\n    this._meshDataHash = /* @__PURE__ */ Object.create(null);\n    this._gpuBatchableMeshHash = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init();\n  }\n  validateRenderable(mesh) {\n    const meshData = this._getMeshData(mesh);\n    const wasBatched = meshData.batched;\n    const isBatched = mesh.batched;\n    meshData.batched = isBatched;\n    if (wasBatched !== isBatched) {\n      return true;\n    } else if (isBatched) {\n      const geometry = mesh._geometry;\n      if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {\n        meshData.indexSize = geometry.indices.length;\n        meshData.vertexSize = geometry.positions.length;\n        return true;\n      }\n      const batchableMesh = this._getBatchableMesh(mesh);\n      const texture = mesh.texture;\n      if (batchableMesh.texture._source !== texture._source) {\n        if (batchableMesh.texture._source !== texture._source) {\n          return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);\n        }\n      }\n    }\n    return false;\n  }\n  addRenderable(mesh, instructionSet) {\n    const batcher = this.renderer.renderPipes.batch;\n    const { batched } = this._getMeshData(mesh);\n    if (batched) {\n      const gpuBatchableMesh = this._getBatchableMesh(mesh);\n      gpuBatchableMesh.texture = mesh._texture;\n      gpuBatchableMesh.geometry = mesh._geometry;\n      batcher.addToBatch(gpuBatchableMesh);\n    } else {\n      batcher.break(instructionSet);\n      instructionSet.add({\n        renderPipeId: "mesh",\n        mesh\n      });\n    }\n  }\n  updateRenderable(mesh) {\n    if (mesh.batched) {\n      const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n      gpuBatchableMesh.texture = mesh._texture;\n      gpuBatchableMesh.geometry = mesh._geometry;\n      gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh);\n    }\n  }\n  destroyRenderable(mesh) {\n    this._meshDataHash[mesh.uid] = null;\n    const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n    if (gpuMesh) {\n      PoolGroup/* BigPool */.u.return(gpuMesh);\n      this._gpuBatchableMeshHash[mesh.uid] = null;\n    }\n  }\n  execute({ mesh }) {\n    if (!mesh.isRenderable)\n      return;\n    mesh.state.blendMode = (0,getAdjustedBlendModeBlend/* getAdjustedBlendModeBlend */.C)(mesh.groupBlendMode, mesh.texture._source);\n    const localUniforms = this.localUniforms;\n    localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n    localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n    localUniforms.update();\n    (0,colorToUniform/* color32BitToUniform */.u)(\n      mesh.groupColorAlpha,\n      localUniforms.uniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, mesh);\n  }\n  _getMeshData(mesh) {\n    return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n  }\n  _initMeshData(mesh) {\n    this._meshDataHash[mesh.uid] = {\n      batched: mesh.batched,\n      indexSize: mesh._geometry.indices?.length,\n      vertexSize: mesh._geometry.positions?.length\n    };\n    mesh.on("destroyed", () => {\n      this.destroyRenderable(mesh);\n    });\n    return this._meshDataHash[mesh.uid];\n  }\n  _getBatchableMesh(mesh) {\n    return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n  }\n  _initBatchableMesh(mesh) {\n    const gpuMesh = PoolGroup/* BigPool */.u.get(BatchableMesh/* BatchableMesh */.Q);\n    gpuMesh.mesh = mesh;\n    gpuMesh.texture = mesh._texture;\n    gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;\n    this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n    gpuMesh.mesh = mesh;\n    return gpuMesh;\n  }\n  destroy() {\n    for (const i in this._gpuBatchableMeshHash) {\n      if (this._gpuBatchableMeshHash[i]) {\n        PoolGroup/* BigPool */.u.return(this._gpuBatchableMeshHash[i]);\n      }\n    }\n    this._gpuBatchableMeshHash = null;\n    this._meshDataHash = null;\n    this.localUniforms = null;\n    this.localUniformsBindGroup = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.renderer = null;\n  }\n}\n/** @ignore */\nMeshPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.y6.WebGLPipes,\n    Extensions/* ExtensionType */.y6.WebGPUPipes,\n    Extensions/* ExtensionType */.y6.CanvasPipes\n  ],\n  name: "mesh"\n};\n\n\n//# sourceMappingURL=MeshPipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/mesh/init.mjs\n\n\n\n"use strict";\nExtensions/* extensions */.Yt.add(MeshPipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYzMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUU7QUFDVDtBQUN3QjtBQUNTO0FBQ3lCO0FBQ3hEO0FBQ2dCO0FBQ3hCOztBQUVwRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0NBQVk7QUFDekMsMEJBQTBCLFdBQVcsb0JBQU0seUJBQXlCO0FBQ3BFLGdCQUFnQiwwREFBMEQ7QUFDMUUsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTCxzQ0FBc0MsMEJBQVM7QUFDL0M7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sd0JBQU87QUFDYjtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBLDJCQUEyQiw4REFBeUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZDQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBTyxLQUFLLGtDQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3QkFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQjtBQUNBO0FBQ0E7O0FBRW9CO0FBQ3BCOzs7QUNySjZEO0FBQ1o7O0FBRWpEO0FBQ0EsNkJBQVUsS0FBSyxRQUFRO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL21lc2gvc2hhcmVkL01lc2hQaXBlLm1qcz83MDU1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9tZXNoL2luaXQubWpzPzIyOGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgQmluZEdyb3VwIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9ncHUvc2hhZGVyL0JpbmRHcm91cC5tanMnO1xuaW1wb3J0IHsgVW5pZm9ybUdyb3VwIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvc2hhZGVyL1VuaWZvcm1Hcm91cC5tanMnO1xuaW1wb3J0IHsgZ2V0QWRqdXN0ZWRCbGVuZE1vZGVCbGVuZCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3N0YXRlL2dldEFkanVzdGVkQmxlbmRNb2RlQmxlbmQubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgY29sb3IzMkJpdFRvVW5pZm9ybSB9IGZyb20gJy4uLy4uL2dyYXBoaWNzL2dwdS9jb2xvclRvVW5pZm9ybS5tanMnO1xuaW1wb3J0IHsgQmF0Y2hhYmxlTWVzaCB9IGZyb20gJy4vQmF0Y2hhYmxlTWVzaC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIE1lc2hQaXBlIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIsIGFkYXB0b3IpIHtcbiAgICB0aGlzLmxvY2FsVW5pZm9ybXMgPSBuZXcgVW5pZm9ybUdyb3VwKHtcbiAgICAgIHVUcmFuc2Zvcm1NYXRyaXg6IHsgdmFsdWU6IG5ldyBNYXRyaXgoKSwgdHlwZTogXCJtYXQzeDM8ZjMyPlwiIH0sXG4gICAgICB1Q29sb3I6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDFdKSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9LFxuICAgICAgdVJvdW5kOiB7IHZhbHVlOiAwLCB0eXBlOiBcImYzMlwiIH1cbiAgICB9KTtcbiAgICB0aGlzLmxvY2FsVW5pZm9ybXNCaW5kR3JvdXAgPSBuZXcgQmluZEdyb3VwKHtcbiAgICAgIDA6IHRoaXMubG9jYWxVbmlmb3Jtc1xuICAgIH0pO1xuICAgIHRoaXMuX21lc2hEYXRhSGFzaCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2dwdUJhdGNoYWJsZU1lc2hIYXNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMuX2FkYXB0b3IgPSBhZGFwdG9yO1xuICAgIHRoaXMuX2FkYXB0b3IuaW5pdCgpO1xuICB9XG4gIHZhbGlkYXRlUmVuZGVyYWJsZShtZXNoKSB7XG4gICAgY29uc3QgbWVzaERhdGEgPSB0aGlzLl9nZXRNZXNoRGF0YShtZXNoKTtcbiAgICBjb25zdCB3YXNCYXRjaGVkID0gbWVzaERhdGEuYmF0Y2hlZDtcbiAgICBjb25zdCBpc0JhdGNoZWQgPSBtZXNoLmJhdGNoZWQ7XG4gICAgbWVzaERhdGEuYmF0Y2hlZCA9IGlzQmF0Y2hlZDtcbiAgICBpZiAod2FzQmF0Y2hlZCAhPT0gaXNCYXRjaGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzQmF0Y2hlZCkge1xuICAgICAgY29uc3QgZ2VvbWV0cnkgPSBtZXNoLl9nZW9tZXRyeTtcbiAgICAgIGlmIChnZW9tZXRyeS5pbmRpY2VzLmxlbmd0aCAhPT0gbWVzaERhdGEuaW5kZXhTaXplIHx8IGdlb21ldHJ5LnBvc2l0aW9ucy5sZW5ndGggIT09IG1lc2hEYXRhLnZlcnRleFNpemUpIHtcbiAgICAgICAgbWVzaERhdGEuaW5kZXhTaXplID0gZ2VvbWV0cnkuaW5kaWNlcy5sZW5ndGg7XG4gICAgICAgIG1lc2hEYXRhLnZlcnRleFNpemUgPSBnZW9tZXRyeS5wb3NpdGlvbnMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJhdGNoYWJsZU1lc2ggPSB0aGlzLl9nZXRCYXRjaGFibGVNZXNoKG1lc2gpO1xuICAgICAgY29uc3QgdGV4dHVyZSA9IG1lc2gudGV4dHVyZTtcbiAgICAgIGlmIChiYXRjaGFibGVNZXNoLnRleHR1cmUuX3NvdXJjZSAhPT0gdGV4dHVyZS5fc291cmNlKSB7XG4gICAgICAgIGlmIChiYXRjaGFibGVNZXNoLnRleHR1cmUuX3NvdXJjZSAhPT0gdGV4dHVyZS5fc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuICFiYXRjaGFibGVNZXNoLmJhdGNoZXIuY2hlY2tBbmRVcGRhdGVUZXh0dXJlKGJhdGNoYWJsZU1lc2gsIHRleHR1cmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhZGRSZW5kZXJhYmxlKG1lc2gsIGluc3RydWN0aW9uU2V0KSB7XG4gICAgY29uc3QgYmF0Y2hlciA9IHRoaXMucmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2g7XG4gICAgY29uc3QgeyBiYXRjaGVkIH0gPSB0aGlzLl9nZXRNZXNoRGF0YShtZXNoKTtcbiAgICBpZiAoYmF0Y2hlZCkge1xuICAgICAgY29uc3QgZ3B1QmF0Y2hhYmxlTWVzaCA9IHRoaXMuX2dldEJhdGNoYWJsZU1lc2gobWVzaCk7XG4gICAgICBncHVCYXRjaGFibGVNZXNoLnRleHR1cmUgPSBtZXNoLl90ZXh0dXJlO1xuICAgICAgZ3B1QmF0Y2hhYmxlTWVzaC5nZW9tZXRyeSA9IG1lc2guX2dlb21ldHJ5O1xuICAgICAgYmF0Y2hlci5hZGRUb0JhdGNoKGdwdUJhdGNoYWJsZU1lc2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXRjaGVyLmJyZWFrKGluc3RydWN0aW9uU2V0KTtcbiAgICAgIGluc3RydWN0aW9uU2V0LmFkZCh7XG4gICAgICAgIHJlbmRlclBpcGVJZDogXCJtZXNoXCIsXG4gICAgICAgIG1lc2hcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICB1cGRhdGVSZW5kZXJhYmxlKG1lc2gpIHtcbiAgICBpZiAobWVzaC5iYXRjaGVkKSB7XG4gICAgICBjb25zdCBncHVCYXRjaGFibGVNZXNoID0gdGhpcy5fZ3B1QmF0Y2hhYmxlTWVzaEhhc2hbbWVzaC51aWRdO1xuICAgICAgZ3B1QmF0Y2hhYmxlTWVzaC50ZXh0dXJlID0gbWVzaC5fdGV4dHVyZTtcbiAgICAgIGdwdUJhdGNoYWJsZU1lc2guZ2VvbWV0cnkgPSBtZXNoLl9nZW9tZXRyeTtcbiAgICAgIGdwdUJhdGNoYWJsZU1lc2guYmF0Y2hlci51cGRhdGVFbGVtZW50KGdwdUJhdGNoYWJsZU1lc2gpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95UmVuZGVyYWJsZShtZXNoKSB7XG4gICAgdGhpcy5fbWVzaERhdGFIYXNoW21lc2gudWlkXSA9IG51bGw7XG4gICAgY29uc3QgZ3B1TWVzaCA9IHRoaXMuX2dwdUJhdGNoYWJsZU1lc2hIYXNoW21lc2gudWlkXTtcbiAgICBpZiAoZ3B1TWVzaCkge1xuICAgICAgQmlnUG9vbC5yZXR1cm4oZ3B1TWVzaCk7XG4gICAgICB0aGlzLl9ncHVCYXRjaGFibGVNZXNoSGFzaFttZXNoLnVpZF0gPSBudWxsO1xuICAgIH1cbiAgfVxuICBleGVjdXRlKHsgbWVzaCB9KSB7XG4gICAgaWYgKCFtZXNoLmlzUmVuZGVyYWJsZSlcbiAgICAgIHJldHVybjtcbiAgICBtZXNoLnN0YXRlLmJsZW5kTW9kZSA9IGdldEFkanVzdGVkQmxlbmRNb2RlQmxlbmQobWVzaC5ncm91cEJsZW5kTW9kZSwgbWVzaC50ZXh0dXJlLl9zb3VyY2UpO1xuICAgIGNvbnN0IGxvY2FsVW5pZm9ybXMgPSB0aGlzLmxvY2FsVW5pZm9ybXM7XG4gICAgbG9jYWxVbmlmb3Jtcy51bmlmb3Jtcy51VHJhbnNmb3JtTWF0cml4ID0gbWVzaC5ncm91cFRyYW5zZm9ybTtcbiAgICBsb2NhbFVuaWZvcm1zLnVuaWZvcm1zLnVSb3VuZCA9IHRoaXMucmVuZGVyZXIuX3JvdW5kUGl4ZWxzIHwgbWVzaC5fcm91bmRQaXhlbHM7XG4gICAgbG9jYWxVbmlmb3Jtcy51cGRhdGUoKTtcbiAgICBjb2xvcjMyQml0VG9Vbmlmb3JtKFxuICAgICAgbWVzaC5ncm91cENvbG9yQWxwaGEsXG4gICAgICBsb2NhbFVuaWZvcm1zLnVuaWZvcm1zLnVDb2xvcixcbiAgICAgIDBcbiAgICApO1xuICAgIHRoaXMuX2FkYXB0b3IuZXhlY3V0ZSh0aGlzLCBtZXNoKTtcbiAgfVxuICBfZ2V0TWVzaERhdGEobWVzaCkge1xuICAgIHJldHVybiB0aGlzLl9tZXNoRGF0YUhhc2hbbWVzaC51aWRdIHx8IHRoaXMuX2luaXRNZXNoRGF0YShtZXNoKTtcbiAgfVxuICBfaW5pdE1lc2hEYXRhKG1lc2gpIHtcbiAgICB0aGlzLl9tZXNoRGF0YUhhc2hbbWVzaC51aWRdID0ge1xuICAgICAgYmF0Y2hlZDogbWVzaC5iYXRjaGVkLFxuICAgICAgaW5kZXhTaXplOiBtZXNoLl9nZW9tZXRyeS5pbmRpY2VzPy5sZW5ndGgsXG4gICAgICB2ZXJ0ZXhTaXplOiBtZXNoLl9nZW9tZXRyeS5wb3NpdGlvbnM/Lmxlbmd0aFxuICAgIH07XG4gICAgbWVzaC5vbihcImRlc3Ryb3llZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmRlc3Ryb3lSZW5kZXJhYmxlKG1lc2gpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9tZXNoRGF0YUhhc2hbbWVzaC51aWRdO1xuICB9XG4gIF9nZXRCYXRjaGFibGVNZXNoKG1lc2gpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3B1QmF0Y2hhYmxlTWVzaEhhc2hbbWVzaC51aWRdIHx8IHRoaXMuX2luaXRCYXRjaGFibGVNZXNoKG1lc2gpO1xuICB9XG4gIF9pbml0QmF0Y2hhYmxlTWVzaChtZXNoKSB7XG4gICAgY29uc3QgZ3B1TWVzaCA9IEJpZ1Bvb2wuZ2V0KEJhdGNoYWJsZU1lc2gpO1xuICAgIGdwdU1lc2gubWVzaCA9IG1lc2g7XG4gICAgZ3B1TWVzaC50ZXh0dXJlID0gbWVzaC5fdGV4dHVyZTtcbiAgICBncHVNZXNoLnJvdW5kUGl4ZWxzID0gdGhpcy5yZW5kZXJlci5fcm91bmRQaXhlbHMgfCBtZXNoLl9yb3VuZFBpeGVscztcbiAgICB0aGlzLl9ncHVCYXRjaGFibGVNZXNoSGFzaFttZXNoLnVpZF0gPSBncHVNZXNoO1xuICAgIGdwdU1lc2gubWVzaCA9IG1lc2g7XG4gICAgcmV0dXJuIGdwdU1lc2g7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5fZ3B1QmF0Y2hhYmxlTWVzaEhhc2gpIHtcbiAgICAgIGlmICh0aGlzLl9ncHVCYXRjaGFibGVNZXNoSGFzaFtpXSkge1xuICAgICAgICBCaWdQb29sLnJldHVybih0aGlzLl9ncHVCYXRjaGFibGVNZXNoSGFzaFtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2dwdUJhdGNoYWJsZU1lc2hIYXNoID0gbnVsbDtcbiAgICB0aGlzLl9tZXNoRGF0YUhhc2ggPSBudWxsO1xuICAgIHRoaXMubG9jYWxVbmlmb3JtcyA9IG51bGw7XG4gICAgdGhpcy5sb2NhbFVuaWZvcm1zQmluZEdyb3VwID0gbnVsbDtcbiAgICB0aGlzLl9hZGFwdG9yLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9hZGFwdG9yID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbk1lc2hQaXBlLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUGlwZXNcbiAgXSxcbiAgbmFtZTogXCJtZXNoXCJcbn07XG5cbmV4cG9ydCB7IE1lc2hQaXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXNoUGlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBleHRlbnNpb25zIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBNZXNoUGlwZSB9IGZyb20gJy4vc2hhcmVkL01lc2hQaXBlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZXh0ZW5zaW9ucy5hZGQoTWVzaFBpcGUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5pdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7632\n')},2828:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Q: () => (/* binding */ BatchableMesh)\n/* harmony export */ });\n\nclass BatchableMesh {\n  constructor() {\n    this.batcher = null;\n    this.batch = null;\n    this.roundPixels = 0;\n    this._uvUpdateId = -1;\n    this._textureMatrixUpdateId = -1;\n  }\n  get blendMode() {\n    return this.mesh.groupBlendMode;\n  }\n  reset() {\n    this.mesh = null;\n    this.texture = null;\n    this.batcher = null;\n    this.batch = null;\n  }\n  packIndex(indexBuffer, index, indicesOffset) {\n    const indices = this.geometry.indices;\n    for (let i = 0; i < indices.length; i++) {\n      indexBuffer[index++] = indices[i] + indicesOffset;\n    }\n  }\n  packAttributes(float32View, uint32View, index, textureId) {\n    const mesh = this.mesh;\n    const geometry = this.geometry;\n    const wt = mesh.groupTransform;\n    const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const positions = geometry.positions;\n    const uvBuffer = geometry.getBuffer("aUV");\n    const uvs = uvBuffer.data;\n    let transformedUvs = uvs;\n    const textureMatrix = this.texture.textureMatrix;\n    if (!textureMatrix.isSimple) {\n      transformedUvs = this._transformedUvs;\n      if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {\n        if (!transformedUvs || transformedUvs.length < uvs.length) {\n          transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n        }\n        this._textureMatrixUpdateId = textureMatrix._updateID;\n        this._uvUpdateId = uvBuffer._updateID;\n        textureMatrix.multiplyUvs(uvs, transformedUvs);\n      }\n    }\n    const abgr = mesh.groupColorAlpha;\n    for (let i = 0; i < positions.length; i += 2) {\n      const x = positions[i];\n      const y = positions[i + 1];\n      float32View[index] = a * x + c * y + tx;\n      float32View[index + 1] = b * x + d * y + ty;\n      float32View[index + 2] = transformedUvs[i];\n      float32View[index + 3] = transformedUvs[i + 1];\n      uint32View[index + 4] = abgr;\n      uint32View[index + 5] = textureIdAndRound;\n      index += 6;\n    }\n  }\n  get vertexSize() {\n    return this.geometry.positions.length / 2;\n  }\n  get indexSize() {\n    return this.geometry.indices.length;\n  }\n}\n\n\n//# sourceMappingURL=BatchableMesh.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjgyOC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9tZXNoL3NoYXJlZC9CYXRjaGFibGVNZXNoLm1qcz9mZDFlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY2xhc3MgQmF0Y2hhYmxlTWVzaCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYmF0Y2hlciA9IG51bGw7XG4gICAgdGhpcy5iYXRjaCA9IG51bGw7XG4gICAgdGhpcy5yb3VuZFBpeGVscyA9IDA7XG4gICAgdGhpcy5fdXZVcGRhdGVJZCA9IC0xO1xuICAgIHRoaXMuX3RleHR1cmVNYXRyaXhVcGRhdGVJZCA9IC0xO1xuICB9XG4gIGdldCBibGVuZE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzaC5ncm91cEJsZW5kTW9kZTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLm1lc2ggPSBudWxsO1xuICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG4gICAgdGhpcy5iYXRjaGVyID0gbnVsbDtcbiAgICB0aGlzLmJhdGNoID0gbnVsbDtcbiAgfVxuICBwYWNrSW5kZXgoaW5kZXhCdWZmZXIsIGluZGV4LCBpbmRpY2VzT2Zmc2V0KSB7XG4gICAgY29uc3QgaW5kaWNlcyA9IHRoaXMuZ2VvbWV0cnkuaW5kaWNlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGluZGV4QnVmZmVyW2luZGV4KytdID0gaW5kaWNlc1tpXSArIGluZGljZXNPZmZzZXQ7XG4gICAgfVxuICB9XG4gIHBhY2tBdHRyaWJ1dGVzKGZsb2F0MzJWaWV3LCB1aW50MzJWaWV3LCBpbmRleCwgdGV4dHVyZUlkKSB7XG4gICAgY29uc3QgbWVzaCA9IHRoaXMubWVzaDtcbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG4gICAgY29uc3Qgd3QgPSBtZXNoLmdyb3VwVHJhbnNmb3JtO1xuICAgIGNvbnN0IHRleHR1cmVJZEFuZFJvdW5kID0gdGV4dHVyZUlkIDw8IDE2IHwgdGhpcy5yb3VuZFBpeGVscyAmIDY1NTM1O1xuICAgIGNvbnN0IGEgPSB3dC5hO1xuICAgIGNvbnN0IGIgPSB3dC5iO1xuICAgIGNvbnN0IGMgPSB3dC5jO1xuICAgIGNvbnN0IGQgPSB3dC5kO1xuICAgIGNvbnN0IHR4ID0gd3QudHg7XG4gICAgY29uc3QgdHkgPSB3dC50eTtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBnZW9tZXRyeS5wb3NpdGlvbnM7XG4gICAgY29uc3QgdXZCdWZmZXIgPSBnZW9tZXRyeS5nZXRCdWZmZXIoXCJhVVZcIik7XG4gICAgY29uc3QgdXZzID0gdXZCdWZmZXIuZGF0YTtcbiAgICBsZXQgdHJhbnNmb3JtZWRVdnMgPSB1dnM7XG4gICAgY29uc3QgdGV4dHVyZU1hdHJpeCA9IHRoaXMudGV4dHVyZS50ZXh0dXJlTWF0cml4O1xuICAgIGlmICghdGV4dHVyZU1hdHJpeC5pc1NpbXBsZSkge1xuICAgICAgdHJhbnNmb3JtZWRVdnMgPSB0aGlzLl90cmFuc2Zvcm1lZFV2cztcbiAgICAgIGlmICh0aGlzLl90ZXh0dXJlTWF0cml4VXBkYXRlSWQgIT09IHRleHR1cmVNYXRyaXguX3VwZGF0ZUlEIHx8IHRoaXMuX3V2VXBkYXRlSWQgIT09IHV2QnVmZmVyLl91cGRhdGVJRCkge1xuICAgICAgICBpZiAoIXRyYW5zZm9ybWVkVXZzIHx8IHRyYW5zZm9ybWVkVXZzLmxlbmd0aCA8IHV2cy5sZW5ndGgpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1lZFV2cyA9IHRoaXMuX3RyYW5zZm9ybWVkVXZzID0gbmV3IEZsb2F0MzJBcnJheSh1dnMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90ZXh0dXJlTWF0cml4VXBkYXRlSWQgPSB0ZXh0dXJlTWF0cml4Ll91cGRhdGVJRDtcbiAgICAgICAgdGhpcy5fdXZVcGRhdGVJZCA9IHV2QnVmZmVyLl91cGRhdGVJRDtcbiAgICAgICAgdGV4dHVyZU1hdHJpeC5tdWx0aXBseVV2cyh1dnMsIHRyYW5zZm9ybWVkVXZzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYWJnciA9IG1lc2guZ3JvdXBDb2xvckFscGhhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjb25zdCB4ID0gcG9zaXRpb25zW2ldO1xuICAgICAgY29uc3QgeSA9IHBvc2l0aW9uc1tpICsgMV07XG4gICAgICBmbG9hdDMyVmlld1tpbmRleF0gPSBhICogeCArIGMgKiB5ICsgdHg7XG4gICAgICBmbG9hdDMyVmlld1tpbmRleCArIDFdID0gYiAqIHggKyBkICogeSArIHR5O1xuICAgICAgZmxvYXQzMlZpZXdbaW5kZXggKyAyXSA9IHRyYW5zZm9ybWVkVXZzW2ldO1xuICAgICAgZmxvYXQzMlZpZXdbaW5kZXggKyAzXSA9IHRyYW5zZm9ybWVkVXZzW2kgKyAxXTtcbiAgICAgIHVpbnQzMlZpZXdbaW5kZXggKyA0XSA9IGFiZ3I7XG4gICAgICB1aW50MzJWaWV3W2luZGV4ICsgNV0gPSB0ZXh0dXJlSWRBbmRSb3VuZDtcbiAgICAgIGluZGV4ICs9IDY7XG4gICAgfVxuICB9XG4gIGdldCB2ZXJ0ZXhTaXplKCkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5LnBvc2l0aW9ucy5sZW5ndGggLyAyO1xuICB9XG4gIGdldCBpbmRleFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkuaW5kaWNlcy5sZW5ndGg7XG4gIH1cbn1cblxuZXhwb3J0IHsgQmF0Y2hhYmxlTWVzaCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hhYmxlTWVzaC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2828\n')},9288:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Q: () => (/* binding */ MeshGeometry)\n/* harmony export */ });\n/* harmony import */ var _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2592);\n/* harmony import */ var _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2864);\n/* harmony import */ var _rendering_renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5364);\n/* harmony import */ var _utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8592);\n\n\n\n\n\n"use strict";\nconst _MeshGeometry = class _MeshGeometry extends _rendering_renderers_shared_geometry_Geometry_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Geometry */ .K {\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (options instanceof Float32Array) {\n      (0,_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__/* .deprecation */ .e)(_utils_logging_deprecation_mjs__WEBPACK_IMPORTED_MODULE_1__/* .v8_0_0 */ .q, "use new MeshGeometry({ positions, uvs, indices }) instead");\n      options = {\n        positions: options,\n        uvs: args[1],\n        indices: args[2]\n      };\n    }\n    options = { ..._MeshGeometry.defaultOptions, ...options };\n    const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n    const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n    const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n    const shrinkToFit = options.shrinkBuffersToFit;\n    const positionBuffer = new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Buffer */ .S({\n      data: positions,\n      label: "attribute-mesh-positions",\n      shrinkToFit,\n      usage: _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .c.VERTEX | _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .c.COPY_DST\n    });\n    const uvBuffer = new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Buffer */ .S({\n      data: uvs,\n      label: "attribute-mesh-uvs",\n      shrinkToFit,\n      usage: _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .c.VERTEX | _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .c.COPY_DST\n    });\n    const indexBuffer = new _rendering_renderers_shared_buffer_Buffer_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Buffer */ .S({\n      data: indices,\n      label: "index-mesh-buffer",\n      shrinkToFit,\n      usage: _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .c.INDEX | _rendering_renderers_shared_buffer_const_mjs__WEBPACK_IMPORTED_MODULE_3__/* .BufferUsage */ .c.COPY_DST\n    });\n    super({\n      attributes: {\n        aPosition: {\n          buffer: positionBuffer,\n          format: "float32x2",\n          stride: 2 * 4,\n          offset: 0\n        },\n        aUV: {\n          buffer: uvBuffer,\n          format: "float32x2",\n          stride: 2 * 4,\n          offset: 0\n        }\n      },\n      indexBuffer,\n      topology: options.topology\n    });\n    this.batchMode = "auto";\n  }\n  /** The positions of the mesh. */\n  get positions() {\n    return this.attributes.aPosition.buffer.data;\n  }\n  set positions(value) {\n    this.attributes.aPosition.buffer.data = value;\n  }\n  /** The UVs of the mesh. */\n  get uvs() {\n    return this.attributes.aUV.buffer.data;\n  }\n  set uvs(value) {\n    this.attributes.aUV.buffer.data = value;\n  }\n  /** The indices of the mesh. */\n  get indices() {\n    return this.indexBuffer.data;\n  }\n  set indices(value) {\n    this.indexBuffer.data = value;\n  }\n};\n_MeshGeometry.defaultOptions = {\n  topology: "triangle-list",\n  shrinkBuffersToFit: false\n};\nlet MeshGeometry = _MeshGeometry;\n\n\n//# sourceMappingURL=MeshGeometry.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTI4OC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQStFO0FBQ0k7QUFDRTtBQUNSOztBQUU3RTtBQUNBLGtEQUFrRCxnR0FBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9GQUFXLENBQUMsMkVBQU0sMEJBQTBCLHlCQUF5QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMEZBQU07QUFDckM7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4RkFBVyxVQUFVLDhGQUFXO0FBQzdDLEtBQUs7QUFDTCx5QkFBeUIsMEZBQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4RkFBVyxVQUFVLDhGQUFXO0FBQzdDLEtBQUs7QUFDTCw0QkFBNEIsMEZBQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4RkFBVyxTQUFTLDhGQUFXO0FBQzVDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3QjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9tZXNoL3NoYXJlZC9NZXNoR2VvbWV0cnkubWpzPzZlZjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvYnVmZmVyL0J1ZmZlci5tanMnO1xuaW1wb3J0IHsgQnVmZmVyVXNhZ2UgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9idWZmZXIvY29uc3QubWpzJztcbmltcG9ydCB7IEdlb21ldHJ5IH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvZ2VvbWV0cnkvR2VvbWV0cnkubWpzJztcbmltcG9ydCB7IGRlcHJlY2F0aW9uLCB2OF8wXzAgfSBmcm9tICcuLi8uLi8uLi91dGlscy9sb2dnaW5nL2RlcHJlY2F0aW9uLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgX01lc2hHZW9tZXRyeSA9IGNsYXNzIF9NZXNoR2VvbWV0cnkgZXh0ZW5kcyBHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3NbMF0gPz8ge307XG4gICAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJ1c2UgbmV3IE1lc2hHZW9tZXRyeSh7IHBvc2l0aW9ucywgdXZzLCBpbmRpY2VzIH0pIGluc3RlYWRcIik7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBwb3NpdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIHV2czogYXJnc1sxXSxcbiAgICAgICAgaW5kaWNlczogYXJnc1syXVxuICAgICAgfTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IHsgLi4uX01lc2hHZW9tZXRyeS5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IG9wdGlvbnMucG9zaXRpb25zIHx8IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDEsIDAsIDEsIDEsIDAsIDFdKTtcbiAgICBjb25zdCB1dnMgPSBvcHRpb25zLnV2cyB8fCBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxLCAwLCAxLCAxLCAwLCAxXSk7XG4gICAgY29uc3QgaW5kaWNlcyA9IG9wdGlvbnMuaW5kaWNlcyB8fCBuZXcgVWludDMyQXJyYXkoWzAsIDEsIDIsIDAsIDIsIDNdKTtcbiAgICBjb25zdCBzaHJpbmtUb0ZpdCA9IG9wdGlvbnMuc2hyaW5rQnVmZmVyc1RvRml0O1xuICAgIGNvbnN0IHBvc2l0aW9uQnVmZmVyID0gbmV3IEJ1ZmZlcih7XG4gICAgICBkYXRhOiBwb3NpdGlvbnMsXG4gICAgICBsYWJlbDogXCJhdHRyaWJ1dGUtbWVzaC1wb3NpdGlvbnNcIixcbiAgICAgIHNocmlua1RvRml0LFxuICAgICAgdXNhZ2U6IEJ1ZmZlclVzYWdlLlZFUlRFWCB8IEJ1ZmZlclVzYWdlLkNPUFlfRFNUXG4gICAgfSk7XG4gICAgY29uc3QgdXZCdWZmZXIgPSBuZXcgQnVmZmVyKHtcbiAgICAgIGRhdGE6IHV2cyxcbiAgICAgIGxhYmVsOiBcImF0dHJpYnV0ZS1tZXNoLXV2c1wiLFxuICAgICAgc2hyaW5rVG9GaXQsXG4gICAgICB1c2FnZTogQnVmZmVyVXNhZ2UuVkVSVEVYIHwgQnVmZmVyVXNhZ2UuQ09QWV9EU1RcbiAgICB9KTtcbiAgICBjb25zdCBpbmRleEJ1ZmZlciA9IG5ldyBCdWZmZXIoe1xuICAgICAgZGF0YTogaW5kaWNlcyxcbiAgICAgIGxhYmVsOiBcImluZGV4LW1lc2gtYnVmZmVyXCIsXG4gICAgICBzaHJpbmtUb0ZpdCxcbiAgICAgIHVzYWdlOiBCdWZmZXJVc2FnZS5JTkRFWCB8IEJ1ZmZlclVzYWdlLkNPUFlfRFNUXG4gICAgfSk7XG4gICAgc3VwZXIoe1xuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICBhUG9zaXRpb246IHtcbiAgICAgICAgICBidWZmZXI6IHBvc2l0aW9uQnVmZmVyLFxuICAgICAgICAgIGZvcm1hdDogXCJmbG9hdDMyeDJcIixcbiAgICAgICAgICBzdHJpZGU6IDIgKiA0LFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9LFxuICAgICAgICBhVVY6IHtcbiAgICAgICAgICBidWZmZXI6IHV2QnVmZmVyLFxuICAgICAgICAgIGZvcm1hdDogXCJmbG9hdDMyeDJcIixcbiAgICAgICAgICBzdHJpZGU6IDIgKiA0LFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaW5kZXhCdWZmZXIsXG4gICAgICB0b3BvbG9neTogb3B0aW9ucy50b3BvbG9neVxuICAgIH0pO1xuICAgIHRoaXMuYmF0Y2hNb2RlID0gXCJhdXRvXCI7XG4gIH1cbiAgLyoqIFRoZSBwb3NpdGlvbnMgb2YgdGhlIG1lc2guICovXG4gIGdldCBwb3NpdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5hUG9zaXRpb24uYnVmZmVyLmRhdGE7XG4gIH1cbiAgc2V0IHBvc2l0aW9ucyh2YWx1ZSkge1xuICAgIHRoaXMuYXR0cmlidXRlcy5hUG9zaXRpb24uYnVmZmVyLmRhdGEgPSB2YWx1ZTtcbiAgfVxuICAvKiogVGhlIFVWcyBvZiB0aGUgbWVzaC4gKi9cbiAgZ2V0IHV2cygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmFVVi5idWZmZXIuZGF0YTtcbiAgfVxuICBzZXQgdXZzKHZhbHVlKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzLmFVVi5idWZmZXIuZGF0YSA9IHZhbHVlO1xuICB9XG4gIC8qKiBUaGUgaW5kaWNlcyBvZiB0aGUgbWVzaC4gKi9cbiAgZ2V0IGluZGljZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhCdWZmZXIuZGF0YTtcbiAgfVxuICBzZXQgaW5kaWNlcyh2YWx1ZSkge1xuICAgIHRoaXMuaW5kZXhCdWZmZXIuZGF0YSA9IHZhbHVlO1xuICB9XG59O1xuX01lc2hHZW9tZXRyeS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgdG9wb2xvZ3k6IFwidHJpYW5nbGUtbGlzdFwiLFxuICBzaHJpbmtCdWZmZXJzVG9GaXQ6IGZhbHNlXG59O1xubGV0IE1lc2hHZW9tZXRyeSA9IF9NZXNoR2VvbWV0cnk7XG5cbmV4cG9ydCB7IE1lc2hHZW9tZXRyeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzaEdlb21ldHJ5Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9288\n')},5630:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(4240);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(2540);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs\nvar BatchableMesh = __webpack_require__(2828);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(8592);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs\nvar MeshGeometry = __webpack_require__(9288);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs\n\n\n\n"use strict";\nconst _PlaneGeometry = class _PlaneGeometry extends MeshGeometry/* MeshGeometry */.Q {\n  constructor(...args) {\n    super({});\n    let options = args[0] ?? {};\n    if (typeof options === "number") {\n      (0,deprecation/* deprecation */.e)(deprecation/* v8_0_0 */.q, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead");\n      options = {\n        width: options,\n        height: args[1],\n        verticesX: args[2],\n        verticesY: args[3]\n      };\n    }\n    this.build(options);\n  }\n  /**\n   * Refreshes plane coordinates\n   * @param options - Options to be applied to plane geometry\n   */\n  build(options) {\n    options = { ..._PlaneGeometry.defaultOptions, ...options };\n    this.verticesX = this.verticesX ?? options.verticesX;\n    this.verticesY = this.verticesY ?? options.verticesY;\n    this.width = this.width ?? options.width;\n    this.height = this.height ?? options.height;\n    const total = this.verticesX * this.verticesY;\n    const verts = [];\n    const uvs = [];\n    const indices = [];\n    const verticesX = this.verticesX - 1;\n    const verticesY = this.verticesY - 1;\n    const sizeX = this.width / verticesX;\n    const sizeY = this.height / verticesY;\n    for (let i = 0; i < total; i++) {\n      const x = i % this.verticesX;\n      const y = i / this.verticesX | 0;\n      verts.push(x * sizeX, y * sizeY);\n      uvs.push(x / verticesX, y / verticesY);\n    }\n    const totalSub = verticesX * verticesY;\n    for (let i = 0; i < totalSub; i++) {\n      const xpos = i % verticesX;\n      const ypos = i / verticesX | 0;\n      const value = ypos * this.verticesX + xpos;\n      const value2 = ypos * this.verticesX + xpos + 1;\n      const value3 = (ypos + 1) * this.verticesX + xpos;\n      const value4 = (ypos + 1) * this.verticesX + xpos + 1;\n      indices.push(\n        value,\n        value2,\n        value3,\n        value2,\n        value4,\n        value3\n      );\n    }\n    this.buffers[0].data = new Float32Array(verts);\n    this.buffers[1].data = new Float32Array(uvs);\n    this.indexBuffer.data = new Uint32Array(indices);\n    this.buffers[0].update();\n    this.buffers[1].update();\n    this.indexBuffer.update();\n  }\n};\n_PlaneGeometry.defaultOptions = {\n  width: 100,\n  height: 100,\n  verticesX: 10,\n  verticesY: 10\n};\nlet PlaneGeometry = _PlaneGeometry;\n\n\n//# sourceMappingURL=PlaneGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs\n\n\n"use strict";\nconst _NineSliceGeometry = class _NineSliceGeometry extends PlaneGeometry {\n  constructor(options = {}) {\n    options = { ..._NineSliceGeometry.defaultOptions, ...options };\n    super({\n      width: options.width,\n      height: options.height,\n      verticesX: 4,\n      verticesY: 4\n    });\n    this.update(options);\n  }\n  /**\n   * Updates the NineSliceGeometry with the options.\n   * @param options - The options of the NineSliceGeometry.\n   */\n  update(options) {\n    this.width = options.width ?? this.width;\n    this.height = options.height ?? this.height;\n    this._originalWidth = options.originalWidth ?? this._originalWidth;\n    this._originalHeight = options.originalHeight ?? this._originalHeight;\n    this._leftWidth = options.leftWidth ?? this._leftWidth;\n    this._rightWidth = options.rightWidth ?? this._rightWidth;\n    this._topHeight = options.topHeight ?? this._topHeight;\n    this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n    this.updateUvs();\n    this.updatePositions();\n  }\n  /** Updates the positions of the vertices. */\n  updatePositions() {\n    const positions = this.positions;\n    const w = this._leftWidth + this._rightWidth;\n    const scaleW = this.width > w ? 1 : this.width / w;\n    const h = this._topHeight + this._bottomHeight;\n    const scaleH = this.height > h ? 1 : this.height / h;\n    const scale = Math.min(scaleW, scaleH);\n    positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;\n    positions[17] = positions[19] = positions[21] = positions[23] = this.height - this._bottomHeight * scale;\n    positions[25] = positions[27] = positions[29] = positions[31] = this.height;\n    positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;\n    positions[4] = positions[12] = positions[20] = positions[28] = this.width - this._rightWidth * scale;\n    positions[6] = positions[14] = positions[22] = positions[30] = this.width;\n    this.getBuffer("aPosition").update();\n  }\n  /** Updates the UVs of the vertices. */\n  updateUvs() {\n    const uvs = this.uvs;\n    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n    const _uvw = 1 / this._originalWidth;\n    const _uvh = 1 / this._originalHeight;\n    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;\n    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;\n    this.getBuffer("aUV").update();\n  }\n};\n/** The default options for the NineSliceGeometry. */\n_NineSliceGeometry.defaultOptions = {\n  /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV\'s of this plane. */\n  width: 100,\n  /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV\'s of this plane. */\n  height: 100,\n  /** The width of the left column. */\n  leftWidth: 10,\n  /** The height of the top row. */\n  topHeight: 10,\n  /** The width of the right column. */\n  rightWidth: 10,\n  /** The height of the bottom row. */\n  bottomHeight: 10,\n  /** The original width of the texture */\n  originalWidth: 100,\n  /** The original height of the texture */\n  originalHeight: 100\n};\nlet NineSliceGeometry = _NineSliceGeometry;\n\n\n//# sourceMappingURL=NineSliceGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs\n\n\n\n\n\n"use strict";\nclass NineSliceSpritePipe {\n  constructor(renderer) {\n    this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  addRenderable(sprite, _instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite._didSpriteUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._gpuSpriteHash[sprite.uid];\n    if (sprite._didSpriteUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite.batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const texture = sprite._texture;\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (gpuSprite.texture._source !== texture._source) {\n      return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);\n    }\n    return false;\n  }\n  destroyRenderable(sprite) {\n    const batchableSprite = this._gpuSpriteHash[sprite.uid];\n    PoolGroup/* BigPool */.u.return(batchableSprite);\n    this._gpuSpriteHash[sprite.uid] = null;\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    sprite._didSpriteUpdate = false;\n    batchableSprite.geometry.update(sprite);\n    batchableSprite.texture = sprite._texture;\n  }\n  _getGpuSprite(sprite) {\n    return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const batchableMesh = new BatchableMesh/* BatchableMesh */.Q();\n    batchableMesh.geometry = new NineSliceGeometry();\n    batchableMesh.mesh = sprite;\n    batchableMesh.texture = sprite._texture;\n    batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    this._gpuSpriteHash[sprite.uid] = batchableMesh;\n    sprite.on("destroyed", () => {\n      this.destroyRenderable(sprite);\n    });\n    return batchableMesh;\n  }\n  destroy() {\n    for (const i in this._gpuSpriteHash) {\n      const batchableMesh = this._gpuSpriteHash[i];\n      batchableMesh.geometry.destroy();\n    }\n    this._gpuSpriteHash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nNineSliceSpritePipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.y6.WebGLPipes,\n    Extensions/* ExtensionType */.y6.WebGPUPipes,\n    Extensions/* ExtensionType */.y6.CanvasPipes\n  ],\n  name: "nineSliceSprite"\n};\n\n\n//# sourceMappingURL=NineSliceSpritePipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs\n\n\n\n"use strict";\nExtensions/* extensions */.Yt.add(NineSliceSpritePipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTYzMC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBMEU7QUFDWDs7QUFFL0Q7QUFDQSxvREFBb0QsZ0NBQVk7QUFDaEU7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLE1BQU0sa0NBQVcsQ0FBQyx5QkFBTSxrREFBa0Qsc0NBQXNDO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5QjtBQUN6Qjs7O0FDN0VnRTs7QUFFaEU7QUFDQSw0REFBNEQsYUFBYTtBQUN6RSwwQkFBMEI7QUFDMUIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZCO0FBQzdCOzs7QUNwRmdFO0FBQ1A7QUFDUTtBQUNMOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0JBQU87QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFhO0FBQzNDLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQjtBQUNBO0FBQ0E7O0FBRStCO0FBQy9COzs7QUM1RTZEO0FBQ0c7O0FBRWhFO0FBQ0EsNkJBQVUsS0FBSyxtQkFBbUI7QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvbWVzaC1wbGFuZS9QbGFuZUdlb21ldHJ5Lm1qcz83ZmY4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9zcHJpdGUtbmluZS1zbGljZS9OaW5lU2xpY2VHZW9tZXRyeS5tanM/YmM2ZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvc3ByaXRlLW5pbmUtc2xpY2UvTmluZVNsaWNlU3ByaXRlUGlwZS5tanM/ZjQ2YiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvc3ByaXRlLW5pbmUtc2xpY2UvaW5pdC5tanM/ZmU1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZXByZWNhdGlvbiwgdjhfMF8wIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9nZ2luZy9kZXByZWNhdGlvbi5tanMnO1xuaW1wb3J0IHsgTWVzaEdlb21ldHJ5IH0gZnJvbSAnLi4vbWVzaC9zaGFyZWQvTWVzaEdlb21ldHJ5Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgX1BsYW5lR2VvbWV0cnkgPSBjbGFzcyBfUGxhbmVHZW9tZXRyeSBleHRlbmRzIE1lc2hHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlcih7fSk7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmdzWzBdID8/IHt9O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIlBsYW5lR2VvbWV0cnkgY29uc3RydWN0b3IgY2hhbmdlZCBwbGVhc2UgdXNlIHsgd2lkdGgsIGhlaWdodCwgdmVydGljZXNYLCB2ZXJ0aWNlc1kgfSBpbnN0ZWFkXCIpO1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgd2lkdGg6IG9wdGlvbnMsXG4gICAgICAgIGhlaWdodDogYXJnc1sxXSxcbiAgICAgICAgdmVydGljZXNYOiBhcmdzWzJdLFxuICAgICAgICB2ZXJ0aWNlc1k6IGFyZ3NbM11cbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuYnVpbGQob3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFJlZnJlc2hlcyBwbGFuZSBjb29yZGluYXRlc1xuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gYmUgYXBwbGllZCB0byBwbGFuZSBnZW9tZXRyeVxuICAgKi9cbiAgYnVpbGQob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7IC4uLl9QbGFuZUdlb21ldHJ5LmRlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgdGhpcy52ZXJ0aWNlc1ggPSB0aGlzLnZlcnRpY2VzWCA/PyBvcHRpb25zLnZlcnRpY2VzWDtcbiAgICB0aGlzLnZlcnRpY2VzWSA9IHRoaXMudmVydGljZXNZID8/IG9wdGlvbnMudmVydGljZXNZO1xuICAgIHRoaXMud2lkdGggPSB0aGlzLndpZHRoID8/IG9wdGlvbnMud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmhlaWdodCA/PyBvcHRpb25zLmhlaWdodDtcbiAgICBjb25zdCB0b3RhbCA9IHRoaXMudmVydGljZXNYICogdGhpcy52ZXJ0aWNlc1k7XG4gICAgY29uc3QgdmVydHMgPSBbXTtcbiAgICBjb25zdCB1dnMgPSBbXTtcbiAgICBjb25zdCBpbmRpY2VzID0gW107XG4gICAgY29uc3QgdmVydGljZXNYID0gdGhpcy52ZXJ0aWNlc1ggLSAxO1xuICAgIGNvbnN0IHZlcnRpY2VzWSA9IHRoaXMudmVydGljZXNZIC0gMTtcbiAgICBjb25zdCBzaXplWCA9IHRoaXMud2lkdGggLyB2ZXJ0aWNlc1g7XG4gICAgY29uc3Qgc2l6ZVkgPSB0aGlzLmhlaWdodCAvIHZlcnRpY2VzWTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICAgIGNvbnN0IHggPSBpICUgdGhpcy52ZXJ0aWNlc1g7XG4gICAgICBjb25zdCB5ID0gaSAvIHRoaXMudmVydGljZXNYIHwgMDtcbiAgICAgIHZlcnRzLnB1c2goeCAqIHNpemVYLCB5ICogc2l6ZVkpO1xuICAgICAgdXZzLnB1c2goeCAvIHZlcnRpY2VzWCwgeSAvIHZlcnRpY2VzWSk7XG4gICAgfVxuICAgIGNvbnN0IHRvdGFsU3ViID0gdmVydGljZXNYICogdmVydGljZXNZO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxTdWI7IGkrKykge1xuICAgICAgY29uc3QgeHBvcyA9IGkgJSB2ZXJ0aWNlc1g7XG4gICAgICBjb25zdCB5cG9zID0gaSAvIHZlcnRpY2VzWCB8IDA7XG4gICAgICBjb25zdCB2YWx1ZSA9IHlwb3MgKiB0aGlzLnZlcnRpY2VzWCArIHhwb3M7XG4gICAgICBjb25zdCB2YWx1ZTIgPSB5cG9zICogdGhpcy52ZXJ0aWNlc1ggKyB4cG9zICsgMTtcbiAgICAgIGNvbnN0IHZhbHVlMyA9ICh5cG9zICsgMSkgKiB0aGlzLnZlcnRpY2VzWCArIHhwb3M7XG4gICAgICBjb25zdCB2YWx1ZTQgPSAoeXBvcyArIDEpICogdGhpcy52ZXJ0aWNlc1ggKyB4cG9zICsgMTtcbiAgICAgIGluZGljZXMucHVzaChcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHZhbHVlMixcbiAgICAgICAgdmFsdWUzLFxuICAgICAgICB2YWx1ZTIsXG4gICAgICAgIHZhbHVlNCxcbiAgICAgICAgdmFsdWUzXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlcnNbMF0uZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkodmVydHMpO1xuICAgIHRoaXMuYnVmZmVyc1sxXS5kYXRhID0gbmV3IEZsb2F0MzJBcnJheSh1dnMpO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIuZGF0YSA9IG5ldyBVaW50MzJBcnJheShpbmRpY2VzKTtcbiAgICB0aGlzLmJ1ZmZlcnNbMF0udXBkYXRlKCk7XG4gICAgdGhpcy5idWZmZXJzWzFdLnVwZGF0ZSgpO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIudXBkYXRlKCk7XG4gIH1cbn07XG5fUGxhbmVHZW9tZXRyeS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgd2lkdGg6IDEwMCxcbiAgaGVpZ2h0OiAxMDAsXG4gIHZlcnRpY2VzWDogMTAsXG4gIHZlcnRpY2VzWTogMTBcbn07XG5sZXQgUGxhbmVHZW9tZXRyeSA9IF9QbGFuZUdlb21ldHJ5O1xuXG5leHBvcnQgeyBQbGFuZUdlb21ldHJ5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QbGFuZUdlb21ldHJ5Lm1qcy5tYXBcbiIsImltcG9ydCB7IFBsYW5lR2VvbWV0cnkgfSBmcm9tICcuLi9tZXNoLXBsYW5lL1BsYW5lR2VvbWV0cnkubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfTmluZVNsaWNlR2VvbWV0cnkgPSBjbGFzcyBfTmluZVNsaWNlR2VvbWV0cnkgZXh0ZW5kcyBQbGFuZUdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgb3B0aW9ucyA9IHsgLi4uX05pbmVTbGljZUdlb21ldHJ5LmRlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgc3VwZXIoe1xuICAgICAgd2lkdGg6IG9wdGlvbnMud2lkdGgsXG4gICAgICBoZWlnaHQ6IG9wdGlvbnMuaGVpZ2h0LFxuICAgICAgdmVydGljZXNYOiA0LFxuICAgICAgdmVydGljZXNZOiA0XG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGUob3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIE5pbmVTbGljZUdlb21ldHJ5IHdpdGggdGhlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2YgdGhlIE5pbmVTbGljZUdlb21ldHJ5LlxuICAgKi9cbiAgdXBkYXRlKG9wdGlvbnMpIHtcbiAgICB0aGlzLndpZHRoID0gb3B0aW9ucy53aWR0aCA/PyB0aGlzLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgPz8gdGhpcy5oZWlnaHQ7XG4gICAgdGhpcy5fb3JpZ2luYWxXaWR0aCA9IG9wdGlvbnMub3JpZ2luYWxXaWR0aCA/PyB0aGlzLl9vcmlnaW5hbFdpZHRoO1xuICAgIHRoaXMuX29yaWdpbmFsSGVpZ2h0ID0gb3B0aW9ucy5vcmlnaW5hbEhlaWdodCA/PyB0aGlzLl9vcmlnaW5hbEhlaWdodDtcbiAgICB0aGlzLl9sZWZ0V2lkdGggPSBvcHRpb25zLmxlZnRXaWR0aCA/PyB0aGlzLl9sZWZ0V2lkdGg7XG4gICAgdGhpcy5fcmlnaHRXaWR0aCA9IG9wdGlvbnMucmlnaHRXaWR0aCA/PyB0aGlzLl9yaWdodFdpZHRoO1xuICAgIHRoaXMuX3RvcEhlaWdodCA9IG9wdGlvbnMudG9wSGVpZ2h0ID8/IHRoaXMuX3RvcEhlaWdodDtcbiAgICB0aGlzLl9ib3R0b21IZWlnaHQgPSBvcHRpb25zLmJvdHRvbUhlaWdodCA/PyB0aGlzLl9ib3R0b21IZWlnaHQ7XG4gICAgdGhpcy51cGRhdGVVdnMoKTtcbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9ucygpO1xuICB9XG4gIC8qKiBVcGRhdGVzIHRoZSBwb3NpdGlvbnMgb2YgdGhlIHZlcnRpY2VzLiAqL1xuICB1cGRhdGVQb3NpdGlvbnMoKSB7XG4gICAgY29uc3QgcG9zaXRpb25zID0gdGhpcy5wb3NpdGlvbnM7XG4gICAgY29uc3QgdyA9IHRoaXMuX2xlZnRXaWR0aCArIHRoaXMuX3JpZ2h0V2lkdGg7XG4gICAgY29uc3Qgc2NhbGVXID0gdGhpcy53aWR0aCA+IHcgPyAxIDogdGhpcy53aWR0aCAvIHc7XG4gICAgY29uc3QgaCA9IHRoaXMuX3RvcEhlaWdodCArIHRoaXMuX2JvdHRvbUhlaWdodDtcbiAgICBjb25zdCBzY2FsZUggPSB0aGlzLmhlaWdodCA+IGggPyAxIDogdGhpcy5oZWlnaHQgLyBoO1xuICAgIGNvbnN0IHNjYWxlID0gTWF0aC5taW4oc2NhbGVXLCBzY2FsZUgpO1xuICAgIHBvc2l0aW9uc1s5XSA9IHBvc2l0aW9uc1sxMV0gPSBwb3NpdGlvbnNbMTNdID0gcG9zaXRpb25zWzE1XSA9IHRoaXMuX3RvcEhlaWdodCAqIHNjYWxlO1xuICAgIHBvc2l0aW9uc1sxN10gPSBwb3NpdGlvbnNbMTldID0gcG9zaXRpb25zWzIxXSA9IHBvc2l0aW9uc1syM10gPSB0aGlzLmhlaWdodCAtIHRoaXMuX2JvdHRvbUhlaWdodCAqIHNjYWxlO1xuICAgIHBvc2l0aW9uc1syNV0gPSBwb3NpdGlvbnNbMjddID0gcG9zaXRpb25zWzI5XSA9IHBvc2l0aW9uc1szMV0gPSB0aGlzLmhlaWdodDtcbiAgICBwb3NpdGlvbnNbMl0gPSBwb3NpdGlvbnNbMTBdID0gcG9zaXRpb25zWzE4XSA9IHBvc2l0aW9uc1syNl0gPSB0aGlzLl9sZWZ0V2lkdGggKiBzY2FsZTtcbiAgICBwb3NpdGlvbnNbNF0gPSBwb3NpdGlvbnNbMTJdID0gcG9zaXRpb25zWzIwXSA9IHBvc2l0aW9uc1syOF0gPSB0aGlzLndpZHRoIC0gdGhpcy5fcmlnaHRXaWR0aCAqIHNjYWxlO1xuICAgIHBvc2l0aW9uc1s2XSA9IHBvc2l0aW9uc1sxNF0gPSBwb3NpdGlvbnNbMjJdID0gcG9zaXRpb25zWzMwXSA9IHRoaXMud2lkdGg7XG4gICAgdGhpcy5nZXRCdWZmZXIoXCJhUG9zaXRpb25cIikudXBkYXRlKCk7XG4gIH1cbiAgLyoqIFVwZGF0ZXMgdGhlIFVWcyBvZiB0aGUgdmVydGljZXMuICovXG4gIHVwZGF0ZVV2cygpIHtcbiAgICBjb25zdCB1dnMgPSB0aGlzLnV2cztcbiAgICB1dnNbMF0gPSB1dnNbOF0gPSB1dnNbMTZdID0gdXZzWzI0XSA9IDA7XG4gICAgdXZzWzFdID0gdXZzWzNdID0gdXZzWzVdID0gdXZzWzddID0gMDtcbiAgICB1dnNbNl0gPSB1dnNbMTRdID0gdXZzWzIyXSA9IHV2c1szMF0gPSAxO1xuICAgIHV2c1syNV0gPSB1dnNbMjddID0gdXZzWzI5XSA9IHV2c1szMV0gPSAxO1xuICAgIGNvbnN0IF91dncgPSAxIC8gdGhpcy5fb3JpZ2luYWxXaWR0aDtcbiAgICBjb25zdCBfdXZoID0gMSAvIHRoaXMuX29yaWdpbmFsSGVpZ2h0O1xuICAgIHV2c1syXSA9IHV2c1sxMF0gPSB1dnNbMThdID0gdXZzWzI2XSA9IF91dncgKiB0aGlzLl9sZWZ0V2lkdGg7XG4gICAgdXZzWzldID0gdXZzWzExXSA9IHV2c1sxM10gPSB1dnNbMTVdID0gX3V2aCAqIHRoaXMuX3RvcEhlaWdodDtcbiAgICB1dnNbNF0gPSB1dnNbMTJdID0gdXZzWzIwXSA9IHV2c1syOF0gPSAxIC0gX3V2dyAqIHRoaXMuX3JpZ2h0V2lkdGg7XG4gICAgdXZzWzE3XSA9IHV2c1sxOV0gPSB1dnNbMjFdID0gdXZzWzIzXSA9IDEgLSBfdXZoICogdGhpcy5fYm90dG9tSGVpZ2h0O1xuICAgIHRoaXMuZ2V0QnVmZmVyKFwiYVVWXCIpLnVwZGF0ZSgpO1xuICB9XG59O1xuLyoqIFRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBOaW5lU2xpY2VHZW9tZXRyeS4gKi9cbl9OaW5lU2xpY2VHZW9tZXRyeS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgLyoqIFRoZSB3aWR0aCBvZiB0aGUgTmluZVNsaWNlUGxhbmUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgdmVydGljZXMgYW5kIFVWJ3Mgb2YgdGhpcyBwbGFuZS4gKi9cbiAgd2lkdGg6IDEwMCxcbiAgLyoqIFRoZSBoZWlnaHQgb2YgdGhlIE5pbmVTbGljZVBsYW5lLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHZlcnRpY2VzIGFuZCBVVidzIG9mIHRoaXMgcGxhbmUuICovXG4gIGhlaWdodDogMTAwLFxuICAvKiogVGhlIHdpZHRoIG9mIHRoZSBsZWZ0IGNvbHVtbi4gKi9cbiAgbGVmdFdpZHRoOiAxMCxcbiAgLyoqIFRoZSBoZWlnaHQgb2YgdGhlIHRvcCByb3cuICovXG4gIHRvcEhlaWdodDogMTAsXG4gIC8qKiBUaGUgd2lkdGggb2YgdGhlIHJpZ2h0IGNvbHVtbi4gKi9cbiAgcmlnaHRXaWR0aDogMTAsXG4gIC8qKiBUaGUgaGVpZ2h0IG9mIHRoZSBib3R0b20gcm93LiAqL1xuICBib3R0b21IZWlnaHQ6IDEwLFxuICAvKiogVGhlIG9yaWdpbmFsIHdpZHRoIG9mIHRoZSB0ZXh0dXJlICovXG4gIG9yaWdpbmFsV2lkdGg6IDEwMCxcbiAgLyoqIFRoZSBvcmlnaW5hbCBoZWlnaHQgb2YgdGhlIHRleHR1cmUgKi9cbiAgb3JpZ2luYWxIZWlnaHQ6IDEwMFxufTtcbmxldCBOaW5lU2xpY2VHZW9tZXRyeSA9IF9OaW5lU2xpY2VHZW9tZXRyeTtcblxuZXhwb3J0IHsgTmluZVNsaWNlR2VvbWV0cnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5pbmVTbGljZUdlb21ldHJ5Lm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgQmF0Y2hhYmxlTWVzaCB9IGZyb20gJy4uL21lc2gvc2hhcmVkL0JhdGNoYWJsZU1lc2gubWpzJztcbmltcG9ydCB7IE5pbmVTbGljZUdlb21ldHJ5IH0gZnJvbSAnLi9OaW5lU2xpY2VHZW9tZXRyeS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIE5pbmVTbGljZVNwcml0ZVBpcGUge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX2dwdVNwcml0ZUhhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIGFkZFJlbmRlcmFibGUoc3ByaXRlLCBfaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCBncHVTcHJpdGUgPSB0aGlzLl9nZXRHcHVTcHJpdGUoc3ByaXRlKTtcbiAgICBpZiAoc3ByaXRlLl9kaWRTcHJpdGVVcGRhdGUpXG4gICAgICB0aGlzLl91cGRhdGVCYXRjaGFibGVTcHJpdGUoc3ByaXRlLCBncHVTcHJpdGUpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzLmJhdGNoLmFkZFRvQmF0Y2goZ3B1U3ByaXRlKTtcbiAgfVxuICB1cGRhdGVSZW5kZXJhYmxlKHNwcml0ZSkge1xuICAgIGNvbnN0IGdwdVNwcml0ZSA9IHRoaXMuX2dwdVNwcml0ZUhhc2hbc3ByaXRlLnVpZF07XG4gICAgaWYgKHNwcml0ZS5fZGlkU3ByaXRlVXBkYXRlKVxuICAgICAgdGhpcy5fdXBkYXRlQmF0Y2hhYmxlU3ByaXRlKHNwcml0ZSwgZ3B1U3ByaXRlKTtcbiAgICBncHVTcHJpdGUuYmF0Y2hlci51cGRhdGVFbGVtZW50KGdwdVNwcml0ZSk7XG4gIH1cbiAgdmFsaWRhdGVSZW5kZXJhYmxlKHNwcml0ZSkge1xuICAgIGNvbnN0IHRleHR1cmUgPSBzcHJpdGUuX3RleHR1cmU7XG4gICAgY29uc3QgZ3B1U3ByaXRlID0gdGhpcy5fZ2V0R3B1U3ByaXRlKHNwcml0ZSk7XG4gICAgaWYgKGdwdVNwcml0ZS50ZXh0dXJlLl9zb3VyY2UgIT09IHRleHR1cmUuX3NvdXJjZSkge1xuICAgICAgcmV0dXJuICFncHVTcHJpdGUuYmF0Y2hlci5jaGVja0FuZFVwZGF0ZVRleHR1cmUoZ3B1U3ByaXRlLCB0ZXh0dXJlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRlc3Ryb3lSZW5kZXJhYmxlKHNwcml0ZSkge1xuICAgIGNvbnN0IGJhdGNoYWJsZVNwcml0ZSA9IHRoaXMuX2dwdVNwcml0ZUhhc2hbc3ByaXRlLnVpZF07XG4gICAgQmlnUG9vbC5yZXR1cm4oYmF0Y2hhYmxlU3ByaXRlKTtcbiAgICB0aGlzLl9ncHVTcHJpdGVIYXNoW3Nwcml0ZS51aWRdID0gbnVsbDtcbiAgfVxuICBfdXBkYXRlQmF0Y2hhYmxlU3ByaXRlKHNwcml0ZSwgYmF0Y2hhYmxlU3ByaXRlKSB7XG4gICAgc3ByaXRlLl9kaWRTcHJpdGVVcGRhdGUgPSBmYWxzZTtcbiAgICBiYXRjaGFibGVTcHJpdGUuZ2VvbWV0cnkudXBkYXRlKHNwcml0ZSk7XG4gICAgYmF0Y2hhYmxlU3ByaXRlLnRleHR1cmUgPSBzcHJpdGUuX3RleHR1cmU7XG4gIH1cbiAgX2dldEdwdVNwcml0ZShzcHJpdGUpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3B1U3ByaXRlSGFzaFtzcHJpdGUudWlkXSB8fCB0aGlzLl9pbml0R1BVU3ByaXRlKHNwcml0ZSk7XG4gIH1cbiAgX2luaXRHUFVTcHJpdGUoc3ByaXRlKSB7XG4gICAgY29uc3QgYmF0Y2hhYmxlTWVzaCA9IG5ldyBCYXRjaGFibGVNZXNoKCk7XG4gICAgYmF0Y2hhYmxlTWVzaC5nZW9tZXRyeSA9IG5ldyBOaW5lU2xpY2VHZW9tZXRyeSgpO1xuICAgIGJhdGNoYWJsZU1lc2gubWVzaCA9IHNwcml0ZTtcbiAgICBiYXRjaGFibGVNZXNoLnRleHR1cmUgPSBzcHJpdGUuX3RleHR1cmU7XG4gICAgYmF0Y2hhYmxlTWVzaC5yb3VuZFBpeGVscyA9IHRoaXMuX3JlbmRlcmVyLl9yb3VuZFBpeGVscyB8IHNwcml0ZS5fcm91bmRQaXhlbHM7XG4gICAgdGhpcy5fZ3B1U3ByaXRlSGFzaFtzcHJpdGUudWlkXSA9IGJhdGNoYWJsZU1lc2g7XG4gICAgc3ByaXRlLm9uKFwiZGVzdHJveWVkXCIsICgpID0+IHtcbiAgICAgIHRoaXMuZGVzdHJveVJlbmRlcmFibGUoc3ByaXRlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYmF0Y2hhYmxlTWVzaDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLl9ncHVTcHJpdGVIYXNoKSB7XG4gICAgICBjb25zdCBiYXRjaGFibGVNZXNoID0gdGhpcy5fZ3B1U3ByaXRlSGFzaFtpXTtcbiAgICAgIGJhdGNoYWJsZU1lc2guZ2VvbWV0cnkuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLl9ncHVTcHJpdGVIYXNoID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5OaW5lU2xpY2VTcHJpdGVQaXBlLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLldlYkdQVVBpcGVzLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUGlwZXNcbiAgXSxcbiAgbmFtZTogXCJuaW5lU2xpY2VTcHJpdGVcIlxufTtcblxuZXhwb3J0IHsgTmluZVNsaWNlU3ByaXRlUGlwZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmluZVNsaWNlU3ByaXRlUGlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBleHRlbnNpb25zIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBOaW5lU2xpY2VTcHJpdGVQaXBlIH0gZnJvbSAnLi9OaW5lU2xpY2VTcHJpdGVQaXBlLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZXh0ZW5zaW9ucy5hZGQoTmluZVNsaWNlU3ByaXRlUGlwZSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5630\n')},6336:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(4240);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs\nvar getAdjustedBlendModeBlend = __webpack_require__(9316);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs\nvar State = __webpack_require__(9952);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/types.mjs\nvar types = __webpack_require__(8640);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs\nvar colorToUniform = __webpack_require__(9652);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs\nvar BatchableMesh = __webpack_require__(2828);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs\nvar MeshGeometry = __webpack_require__(9288);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(328);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs + 8 modules\nvar compileHighShaderToProgram = __webpack_require__(9936);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs\nvar localUniformBit = __webpack_require__(304);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs\nvar roundPixelsBit = __webpack_require__(1124);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs\nvar Shader = __webpack_require__(1656);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 2 modules\nvar UniformGroup = __webpack_require__(5596);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(8518);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs\n\nconst tilingBit = {\n  name: "tiling-bit",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            } \n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    )\n  }\n};\nconst tilingBitGl = {\n  name: "tiling-bit",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n        \n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n        \n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n    \n        `\n    )\n  }\n};\n\n\n//# sourceMappingURL=tilingBit.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs\n\n\n\n\n\n\n\n\n\n"use strict";\nlet gpuProgram;\nlet glProgram;\nclass TilingSpriteShader extends Shader/* Shader */.g {\n  constructor() {\n    gpuProgram ?? (gpuProgram = (0,compileHighShaderToProgram/* compileHighShaderGpuProgram */.c)({\n      name: "tiling-sprite-shader",\n      bits: [\n        localUniformBit/* localUniformBit */.Ss,\n        tilingBit,\n        roundPixelsBit/* roundPixelsBit */.i\n      ]\n    }));\n    glProgram ?? (glProgram = (0,compileHighShaderToProgram/* compileHighShaderGlProgram */.o)({\n      name: "tiling-sprite-shader",\n      bits: [\n        localUniformBit/* localUniformBitGl */.UD,\n        tilingBitGl,\n        roundPixelsBit/* roundPixelsBitGl */.Q\n      ]\n    }));\n    const tilingUniforms = new UniformGroup/* UniformGroup */.W({\n      uMapCoord: { value: new Matrix/* Matrix */.W(), type: "mat3x3<f32>" },\n      uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" },\n      uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" },\n      uTextureTransform: { value: new Matrix/* Matrix */.W(), type: "mat3x3<f32>" },\n      uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: "vec4<f32>" }\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: new UniformGroup/* UniformGroup */.W({\n          uTransformMatrix: { value: new Matrix/* Matrix */.W(), type: "mat3x3<f32>" },\n          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },\n          uRound: { value: 0, type: "f32" }\n        }),\n        tilingUniforms,\n        uTexture: Texture/* Texture */.w.EMPTY.source,\n        uSampler: Texture/* Texture */.w.EMPTY.source.style\n      }\n    });\n  }\n  updateUniforms(width, height, matrix, anchorX, anchorY, texture) {\n    const tilingUniforms = this.resources.tilingUniforms;\n    const textureWidth = texture.width;\n    const textureHeight = texture.height;\n    const textureMatrix = texture.textureMatrix;\n    const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n    uTextureTransform.set(\n      matrix.a * textureWidth / width,\n      matrix.b * textureWidth / height,\n      matrix.c * textureHeight / width,\n      matrix.d * textureHeight / height,\n      matrix.tx / width,\n      matrix.ty / height\n    );\n    uTextureTransform.invert();\n    tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n    tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n    tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n    tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n    tilingUniforms.uniforms.uSizeAnchor[0] = width;\n    tilingUniforms.uniforms.uSizeAnchor[1] = height;\n    tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n    tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n    if (texture) {\n      this.resources.uTexture = texture.source;\n      this.resources.uSampler = texture.source.style;\n    }\n  }\n}\n\n\n//# sourceMappingURL=TilingSpriteShader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs\n\n\n"use strict";\nclass QuadGeometry extends MeshGeometry/* MeshGeometry */.Q {\n  constructor() {\n    super({\n      positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      indices: new Uint32Array([0, 1, 2, 0, 2, 3])\n    });\n  }\n}\n\n\n//# sourceMappingURL=QuadGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs\n\nfunction setPositions(tilingSprite, positions) {\n  const anchorX = tilingSprite.anchor.x;\n  const anchorY = tilingSprite.anchor.y;\n  positions[0] = -anchorX * tilingSprite.width;\n  positions[1] = -anchorY * tilingSprite.height;\n  positions[2] = (1 - anchorX) * tilingSprite.width;\n  positions[3] = -anchorY * tilingSprite.height;\n  positions[4] = (1 - anchorX) * tilingSprite.width;\n  positions[5] = (1 - anchorY) * tilingSprite.height;\n  positions[6] = -anchorX * tilingSprite.width;\n  positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n\n\n//# sourceMappingURL=setPositions.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs\n\nfunction applyMatrix(array, stride, offset, matrix) {\n  let index = 0;\n  const size = array.length / (stride || 2);\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  offset *= stride;\n  while (index < size) {\n    const x = array[offset];\n    const y = array[offset + 1];\n    array[offset] = a * x + c * y + tx;\n    array[offset + 1] = b * x + d * y + ty;\n    offset += stride;\n    index++;\n  }\n}\n\n\n//# sourceMappingURL=applyMatrix.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs\n\n\n\n"use strict";\nfunction setUvs(tilingSprite, uvs) {\n  const texture = tilingSprite.texture;\n  const width = texture.frame.width;\n  const height = texture.frame.height;\n  let anchorX = 0;\n  let anchorY = 0;\n  if (tilingSprite._applyAnchorToTexture) {\n    anchorX = tilingSprite.anchor.x;\n    anchorY = tilingSprite.anchor.y;\n  }\n  uvs[0] = uvs[6] = -anchorX;\n  uvs[2] = uvs[4] = 1 - anchorX;\n  uvs[1] = uvs[3] = -anchorY;\n  uvs[5] = uvs[7] = 1 - anchorY;\n  const textureMatrix = Matrix/* Matrix */.W.shared;\n  textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n  textureMatrix.tx /= tilingSprite.width;\n  textureMatrix.ty /= tilingSprite.height;\n  textureMatrix.invert();\n  textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n  applyMatrix(uvs, 2, 0, textureMatrix);\n}\n\n\n//# sourceMappingURL=setUvs.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst sharedQuad = new QuadGeometry();\nclass TilingSpritePipe {\n  constructor(renderer) {\n    this._state = State/* State */.A.default2d;\n    this._tilingSpriteDataHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  validateRenderable(renderable) {\n    const tilingSpriteData = this._getTilingSpriteData(renderable);\n    const couldBatch = tilingSpriteData.canBatch;\n    this._updateCanBatch(renderable);\n    const canBatch = tilingSpriteData.canBatch;\n    if (canBatch && canBatch === couldBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      if (batchableMesh && batchableMesh.texture._source !== renderable.texture._source) {\n        return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, renderable.texture);\n      }\n    }\n    return couldBatch !== canBatch;\n  }\n  addRenderable(tilingSprite, instructionSet) {\n    const batcher = this._renderer.renderPipes.batch;\n    this._updateCanBatch(tilingSprite);\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { geometry, canBatch } = tilingSpriteData;\n    if (canBatch) {\n      tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh/* BatchableMesh */.Q());\n      const batchableMesh = tilingSpriteData.batchableMesh;\n      if (tilingSprite._didTilingSpriteUpdate) {\n        tilingSprite._didTilingSpriteUpdate = false;\n        this._updateBatchableMesh(tilingSprite);\n        batchableMesh.geometry = geometry;\n        batchableMesh.mesh = tilingSprite;\n        batchableMesh.texture = tilingSprite._texture;\n      }\n      batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;\n      batcher.addToBatch(batchableMesh);\n    } else {\n      batcher.break(instructionSet);\n      tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader());\n      this.updateRenderable(tilingSprite);\n      instructionSet.add(tilingSprite);\n    }\n  }\n  execute(tilingSprite) {\n    const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];\n    shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n    localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n    (0,colorToUniform/* color32BitToUniform */.u)(\n      tilingSprite.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._state.blendMode = (0,getAdjustedBlendModeBlend/* getAdjustedBlendModeBlend */.C)(tilingSprite.groupBlendMode, tilingSprite.texture._source);\n    this._renderer.encoder.draw({\n      geometry: sharedQuad,\n      shader,\n      state: this._state\n    });\n  }\n  updateRenderable(tilingSprite) {\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { canBatch } = tilingSpriteData;\n    if (canBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      if (tilingSprite._didTilingSpriteUpdate)\n        this._updateBatchableMesh(tilingSprite);\n      batchableMesh.batcher.updateElement(batchableMesh);\n    } else if (tilingSprite._didTilingSpriteUpdate) {\n      const { shader } = tilingSpriteData;\n      shader.updateUniforms(\n        tilingSprite.width,\n        tilingSprite.height,\n        tilingSprite._tileTransform.matrix,\n        tilingSprite.anchor.x,\n        tilingSprite.anchor.y,\n        tilingSprite.texture\n      );\n    }\n    tilingSprite._didTilingSpriteUpdate = false;\n  }\n  destroyRenderable(tilingSprite) {\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    tilingSpriteData.batchableMesh = null;\n    tilingSpriteData.shader?.destroy();\n    this._tilingSpriteDataHash[tilingSprite.uid] = null;\n  }\n  _getTilingSpriteData(renderable) {\n    return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);\n  }\n  _initTilingSpriteData(tilingSprite) {\n    const geometry = new MeshGeometry/* MeshGeometry */.Q({\n      indices: sharedQuad.indices,\n      positions: sharedQuad.positions.slice(),\n      uvs: sharedQuad.uvs.slice()\n    });\n    this._tilingSpriteDataHash[tilingSprite.uid] = {\n      canBatch: true,\n      renderable: tilingSprite,\n      geometry\n    };\n    tilingSprite.on("destroyed", () => {\n      this.destroyRenderable(tilingSprite);\n    });\n    return this._tilingSpriteDataHash[tilingSprite.uid];\n  }\n  _updateBatchableMesh(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const { geometry } = renderableData;\n    const style = tilingSprite.texture.source.style;\n    if (style.addressMode !== "repeat") {\n      style.addressMode = "repeat";\n      style.update();\n    }\n    setUvs(tilingSprite, geometry.uvs);\n    setPositions(tilingSprite, geometry.positions);\n  }\n  destroy() {\n    for (const i in this._tilingSpriteDataHash) {\n      this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);\n    }\n    this._tilingSpriteDataHash = null;\n    this._renderer = null;\n  }\n  _updateCanBatch(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const texture = tilingSprite.texture;\n    let _nonPowOf2wrapping = true;\n    if (this._renderer.type === types/* RendererType */.G.WEBGL) {\n      _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;\n    }\n    renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n    return renderableData.canBatch;\n  }\n}\n/** @ignore */\nTilingSpritePipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.y6.WebGLPipes,\n    Extensions/* ExtensionType */.y6.WebGPUPipes,\n    Extensions/* ExtensionType */.y6.CanvasPipes\n  ],\n  name: "tilingSprite"\n};\n\n\n//# sourceMappingURL=TilingSpritePipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs\n\n\n\n"use strict";\nExtensions/* extensions */.Yt.add(TilingSpritePipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LElBQUksTUFBTTtBQUNWLElBQUksWUFBWTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MseUJBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakI7QUFDQTtBQUNBOztBQUU0QjtBQUM1Qjs7O0FDaks2RDtBQUNIOztBQUUxRDtBQUNBLDZCQUFVLEtBQUssZ0JBQWdCO0FBQy9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3Nwcml0ZS10aWxpbmcvc2hhZGVyL3RpbGluZ0JpdC5tanM/OWRiZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvc3ByaXRlLXRpbGluZy9zaGFkZXIvVGlsaW5nU3ByaXRlU2hhZGVyLm1qcz81ODUyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9zcHJpdGUtdGlsaW5nL3V0aWxzL1F1YWRHZW9tZXRyeS5tanM/OGExYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvc3ByaXRlLXRpbGluZy91dGlscy9zZXRQb3NpdGlvbnMubWpzPzg0OWUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3Nwcml0ZS10aWxpbmcvdXRpbHMvYXBwbHlNYXRyaXgubWpzPzllYWQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3Nwcml0ZS10aWxpbmcvdXRpbHMvc2V0VXZzLm1qcz9lZTkyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS9zcHJpdGUtdGlsaW5nL1RpbGluZ1Nwcml0ZVBpcGUubWpzPzhkNDMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3Nwcml0ZS10aWxpbmcvaW5pdC5tanM/ZDBhYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHRpbGluZ0JpdCA9IHtcbiAgbmFtZTogXCJ0aWxpbmctYml0XCIsXG4gIHZlcnRleDoge1xuICAgIGhlYWRlcjogKFxuICAgICAgLyogd2dzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgc3RydWN0IFRpbGluZ1VuaWZvcm1zIHtcbiAgICAgICAgICAgICAgICB1TWFwQ29vcmQ6bWF0M3gzPGYzMj4sXG4gICAgICAgICAgICAgICAgdUNsYW1wRnJhbWU6dmVjNDxmMzI+LFxuICAgICAgICAgICAgICAgIHVDbGFtcE9mZnNldDp2ZWMyPGYzMj4sXG4gICAgICAgICAgICAgICAgdVRleHR1cmVUcmFuc2Zvcm06bWF0M3gzPGYzMj4sXG4gICAgICAgICAgICAgICAgdVNpemVBbmNob3I6dmVjNDxmMzI+XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBAZ3JvdXAoMikgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IHRpbGluZ1VuaWZvcm1zOiBUaWxpbmdVbmlmb3JtcztcbiAgICAgICAgICAgIEBncm91cCgyKSBAYmluZGluZygxKSB2YXIgdVRleHR1cmU6IHRleHR1cmVfMmQ8ZjMyPjtcbiAgICAgICAgICAgIEBncm91cCgyKSBAYmluZGluZygyKSB2YXIgdVNhbXBsZXI6IHNhbXBsZXI7XG4gICAgICAgIGBcbiAgICApLFxuICAgIG1haW46IChcbiAgICAgIC8qIHdnc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIHV2ID0gKHRpbGluZ1VuaWZvcm1zLnVUZXh0dXJlVHJhbnNmb3JtICogdmVjMyh1diwgMS4wKSkueHk7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uID0gKHBvc2l0aW9uIC0gdGlsaW5nVW5pZm9ybXMudVNpemVBbmNob3IuencpICogdGlsaW5nVW5pZm9ybXMudVNpemVBbmNob3IueHk7XG4gICAgICAgIGBcbiAgICApXG4gIH0sXG4gIGZyYWdtZW50OiB7XG4gICAgaGVhZGVyOiAoXG4gICAgICAvKiB3Z3NsICovXG4gICAgICBgXG4gICAgICAgICAgICBzdHJ1Y3QgVGlsaW5nVW5pZm9ybXMge1xuICAgICAgICAgICAgICAgIHVNYXBDb29yZDptYXQzeDM8ZjMyPixcbiAgICAgICAgICAgICAgICB1Q2xhbXBGcmFtZTp2ZWM0PGYzMj4sXG4gICAgICAgICAgICAgICAgdUNsYW1wT2Zmc2V0OnZlYzI8ZjMyPixcbiAgICAgICAgICAgICAgICB1VGV4dHVyZVRyYW5zZm9ybTptYXQzeDM8ZjMyPixcbiAgICAgICAgICAgICAgICB1U2l6ZUFuY2hvcjp2ZWM0PGYzMj5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIEBncm91cCgyKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gdGlsaW5nVW5pZm9ybXM6IFRpbGluZ1VuaWZvcm1zO1xuICAgICAgICAgICAgQGdyb3VwKDIpIEBiaW5kaW5nKDEpIHZhciB1VGV4dHVyZTogdGV4dHVyZV8yZDxmMzI+O1xuICAgICAgICAgICAgQGdyb3VwKDIpIEBiaW5kaW5nKDIpIHZhciB1U2FtcGxlcjogc2FtcGxlcjtcbiAgICAgICAgYFxuICAgICksXG4gICAgbWFpbjogKFxuICAgICAgLyogd2dzbCAqL1xuICAgICAgYFxuXG4gICAgICAgICAgICB2YXIgY29vcmQgPSB2VVYgKyBjZWlsKHRpbGluZ1VuaWZvcm1zLnVDbGFtcE9mZnNldCAtIHZVVik7XG4gICAgICAgICAgICBjb29yZCA9ICh0aWxpbmdVbmlmb3Jtcy51TWFwQ29vcmQgKiB2ZWMzKGNvb3JkLCAxLjApKS54eTtcbiAgICAgICAgICAgIHZhciB1bmNsYW1wZWQgPSBjb29yZDtcbiAgICAgICAgICAgIGNvb3JkID0gY2xhbXAoY29vcmQsIHRpbGluZ1VuaWZvcm1zLnVDbGFtcEZyYW1lLnh5LCB0aWxpbmdVbmlmb3Jtcy51Q2xhbXBGcmFtZS56dyk7XG5cbiAgICAgICAgICAgIHZhciBiaWFzID0gMC47XG5cbiAgICAgICAgICAgIGlmKHVuY2xhbXBlZC54ID09IGNvb3JkLnggJiYgdW5jbGFtcGVkLnkgPT0gY29vcmQueSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiaWFzID0gLTMyLjtcbiAgICAgICAgICAgIH0gXG5cbiAgICAgICAgICAgIG91dENvbG9yID0gdGV4dHVyZVNhbXBsZUJpYXModVRleHR1cmUsIHVTYW1wbGVyLCBjb29yZCwgYmlhcyk7XG4gICAgICAgIGBcbiAgICApXG4gIH1cbn07XG5jb25zdCB0aWxpbmdCaXRHbCA9IHtcbiAgbmFtZTogXCJ0aWxpbmctYml0XCIsXG4gIHZlcnRleDoge1xuICAgIGhlYWRlcjogKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHVUZXh0dXJlVHJhbnNmb3JtO1xuICAgICAgICAgICAgdW5pZm9ybSB2ZWM0IHVTaXplQW5jaG9yO1xuICAgICAgICBcbiAgICAgICAgYFxuICAgICksXG4gICAgbWFpbjogKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgdXYgPSAodVRleHR1cmVUcmFuc2Zvcm0gKiB2ZWMzKGFVViwgMS4wKSkueHk7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uID0gKHBvc2l0aW9uIC0gdVNpemVBbmNob3IuencpICogdVNpemVBbmNob3IueHk7XG4gICAgICAgIGBcbiAgICApXG4gIH0sXG4gIGZyYWdtZW50OiB7XG4gICAgaGVhZGVyOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgXG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyB1TWFwQ29vcmQ7XG4gICAgICAgICAgICB1bmlmb3JtIHZlYzQgdUNsYW1wRnJhbWU7XG4gICAgICAgICAgICB1bmlmb3JtIHZlYzIgdUNsYW1wT2Zmc2V0O1xuICAgICAgICBgXG4gICAgKSxcbiAgICBtYWluOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgXG5cbiAgICAgICAgdmVjMiBjb29yZCA9IHZVViArIGNlaWwodUNsYW1wT2Zmc2V0IC0gdlVWKTtcbiAgICAgICAgY29vcmQgPSAodU1hcENvb3JkICogdmVjMyhjb29yZCwgMS4wKSkueHk7XG4gICAgICAgIHZlYzIgdW5jbGFtcGVkID0gY29vcmQ7XG4gICAgICAgIGNvb3JkID0gY2xhbXAoY29vcmQsIHVDbGFtcEZyYW1lLnh5LCB1Q2xhbXBGcmFtZS56dyk7XG4gICAgICAgIFxuICAgICAgICBvdXRDb2xvciA9IHRleHR1cmUodVRleHR1cmUsIGNvb3JkLCB1bmNsYW1wZWQgPT0gY29vcmQgPyAwLjAgOiAtMzIuMCk7Ly8gbG9kLWJpYXMgdmVyeSBuZWdhdGl2ZSB0byBmb3JjZSBsb2QgMFxuICAgIFxuICAgICAgICBgXG4gICAgKVxuICB9XG59O1xuXG5leHBvcnQgeyB0aWxpbmdCaXQsIHRpbGluZ0JpdEdsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aWxpbmdCaXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgY29tcGlsZUhpZ2hTaGFkZXJHcHVQcm9ncmFtLCBjb21waWxlSGlnaFNoYWRlckdsUHJvZ3JhbSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9oaWdoLXNoYWRlci9jb21waWxlSGlnaFNoYWRlclRvUHJvZ3JhbS5tanMnO1xuaW1wb3J0IHsgbG9jYWxVbmlmb3JtQml0LCBsb2NhbFVuaWZvcm1CaXRHbCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9oaWdoLXNoYWRlci9zaGFkZXItYml0cy9sb2NhbFVuaWZvcm1CaXQubWpzJztcbmltcG9ydCB7IHJvdW5kUGl4ZWxzQml0LCByb3VuZFBpeGVsc0JpdEdsIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2hpZ2gtc2hhZGVyL3NoYWRlci1iaXRzL3JvdW5kUGl4ZWxzQml0Lm1qcyc7XG5pbXBvcnQgeyBTaGFkZXIgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvU2hhZGVyLm1qcyc7XG5pbXBvcnQgeyBVbmlmb3JtR3JvdXAgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvVW5pZm9ybUdyb3VwLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyB0aWxpbmdCaXQsIHRpbGluZ0JpdEdsIH0gZnJvbSAnLi90aWxpbmdCaXQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5sZXQgZ3B1UHJvZ3JhbTtcbmxldCBnbFByb2dyYW07XG5jbGFzcyBUaWxpbmdTcHJpdGVTaGFkZXIgZXh0ZW5kcyBTaGFkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBncHVQcm9ncmFtID8/IChncHVQcm9ncmFtID0gY29tcGlsZUhpZ2hTaGFkZXJHcHVQcm9ncmFtKHtcbiAgICAgIG5hbWU6IFwidGlsaW5nLXNwcml0ZS1zaGFkZXJcIixcbiAgICAgIGJpdHM6IFtcbiAgICAgICAgbG9jYWxVbmlmb3JtQml0LFxuICAgICAgICB0aWxpbmdCaXQsXG4gICAgICAgIHJvdW5kUGl4ZWxzQml0XG4gICAgICBdXG4gICAgfSkpO1xuICAgIGdsUHJvZ3JhbSA/PyAoZ2xQcm9ncmFtID0gY29tcGlsZUhpZ2hTaGFkZXJHbFByb2dyYW0oe1xuICAgICAgbmFtZTogXCJ0aWxpbmctc3ByaXRlLXNoYWRlclwiLFxuICAgICAgYml0czogW1xuICAgICAgICBsb2NhbFVuaWZvcm1CaXRHbCxcbiAgICAgICAgdGlsaW5nQml0R2wsXG4gICAgICAgIHJvdW5kUGl4ZWxzQml0R2xcbiAgICAgIF1cbiAgICB9KSk7XG4gICAgY29uc3QgdGlsaW5nVW5pZm9ybXMgPSBuZXcgVW5pZm9ybUdyb3VwKHtcbiAgICAgIHVNYXBDb29yZDogeyB2YWx1ZTogbmV3IE1hdHJpeCgpLCB0eXBlOiBcIm1hdDN4MzxmMzI+XCIgfSxcbiAgICAgIHVDbGFtcEZyYW1lOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxLCAxXSksIHR5cGU6IFwidmVjNDxmMzI+XCIgfSxcbiAgICAgIHVDbGFtcE9mZnNldDogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShbMCwgMF0pLCB0eXBlOiBcInZlYzI8ZjMyPlwiIH0sXG4gICAgICB1VGV4dHVyZVRyYW5zZm9ybTogeyB2YWx1ZTogbmV3IE1hdHJpeCgpLCB0eXBlOiBcIm1hdDN4MzxmMzI+XCIgfSxcbiAgICAgIHVTaXplQW5jaG9yOiB7IHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KFsxMDAsIDEwMCwgMC41LCAwLjVdKSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9XG4gICAgfSk7XG4gICAgc3VwZXIoe1xuICAgICAgZ2xQcm9ncmFtLFxuICAgICAgZ3B1UHJvZ3JhbSxcbiAgICAgIHJlc291cmNlczoge1xuICAgICAgICBsb2NhbFVuaWZvcm1zOiBuZXcgVW5pZm9ybUdyb3VwKHtcbiAgICAgICAgICB1VHJhbnNmb3JtTWF0cml4OiB7IHZhbHVlOiBuZXcgTWF0cml4KCksIHR5cGU6IFwibWF0M3gzPGYzMj5cIiB9LFxuICAgICAgICAgIHVDb2xvcjogeyB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMSwgMV0pLCB0eXBlOiBcInZlYzQ8ZjMyPlwiIH0sXG4gICAgICAgICAgdVJvdW5kOiB7IHZhbHVlOiAwLCB0eXBlOiBcImYzMlwiIH1cbiAgICAgICAgfSksXG4gICAgICAgIHRpbGluZ1VuaWZvcm1zLFxuICAgICAgICB1VGV4dHVyZTogVGV4dHVyZS5FTVBUWS5zb3VyY2UsXG4gICAgICAgIHVTYW1wbGVyOiBUZXh0dXJlLkVNUFRZLnNvdXJjZS5zdHlsZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVVuaWZvcm1zKHdpZHRoLCBoZWlnaHQsIG1hdHJpeCwgYW5jaG9yWCwgYW5jaG9yWSwgdGV4dHVyZSkge1xuICAgIGNvbnN0IHRpbGluZ1VuaWZvcm1zID0gdGhpcy5yZXNvdXJjZXMudGlsaW5nVW5pZm9ybXM7XG4gICAgY29uc3QgdGV4dHVyZVdpZHRoID0gdGV4dHVyZS53aWR0aDtcbiAgICBjb25zdCB0ZXh0dXJlSGVpZ2h0ID0gdGV4dHVyZS5oZWlnaHQ7XG4gICAgY29uc3QgdGV4dHVyZU1hdHJpeCA9IHRleHR1cmUudGV4dHVyZU1hdHJpeDtcbiAgICBjb25zdCB1VGV4dHVyZVRyYW5zZm9ybSA9IHRpbGluZ1VuaWZvcm1zLnVuaWZvcm1zLnVUZXh0dXJlVHJhbnNmb3JtO1xuICAgIHVUZXh0dXJlVHJhbnNmb3JtLnNldChcbiAgICAgIG1hdHJpeC5hICogdGV4dHVyZVdpZHRoIC8gd2lkdGgsXG4gICAgICBtYXRyaXguYiAqIHRleHR1cmVXaWR0aCAvIGhlaWdodCxcbiAgICAgIG1hdHJpeC5jICogdGV4dHVyZUhlaWdodCAvIHdpZHRoLFxuICAgICAgbWF0cml4LmQgKiB0ZXh0dXJlSGVpZ2h0IC8gaGVpZ2h0LFxuICAgICAgbWF0cml4LnR4IC8gd2lkdGgsXG4gICAgICBtYXRyaXgudHkgLyBoZWlnaHRcbiAgICApO1xuICAgIHVUZXh0dXJlVHJhbnNmb3JtLmludmVydCgpO1xuICAgIHRpbGluZ1VuaWZvcm1zLnVuaWZvcm1zLnVNYXBDb29yZCA9IHRleHR1cmVNYXRyaXgubWFwQ29vcmQ7XG4gICAgdGlsaW5nVW5pZm9ybXMudW5pZm9ybXMudUNsYW1wRnJhbWUgPSB0ZXh0dXJlTWF0cml4LnVDbGFtcEZyYW1lO1xuICAgIHRpbGluZ1VuaWZvcm1zLnVuaWZvcm1zLnVDbGFtcE9mZnNldCA9IHRleHR1cmVNYXRyaXgudUNsYW1wT2Zmc2V0O1xuICAgIHRpbGluZ1VuaWZvcm1zLnVuaWZvcm1zLnVUZXh0dXJlVHJhbnNmb3JtID0gdVRleHR1cmVUcmFuc2Zvcm07XG4gICAgdGlsaW5nVW5pZm9ybXMudW5pZm9ybXMudVNpemVBbmNob3JbMF0gPSB3aWR0aDtcbiAgICB0aWxpbmdVbmlmb3Jtcy51bmlmb3Jtcy51U2l6ZUFuY2hvclsxXSA9IGhlaWdodDtcbiAgICB0aWxpbmdVbmlmb3Jtcy51bmlmb3Jtcy51U2l6ZUFuY2hvclsyXSA9IGFuY2hvclg7XG4gICAgdGlsaW5nVW5pZm9ybXMudW5pZm9ybXMudVNpemVBbmNob3JbM10gPSBhbmNob3JZO1xuICAgIGlmICh0ZXh0dXJlKSB7XG4gICAgICB0aGlzLnJlc291cmNlcy51VGV4dHVyZSA9IHRleHR1cmUuc291cmNlO1xuICAgICAgdGhpcy5yZXNvdXJjZXMudVNhbXBsZXIgPSB0ZXh0dXJlLnNvdXJjZS5zdHlsZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgVGlsaW5nU3ByaXRlU2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWxpbmdTcHJpdGVTaGFkZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWVzaEdlb21ldHJ5IH0gZnJvbSAnLi4vLi4vbWVzaC9zaGFyZWQvTWVzaEdlb21ldHJ5Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY2xhc3MgUXVhZEdlb21ldHJ5IGV4dGVuZHMgTWVzaEdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgcG9zaXRpb25zOiBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAxLCAwLCAxLCAxLCAwLCAxXSksXG4gICAgICB1dnM6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDEsIDAsIDEsIDEsIDAsIDFdKSxcbiAgICAgIGluZGljZXM6IG5ldyBVaW50MzJBcnJheShbMCwgMSwgMiwgMCwgMiwgM10pXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgUXVhZEdlb21ldHJ5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1RdWFkR2VvbWV0cnkubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBzZXRQb3NpdGlvbnModGlsaW5nU3ByaXRlLCBwb3NpdGlvbnMpIHtcbiAgY29uc3QgYW5jaG9yWCA9IHRpbGluZ1Nwcml0ZS5hbmNob3IueDtcbiAgY29uc3QgYW5jaG9yWSA9IHRpbGluZ1Nwcml0ZS5hbmNob3IueTtcbiAgcG9zaXRpb25zWzBdID0gLWFuY2hvclggKiB0aWxpbmdTcHJpdGUud2lkdGg7XG4gIHBvc2l0aW9uc1sxXSA9IC1hbmNob3JZICogdGlsaW5nU3ByaXRlLmhlaWdodDtcbiAgcG9zaXRpb25zWzJdID0gKDEgLSBhbmNob3JYKSAqIHRpbGluZ1Nwcml0ZS53aWR0aDtcbiAgcG9zaXRpb25zWzNdID0gLWFuY2hvclkgKiB0aWxpbmdTcHJpdGUuaGVpZ2h0O1xuICBwb3NpdGlvbnNbNF0gPSAoMSAtIGFuY2hvclgpICogdGlsaW5nU3ByaXRlLndpZHRoO1xuICBwb3NpdGlvbnNbNV0gPSAoMSAtIGFuY2hvclkpICogdGlsaW5nU3ByaXRlLmhlaWdodDtcbiAgcG9zaXRpb25zWzZdID0gLWFuY2hvclggKiB0aWxpbmdTcHJpdGUud2lkdGg7XG4gIHBvc2l0aW9uc1s3XSA9ICgxIC0gYW5jaG9yWSkgKiB0aWxpbmdTcHJpdGUuaGVpZ2h0O1xufVxuXG5leHBvcnQgeyBzZXRQb3NpdGlvbnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNldFBvc2l0aW9ucy5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGFwcGx5TWF0cml4KGFycmF5LCBzdHJpZGUsIG9mZnNldCwgbWF0cml4KSB7XG4gIGxldCBpbmRleCA9IDA7XG4gIGNvbnN0IHNpemUgPSBhcnJheS5sZW5ndGggLyAoc3RyaWRlIHx8IDIpO1xuICBjb25zdCBhID0gbWF0cml4LmE7XG4gIGNvbnN0IGIgPSBtYXRyaXguYjtcbiAgY29uc3QgYyA9IG1hdHJpeC5jO1xuICBjb25zdCBkID0gbWF0cml4LmQ7XG4gIGNvbnN0IHR4ID0gbWF0cml4LnR4O1xuICBjb25zdCB0eSA9IG1hdHJpeC50eTtcbiAgb2Zmc2V0ICo9IHN0cmlkZTtcbiAgd2hpbGUgKGluZGV4IDwgc2l6ZSkge1xuICAgIGNvbnN0IHggPSBhcnJheVtvZmZzZXRdO1xuICAgIGNvbnN0IHkgPSBhcnJheVtvZmZzZXQgKyAxXTtcbiAgICBhcnJheVtvZmZzZXRdID0gYSAqIHggKyBjICogeSArIHR4O1xuICAgIGFycmF5W29mZnNldCArIDFdID0gYiAqIHggKyBkICogeSArIHR5O1xuICAgIG9mZnNldCArPSBzdHJpZGU7XG4gICAgaW5kZXgrKztcbiAgfVxufVxuXG5leHBvcnQgeyBhcHBseU1hdHJpeCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbHlNYXRyaXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgYXBwbHlNYXRyaXggfSBmcm9tICcuL2FwcGx5TWF0cml4Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gc2V0VXZzKHRpbGluZ1Nwcml0ZSwgdXZzKSB7XG4gIGNvbnN0IHRleHR1cmUgPSB0aWxpbmdTcHJpdGUudGV4dHVyZTtcbiAgY29uc3Qgd2lkdGggPSB0ZXh0dXJlLmZyYW1lLndpZHRoO1xuICBjb25zdCBoZWlnaHQgPSB0ZXh0dXJlLmZyYW1lLmhlaWdodDtcbiAgbGV0IGFuY2hvclggPSAwO1xuICBsZXQgYW5jaG9yWSA9IDA7XG4gIGlmICh0aWxpbmdTcHJpdGUuX2FwcGx5QW5jaG9yVG9UZXh0dXJlKSB7XG4gICAgYW5jaG9yWCA9IHRpbGluZ1Nwcml0ZS5hbmNob3IueDtcbiAgICBhbmNob3JZID0gdGlsaW5nU3ByaXRlLmFuY2hvci55O1xuICB9XG4gIHV2c1swXSA9IHV2c1s2XSA9IC1hbmNob3JYO1xuICB1dnNbMl0gPSB1dnNbNF0gPSAxIC0gYW5jaG9yWDtcbiAgdXZzWzFdID0gdXZzWzNdID0gLWFuY2hvclk7XG4gIHV2c1s1XSA9IHV2c1s3XSA9IDEgLSBhbmNob3JZO1xuICBjb25zdCB0ZXh0dXJlTWF0cml4ID0gTWF0cml4LnNoYXJlZDtcbiAgdGV4dHVyZU1hdHJpeC5jb3B5RnJvbSh0aWxpbmdTcHJpdGUuX3RpbGVUcmFuc2Zvcm0ubWF0cml4KTtcbiAgdGV4dHVyZU1hdHJpeC50eCAvPSB0aWxpbmdTcHJpdGUud2lkdGg7XG4gIHRleHR1cmVNYXRyaXgudHkgLz0gdGlsaW5nU3ByaXRlLmhlaWdodDtcbiAgdGV4dHVyZU1hdHJpeC5pbnZlcnQoKTtcbiAgdGV4dHVyZU1hdHJpeC5zY2FsZSh0aWxpbmdTcHJpdGUud2lkdGggLyB3aWR0aCwgdGlsaW5nU3ByaXRlLmhlaWdodCAvIGhlaWdodCk7XG4gIGFwcGx5TWF0cml4KHV2cywgMiwgMCwgdGV4dHVyZU1hdHJpeCk7XG59XG5cbmV4cG9ydCB7IHNldFV2cyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0VXZzLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IGdldEFkanVzdGVkQmxlbmRNb2RlQmxlbmQgfSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zdGF0ZS9nZXRBZGp1c3RlZEJsZW5kTW9kZUJsZW5kLm1qcyc7XG5pbXBvcnQgeyBTdGF0ZSB9IGZyb20gJy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3N0YXRlL1N0YXRlLm1qcyc7XG5pbXBvcnQgeyBSZW5kZXJlclR5cGUgfSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3R5cGVzLm1qcyc7XG5pbXBvcnQgeyBjb2xvcjMyQml0VG9Vbmlmb3JtIH0gZnJvbSAnLi4vZ3JhcGhpY3MvZ3B1L2NvbG9yVG9Vbmlmb3JtLm1qcyc7XG5pbXBvcnQgeyBCYXRjaGFibGVNZXNoIH0gZnJvbSAnLi4vbWVzaC9zaGFyZWQvQmF0Y2hhYmxlTWVzaC5tanMnO1xuaW1wb3J0IHsgTWVzaEdlb21ldHJ5IH0gZnJvbSAnLi4vbWVzaC9zaGFyZWQvTWVzaEdlb21ldHJ5Lm1qcyc7XG5pbXBvcnQgeyBUaWxpbmdTcHJpdGVTaGFkZXIgfSBmcm9tICcuL3NoYWRlci9UaWxpbmdTcHJpdGVTaGFkZXIubWpzJztcbmltcG9ydCB7IFF1YWRHZW9tZXRyeSB9IGZyb20gJy4vdXRpbHMvUXVhZEdlb21ldHJ5Lm1qcyc7XG5pbXBvcnQgeyBzZXRQb3NpdGlvbnMgfSBmcm9tICcuL3V0aWxzL3NldFBvc2l0aW9ucy5tanMnO1xuaW1wb3J0IHsgc2V0VXZzIH0gZnJvbSAnLi91dGlscy9zZXRVdnMubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBzaGFyZWRRdWFkID0gbmV3IFF1YWRHZW9tZXRyeSgpO1xuY2xhc3MgVGlsaW5nU3ByaXRlUGlwZSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fc3RhdGUgPSBTdGF0ZS5kZWZhdWx0MmQ7XG4gICAgdGhpcy5fdGlsaW5nU3ByaXRlRGF0YUhhc2ggPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIHZhbGlkYXRlUmVuZGVyYWJsZShyZW5kZXJhYmxlKSB7XG4gICAgY29uc3QgdGlsaW5nU3ByaXRlRGF0YSA9IHRoaXMuX2dldFRpbGluZ1Nwcml0ZURhdGEocmVuZGVyYWJsZSk7XG4gICAgY29uc3QgY291bGRCYXRjaCA9IHRpbGluZ1Nwcml0ZURhdGEuY2FuQmF0Y2g7XG4gICAgdGhpcy5fdXBkYXRlQ2FuQmF0Y2gocmVuZGVyYWJsZSk7XG4gICAgY29uc3QgY2FuQmF0Y2ggPSB0aWxpbmdTcHJpdGVEYXRhLmNhbkJhdGNoO1xuICAgIGlmIChjYW5CYXRjaCAmJiBjYW5CYXRjaCA9PT0gY291bGRCYXRjaCkge1xuICAgICAgY29uc3QgeyBiYXRjaGFibGVNZXNoIH0gPSB0aWxpbmdTcHJpdGVEYXRhO1xuICAgICAgaWYgKGJhdGNoYWJsZU1lc2ggJiYgYmF0Y2hhYmxlTWVzaC50ZXh0dXJlLl9zb3VyY2UgIT09IHJlbmRlcmFibGUudGV4dHVyZS5fc291cmNlKSB7XG4gICAgICAgIHJldHVybiAhYmF0Y2hhYmxlTWVzaC5iYXRjaGVyLmNoZWNrQW5kVXBkYXRlVGV4dHVyZShiYXRjaGFibGVNZXNoLCByZW5kZXJhYmxlLnRleHR1cmUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY291bGRCYXRjaCAhPT0gY2FuQmF0Y2g7XG4gIH1cbiAgYWRkUmVuZGVyYWJsZSh0aWxpbmdTcHJpdGUsIGluc3RydWN0aW9uU2V0KSB7XG4gICAgY29uc3QgYmF0Y2hlciA9IHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzLmJhdGNoO1xuICAgIHRoaXMuX3VwZGF0ZUNhbkJhdGNoKHRpbGluZ1Nwcml0ZSk7XG4gICAgY29uc3QgdGlsaW5nU3ByaXRlRGF0YSA9IHRoaXMuX2dldFRpbGluZ1Nwcml0ZURhdGEodGlsaW5nU3ByaXRlKTtcbiAgICBjb25zdCB7IGdlb21ldHJ5LCBjYW5CYXRjaCB9ID0gdGlsaW5nU3ByaXRlRGF0YTtcbiAgICBpZiAoY2FuQmF0Y2gpIHtcbiAgICAgIHRpbGluZ1Nwcml0ZURhdGEuYmF0Y2hhYmxlTWVzaCB8fCAodGlsaW5nU3ByaXRlRGF0YS5iYXRjaGFibGVNZXNoID0gbmV3IEJhdGNoYWJsZU1lc2goKSk7XG4gICAgICBjb25zdCBiYXRjaGFibGVNZXNoID0gdGlsaW5nU3ByaXRlRGF0YS5iYXRjaGFibGVNZXNoO1xuICAgICAgaWYgKHRpbGluZ1Nwcml0ZS5fZGlkVGlsaW5nU3ByaXRlVXBkYXRlKSB7XG4gICAgICAgIHRpbGluZ1Nwcml0ZS5fZGlkVGlsaW5nU3ByaXRlVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJhdGNoYWJsZU1lc2godGlsaW5nU3ByaXRlKTtcbiAgICAgICAgYmF0Y2hhYmxlTWVzaC5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICAgICAgICBiYXRjaGFibGVNZXNoLm1lc2ggPSB0aWxpbmdTcHJpdGU7XG4gICAgICAgIGJhdGNoYWJsZU1lc2gudGV4dHVyZSA9IHRpbGluZ1Nwcml0ZS5fdGV4dHVyZTtcbiAgICAgIH1cbiAgICAgIGJhdGNoYWJsZU1lc2gucm91bmRQaXhlbHMgPSB0aGlzLl9yZW5kZXJlci5fcm91bmRQaXhlbHMgfCB0aWxpbmdTcHJpdGUuX3JvdW5kUGl4ZWxzO1xuICAgICAgYmF0Y2hlci5hZGRUb0JhdGNoKGJhdGNoYWJsZU1lc2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXRjaGVyLmJyZWFrKGluc3RydWN0aW9uU2V0KTtcbiAgICAgIHRpbGluZ1Nwcml0ZURhdGEuc2hhZGVyIHx8ICh0aWxpbmdTcHJpdGVEYXRhLnNoYWRlciA9IG5ldyBUaWxpbmdTcHJpdGVTaGFkZXIoKSk7XG4gICAgICB0aGlzLnVwZGF0ZVJlbmRlcmFibGUodGlsaW5nU3ByaXRlKTtcbiAgICAgIGluc3RydWN0aW9uU2V0LmFkZCh0aWxpbmdTcHJpdGUpO1xuICAgIH1cbiAgfVxuICBleGVjdXRlKHRpbGluZ1Nwcml0ZSkge1xuICAgIGNvbnN0IHsgc2hhZGVyIH0gPSB0aGlzLl90aWxpbmdTcHJpdGVEYXRhSGFzaFt0aWxpbmdTcHJpdGUudWlkXTtcbiAgICBzaGFkZXIuZ3JvdXBzWzBdID0gdGhpcy5fcmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMuYmluZEdyb3VwO1xuICAgIGNvbnN0IGxvY2FsVW5pZm9ybXMgPSBzaGFkZXIucmVzb3VyY2VzLmxvY2FsVW5pZm9ybXMudW5pZm9ybXM7XG4gICAgbG9jYWxVbmlmb3Jtcy51VHJhbnNmb3JtTWF0cml4ID0gdGlsaW5nU3ByaXRlLmdyb3VwVHJhbnNmb3JtO1xuICAgIGxvY2FsVW5pZm9ybXMudVJvdW5kID0gdGhpcy5fcmVuZGVyZXIuX3JvdW5kUGl4ZWxzIHwgdGlsaW5nU3ByaXRlLl9yb3VuZFBpeGVscztcbiAgICBjb2xvcjMyQml0VG9Vbmlmb3JtKFxuICAgICAgdGlsaW5nU3ByaXRlLmdyb3VwQ29sb3JBbHBoYSxcbiAgICAgIGxvY2FsVW5pZm9ybXMudUNvbG9yLFxuICAgICAgMFxuICAgICk7XG4gICAgdGhpcy5fc3RhdGUuYmxlbmRNb2RlID0gZ2V0QWRqdXN0ZWRCbGVuZE1vZGVCbGVuZCh0aWxpbmdTcHJpdGUuZ3JvdXBCbGVuZE1vZGUsIHRpbGluZ1Nwcml0ZS50ZXh0dXJlLl9zb3VyY2UpO1xuICAgIHRoaXMuX3JlbmRlcmVyLmVuY29kZXIuZHJhdyh7XG4gICAgICBnZW9tZXRyeTogc2hhcmVkUXVhZCxcbiAgICAgIHNoYWRlcixcbiAgICAgIHN0YXRlOiB0aGlzLl9zdGF0ZVxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVJlbmRlcmFibGUodGlsaW5nU3ByaXRlKSB7XG4gICAgY29uc3QgdGlsaW5nU3ByaXRlRGF0YSA9IHRoaXMuX2dldFRpbGluZ1Nwcml0ZURhdGEodGlsaW5nU3ByaXRlKTtcbiAgICBjb25zdCB7IGNhbkJhdGNoIH0gPSB0aWxpbmdTcHJpdGVEYXRhO1xuICAgIGlmIChjYW5CYXRjaCkge1xuICAgICAgY29uc3QgeyBiYXRjaGFibGVNZXNoIH0gPSB0aWxpbmdTcHJpdGVEYXRhO1xuICAgICAgaWYgKHRpbGluZ1Nwcml0ZS5fZGlkVGlsaW5nU3ByaXRlVXBkYXRlKVxuICAgICAgICB0aGlzLl91cGRhdGVCYXRjaGFibGVNZXNoKHRpbGluZ1Nwcml0ZSk7XG4gICAgICBiYXRjaGFibGVNZXNoLmJhdGNoZXIudXBkYXRlRWxlbWVudChiYXRjaGFibGVNZXNoKTtcbiAgICB9IGVsc2UgaWYgKHRpbGluZ1Nwcml0ZS5fZGlkVGlsaW5nU3ByaXRlVXBkYXRlKSB7XG4gICAgICBjb25zdCB7IHNoYWRlciB9ID0gdGlsaW5nU3ByaXRlRGF0YTtcbiAgICAgIHNoYWRlci51cGRhdGVVbmlmb3JtcyhcbiAgICAgICAgdGlsaW5nU3ByaXRlLndpZHRoLFxuICAgICAgICB0aWxpbmdTcHJpdGUuaGVpZ2h0LFxuICAgICAgICB0aWxpbmdTcHJpdGUuX3RpbGVUcmFuc2Zvcm0ubWF0cml4LFxuICAgICAgICB0aWxpbmdTcHJpdGUuYW5jaG9yLngsXG4gICAgICAgIHRpbGluZ1Nwcml0ZS5hbmNob3IueSxcbiAgICAgICAgdGlsaW5nU3ByaXRlLnRleHR1cmVcbiAgICAgICk7XG4gICAgfVxuICAgIHRpbGluZ1Nwcml0ZS5fZGlkVGlsaW5nU3ByaXRlVXBkYXRlID0gZmFsc2U7XG4gIH1cbiAgZGVzdHJveVJlbmRlcmFibGUodGlsaW5nU3ByaXRlKSB7XG4gICAgY29uc3QgdGlsaW5nU3ByaXRlRGF0YSA9IHRoaXMuX2dldFRpbGluZ1Nwcml0ZURhdGEodGlsaW5nU3ByaXRlKTtcbiAgICB0aWxpbmdTcHJpdGVEYXRhLmJhdGNoYWJsZU1lc2ggPSBudWxsO1xuICAgIHRpbGluZ1Nwcml0ZURhdGEuc2hhZGVyPy5kZXN0cm95KCk7XG4gICAgdGhpcy5fdGlsaW5nU3ByaXRlRGF0YUhhc2hbdGlsaW5nU3ByaXRlLnVpZF0gPSBudWxsO1xuICB9XG4gIF9nZXRUaWxpbmdTcHJpdGVEYXRhKHJlbmRlcmFibGUpIHtcbiAgICByZXR1cm4gdGhpcy5fdGlsaW5nU3ByaXRlRGF0YUhhc2hbcmVuZGVyYWJsZS51aWRdIHx8IHRoaXMuX2luaXRUaWxpbmdTcHJpdGVEYXRhKHJlbmRlcmFibGUpO1xuICB9XG4gIF9pbml0VGlsaW5nU3ByaXRlRGF0YSh0aWxpbmdTcHJpdGUpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBNZXNoR2VvbWV0cnkoe1xuICAgICAgaW5kaWNlczogc2hhcmVkUXVhZC5pbmRpY2VzLFxuICAgICAgcG9zaXRpb25zOiBzaGFyZWRRdWFkLnBvc2l0aW9ucy5zbGljZSgpLFxuICAgICAgdXZzOiBzaGFyZWRRdWFkLnV2cy5zbGljZSgpXG4gICAgfSk7XG4gICAgdGhpcy5fdGlsaW5nU3ByaXRlRGF0YUhhc2hbdGlsaW5nU3ByaXRlLnVpZF0gPSB7XG4gICAgICBjYW5CYXRjaDogdHJ1ZSxcbiAgICAgIHJlbmRlcmFibGU6IHRpbGluZ1Nwcml0ZSxcbiAgICAgIGdlb21ldHJ5XG4gICAgfTtcbiAgICB0aWxpbmdTcHJpdGUub24oXCJkZXN0cm95ZWRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5kZXN0cm95UmVuZGVyYWJsZSh0aWxpbmdTcHJpdGUpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl90aWxpbmdTcHJpdGVEYXRhSGFzaFt0aWxpbmdTcHJpdGUudWlkXTtcbiAgfVxuICBfdXBkYXRlQmF0Y2hhYmxlTWVzaCh0aWxpbmdTcHJpdGUpIHtcbiAgICBjb25zdCByZW5kZXJhYmxlRGF0YSA9IHRoaXMuX2dldFRpbGluZ1Nwcml0ZURhdGEodGlsaW5nU3ByaXRlKTtcbiAgICBjb25zdCB7IGdlb21ldHJ5IH0gPSByZW5kZXJhYmxlRGF0YTtcbiAgICBjb25zdCBzdHlsZSA9IHRpbGluZ1Nwcml0ZS50ZXh0dXJlLnNvdXJjZS5zdHlsZTtcbiAgICBpZiAoc3R5bGUuYWRkcmVzc01vZGUgIT09IFwicmVwZWF0XCIpIHtcbiAgICAgIHN0eWxlLmFkZHJlc3NNb2RlID0gXCJyZXBlYXRcIjtcbiAgICAgIHN0eWxlLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBzZXRVdnModGlsaW5nU3ByaXRlLCBnZW9tZXRyeS51dnMpO1xuICAgIHNldFBvc2l0aW9ucyh0aWxpbmdTcHJpdGUsIGdlb21ldHJ5LnBvc2l0aW9ucyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5fdGlsaW5nU3ByaXRlRGF0YUhhc2gpIHtcbiAgICAgIHRoaXMuZGVzdHJveVJlbmRlcmFibGUodGhpcy5fdGlsaW5nU3ByaXRlRGF0YUhhc2hbaV0ucmVuZGVyYWJsZSk7XG4gICAgfVxuICAgIHRoaXMuX3RpbGluZ1Nwcml0ZURhdGFIYXNoID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbiAgX3VwZGF0ZUNhbkJhdGNoKHRpbGluZ1Nwcml0ZSkge1xuICAgIGNvbnN0IHJlbmRlcmFibGVEYXRhID0gdGhpcy5fZ2V0VGlsaW5nU3ByaXRlRGF0YSh0aWxpbmdTcHJpdGUpO1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aWxpbmdTcHJpdGUudGV4dHVyZTtcbiAgICBsZXQgX25vblBvd09mMndyYXBwaW5nID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5fcmVuZGVyZXIudHlwZSA9PT0gUmVuZGVyZXJUeXBlLldFQkdMKSB7XG4gICAgICBfbm9uUG93T2Yyd3JhcHBpbmcgPSB0aGlzLl9yZW5kZXJlci5jb250ZXh0LnN1cHBvcnRzLm5vblBvd09mMndyYXBwaW5nO1xuICAgIH1cbiAgICByZW5kZXJhYmxlRGF0YS5jYW5CYXRjaCA9IHRleHR1cmUudGV4dHVyZU1hdHJpeC5pc1NpbXBsZSAmJiAoX25vblBvd09mMndyYXBwaW5nIHx8IHRleHR1cmUuc291cmNlLmlzUG93ZXJPZlR3byk7XG4gICAgcmV0dXJuIHJlbmRlcmFibGVEYXRhLmNhbkJhdGNoO1xuICB9XG59XG4vKiogQGlnbm9yZSAqL1xuVGlsaW5nU3ByaXRlUGlwZS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1BpcGVzXG4gIF0sXG4gIG5hbWU6IFwidGlsaW5nU3ByaXRlXCJcbn07XG5cbmV4cG9ydCB7IFRpbGluZ1Nwcml0ZVBpcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbGluZ1Nwcml0ZVBpcGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgVGlsaW5nU3ByaXRlUGlwZSB9IGZyb20gJy4vVGlsaW5nU3ByaXRlUGlwZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmV4dGVuc2lvbnMuYWRkKFRpbGluZ1Nwcml0ZVBpcGUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5pdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6336\n')},928:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(4240);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/cache/Cache.mjs\nvar Cache = __webpack_require__(5288);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(2540);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs\nvar Graphics = __webpack_require__(420);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs\nvar Matrix = __webpack_require__(328);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs + 1 modules\nvar maxRecommendedTextures = __webpack_require__(760);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs + 8 modules\nvar compileHighShaderToProgram = __webpack_require__(9936);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs\nvar colorBit = __webpack_require__(4452);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs\nvar generateTextureBatchBit = __webpack_require__(6624);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs\nvar roundPixelsBit = __webpack_require__(1124);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs\nvar getBatchSamplersUniformGroup = __webpack_require__(9208);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs\nvar Shader = __webpack_require__(1656);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs + 2 modules\nvar UniformGroup = __webpack_require__(5596);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs\n\nconst localUniformMSDFBit = {\n  name: "local-uniform-msdf-bit",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `\n    ),\n    main: (\n      /* wgsl */\n      ` \n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        `\n    )\n  }\n};\nconst localUniformMSDFBitGl = {\n  name: "local-uniform-msdf-bit",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform float uDistance;\n         `\n    ),\n    main: (\n      /* glsl */\n      ` \n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        `\n    )\n  }\n};\n\n\n//# sourceMappingURL=localUniformMSDFBit.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs\n\nconst mSDFBit = {\n  name: "msdf-bit",\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n                \n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n             \n            }\n        `\n    )\n  }\n};\nconst mSDFBitGl = {\n  name: "msdf-bit",\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n                \n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median = min(median, msdfColor.a);\n            \n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);  \n              \n                return coverage;\n            }\n        `\n    )\n  }\n};\n\n\n//# sourceMappingURL=mSDFBit.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nlet gpuProgram;\nlet glProgram;\nclass SdfShader extends Shader/* Shader */.g {\n  constructor() {\n    const uniforms = new UniformGroup/* UniformGroup */.W({\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },\n      uTransformMatrix: { value: new Matrix/* Matrix */.W(), type: "mat3x3<f32>" },\n      uDistance: { value: 4, type: "f32" },\n      uRound: { value: 0, type: "f32" }\n    });\n    const maxTextures = (0,maxRecommendedTextures/* getMaxTexturesPerBatch */.q)();\n    gpuProgram ?? (gpuProgram = (0,compileHighShaderToProgram/* compileHighShaderGpuProgram */.c)({\n      name: "sdf-shader",\n      bits: [\n        colorBit/* colorBit */.O,\n        (0,generateTextureBatchBit/* generateTextureBatchBit */.K)(maxTextures),\n        localUniformMSDFBit,\n        mSDFBit,\n        roundPixelsBit/* roundPixelsBit */.i\n      ]\n    }));\n    glProgram ?? (glProgram = (0,compileHighShaderToProgram/* compileHighShaderGlProgram */.o)({\n      name: "sdf-shader",\n      bits: [\n        colorBit/* colorBitGl */.K,\n        (0,generateTextureBatchBit/* generateTextureBatchBitGl */.w)(maxTextures),\n        localUniformMSDFBitGl,\n        mSDFBitGl,\n        roundPixelsBit/* roundPixelsBitGl */.Q\n      ]\n    }));\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: uniforms,\n        batchSamplers: (0,getBatchSamplersUniformGroup/* getBatchSamplersUniformGroup */.q)(maxTextures)\n      }\n    });\n  }\n}\n\n\n//# sourceMappingURL=SdfShader.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(8592);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(8796);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/TextStyle.mjs\nvar TextStyle = __webpack_require__(9920);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(5536);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(5520);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs\nvar CanvasPool = __webpack_require__(8168);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs\nvar ImageSource = __webpack_require__(8512);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(8518);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs\nvar CanvasTextMetrics = __webpack_require__(3768);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs\nvar fontStringFromTextStyle = __webpack_require__(5844);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs\nvar getCanvasFillStyle = __webpack_require__(3480);\n// EXTERNAL MODULE: ./node_modules/pixi.js/node_modules/eventemitter3/index.mjs\nvar eventemitter3 = __webpack_require__(8440);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs\n\n\n\n"use strict";\nclass AbstractBitmapFont extends eventemitter3/* default */.c {\n  constructor() {\n    super(...arguments);\n    /** The map of characters by character code. */\n    this.chars = /* @__PURE__ */ Object.create(null);\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    this.lineHeight = 0;\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    this.fontFamily = "";\n    /** The metrics of the font face. */\n    this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    this.baseLineOffset = 0;\n    /** The range and type of the distance field for this font. */\n    this.distanceField = { type: "none", range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    this.pages = [];\n    /** should the fill for this font be applied as a tint to the text. */\n    this.applyFillAsTint = true;\n    /** The size of the font face in pixels. */\n    this.baseMeasurementFontSize = 100;\n    this.baseRenderedFontSize = 100;\n  }\n  /**\n   * The name of the font face.\n   * @deprecated since 8.0.0 Use `fontFamily` instead.\n   */\n  get font() {\n    (0,deprecation/* deprecation */.e)(deprecation/* v8_0_0 */.q, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.");\n    return this.fontFamily;\n  }\n  /**\n   * The map of base page textures (i.e., sheets of glyphs).\n   * @deprecated since 8.0.0 Use `pages` instead.\n   */\n  get pageTextures() {\n    (0,deprecation/* deprecation */.e)(deprecation/* v8_0_0 */.q, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");\n    return this.pages;\n  }\n  /**\n   * The size of the font face in pixels.\n   * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n   */\n  get size() {\n    (0,deprecation/* deprecation */.e)(deprecation/* v8_0_0 */.q, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.");\n    return this.fontMetrics.fontSize;\n  }\n  /**\n   * The kind of distance field for this font or "none".\n   * @deprecated since 8.0.0 Use `distanceField.type` instead.\n   */\n  get distanceFieldRange() {\n    (0,deprecation/* deprecation */.e)(deprecation/* v8_0_0 */.q, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.");\n    return this.distanceField.range;\n  }\n  /**\n   * The range of the distance field in pixels.\n   * @deprecated since 8.0.0 Use `distanceField.range` instead.\n   */\n  get distanceFieldType() {\n    (0,deprecation/* deprecation */.e)(deprecation/* v8_0_0 */.q, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.");\n    return this.distanceField.type;\n  }\n  destroy(destroyTextures = false) {\n    this.emit("destroy", this);\n    this.removeAllListeners();\n    for (const i in this.chars) {\n      this.chars[i].texture?.destroy();\n    }\n    this.chars = null;\n    if (destroyTextures) {\n      this.pages.forEach((page) => page.texture.destroy(true));\n      this.pages = null;\n    }\n  }\n}\n\n\n//# sourceMappingURL=AbstractBitmapFont.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs\n\nfunction resolveCharacters(chars) {\n  if (chars === "") {\n    return [];\n  }\n  if (typeof chars === "string") {\n    chars = [chars];\n  }\n  const result = [];\n  for (let i = 0, j = chars.length; i < j; i++) {\n    const item = chars[i];\n    if (Array.isArray(item)) {\n      if (item.length !== 2) {\n        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n      }\n      if (item[0].length === 0 || item[1].length === 0) {\n        throw new Error("[BitmapFont]: Invalid character delimiter.");\n      }\n      const startCode = item[0].charCodeAt(0);\n      const endCode = item[1].charCodeAt(0);\n      if (endCode < startCode) {\n        throw new Error("[BitmapFont]: Invalid character range.");\n      }\n      for (let i2 = startCode, j2 = endCode; i2 <= j2; i2++) {\n        result.push(String.fromCharCode(i2));\n      }\n    } else {\n      result.push(...Array.from(item));\n    }\n  }\n  if (result.length === 0) {\n    throw new Error("[BitmapFont]: Empty set when resolving characters.");\n  }\n  return result;\n}\n\n\n//# sourceMappingURL=resolveCharacters.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nconst _DynamicBitmapFont = class _DynamicBitmapFont extends AbstractBitmapFont {\n  /**\n   * @param options - The options for the dynamic bitmap font.\n   */\n  constructor(options) {\n    super();\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    this.resolution = 1;\n    /** The pages of the font. */\n    this.pages = [];\n    this._padding = 0;\n    this._measureCache = /* @__PURE__ */ Object.create(null);\n    this._currentChars = [];\n    this._currentX = 0;\n    this._currentY = 0;\n    this._currentPageIndex = -1;\n    this._skipKerning = false;\n    const dynamicOptions = { ..._DynamicBitmapFont.defaultOptions, ...options };\n    this._textureSize = dynamicOptions.textureSize;\n    this._mipmap = dynamicOptions.mipmap;\n    const style = dynamicOptions.style.clone();\n    if (dynamicOptions.overrideFill) {\n      style._fill.color = 16777215;\n      style._fill.alpha = 1;\n      style._fill.texture = Texture/* Texture */.w.WHITE;\n      style._fill.fill = null;\n    }\n    this.applyFillAsTint = dynamicOptions.overrideFill;\n    const requestedFontSize = style.fontSize;\n    style.fontSize = this.baseMeasurementFontSize;\n    const font = (0,fontStringFromTextStyle/* fontStringFromTextStyle */.y)(style);\n    if (dynamicOptions.overrideSize) {\n      if (style._stroke) {\n        style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n      }\n    } else {\n      style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n    }\n    this._style = style;\n    this._skipKerning = dynamicOptions.skipKerning ?? false;\n    this.resolution = dynamicOptions.resolution ?? 1;\n    this._padding = dynamicOptions.padding ?? 4;\n    this.fontMetrics = CanvasTextMetrics/* CanvasTextMetrics */.y.measureFont(font);\n    this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n  }\n  ensureCharacters(chars) {\n    const charList = resolveCharacters(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self) => self.indexOf(char) === index);\n    if (!charList.length)\n      return;\n    this._currentChars = [...this._currentChars, ...charList];\n    let pageData;\n    if (this._currentPageIndex === -1) {\n      pageData = this._nextPage();\n    } else {\n      pageData = this.pages[this._currentPageIndex];\n    }\n    let { canvas, context } = pageData.canvasAndContext;\n    let textureSource = pageData.texture.source;\n    const style = this._style;\n    let currentX = this._currentX;\n    let currentY = this._currentY;\n    const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n    const padding = this._padding * fontScale;\n    const widthScale = style.fontStyle === "italic" ? 2 : 1;\n    let maxCharHeight = 0;\n    let skipTexture = false;\n    for (let i = 0; i < charList.length; i++) {\n      const char = charList[i];\n      const metrics = CanvasTextMetrics/* CanvasTextMetrics */.y.measureText(char, style, canvas, false);\n      metrics.lineHeight = metrics.height;\n      const width = widthScale * metrics.width * fontScale;\n      const height = metrics.height * fontScale;\n      const paddedWidth = width + padding * 2;\n      const paddedHeight = height + padding * 2;\n      skipTexture = false;\n      if (char !== "\\n" && char !== "\\r" && char !== "\t" && char !== " ") {\n        skipTexture = true;\n        maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));\n      }\n      if (currentX + paddedWidth > this._textureSize) {\n        currentY += maxCharHeight;\n        maxCharHeight = paddedHeight;\n        currentX = 0;\n        if (currentY + maxCharHeight > this._textureSize) {\n          textureSource.update();\n          const pageData2 = this._nextPage();\n          canvas = pageData2.canvasAndContext.canvas;\n          context = pageData2.canvasAndContext.context;\n          textureSource = pageData2.texture.source;\n          currentY = 0;\n        }\n      }\n      const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);\n      this.chars[char] = {\n        id: char.codePointAt(0),\n        xOffset: -this._padding,\n        yOffset: -this._padding,\n        xAdvance,\n        kerning: {}\n      };\n      if (skipTexture) {\n        this._drawGlyph(\n          context,\n          metrics,\n          currentX + padding,\n          currentY + padding,\n          fontScale,\n          style\n        );\n        const px = textureSource.width * fontScale;\n        const py = textureSource.height * fontScale;\n        const frame = new Rectangle/* Rectangle */.Y(\n          currentX / px * textureSource.width,\n          currentY / py * textureSource.height,\n          paddedWidth / px * textureSource.width,\n          paddedHeight / py * textureSource.height\n        );\n        this.chars[char].texture = new Texture/* Texture */.w({\n          source: textureSource,\n          frame\n        });\n        currentX += Math.ceil(paddedWidth);\n      }\n    }\n    textureSource.update();\n    this._currentX = currentX;\n    this._currentY = currentY;\n    this._skipKerning && this._applyKerning(charList, context);\n  }\n  /**\n   * @deprecated since 8.0.0\n   * The map of base page textures (i.e., sheets of glyphs).\n   */\n  get pageTextures() {\n    (0,deprecation/* deprecation */.e)(deprecation/* v8_0_0 */.q, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");\n    return this.pages;\n  }\n  _applyKerning(newChars, context) {\n    const measureCache = this._measureCache;\n    for (let i = 0; i < newChars.length; i++) {\n      const first = newChars[i];\n      for (let j = 0; j < this._currentChars.length; j++) {\n        const second = this._currentChars[j];\n        let c1 = measureCache[first];\n        if (!c1)\n          c1 = measureCache[first] = context.measureText(first).width;\n        let c2 = measureCache[second];\n        if (!c2)\n          c2 = measureCache[second] = context.measureText(second).width;\n        let total = context.measureText(first + second).width;\n        let amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[first].kerning[second] = amount;\n        }\n        total = context.measureText(first + second).width;\n        amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[second].kerning[first] = amount;\n        }\n      }\n    }\n  }\n  _nextPage() {\n    this._currentPageIndex++;\n    const textureResolution = this.resolution;\n    const canvasAndContext = CanvasPool/* CanvasPool */.G.getOptimalCanvasAndContext(\n      this._textureSize,\n      this._textureSize,\n      textureResolution\n    );\n    this._setupContext(canvasAndContext.context, this._style, textureResolution);\n    const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n    const texture = new Texture/* Texture */.w({\n      source: new ImageSource/* ImageSource */.K({\n        resource: canvasAndContext.canvas,\n        resolution,\n        alphaMode: "premultiply-alpha-on-upload",\n        autoGenerateMipmaps: this._mipmap\n      })\n    });\n    const pageData = {\n      canvasAndContext,\n      texture\n    };\n    this.pages[this._currentPageIndex] = pageData;\n    return pageData;\n  }\n  // canvas style!\n  _setupContext(context, style, resolution) {\n    style.fontSize = this.baseRenderedFontSize;\n    context.scale(resolution, resolution);\n    context.font = (0,fontStringFromTextStyle/* fontStringFromTextStyle */.y)(style);\n    style.fontSize = this.baseMeasurementFontSize;\n    context.textBaseline = style.textBaseline;\n    const stroke = style._stroke;\n    const strokeThickness = stroke?.width ?? 0;\n    if (stroke) {\n      context.lineWidth = strokeThickness;\n      context.lineJoin = stroke.join;\n      context.miterLimit = stroke.miterLimit;\n      context.strokeStyle = (0,getCanvasFillStyle/* getCanvasFillStyle */.S)(stroke, context);\n    }\n    if (style._fill) {\n      context.fillStyle = (0,getCanvasFillStyle/* getCanvasFillStyle */.S)(style._fill, context);\n    }\n    if (style.dropShadow) {\n      const shadowOptions = style.dropShadow;\n      const rgb = Color/* Color */.g.shared.setValue(shadowOptions.color).toArray();\n      const dropShadowBlur = shadowOptions.blur * resolution;\n      const dropShadowDistance = shadowOptions.distance * resolution;\n      context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n      context.shadowBlur = dropShadowBlur;\n      context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n      context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n    } else {\n      context.shadowColor = "black";\n      context.shadowBlur = 0;\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n    }\n  }\n  _drawGlyph(context, metrics, x, y, fontScale, style) {\n    const char = metrics.text;\n    const fontProperties = metrics.fontProperties;\n    const stroke = style._stroke;\n    const strokeThickness = (stroke?.width ?? 0) * fontScale;\n    const tx = x + strokeThickness / 2;\n    const ty = y - strokeThickness / 2;\n    const descent = fontProperties.descent * fontScale;\n    const lineHeight = metrics.lineHeight * fontScale;\n    if (style.stroke && strokeThickness) {\n      context.strokeText(char, tx, ty + lineHeight - descent);\n    }\n    if (style._fill) {\n      context.fillText(char, tx, ty + lineHeight - descent);\n    }\n  }\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const { canvasAndContext, texture } = this.pages[i];\n      canvasAndContext.canvas.width = canvasAndContext.canvas.width;\n      CanvasPool/* CanvasPool */.G.returnCanvasAndContext(canvasAndContext);\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n};\n_DynamicBitmapFont.defaultOptions = {\n  textureSize: 512,\n  style: new TextStyle/* TextStyle */.I(),\n  mipmap: true\n};\nlet DynamicBitmapFont = _DynamicBitmapFont;\n\n\n//# sourceMappingURL=DynamicBitmapFont.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs\n\nfunction getBitmapTextLayout(chars, style, font) {\n  const layoutData = {\n    width: 0,\n    height: 0,\n    offsetY: 0,\n    scale: style.fontSize / font.baseMeasurementFontSize,\n    lines: [{\n      width: 0,\n      charPositions: [],\n      spaceWidth: 0,\n      spacesIndex: [],\n      chars: []\n    }]\n  };\n  layoutData.offsetY = font.baseLineOffset;\n  let currentLine = layoutData.lines[0];\n  let previousChar = null;\n  let firstWord = true;\n  const currentWord = {\n    spaceWord: false,\n    width: 0,\n    start: 0,\n    index: 0,\n    // use index to not modify the array as we use it a lot!\n    positions: [],\n    chars: []\n  };\n  const nextWord = (word) => {\n    const start = currentLine.width;\n    for (let j = 0; j < currentWord.index; j++) {\n      const position = word.positions[j];\n      currentLine.chars.push(word.chars[j]);\n      currentLine.charPositions.push(position + start);\n    }\n    currentLine.width += word.width;\n    firstWord = false;\n    currentWord.width = 0;\n    currentWord.index = 0;\n    currentWord.chars.length = 0;\n  };\n  const nextLine = () => {\n    let index = currentLine.chars.length - 1;\n    let lastChar = currentLine.chars[index];\n    while (lastChar === " ") {\n      currentLine.width -= font.chars[lastChar].xAdvance;\n      lastChar = currentLine.chars[--index];\n    }\n    layoutData.width = Math.max(layoutData.width, currentLine.width);\n    currentLine = {\n      width: 0,\n      charPositions: [],\n      chars: [],\n      spaceWidth: 0,\n      spacesIndex: []\n    };\n    firstWord = true;\n    layoutData.lines.push(currentLine);\n    layoutData.height += font.lineHeight;\n  };\n  const scale = font.baseMeasurementFontSize / style.fontSize;\n  const adjustedLetterSpacing = style.letterSpacing * scale;\n  const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n  for (let i = 0; i < chars.length + 1; i++) {\n    let char;\n    const isEnd = i === chars.length;\n    if (!isEnd) {\n      char = chars[i];\n    }\n    const charData = font.chars[char] || font.chars[" "];\n    const isSpace = /(?:\\s)/.test(char);\n    const isWordBreak = isSpace || char === "\\r" || char === "\\n" || isEnd;\n    if (isWordBreak) {\n      const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;\n      if (addWordToNextLine) {\n        nextLine();\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      } else {\n        currentWord.start = currentLine.width;\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      }\n      if (char === "\\r" || char === "\\n") {\n        if (currentLine.width !== 0) {\n          nextLine();\n        }\n      } else if (!isEnd) {\n        const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n        currentLine.width += spaceWidth;\n        currentLine.spaceWidth = spaceWidth;\n        currentLine.spacesIndex.push(currentLine.charPositions.length);\n        currentLine.chars.push(char);\n      }\n    } else {\n      const kerning = charData.kerning[previousChar] || 0;\n      const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n      currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n      currentWord.chars.push(char);\n      currentWord.width += nextCharWidth;\n    }\n    previousChar = char;\n  }\n  nextLine();\n  if (style.align === "center") {\n    alignCenter(layoutData);\n  } else if (style.align === "right") {\n    alignRight(layoutData);\n  } else if (style.align === "justify") {\n    alignJustify(layoutData);\n  }\n  return layoutData;\n}\nfunction alignCenter(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width / 2 - line.width / 2;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignRight(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width - line.width;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignJustify(measurementData) {\n  const width = measurementData.width;\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    let indy = 0;\n    let spaceIndex = line.spacesIndex[indy++];\n    let offset = 0;\n    const totalSpaces = line.spacesIndex.length;\n    const newSpaceWidth = (width - line.width) / totalSpaces;\n    const spaceWidth = newSpaceWidth;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      if (j === spaceIndex) {\n        spaceIndex = line.spacesIndex[indy++];\n        offset += spaceWidth;\n      }\n      line.charPositions[j] += offset;\n    }\n  }\n}\n\n\n//# sourceMappingURL=getBitmapTextLayout.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs\n\n\n\n\n\n\n\n\n"use strict";\nlet fontCount = 0;\nclass BitmapFontManagerClass {\n  constructor() {\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from(\'ExampleFont\', style, { chars: BitmapFont.ALPHA })\n     */\n    this.ALPHA = [["a", "z"], ["A", "Z"], " "];\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from(\'ExampleFont\', style, { chars: BitmapFont.NUMERIC })\n     */\n    this.NUMERIC = [["0", "9"]];\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];\n    /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    this.ASCII = [[" ", "~"]];\n    /** Default options for installing a new BitmapFont. */\n    this.defaultOptions = {\n      chars: this.ALPHANUMERIC,\n      resolution: 1,\n      padding: 4,\n      skipKerning: false\n    };\n  }\n  /**\n   * Get a font for the specified text and style.\n   * @param text - The text to get the font for\n   * @param style - The style to use\n   */\n  getFont(text, style) {\n    let fontFamilyKey = `${style.fontFamily}-bitmap`;\n    let overrideFill = true;\n    if (style._fill.fill && !style._stroke) {\n      fontFamilyKey += style._fill.fill.styleKey;\n      overrideFill = false;\n    } else if (style._stroke || style.dropShadow) {\n      let key = style.styleKey;\n      key = key.substring(0, key.lastIndexOf("-"));\n      fontFamilyKey = `${key}-bitmap`;\n      overrideFill = false;\n    }\n    if (!Cache/* Cache */.u.has(fontFamilyKey)) {\n      const fnt = new DynamicBitmapFont({\n        style,\n        overrideFill,\n        overrideSize: true,\n        ...this.defaultOptions\n      });\n      fontCount++;\n      if (fontCount > 50) {\n        (0,warn/* warn */.m)("BitmapText", `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \\`BitmapFont.install({name:"style1", style})\\``);\n      }\n      fnt.once("destroy", () => {\n        fontCount--;\n        Cache/* Cache */.u.remove(fontFamilyKey);\n      });\n      Cache/* Cache */.u.set(\n        fontFamilyKey,\n        fnt\n      );\n    }\n    const dynamicFont = Cache/* Cache */.u.get(fontFamilyKey);\n    dynamicFont.ensureCharacters?.(text);\n    return dynamicFont;\n  }\n  /**\n   * Get the layout of a text for the specified style.\n   * @param text - The text to get the layout for\n   * @param style - The style to use\n   */\n  getLayout(text, style) {\n    const bitmapFont = this.getFont(text, style);\n    return getBitmapTextLayout([...text], style, bitmapFont);\n  }\n  /**\n   * Measure the text using the specified style.\n   * @param text - The text to measure\n   * @param style - The style to use\n   */\n  measureText(text, style) {\n    return this.getLayout(text, style);\n  }\n  // eslint-disable-next-line max-len\n  install(...args) {\n    let options = args[0];\n    if (typeof options === "string") {\n      options = {\n        name: options,\n        style: args[1],\n        chars: args[2]?.chars,\n        resolution: args[2]?.resolution,\n        padding: args[2]?.padding,\n        skipKerning: args[2]?.skipKerning\n      };\n      (0,deprecation/* deprecation */.e)(deprecation/* v8_0_0 */.q, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})");\n    }\n    const name = options?.name;\n    if (!name) {\n      throw new Error("[BitmapFontManager] Property `name` is required.");\n    }\n    options = { ...this.defaultOptions, ...options };\n    const textStyle = options.style;\n    const style = textStyle instanceof TextStyle/* TextStyle */.I ? textStyle : new TextStyle/* TextStyle */.I(textStyle);\n    const overrideFill = style._fill.fill !== null && style._fill.fill !== void 0;\n    const font = new DynamicBitmapFont({\n      style,\n      overrideFill,\n      skipKerning: options.skipKerning,\n      padding: options.padding,\n      resolution: options.resolution,\n      overrideSize: false\n    });\n    const flatChars = resolveCharacters(options.chars);\n    font.ensureCharacters(flatChars.join(""));\n    Cache/* Cache */.u.set(`${name}-bitmap`, font);\n    font.once("destroy", () => Cache/* Cache */.u.remove(`${name}-bitmap`));\n    return font;\n  }\n  /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */\n  uninstall(name) {\n    const cacheKey = `${name}-bitmap`;\n    const font = Cache/* Cache */.u.get(cacheKey);\n    if (font) {\n      Cache/* Cache */.u.remove(cacheKey);\n      font.destroy();\n    }\n  }\n}\nconst BitmapFontManager = new BitmapFontManagerClass();\n\n\n//# sourceMappingURL=BitmapFontManager.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs\n\n\n\n\n\n\n\n\n"use strict";\nclass BitmapTextPipe {\n  // private _sdfShader: SdfShader;\n  constructor(renderer) {\n    this._gpuBitmapText = {};\n    this._renderer = renderer;\n  }\n  validateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    if (bitmapText._didTextUpdate) {\n      bitmapText._didTextUpdate = false;\n      this._updateContext(bitmapText, graphicsRenderable);\n    }\n    return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n  }\n  addRenderable(bitmapText, instructionSet) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    if (bitmapText._didTextUpdate) {\n      bitmapText._didTextUpdate = false;\n      this._updateContext(bitmapText, graphicsRenderable);\n    }\n    this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  destroyRenderable(bitmapText) {\n    this._destroyRenderableByUid(bitmapText.uid);\n  }\n  _destroyRenderableByUid(renderableUid) {\n    const context = this._gpuBitmapText[renderableUid].context;\n    if (context.customShader) {\n      PoolGroup/* BigPool */.u.return(context.customShader);\n      context.customShader = null;\n    }\n    PoolGroup/* BigPool */.u.return(this._gpuBitmapText[renderableUid]);\n    this._gpuBitmapText[renderableUid] = null;\n  }\n  updateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  _updateContext(bitmapText, proxyGraphics) {\n    const { context } = proxyGraphics;\n    const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n    context.clear();\n    if (bitmapFont.distanceField.type !== "none") {\n      if (!context.customShader) {\n        context.customShader = PoolGroup/* BigPool */.u.get(SdfShader);\n      }\n    }\n    const chars = Array.from(bitmapText.text);\n    const style = bitmapText._style;\n    let currentY = bitmapFont.baseLineOffset;\n    const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont);\n    let index = 0;\n    const padding = style.padding;\n    const scale = bitmapTextLayout.scale;\n    let tx = bitmapTextLayout.width;\n    let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;\n    if (style._stroke) {\n      tx += style._stroke.width / scale;\n      ty += style._stroke.width / scale;\n    }\n    context.translate(-bitmapText._anchor._x * tx - padding, -bitmapText._anchor._y * ty - padding).scale(scale, scale);\n    const tint = bitmapFont.applyFillAsTint ? style._fill.color : 16777215;\n    for (let i = 0; i < bitmapTextLayout.lines.length; i++) {\n      const line = bitmapTextLayout.lines[i];\n      for (let j = 0; j < line.charPositions.length; j++) {\n        const char = chars[index++];\n        const charData = bitmapFont.chars[char];\n        if (charData?.texture) {\n          context.texture(\n            charData.texture,\n            tint ? tint : "black",\n            Math.round(line.charPositions[j] + charData.xOffset),\n            Math.round(currentY + charData.yOffset)\n          );\n        }\n      }\n      currentY += bitmapFont.lineHeight;\n    }\n  }\n  _getGpuBitmapText(bitmapText) {\n    return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);\n  }\n  initGpuText(bitmapText) {\n    const proxyRenderable = PoolGroup/* BigPool */.u.get(Graphics/* Graphics */.W);\n    this._gpuBitmapText[bitmapText.uid] = proxyRenderable;\n    this._updateContext(bitmapText, proxyRenderable);\n    bitmapText.on("destroyed", () => {\n      this.destroyRenderable(bitmapText);\n    });\n    return this._gpuBitmapText[bitmapText.uid];\n  }\n  _updateDistanceField(bitmapText) {\n    const context = this._getGpuBitmapText(bitmapText).context;\n    const fontFamily = bitmapText._style.fontFamily;\n    const dynamicFont = Cache/* Cache */.u.get(`${fontFamily}-bitmap`);\n    const { a, b, c, d } = bitmapText.groupTransform;\n    const dx = Math.sqrt(a * a + b * b);\n    const dy = Math.sqrt(c * c + d * d);\n    const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n    const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n    const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);\n    context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n  }\n  destroy() {\n    for (const uid in this._gpuBitmapText) {\n      this._destroyRenderableByUid(uid);\n    }\n    this._gpuBitmapText = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nBitmapTextPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.y6.WebGLPipes,\n    Extensions/* ExtensionType */.y6.WebGPUPipes,\n    Extensions/* ExtensionType */.y6.CanvasPipes\n  ],\n  name: "bitmapText"\n};\nfunction syncWithProxy(container, proxy) {\n  proxy.groupTransform = container.groupTransform;\n  proxy.groupColorAlpha = container.groupColorAlpha;\n  proxy.groupColor = container.groupColor;\n  proxy.groupBlendMode = container.groupBlendMode;\n  proxy.globalDisplayStatus = container.globalDisplayStatus;\n  proxy.groupTransform = container.groupTransform;\n  proxy.localDisplayStatus = container.localDisplayStatus;\n  proxy.groupAlpha = container.groupAlpha;\n  proxy._roundPixels = container._roundPixels;\n}\n\n\n//# sourceMappingURL=BitmapTextPipe.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-bitmap/init.mjs\n\n\n\n"use strict";\nExtensions/* extensions */.Yt.add(BitmapTextPipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEI7QUFDMUI7OztBQ3RKNkQ7QUFDUDs7QUFFdEQ7QUFDQSw2QkFBVSxLQUFLLGNBQWM7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC9zZGZTaGFkZXIvc2hhZGVyLWJpdHMvbG9jYWxVbmlmb3JtTVNERkJpdC5tanM/OWQyNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC9zZGZTaGFkZXIvc2hhZGVyLWJpdHMvbVNERkJpdC5tanM/ZTg1YSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC9zZGZTaGFkZXIvU2RmU2hhZGVyLm1qcz8xYjk0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWJpdG1hcC9BYnN0cmFjdEJpdG1hcEZvbnQubWpzP2U2YzgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtYml0bWFwL3V0aWxzL3Jlc29sdmVDaGFyYWN0ZXJzLm1qcz8yY2JhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWJpdG1hcC9EeW5hbWljQml0bWFwRm9udC5tanM/NTRmNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1iaXRtYXAvdXRpbHMvZ2V0Qml0bWFwVGV4dExheW91dC5tanM/NjYyMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1iaXRtYXAvQml0bWFwRm9udE1hbmFnZXIubWpzP2VkZWIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtYml0bWFwL0JpdG1hcFRleHRQaXBlLm1qcz82YzE1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWJpdG1hcC9pbml0Lm1qcz8wYmJjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgbG9jYWxVbmlmb3JtTVNERkJpdCA9IHtcbiAgbmFtZTogXCJsb2NhbC11bmlmb3JtLW1zZGYtYml0XCIsXG4gIHZlcnRleDoge1xuICAgIGhlYWRlcjogKFxuICAgICAgLyogd2dzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgc3RydWN0IExvY2FsVW5pZm9ybXMge1xuICAgICAgICAgICAgICAgIHVDb2xvcjp2ZWM0PGYzMj4sXG4gICAgICAgICAgICAgICAgdVRyYW5zZm9ybU1hdHJpeDptYXQzeDM8ZjMyPixcbiAgICAgICAgICAgICAgICB1RGlzdGFuY2U6IGYzMixcbiAgICAgICAgICAgICAgICB1Um91bmQ6ZjMyLFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBAZ3JvdXAoMikgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IGxvY2FsVW5pZm9ybXMgOiBMb2NhbFVuaWZvcm1zO1xuICAgICAgICBgXG4gICAgKSxcbiAgICBtYWluOiAoXG4gICAgICAvKiB3Z3NsICovXG4gICAgICBgXG4gICAgICAgICAgICB2Q29sb3IgKj0gbG9jYWxVbmlmb3Jtcy51Q29sb3I7XG4gICAgICAgICAgICBtb2RlbE1hdHJpeCAqPSBsb2NhbFVuaWZvcm1zLnVUcmFuc2Zvcm1NYXRyaXg7XG4gICAgICAgIGBcbiAgICApLFxuICAgIGVuZDogKFxuICAgICAgLyogd2dzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgaWYobG9jYWxVbmlmb3Jtcy51Um91bmQgPT0gMSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2UG9zaXRpb24gPSB2ZWM0KHJvdW5kUGl4ZWxzKHZQb3NpdGlvbi54eSwgZ2xvYmFsVW5pZm9ybXMudVJlc29sdXRpb24pLCB2UG9zaXRpb24uencpO1xuICAgICAgICAgICAgfVxuICAgICAgICBgXG4gICAgKVxuICB9LFxuICBmcmFnbWVudDoge1xuICAgIGhlYWRlcjogKFxuICAgICAgLyogd2dzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgc3RydWN0IExvY2FsVW5pZm9ybXMge1xuICAgICAgICAgICAgICAgIHVDb2xvcjp2ZWM0PGYzMj4sXG4gICAgICAgICAgICAgICAgdVRyYW5zZm9ybU1hdHJpeDptYXQzeDM8ZjMyPixcbiAgICAgICAgICAgICAgICB1RGlzdGFuY2U6IGYzMlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBAZ3JvdXAoMikgQGJpbmRpbmcoMCkgdmFyPHVuaWZvcm0+IGxvY2FsVW5pZm9ybXMgOiBMb2NhbFVuaWZvcm1zO1xuICAgICAgICAgYFxuICAgICksXG4gICAgbWFpbjogKFxuICAgICAgLyogd2dzbCAqL1xuICAgICAgYCBcbiAgICAgICAgICAgIG91dENvbG9yID0gdmVjNDxmMzI+KGNhbGN1bGF0ZU1TREZBbHBoYShvdXRDb2xvciwgbG9jYWxVbmlmb3Jtcy51Q29sb3IsIGxvY2FsVW5pZm9ybXMudURpc3RhbmNlKSk7XG4gICAgICAgIGBcbiAgICApXG4gIH1cbn07XG5jb25zdCBsb2NhbFVuaWZvcm1NU0RGQml0R2wgPSB7XG4gIG5hbWU6IFwibG9jYWwtdW5pZm9ybS1tc2RmLWJpdFwiLFxuICB2ZXJ0ZXg6IHtcbiAgICBoZWFkZXI6IChcbiAgICAgIC8qIGdsc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyB1VHJhbnNmb3JtTWF0cml4O1xuICAgICAgICAgICAgdW5pZm9ybSB2ZWM0IHVDb2xvcjtcbiAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdVJvdW5kO1xuICAgICAgICBgXG4gICAgKSxcbiAgICBtYWluOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgXG4gICAgICAgICAgICB2Q29sb3IgKj0gdUNvbG9yO1xuICAgICAgICAgICAgbW9kZWxNYXRyaXggKj0gdVRyYW5zZm9ybU1hdHJpeDtcbiAgICAgICAgYFxuICAgICksXG4gICAgZW5kOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgXG4gICAgICAgICAgICBpZih1Um91bmQgPT0gMS4pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24ueHkgPSByb3VuZFBpeGVscyhnbF9Qb3NpdGlvbi54eSwgdVJlc29sdXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICBgXG4gICAgKVxuICB9LFxuICBmcmFnbWVudDoge1xuICAgIGhlYWRlcjogKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1RGlzdGFuY2U7XG4gICAgICAgICBgXG4gICAgKSxcbiAgICBtYWluOiAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgIFxuICAgICAgICAgICAgb3V0Q29sb3IgPSB2ZWM0KGNhbGN1bGF0ZU1TREZBbHBoYShvdXRDb2xvciwgdkNvbG9yLCB1RGlzdGFuY2UpKTtcbiAgICAgICAgYFxuICAgIClcbiAgfVxufTtcblxuZXhwb3J0IHsgbG9jYWxVbmlmb3JtTVNERkJpdCwgbG9jYWxVbmlmb3JtTVNERkJpdEdsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbFVuaWZvcm1NU0RGQml0Lm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgbVNERkJpdCA9IHtcbiAgbmFtZTogXCJtc2RmLWJpdFwiLFxuICBmcmFnbWVudDoge1xuICAgIGhlYWRlcjogKFxuICAgICAgLyogd2dzbCAqL1xuICAgICAgYFxuICAgICAgICAgICAgZm4gY2FsY3VsYXRlTVNERkFscGhhKG1zZGZDb2xvcjp2ZWM0PGYzMj4sIHNoYXBlQ29sb3I6dmVjNDxmMzI+LCBkaXN0YW5jZTpmMzIpIC0+IGYzMiB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gTVNERlxuICAgICAgICAgICAgICAgIHZhciBtZWRpYW4gPSBtc2RmQ29sb3IuciArIG1zZGZDb2xvci5nICsgbXNkZkNvbG9yLmIgLVxuICAgICAgICAgICAgICAgICAgICBtaW4obXNkZkNvbG9yLnIsIG1pbihtc2RmQ29sb3IuZywgbXNkZkNvbG9yLmIpKSAtXG4gICAgICAgICAgICAgICAgICAgIG1heChtc2RmQ29sb3IuciwgbWF4KG1zZGZDb2xvci5nLCBtc2RmQ29sb3IuYikpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gU0RGXG4gICAgICAgICAgICAgICAgbWVkaWFuID0gbWluKG1lZGlhbiwgbXNkZkNvbG9yLmEpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNjcmVlblB4RGlzdGFuY2UgPSBkaXN0YW5jZSAqIChtZWRpYW4gLSAwLjUpO1xuICAgICAgICAgICAgICAgIHZhciBhbHBoYSA9IGNsYW1wKHNjcmVlblB4RGlzdGFuY2UgKyAwLjUsIDAuMCwgMS4wKTtcbiAgICAgICAgICAgICAgICBpZiAobWVkaWFuIDwgMC4wMSkge1xuICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IDAuMDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1lZGlhbiA+IDAuOTkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSAxLjA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gR2FtbWEgY29ycmVjdGlvbiBmb3IgY292ZXJhZ2UtbGlrZSBhbHBoYVxuICAgICAgICAgICAgICAgIHZhciBsdW1hOiBmMzIgPSBkb3Qoc2hhcGVDb2xvci5yZ2IsIHZlYzM8ZjMyPigwLjI5OSwgMC41ODcsIDAuMTE0KSk7XG4gICAgICAgICAgICAgICAgdmFyIGdhbW1hOiBmMzIgPSBtaXgoMS4wLCAxLjAgLyAyLjIsIGx1bWEpO1xuICAgICAgICAgICAgICAgIHZhciBjb3ZlcmFnZTogZjMyID0gcG93KHNoYXBlQ29sb3IuYSAqIGFscGhhLCBnYW1tYSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY292ZXJhZ2U7XG4gICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIGBcbiAgICApXG4gIH1cbn07XG5jb25zdCBtU0RGQml0R2wgPSB7XG4gIG5hbWU6IFwibXNkZi1iaXRcIixcbiAgZnJhZ21lbnQ6IHtcbiAgICBoZWFkZXI6IChcbiAgICAgIC8qIGdsc2wgKi9cbiAgICAgIGBcbiAgICAgICAgICAgIGZsb2F0IGNhbGN1bGF0ZU1TREZBbHBoYSh2ZWM0IG1zZGZDb2xvciwgdmVjNCBzaGFwZUNvbG9yLCBmbG9hdCBkaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIE1TREZcbiAgICAgICAgICAgICAgICBmbG9hdCBtZWRpYW4gPSBtc2RmQ29sb3IuciArIG1zZGZDb2xvci5nICsgbXNkZkNvbG9yLmIgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW4obXNkZkNvbG9yLnIsIG1pbihtc2RmQ29sb3IuZywgbXNkZkNvbG9yLmIpKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heChtc2RmQ29sb3IuciwgbWF4KG1zZGZDb2xvci5nLCBtc2RmQ29sb3IuYikpO1xuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gU0RGXG4gICAgICAgICAgICAgICAgbWVkaWFuID0gbWluKG1lZGlhbiwgbXNkZkNvbG9yLmEpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZmxvYXQgc2NyZWVuUHhEaXN0YW5jZSA9IGRpc3RhbmNlICogKG1lZGlhbiAtIDAuNSk7XG4gICAgICAgICAgICAgICAgZmxvYXQgYWxwaGEgPSBjbGFtcChzY3JlZW5QeERpc3RhbmNlICsgMC41LCAwLjAsIDEuMCk7XG4gICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChtZWRpYW4gPCAwLjAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGFscGhhID0gMC4wO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWVkaWFuID4gMC45OSkge1xuICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IDEuMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBHYW1tYSBjb3JyZWN0aW9uIGZvciBjb3ZlcmFnZS1saWtlIGFscGhhXG4gICAgICAgICAgICAgICAgZmxvYXQgbHVtYSA9IGRvdChzaGFwZUNvbG9yLnJnYiwgdmVjMygwLjI5OSwgMC41ODcsIDAuMTE0KSk7XG4gICAgICAgICAgICAgICAgZmxvYXQgZ2FtbWEgPSBtaXgoMS4wLCAxLjAgLyAyLjIsIGx1bWEpO1xuICAgICAgICAgICAgICAgIGZsb2F0IGNvdmVyYWdlID0gcG93KHNoYXBlQ29sb3IuYSAqIGFscGhhLCBnYW1tYSk7ICBcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvdmVyYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICBgXG4gICAgKVxuICB9XG59O1xuXG5leHBvcnQgeyBtU0RGQml0LCBtU0RGQml0R2wgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1TREZCaXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi4vLi4vLi4vbWF0aHMvbWF0cml4L01hdHJpeC5tanMnO1xuaW1wb3J0IHsgZ2V0TWF4VGV4dHVyZXNQZXJCYXRjaCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9iYXRjaGVyL2dsL3V0aWxzL21heFJlY29tbWVuZGVkVGV4dHVyZXMubWpzJztcbmltcG9ydCB7IGNvbXBpbGVIaWdoU2hhZGVyR3B1UHJvZ3JhbSwgY29tcGlsZUhpZ2hTaGFkZXJHbFByb2dyYW0gfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvY29tcGlsZUhpZ2hTaGFkZXJUb1Byb2dyYW0ubWpzJztcbmltcG9ydCB7IGNvbG9yQml0LCBjb2xvckJpdEdsIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL2hpZ2gtc2hhZGVyL3NoYWRlci1iaXRzL2NvbG9yQml0Lm1qcyc7XG5pbXBvcnQgeyBnZW5lcmF0ZVRleHR1cmVCYXRjaEJpdCwgZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaXRHbCB9IGZyb20gJy4uLy4uLy4uL3JlbmRlcmluZy9oaWdoLXNoYWRlci9zaGFkZXItYml0cy9nZW5lcmF0ZVRleHR1cmVCYXRjaEJpdC5tanMnO1xuaW1wb3J0IHsgcm91bmRQaXhlbHNCaXQsIHJvdW5kUGl4ZWxzQml0R2wgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvaGlnaC1zaGFkZXIvc2hhZGVyLWJpdHMvcm91bmRQaXhlbHNCaXQubWpzJztcbmltcG9ydCB7IGdldEJhdGNoU2FtcGxlcnNVbmlmb3JtR3JvdXAgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL2dsL3NoYWRlci9nZXRCYXRjaFNhbXBsZXJzVW5pZm9ybUdyb3VwLm1qcyc7XG5pbXBvcnQgeyBTaGFkZXIgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvU2hhZGVyLm1qcyc7XG5pbXBvcnQgeyBVbmlmb3JtR3JvdXAgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC9zaGFkZXIvVW5pZm9ybUdyb3VwLm1qcyc7XG5pbXBvcnQgeyBsb2NhbFVuaWZvcm1NU0RGQml0LCBsb2NhbFVuaWZvcm1NU0RGQml0R2wgfSBmcm9tICcuL3NoYWRlci1iaXRzL2xvY2FsVW5pZm9ybU1TREZCaXQubWpzJztcbmltcG9ydCB7IG1TREZCaXQsIG1TREZCaXRHbCB9IGZyb20gJy4vc2hhZGVyLWJpdHMvbVNERkJpdC5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmxldCBncHVQcm9ncmFtO1xubGV0IGdsUHJvZ3JhbTtcbmNsYXNzIFNkZlNoYWRlciBleHRlbmRzIFNoYWRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnN0IHVuaWZvcm1zID0gbmV3IFVuaWZvcm1Hcm91cCh7XG4gICAgICB1Q29sb3I6IHsgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDFdKSwgdHlwZTogXCJ2ZWM0PGYzMj5cIiB9LFxuICAgICAgdVRyYW5zZm9ybU1hdHJpeDogeyB2YWx1ZTogbmV3IE1hdHJpeCgpLCB0eXBlOiBcIm1hdDN4MzxmMzI+XCIgfSxcbiAgICAgIHVEaXN0YW5jZTogeyB2YWx1ZTogNCwgdHlwZTogXCJmMzJcIiB9LFxuICAgICAgdVJvdW5kOiB7IHZhbHVlOiAwLCB0eXBlOiBcImYzMlwiIH1cbiAgICB9KTtcbiAgICBjb25zdCBtYXhUZXh0dXJlcyA9IGdldE1heFRleHR1cmVzUGVyQmF0Y2goKTtcbiAgICBncHVQcm9ncmFtID8/IChncHVQcm9ncmFtID0gY29tcGlsZUhpZ2hTaGFkZXJHcHVQcm9ncmFtKHtcbiAgICAgIG5hbWU6IFwic2RmLXNoYWRlclwiLFxuICAgICAgYml0czogW1xuICAgICAgICBjb2xvckJpdCxcbiAgICAgICAgZ2VuZXJhdGVUZXh0dXJlQmF0Y2hCaXQobWF4VGV4dHVyZXMpLFxuICAgICAgICBsb2NhbFVuaWZvcm1NU0RGQml0LFxuICAgICAgICBtU0RGQml0LFxuICAgICAgICByb3VuZFBpeGVsc0JpdFxuICAgICAgXVxuICAgIH0pKTtcbiAgICBnbFByb2dyYW0gPz8gKGdsUHJvZ3JhbSA9IGNvbXBpbGVIaWdoU2hhZGVyR2xQcm9ncmFtKHtcbiAgICAgIG5hbWU6IFwic2RmLXNoYWRlclwiLFxuICAgICAgYml0czogW1xuICAgICAgICBjb2xvckJpdEdsLFxuICAgICAgICBnZW5lcmF0ZVRleHR1cmVCYXRjaEJpdEdsKG1heFRleHR1cmVzKSxcbiAgICAgICAgbG9jYWxVbmlmb3JtTVNERkJpdEdsLFxuICAgICAgICBtU0RGQml0R2wsXG4gICAgICAgIHJvdW5kUGl4ZWxzQml0R2xcbiAgICAgIF1cbiAgICB9KSk7XG4gICAgc3VwZXIoe1xuICAgICAgZ2xQcm9ncmFtLFxuICAgICAgZ3B1UHJvZ3JhbSxcbiAgICAgIHJlc291cmNlczoge1xuICAgICAgICBsb2NhbFVuaWZvcm1zOiB1bmlmb3JtcyxcbiAgICAgICAgYmF0Y2hTYW1wbGVyczogZ2V0QmF0Y2hTYW1wbGVyc1VuaWZvcm1Hcm91cChtYXhUZXh0dXJlcylcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgeyBTZGZTaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNkZlNoYWRlci5tanMubWFwXG4iLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBBYnN0cmFjdEJpdG1hcEZvbnQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIC8qKiBUaGUgbWFwIG9mIGNoYXJhY3RlcnMgYnkgY2hhcmFjdGVyIGNvZGUuICovXG4gICAgdGhpcy5jaGFycyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIC8qKlxuICAgICAqIFRoZSBsaW5lLWhlaWdodCBvZiB0aGUgZm9udCBmYWNlIGluIHBpeGVscy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGluZUhlaWdodCA9IDA7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGZvbnQgZmFjZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5mb250RmFtaWx5ID0gXCJcIjtcbiAgICAvKiogVGhlIG1ldHJpY3Mgb2YgdGhlIGZvbnQgZmFjZS4gKi9cbiAgICB0aGlzLmZvbnRNZXRyaWNzID0geyBmb250U2l6ZTogMCwgYXNjZW50OiAwLCBkZXNjZW50OiAwIH07XG4gICAgLyoqXG4gICAgICogVGhlIG9mZnNldCBvZiB0aGUgZm9udCBmYWNlIGZyb20gdGhlIGJhc2VsaW5lLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5iYXNlTGluZU9mZnNldCA9IDA7XG4gICAgLyoqIFRoZSByYW5nZSBhbmQgdHlwZSBvZiB0aGUgZGlzdGFuY2UgZmllbGQgZm9yIHRoaXMgZm9udC4gKi9cbiAgICB0aGlzLmRpc3RhbmNlRmllbGQgPSB7IHR5cGU6IFwibm9uZVwiLCByYW5nZTogMCB9O1xuICAgIC8qKiBUaGUgbWFwIG9mIGJhc2UgcGFnZSB0ZXh0dXJlcyAoaS5lLiwgc2hlZXRzIG9mIGdseXBocykuICovXG4gICAgdGhpcy5wYWdlcyA9IFtdO1xuICAgIC8qKiBzaG91bGQgdGhlIGZpbGwgZm9yIHRoaXMgZm9udCBiZSBhcHBsaWVkIGFzIGEgdGludCB0byB0aGUgdGV4dC4gKi9cbiAgICB0aGlzLmFwcGx5RmlsbEFzVGludCA9IHRydWU7XG4gICAgLyoqIFRoZSBzaXplIG9mIHRoZSBmb250IGZhY2UgaW4gcGl4ZWxzLiAqL1xuICAgIHRoaXMuYmFzZU1lYXN1cmVtZW50Rm9udFNpemUgPSAxMDA7XG4gICAgdGhpcy5iYXNlUmVuZGVyZWRGb250U2l6ZSA9IDEwMDtcbiAgfVxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGZvbnQgZmFjZS5cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjAgVXNlIGBmb250RmFtaWx5YCBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGZvbnQoKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkJpdG1hcEZvbnQuZm9udCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIEJpdG1hcEZvbnQuZm9udEZhbWlseSBpbnN0ZWFkLlwiKTtcbiAgICByZXR1cm4gdGhpcy5mb250RmFtaWx5O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbWFwIG9mIGJhc2UgcGFnZSB0ZXh0dXJlcyAoaS5lLiwgc2hlZXRzIG9mIGdseXBocykuXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wIFVzZSBgcGFnZXNgIGluc3RlYWQuXG4gICAqL1xuICBnZXQgcGFnZVRleHR1cmVzKCkge1xuICAgIGRlcHJlY2F0aW9uKHY4XzBfMCwgXCJCaXRtYXBGb250LnBhZ2VUZXh0dXJlcyBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIEJpdG1hcEZvbnQucGFnZXMgaW5zdGVhZC5cIik7XG4gICAgcmV0dXJuIHRoaXMucGFnZXM7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSBmb250IGZhY2UgaW4gcGl4ZWxzLlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA4LjAuMCBVc2UgYGZvbnRNZXRyaWNzLmZvbnRTaXplYCBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IHNpemUoKSB7XG4gICAgZGVwcmVjYXRpb24odjhfMF8wLCBcIkJpdG1hcEZvbnQuc2l6ZSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIEJpdG1hcEZvbnQuZm9udE1ldHJpY3MuZm9udFNpemUgaW5zdGVhZC5cIik7XG4gICAgcmV0dXJuIHRoaXMuZm9udE1ldHJpY3MuZm9udFNpemU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBraW5kIG9mIGRpc3RhbmNlIGZpZWxkIGZvciB0aGlzIGZvbnQgb3IgXCJub25lXCIuXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wIFVzZSBgZGlzdGFuY2VGaWVsZC50eXBlYCBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IGRpc3RhbmNlRmllbGRSYW5nZSgpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiQml0bWFwRm9udC5kaXN0YW5jZUZpZWxkUmFuZ2UgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBCaXRtYXBGb250LmRpc3RhbmNlRmllbGQucmFuZ2UgaW5zdGVhZC5cIik7XG4gICAgcmV0dXJuIHRoaXMuZGlzdGFuY2VGaWVsZC5yYW5nZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHJhbmdlIG9mIHRoZSBkaXN0YW5jZSBmaWVsZCBpbiBwaXhlbHMuXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDguMC4wIFVzZSBgZGlzdGFuY2VGaWVsZC5yYW5nZWAgaW5zdGVhZC5cbiAgICovXG4gIGdldCBkaXN0YW5jZUZpZWxkVHlwZSgpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiQml0bWFwRm9udC5kaXN0YW5jZUZpZWxkVHlwZSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIEJpdG1hcEZvbnQuZGlzdGFuY2VGaWVsZC50eXBlIGluc3RlYWQuXCIpO1xuICAgIHJldHVybiB0aGlzLmRpc3RhbmNlRmllbGQudHlwZTtcbiAgfVxuICBkZXN0cm95KGRlc3Ryb3lUZXh0dXJlcyA9IGZhbHNlKSB7XG4gICAgdGhpcy5lbWl0KFwiZGVzdHJveVwiLCB0aGlzKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLmNoYXJzKSB7XG4gICAgICB0aGlzLmNoYXJzW2ldLnRleHR1cmU/LmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5jaGFycyA9IG51bGw7XG4gICAgaWYgKGRlc3Ryb3lUZXh0dXJlcykge1xuICAgICAgdGhpcy5wYWdlcy5mb3JFYWNoKChwYWdlKSA9PiBwYWdlLnRleHR1cmUuZGVzdHJveSh0cnVlKSk7XG4gICAgICB0aGlzLnBhZ2VzID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgQWJzdHJhY3RCaXRtYXBGb250IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYnN0cmFjdEJpdG1hcEZvbnQubWpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiByZXNvbHZlQ2hhcmFjdGVycyhjaGFycykge1xuICBpZiAoY2hhcnMgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKHR5cGVvZiBjaGFycyA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNoYXJzID0gW2NoYXJzXTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSBjaGFycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICBjb25zdCBpdGVtID0gY2hhcnNbaV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgIGlmIChpdGVtLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtCaXRtYXBGb250XTogSW52YWxpZCBjaGFyYWN0ZXIgcmFuZ2UgbGVuZ3RoLCBleHBlY3RpbmcgMiBnb3QgJHtpdGVtLmxlbmd0aH0uYCk7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVswXS5sZW5ndGggPT09IDAgfHwgaXRlbVsxXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW0JpdG1hcEZvbnRdOiBJbnZhbGlkIGNoYXJhY3RlciBkZWxpbWl0ZXIuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnRDb2RlID0gaXRlbVswXS5jaGFyQ29kZUF0KDApO1xuICAgICAgY29uc3QgZW5kQ29kZSA9IGl0ZW1bMV0uY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmIChlbmRDb2RlIDwgc3RhcnRDb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIltCaXRtYXBGb250XTogSW52YWxpZCBjaGFyYWN0ZXIgcmFuZ2UuXCIpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaTIgPSBzdGFydENvZGUsIGoyID0gZW5kQ29kZTsgaTIgPD0gajI7IGkyKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShpMikpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaCguLi5BcnJheS5mcm9tKGl0ZW0pKTtcbiAgICB9XG4gIH1cbiAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJbQml0bWFwRm9udF06IEVtcHR5IHNldCB3aGVuIHJlc29sdmluZyBjaGFyYWN0ZXJzLlwiKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyByZXNvbHZlQ2hhcmFjdGVycyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZUNoYXJhY3RlcnMubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi9jb2xvci9Db2xvci5tanMnO1xuaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi4vLi4vbWF0aHMvc2hhcGVzL1JlY3RhbmdsZS5tanMnO1xuaW1wb3J0IHsgQ2FudmFzUG9vbCB9IGZyb20gJy4uLy4uL3JlbmRlcmluZy9yZW5kZXJlcnMvc2hhcmVkL3RleHR1cmUvQ2FudmFzUG9vbC5tanMnO1xuaW1wb3J0IHsgSW1hZ2VTb3VyY2UgfSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL3NvdXJjZXMvSW1hZ2VTb3VyY2UubWpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmUubWpzJztcbmltcG9ydCB7IGRlcHJlY2F0aW9uLCB2OF8wXzAgfSBmcm9tICcuLi8uLi91dGlscy9sb2dnaW5nL2RlcHJlY2F0aW9uLm1qcyc7XG5pbXBvcnQgeyBDYW52YXNUZXh0TWV0cmljcyB9IGZyb20gJy4uL3RleHQvY2FudmFzL0NhbnZhc1RleHRNZXRyaWNzLm1qcyc7XG5pbXBvcnQgeyBmb250U3RyaW5nRnJvbVRleHRTdHlsZSB9IGZyb20gJy4uL3RleHQvY2FudmFzL3V0aWxzL2ZvbnRTdHJpbmdGcm9tVGV4dFN0eWxlLm1qcyc7XG5pbXBvcnQgeyBnZXRDYW52YXNGaWxsU3R5bGUgfSBmcm9tICcuLi90ZXh0L2NhbnZhcy91dGlscy9nZXRDYW52YXNGaWxsU3R5bGUubWpzJztcbmltcG9ydCB7IFRleHRTdHlsZSB9IGZyb20gJy4uL3RleHQvVGV4dFN0eWxlLm1qcyc7XG5pbXBvcnQgeyBBYnN0cmFjdEJpdG1hcEZvbnQgfSBmcm9tICcuL0Fic3RyYWN0Qml0bWFwRm9udC5tanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUNoYXJhY3RlcnMgfSBmcm9tICcuL3V0aWxzL3Jlc29sdmVDaGFyYWN0ZXJzLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgX0R5bmFtaWNCaXRtYXBGb250ID0gY2xhc3MgX0R5bmFtaWNCaXRtYXBGb250IGV4dGVuZHMgQWJzdHJhY3RCaXRtYXBGb250IHtcbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBkeW5hbWljIGJpdG1hcCBmb250LlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogdGhpcyBpcyBhIHJlc29sdXRpb24gbW9kaWZpZXIgZm9yIHRoZSBmb250IHNpemUuLlxuICAgICAqIHRleHR1cmUgcmVzb2x1dGlvbiB3aWxsIGFsc28gYmUgdXNlZCB0byBzY2FsZSB0ZXh0dXJlIGFjY29yZGluZyB0byBpdHMgZm9udCBzaXplIGFsc29cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb24gPSAxO1xuICAgIC8qKiBUaGUgcGFnZXMgb2YgdGhlIGZvbnQuICovXG4gICAgdGhpcy5wYWdlcyA9IFtdO1xuICAgIHRoaXMuX3BhZGRpbmcgPSAwO1xuICAgIHRoaXMuX21lYXN1cmVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2N1cnJlbnRDaGFycyA9IFtdO1xuICAgIHRoaXMuX2N1cnJlbnRYID0gMDtcbiAgICB0aGlzLl9jdXJyZW50WSA9IDA7XG4gICAgdGhpcy5fY3VycmVudFBhZ2VJbmRleCA9IC0xO1xuICAgIHRoaXMuX3NraXBLZXJuaW5nID0gZmFsc2U7XG4gICAgY29uc3QgZHluYW1pY09wdGlvbnMgPSB7IC4uLl9EeW5hbWljQml0bWFwRm9udC5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIHRoaXMuX3RleHR1cmVTaXplID0gZHluYW1pY09wdGlvbnMudGV4dHVyZVNpemU7XG4gICAgdGhpcy5fbWlwbWFwID0gZHluYW1pY09wdGlvbnMubWlwbWFwO1xuICAgIGNvbnN0IHN0eWxlID0gZHluYW1pY09wdGlvbnMuc3R5bGUuY2xvbmUoKTtcbiAgICBpZiAoZHluYW1pY09wdGlvbnMub3ZlcnJpZGVGaWxsKSB7XG4gICAgICBzdHlsZS5fZmlsbC5jb2xvciA9IDE2Nzc3MjE1O1xuICAgICAgc3R5bGUuX2ZpbGwuYWxwaGEgPSAxO1xuICAgICAgc3R5bGUuX2ZpbGwudGV4dHVyZSA9IFRleHR1cmUuV0hJVEU7XG4gICAgICBzdHlsZS5fZmlsbC5maWxsID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5hcHBseUZpbGxBc1RpbnQgPSBkeW5hbWljT3B0aW9ucy5vdmVycmlkZUZpbGw7XG4gICAgY29uc3QgcmVxdWVzdGVkRm9udFNpemUgPSBzdHlsZS5mb250U2l6ZTtcbiAgICBzdHlsZS5mb250U2l6ZSA9IHRoaXMuYmFzZU1lYXN1cmVtZW50Rm9udFNpemU7XG4gICAgY29uc3QgZm9udCA9IGZvbnRTdHJpbmdGcm9tVGV4dFN0eWxlKHN0eWxlKTtcbiAgICBpZiAoZHluYW1pY09wdGlvbnMub3ZlcnJpZGVTaXplKSB7XG4gICAgICBpZiAoc3R5bGUuX3N0cm9rZSkge1xuICAgICAgICBzdHlsZS5fc3Ryb2tlLndpZHRoICo9IHRoaXMuYmFzZVJlbmRlcmVkRm9udFNpemUgLyByZXF1ZXN0ZWRGb250U2l6ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuZm9udFNpemUgPSB0aGlzLmJhc2VSZW5kZXJlZEZvbnRTaXplID0gcmVxdWVzdGVkRm9udFNpemU7XG4gICAgfVxuICAgIHRoaXMuX3N0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5fc2tpcEtlcm5pbmcgPSBkeW5hbWljT3B0aW9ucy5za2lwS2VybmluZyA/PyBmYWxzZTtcbiAgICB0aGlzLnJlc29sdXRpb24gPSBkeW5hbWljT3B0aW9ucy5yZXNvbHV0aW9uID8/IDE7XG4gICAgdGhpcy5fcGFkZGluZyA9IGR5bmFtaWNPcHRpb25zLnBhZGRpbmcgPz8gNDtcbiAgICB0aGlzLmZvbnRNZXRyaWNzID0gQ2FudmFzVGV4dE1ldHJpY3MubWVhc3VyZUZvbnQoZm9udCk7XG4gICAgdGhpcy5saW5lSGVpZ2h0ID0gc3R5bGUubGluZUhlaWdodCB8fCB0aGlzLmZvbnRNZXRyaWNzLmZvbnRTaXplIHx8IHN0eWxlLmZvbnRTaXplO1xuICB9XG4gIGVuc3VyZUNoYXJhY3RlcnMoY2hhcnMpIHtcbiAgICBjb25zdCBjaGFyTGlzdCA9IHJlc29sdmVDaGFyYWN0ZXJzKGNoYXJzKS5maWx0ZXIoKGNoYXIpID0+ICF0aGlzLl9jdXJyZW50Q2hhcnMuaW5jbHVkZXMoY2hhcikpLmZpbHRlcigoY2hhciwgaW5kZXgsIHNlbGYpID0+IHNlbGYuaW5kZXhPZihjaGFyKSA9PT0gaW5kZXgpO1xuICAgIGlmICghY2hhckxpc3QubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2N1cnJlbnRDaGFycyA9IFsuLi50aGlzLl9jdXJyZW50Q2hhcnMsIC4uLmNoYXJMaXN0XTtcbiAgICBsZXQgcGFnZURhdGE7XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRQYWdlSW5kZXggPT09IC0xKSB7XG4gICAgICBwYWdlRGF0YSA9IHRoaXMuX25leHRQYWdlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhZ2VEYXRhID0gdGhpcy5wYWdlc1t0aGlzLl9jdXJyZW50UGFnZUluZGV4XTtcbiAgICB9XG4gICAgbGV0IHsgY2FudmFzLCBjb250ZXh0IH0gPSBwYWdlRGF0YS5jYW52YXNBbmRDb250ZXh0O1xuICAgIGxldCB0ZXh0dXJlU291cmNlID0gcGFnZURhdGEudGV4dHVyZS5zb3VyY2U7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLl9zdHlsZTtcbiAgICBsZXQgY3VycmVudFggPSB0aGlzLl9jdXJyZW50WDtcbiAgICBsZXQgY3VycmVudFkgPSB0aGlzLl9jdXJyZW50WTtcbiAgICBjb25zdCBmb250U2NhbGUgPSB0aGlzLmJhc2VSZW5kZXJlZEZvbnRTaXplIC8gdGhpcy5iYXNlTWVhc3VyZW1lbnRGb250U2l6ZTtcbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5fcGFkZGluZyAqIGZvbnRTY2FsZTtcbiAgICBjb25zdCB3aWR0aFNjYWxlID0gc3R5bGUuZm9udFN0eWxlID09PSBcIml0YWxpY1wiID8gMiA6IDE7XG4gICAgbGV0IG1heENoYXJIZWlnaHQgPSAwO1xuICAgIGxldCBza2lwVGV4dHVyZSA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhckxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYXIgPSBjaGFyTGlzdFtpXTtcbiAgICAgIGNvbnN0IG1ldHJpY3MgPSBDYW52YXNUZXh0TWV0cmljcy5tZWFzdXJlVGV4dChjaGFyLCBzdHlsZSwgY2FudmFzLCBmYWxzZSk7XG4gICAgICBtZXRyaWNzLmxpbmVIZWlnaHQgPSBtZXRyaWNzLmhlaWdodDtcbiAgICAgIGNvbnN0IHdpZHRoID0gd2lkdGhTY2FsZSAqIG1ldHJpY3Mud2lkdGggKiBmb250U2NhbGU7XG4gICAgICBjb25zdCBoZWlnaHQgPSBtZXRyaWNzLmhlaWdodCAqIGZvbnRTY2FsZTtcbiAgICAgIGNvbnN0IHBhZGRlZFdpZHRoID0gd2lkdGggKyBwYWRkaW5nICogMjtcbiAgICAgIGNvbnN0IHBhZGRlZEhlaWdodCA9IGhlaWdodCArIHBhZGRpbmcgKiAyO1xuICAgICAgc2tpcFRleHR1cmUgPSBmYWxzZTtcbiAgICAgIGlmIChjaGFyICE9PSBcIlxcblwiICYmIGNoYXIgIT09IFwiXFxyXCIgJiYgY2hhciAhPT0gXCJcdFwiICYmIGNoYXIgIT09IFwiIFwiKSB7XG4gICAgICAgIHNraXBUZXh0dXJlID0gdHJ1ZTtcbiAgICAgICAgbWF4Q2hhckhlaWdodCA9IE1hdGguY2VpbChNYXRoLm1heChwYWRkZWRIZWlnaHQsIG1heENoYXJIZWlnaHQpKTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50WCArIHBhZGRlZFdpZHRoID4gdGhpcy5fdGV4dHVyZVNpemUpIHtcbiAgICAgICAgY3VycmVudFkgKz0gbWF4Q2hhckhlaWdodDtcbiAgICAgICAgbWF4Q2hhckhlaWdodCA9IHBhZGRlZEhlaWdodDtcbiAgICAgICAgY3VycmVudFggPSAwO1xuICAgICAgICBpZiAoY3VycmVudFkgKyBtYXhDaGFySGVpZ2h0ID4gdGhpcy5fdGV4dHVyZVNpemUpIHtcbiAgICAgICAgICB0ZXh0dXJlU291cmNlLnVwZGF0ZSgpO1xuICAgICAgICAgIGNvbnN0IHBhZ2VEYXRhMiA9IHRoaXMuX25leHRQYWdlKCk7XG4gICAgICAgICAgY2FudmFzID0gcGFnZURhdGEyLmNhbnZhc0FuZENvbnRleHQuY2FudmFzO1xuICAgICAgICAgIGNvbnRleHQgPSBwYWdlRGF0YTIuY2FudmFzQW5kQ29udGV4dC5jb250ZXh0O1xuICAgICAgICAgIHRleHR1cmVTb3VyY2UgPSBwYWdlRGF0YTIudGV4dHVyZS5zb3VyY2U7XG4gICAgICAgICAgY3VycmVudFkgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB4QWR2YW5jZSA9IHdpZHRoIC8gZm9udFNjYWxlIC0gKHN0eWxlLmRyb3BTaGFkb3c/LmRpc3RhbmNlID8/IDApIC0gKHN0eWxlLl9zdHJva2U/LndpZHRoID8/IDApO1xuICAgICAgdGhpcy5jaGFyc1tjaGFyXSA9IHtcbiAgICAgICAgaWQ6IGNoYXIuY29kZVBvaW50QXQoMCksXG4gICAgICAgIHhPZmZzZXQ6IC10aGlzLl9wYWRkaW5nLFxuICAgICAgICB5T2Zmc2V0OiAtdGhpcy5fcGFkZGluZyxcbiAgICAgICAgeEFkdmFuY2UsXG4gICAgICAgIGtlcm5pbmc6IHt9XG4gICAgICB9O1xuICAgICAgaWYgKHNraXBUZXh0dXJlKSB7XG4gICAgICAgIHRoaXMuX2RyYXdHbHlwaChcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIG1ldHJpY3MsXG4gICAgICAgICAgY3VycmVudFggKyBwYWRkaW5nLFxuICAgICAgICAgIGN1cnJlbnRZICsgcGFkZGluZyxcbiAgICAgICAgICBmb250U2NhbGUsXG4gICAgICAgICAgc3R5bGVcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcHggPSB0ZXh0dXJlU291cmNlLndpZHRoICogZm9udFNjYWxlO1xuICAgICAgICBjb25zdCBweSA9IHRleHR1cmVTb3VyY2UuaGVpZ2h0ICogZm9udFNjYWxlO1xuICAgICAgICBjb25zdCBmcmFtZSA9IG5ldyBSZWN0YW5nbGUoXG4gICAgICAgICAgY3VycmVudFggLyBweCAqIHRleHR1cmVTb3VyY2Uud2lkdGgsXG4gICAgICAgICAgY3VycmVudFkgLyBweSAqIHRleHR1cmVTb3VyY2UuaGVpZ2h0LFxuICAgICAgICAgIHBhZGRlZFdpZHRoIC8gcHggKiB0ZXh0dXJlU291cmNlLndpZHRoLFxuICAgICAgICAgIHBhZGRlZEhlaWdodCAvIHB5ICogdGV4dHVyZVNvdXJjZS5oZWlnaHRcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5jaGFyc1tjaGFyXS50ZXh0dXJlID0gbmV3IFRleHR1cmUoe1xuICAgICAgICAgIHNvdXJjZTogdGV4dHVyZVNvdXJjZSxcbiAgICAgICAgICBmcmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgY3VycmVudFggKz0gTWF0aC5jZWlsKHBhZGRlZFdpZHRoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGV4dHVyZVNvdXJjZS51cGRhdGUoKTtcbiAgICB0aGlzLl9jdXJyZW50WCA9IGN1cnJlbnRYO1xuICAgIHRoaXMuX2N1cnJlbnRZID0gY3VycmVudFk7XG4gICAgdGhpcy5fc2tpcEtlcm5pbmcgJiYgdGhpcy5fYXBwbHlLZXJuaW5nKGNoYXJMaXN0LCBjb250ZXh0KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgOC4wLjBcbiAgICogVGhlIG1hcCBvZiBiYXNlIHBhZ2UgdGV4dHVyZXMgKGkuZS4sIHNoZWV0cyBvZiBnbHlwaHMpLlxuICAgKi9cbiAgZ2V0IHBhZ2VUZXh0dXJlcygpIHtcbiAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiQml0bWFwRm9udC5wYWdlVGV4dHVyZXMgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBCaXRtYXBGb250LnBhZ2VzIGluc3RlYWQuXCIpO1xuICAgIHJldHVybiB0aGlzLnBhZ2VzO1xuICB9XG4gIF9hcHBseUtlcm5pbmcobmV3Q2hhcnMsIGNvbnRleHQpIHtcbiAgICBjb25zdCBtZWFzdXJlQ2FjaGUgPSB0aGlzLl9tZWFzdXJlQ2FjaGU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZmlyc3QgPSBuZXdDaGFyc1tpXTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5fY3VycmVudENoYXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IHNlY29uZCA9IHRoaXMuX2N1cnJlbnRDaGFyc1tqXTtcbiAgICAgICAgbGV0IGMxID0gbWVhc3VyZUNhY2hlW2ZpcnN0XTtcbiAgICAgICAgaWYgKCFjMSlcbiAgICAgICAgICBjMSA9IG1lYXN1cmVDYWNoZVtmaXJzdF0gPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGZpcnN0KS53aWR0aDtcbiAgICAgICAgbGV0IGMyID0gbWVhc3VyZUNhY2hlW3NlY29uZF07XG4gICAgICAgIGlmICghYzIpXG4gICAgICAgICAgYzIgPSBtZWFzdXJlQ2FjaGVbc2Vjb25kXSA9IGNvbnRleHQubWVhc3VyZVRleHQoc2Vjb25kKS53aWR0aDtcbiAgICAgICAgbGV0IHRvdGFsID0gY29udGV4dC5tZWFzdXJlVGV4dChmaXJzdCArIHNlY29uZCkud2lkdGg7XG4gICAgICAgIGxldCBhbW91bnQgPSB0b3RhbCAtIChjMSArIGMyKTtcbiAgICAgICAgaWYgKGFtb3VudCkge1xuICAgICAgICAgIHRoaXMuY2hhcnNbZmlyc3RdLmtlcm5pbmdbc2Vjb25kXSA9IGFtb3VudDtcbiAgICAgICAgfVxuICAgICAgICB0b3RhbCA9IGNvbnRleHQubWVhc3VyZVRleHQoZmlyc3QgKyBzZWNvbmQpLndpZHRoO1xuICAgICAgICBhbW91bnQgPSB0b3RhbCAtIChjMSArIGMyKTtcbiAgICAgICAgaWYgKGFtb3VudCkge1xuICAgICAgICAgIHRoaXMuY2hhcnNbc2Vjb25kXS5rZXJuaW5nW2ZpcnN0XSA9IGFtb3VudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfbmV4dFBhZ2UoKSB7XG4gICAgdGhpcy5fY3VycmVudFBhZ2VJbmRleCsrO1xuICAgIGNvbnN0IHRleHR1cmVSZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xuICAgIGNvbnN0IGNhbnZhc0FuZENvbnRleHQgPSBDYW52YXNQb29sLmdldE9wdGltYWxDYW52YXNBbmRDb250ZXh0KFxuICAgICAgdGhpcy5fdGV4dHVyZVNpemUsXG4gICAgICB0aGlzLl90ZXh0dXJlU2l6ZSxcbiAgICAgIHRleHR1cmVSZXNvbHV0aW9uXG4gICAgKTtcbiAgICB0aGlzLl9zZXR1cENvbnRleHQoY2FudmFzQW5kQ29udGV4dC5jb250ZXh0LCB0aGlzLl9zdHlsZSwgdGV4dHVyZVJlc29sdXRpb24pO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0ZXh0dXJlUmVzb2x1dGlvbiAqICh0aGlzLmJhc2VSZW5kZXJlZEZvbnRTaXplIC8gdGhpcy5iYXNlTWVhc3VyZW1lbnRGb250U2l6ZSk7XG4gICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKHtcbiAgICAgIHNvdXJjZTogbmV3IEltYWdlU291cmNlKHtcbiAgICAgICAgcmVzb3VyY2U6IGNhbnZhc0FuZENvbnRleHQuY2FudmFzLFxuICAgICAgICByZXNvbHV0aW9uLFxuICAgICAgICBhbHBoYU1vZGU6IFwicHJlbXVsdGlwbHktYWxwaGEtb24tdXBsb2FkXCIsXG4gICAgICAgIGF1dG9HZW5lcmF0ZU1pcG1hcHM6IHRoaXMuX21pcG1hcFxuICAgICAgfSlcbiAgICB9KTtcbiAgICBjb25zdCBwYWdlRGF0YSA9IHtcbiAgICAgIGNhbnZhc0FuZENvbnRleHQsXG4gICAgICB0ZXh0dXJlXG4gICAgfTtcbiAgICB0aGlzLnBhZ2VzW3RoaXMuX2N1cnJlbnRQYWdlSW5kZXhdID0gcGFnZURhdGE7XG4gICAgcmV0dXJuIHBhZ2VEYXRhO1xuICB9XG4gIC8vIGNhbnZhcyBzdHlsZSFcbiAgX3NldHVwQ29udGV4dChjb250ZXh0LCBzdHlsZSwgcmVzb2x1dGlvbikge1xuICAgIHN0eWxlLmZvbnRTaXplID0gdGhpcy5iYXNlUmVuZGVyZWRGb250U2l6ZTtcbiAgICBjb250ZXh0LnNjYWxlKHJlc29sdXRpb24sIHJlc29sdXRpb24pO1xuICAgIGNvbnRleHQuZm9udCA9IGZvbnRTdHJpbmdGcm9tVGV4dFN0eWxlKHN0eWxlKTtcbiAgICBzdHlsZS5mb250U2l6ZSA9IHRoaXMuYmFzZU1lYXN1cmVtZW50Rm9udFNpemU7XG4gICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmU7XG4gICAgY29uc3Qgc3Ryb2tlID0gc3R5bGUuX3N0cm9rZTtcbiAgICBjb25zdCBzdHJva2VUaGlja25lc3MgPSBzdHJva2U/LndpZHRoID8/IDA7XG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBzdHJva2VUaGlja25lc3M7XG4gICAgICBjb250ZXh0LmxpbmVKb2luID0gc3Ryb2tlLmpvaW47XG4gICAgICBjb250ZXh0Lm1pdGVyTGltaXQgPSBzdHJva2UubWl0ZXJMaW1pdDtcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBnZXRDYW52YXNGaWxsU3R5bGUoc3Ryb2tlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKHN0eWxlLl9maWxsKSB7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGdldENhbnZhc0ZpbGxTdHlsZShzdHlsZS5fZmlsbCwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChzdHlsZS5kcm9wU2hhZG93KSB7XG4gICAgICBjb25zdCBzaGFkb3dPcHRpb25zID0gc3R5bGUuZHJvcFNoYWRvdztcbiAgICAgIGNvbnN0IHJnYiA9IENvbG9yLnNoYXJlZC5zZXRWYWx1ZShzaGFkb3dPcHRpb25zLmNvbG9yKS50b0FycmF5KCk7XG4gICAgICBjb25zdCBkcm9wU2hhZG93Qmx1ciA9IHNoYWRvd09wdGlvbnMuYmx1ciAqIHJlc29sdXRpb247XG4gICAgICBjb25zdCBkcm9wU2hhZG93RGlzdGFuY2UgPSBzaGFkb3dPcHRpb25zLmRpc3RhbmNlICogcmVzb2x1dGlvbjtcbiAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBgcmdiYSgke3JnYlswXSAqIDI1NX0sJHtyZ2JbMV0gKiAyNTV9LCR7cmdiWzJdICogMjU1fSwke3NoYWRvd09wdGlvbnMuYWxwaGF9KWA7XG4gICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSBkcm9wU2hhZG93Qmx1cjtcbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IE1hdGguY29zKHNoYWRvd09wdGlvbnMuYW5nbGUpICogZHJvcFNoYWRvd0Rpc3RhbmNlO1xuICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gTWF0aC5zaW4oc2hhZG93T3B0aW9ucy5hbmdsZSkgKiBkcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBcImJsYWNrXCI7XG4gICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSAwO1xuICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgfVxuICB9XG4gIF9kcmF3R2x5cGgoY29udGV4dCwgbWV0cmljcywgeCwgeSwgZm9udFNjYWxlLCBzdHlsZSkge1xuICAgIGNvbnN0IGNoYXIgPSBtZXRyaWNzLnRleHQ7XG4gICAgY29uc3QgZm9udFByb3BlcnRpZXMgPSBtZXRyaWNzLmZvbnRQcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHN0cm9rZSA9IHN0eWxlLl9zdHJva2U7XG4gICAgY29uc3Qgc3Ryb2tlVGhpY2tuZXNzID0gKHN0cm9rZT8ud2lkdGggPz8gMCkgKiBmb250U2NhbGU7XG4gICAgY29uc3QgdHggPSB4ICsgc3Ryb2tlVGhpY2tuZXNzIC8gMjtcbiAgICBjb25zdCB0eSA9IHkgLSBzdHJva2VUaGlja25lc3MgLyAyO1xuICAgIGNvbnN0IGRlc2NlbnQgPSBmb250UHJvcGVydGllcy5kZXNjZW50ICogZm9udFNjYWxlO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBtZXRyaWNzLmxpbmVIZWlnaHQgKiBmb250U2NhbGU7XG4gICAgaWYgKHN0eWxlLnN0cm9rZSAmJiBzdHJva2VUaGlja25lc3MpIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dChjaGFyLCB0eCwgdHkgKyBsaW5lSGVpZ2h0IC0gZGVzY2VudCk7XG4gICAgfVxuICAgIGlmIChzdHlsZS5fZmlsbCkge1xuICAgICAgY29udGV4dC5maWxsVGV4dChjaGFyLCB0eCwgdHkgKyBsaW5lSGVpZ2h0IC0gZGVzY2VudCk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgeyBjYW52YXNBbmRDb250ZXh0LCB0ZXh0dXJlIH0gPSB0aGlzLnBhZ2VzW2ldO1xuICAgICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMud2lkdGggPSBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy53aWR0aDtcbiAgICAgIENhbnZhc1Bvb2wucmV0dXJuQ2FudmFzQW5kQ29udGV4dChjYW52YXNBbmRDb250ZXh0KTtcbiAgICAgIHRleHR1cmUuZGVzdHJveSh0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5wYWdlcyA9IG51bGw7XG4gIH1cbn07XG5fRHluYW1pY0JpdG1hcEZvbnQuZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHRleHR1cmVTaXplOiA1MTIsXG4gIHN0eWxlOiBuZXcgVGV4dFN0eWxlKCksXG4gIG1pcG1hcDogdHJ1ZVxufTtcbmxldCBEeW5hbWljQml0bWFwRm9udCA9IF9EeW5hbWljQml0bWFwRm9udDtcblxuZXhwb3J0IHsgRHluYW1pY0JpdG1hcEZvbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUR5bmFtaWNCaXRtYXBGb250Lm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZ2V0Qml0bWFwVGV4dExheW91dChjaGFycywgc3R5bGUsIGZvbnQpIHtcbiAgY29uc3QgbGF5b3V0RGF0YSA9IHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgb2Zmc2V0WTogMCxcbiAgICBzY2FsZTogc3R5bGUuZm9udFNpemUgLyBmb250LmJhc2VNZWFzdXJlbWVudEZvbnRTaXplLFxuICAgIGxpbmVzOiBbe1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBjaGFyUG9zaXRpb25zOiBbXSxcbiAgICAgIHNwYWNlV2lkdGg6IDAsXG4gICAgICBzcGFjZXNJbmRleDogW10sXG4gICAgICBjaGFyczogW11cbiAgICB9XVxuICB9O1xuICBsYXlvdXREYXRhLm9mZnNldFkgPSBmb250LmJhc2VMaW5lT2Zmc2V0O1xuICBsZXQgY3VycmVudExpbmUgPSBsYXlvdXREYXRhLmxpbmVzWzBdO1xuICBsZXQgcHJldmlvdXNDaGFyID0gbnVsbDtcbiAgbGV0IGZpcnN0V29yZCA9IHRydWU7XG4gIGNvbnN0IGN1cnJlbnRXb3JkID0ge1xuICAgIHNwYWNlV29yZDogZmFsc2UsXG4gICAgd2lkdGg6IDAsXG4gICAgc3RhcnQ6IDAsXG4gICAgaW5kZXg6IDAsXG4gICAgLy8gdXNlIGluZGV4IHRvIG5vdCBtb2RpZnkgdGhlIGFycmF5IGFzIHdlIHVzZSBpdCBhIGxvdCFcbiAgICBwb3NpdGlvbnM6IFtdLFxuICAgIGNoYXJzOiBbXVxuICB9O1xuICBjb25zdCBuZXh0V29yZCA9ICh3b3JkKSA9PiB7XG4gICAgY29uc3Qgc3RhcnQgPSBjdXJyZW50TGluZS53aWR0aDtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGN1cnJlbnRXb3JkLmluZGV4OyBqKyspIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gd29yZC5wb3NpdGlvbnNbal07XG4gICAgICBjdXJyZW50TGluZS5jaGFycy5wdXNoKHdvcmQuY2hhcnNbal0pO1xuICAgICAgY3VycmVudExpbmUuY2hhclBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uICsgc3RhcnQpO1xuICAgIH1cbiAgICBjdXJyZW50TGluZS53aWR0aCArPSB3b3JkLndpZHRoO1xuICAgIGZpcnN0V29yZCA9IGZhbHNlO1xuICAgIGN1cnJlbnRXb3JkLndpZHRoID0gMDtcbiAgICBjdXJyZW50V29yZC5pbmRleCA9IDA7XG4gICAgY3VycmVudFdvcmQuY2hhcnMubGVuZ3RoID0gMDtcbiAgfTtcbiAgY29uc3QgbmV4dExpbmUgPSAoKSA9PiB7XG4gICAgbGV0IGluZGV4ID0gY3VycmVudExpbmUuY2hhcnMubGVuZ3RoIC0gMTtcbiAgICBsZXQgbGFzdENoYXIgPSBjdXJyZW50TGluZS5jaGFyc1tpbmRleF07XG4gICAgd2hpbGUgKGxhc3RDaGFyID09PSBcIiBcIikge1xuICAgICAgY3VycmVudExpbmUud2lkdGggLT0gZm9udC5jaGFyc1tsYXN0Q2hhcl0ueEFkdmFuY2U7XG4gICAgICBsYXN0Q2hhciA9IGN1cnJlbnRMaW5lLmNoYXJzWy0taW5kZXhdO1xuICAgIH1cbiAgICBsYXlvdXREYXRhLndpZHRoID0gTWF0aC5tYXgobGF5b3V0RGF0YS53aWR0aCwgY3VycmVudExpbmUud2lkdGgpO1xuICAgIGN1cnJlbnRMaW5lID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBjaGFyUG9zaXRpb25zOiBbXSxcbiAgICAgIGNoYXJzOiBbXSxcbiAgICAgIHNwYWNlV2lkdGg6IDAsXG4gICAgICBzcGFjZXNJbmRleDogW11cbiAgICB9O1xuICAgIGZpcnN0V29yZCA9IHRydWU7XG4gICAgbGF5b3V0RGF0YS5saW5lcy5wdXNoKGN1cnJlbnRMaW5lKTtcbiAgICBsYXlvdXREYXRhLmhlaWdodCArPSBmb250LmxpbmVIZWlnaHQ7XG4gIH07XG4gIGNvbnN0IHNjYWxlID0gZm9udC5iYXNlTWVhc3VyZW1lbnRGb250U2l6ZSAvIHN0eWxlLmZvbnRTaXplO1xuICBjb25zdCBhZGp1c3RlZExldHRlclNwYWNpbmcgPSBzdHlsZS5sZXR0ZXJTcGFjaW5nICogc2NhbGU7XG4gIGNvbnN0IGFkanVzdGVkV29yZFdyYXBXaWR0aCA9IHN0eWxlLndvcmRXcmFwV2lkdGggKiBzY2FsZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGggKyAxOyBpKyspIHtcbiAgICBsZXQgY2hhcjtcbiAgICBjb25zdCBpc0VuZCA9IGkgPT09IGNoYXJzLmxlbmd0aDtcbiAgICBpZiAoIWlzRW5kKSB7XG4gICAgICBjaGFyID0gY2hhcnNbaV07XG4gICAgfVxuICAgIGNvbnN0IGNoYXJEYXRhID0gZm9udC5jaGFyc1tjaGFyXSB8fCBmb250LmNoYXJzW1wiIFwiXTtcbiAgICBjb25zdCBpc1NwYWNlID0gLyg/OlxccykvLnRlc3QoY2hhcik7XG4gICAgY29uc3QgaXNXb3JkQnJlYWsgPSBpc1NwYWNlIHx8IGNoYXIgPT09IFwiXFxyXCIgfHwgY2hhciA9PT0gXCJcXG5cIiB8fCBpc0VuZDtcbiAgICBpZiAoaXNXb3JkQnJlYWspIHtcbiAgICAgIGNvbnN0IGFkZFdvcmRUb05leHRMaW5lID0gIWZpcnN0V29yZCAmJiBzdHlsZS53b3JkV3JhcCAmJiBjdXJyZW50TGluZS53aWR0aCArIGN1cnJlbnRXb3JkLndpZHRoIC0gYWRqdXN0ZWRMZXR0ZXJTcGFjaW5nID4gYWRqdXN0ZWRXb3JkV3JhcFdpZHRoO1xuICAgICAgaWYgKGFkZFdvcmRUb05leHRMaW5lKSB7XG4gICAgICAgIG5leHRMaW5lKCk7XG4gICAgICAgIG5leHRXb3JkKGN1cnJlbnRXb3JkKTtcbiAgICAgICAgaWYgKCFpc0VuZCkge1xuICAgICAgICAgIGN1cnJlbnRMaW5lLmNoYXJQb3NpdGlvbnMucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFdvcmQuc3RhcnQgPSBjdXJyZW50TGluZS53aWR0aDtcbiAgICAgICAgbmV4dFdvcmQoY3VycmVudFdvcmQpO1xuICAgICAgICBpZiAoIWlzRW5kKSB7XG4gICAgICAgICAgY3VycmVudExpbmUuY2hhclBvc2l0aW9ucy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2hhciA9PT0gXCJcXHJcIiB8fCBjaGFyID09PSBcIlxcblwiKSB7XG4gICAgICAgIGlmIChjdXJyZW50TGluZS53aWR0aCAhPT0gMCkge1xuICAgICAgICAgIG5leHRMaW5lKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzRW5kKSB7XG4gICAgICAgIGNvbnN0IHNwYWNlV2lkdGggPSBjaGFyRGF0YS54QWR2YW5jZSArIChjaGFyRGF0YS5rZXJuaW5nW3ByZXZpb3VzQ2hhcl0gfHwgMCkgKyBhZGp1c3RlZExldHRlclNwYWNpbmc7XG4gICAgICAgIGN1cnJlbnRMaW5lLndpZHRoICs9IHNwYWNlV2lkdGg7XG4gICAgICAgIGN1cnJlbnRMaW5lLnNwYWNlV2lkdGggPSBzcGFjZVdpZHRoO1xuICAgICAgICBjdXJyZW50TGluZS5zcGFjZXNJbmRleC5wdXNoKGN1cnJlbnRMaW5lLmNoYXJQb3NpdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgY3VycmVudExpbmUuY2hhcnMucHVzaChjaGFyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qga2VybmluZyA9IGNoYXJEYXRhLmtlcm5pbmdbcHJldmlvdXNDaGFyXSB8fCAwO1xuICAgICAgY29uc3QgbmV4dENoYXJXaWR0aCA9IGNoYXJEYXRhLnhBZHZhbmNlICsga2VybmluZyArIGFkanVzdGVkTGV0dGVyU3BhY2luZztcbiAgICAgIGN1cnJlbnRXb3JkLnBvc2l0aW9uc1tjdXJyZW50V29yZC5pbmRleCsrXSA9IGN1cnJlbnRXb3JkLndpZHRoICsga2VybmluZztcbiAgICAgIGN1cnJlbnRXb3JkLmNoYXJzLnB1c2goY2hhcik7XG4gICAgICBjdXJyZW50V29yZC53aWR0aCArPSBuZXh0Q2hhcldpZHRoO1xuICAgIH1cbiAgICBwcmV2aW91c0NoYXIgPSBjaGFyO1xuICB9XG4gIG5leHRMaW5lKCk7XG4gIGlmIChzdHlsZS5hbGlnbiA9PT0gXCJjZW50ZXJcIikge1xuICAgIGFsaWduQ2VudGVyKGxheW91dERhdGEpO1xuICB9IGVsc2UgaWYgKHN0eWxlLmFsaWduID09PSBcInJpZ2h0XCIpIHtcbiAgICBhbGlnblJpZ2h0KGxheW91dERhdGEpO1xuICB9IGVsc2UgaWYgKHN0eWxlLmFsaWduID09PSBcImp1c3RpZnlcIikge1xuICAgIGFsaWduSnVzdGlmeShsYXlvdXREYXRhKTtcbiAgfVxuICByZXR1cm4gbGF5b3V0RGF0YTtcbn1cbmZ1bmN0aW9uIGFsaWduQ2VudGVyKG1lYXN1cmVtZW50RGF0YSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1lYXN1cmVtZW50RGF0YS5saW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmUgPSBtZWFzdXJlbWVudERhdGEubGluZXNbaV07XG4gICAgY29uc3Qgb2Zmc2V0ID0gbWVhc3VyZW1lbnREYXRhLndpZHRoIC8gMiAtIGxpbmUud2lkdGggLyAyO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGluZS5jaGFyUG9zaXRpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICBsaW5lLmNoYXJQb3NpdGlvbnNbal0gKz0gb2Zmc2V0O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWxpZ25SaWdodChtZWFzdXJlbWVudERhdGEpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZWFzdXJlbWVudERhdGEubGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsaW5lID0gbWVhc3VyZW1lbnREYXRhLmxpbmVzW2ldO1xuICAgIGNvbnN0IG9mZnNldCA9IG1lYXN1cmVtZW50RGF0YS53aWR0aCAtIGxpbmUud2lkdGg7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lLmNoYXJQb3NpdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGxpbmUuY2hhclBvc2l0aW9uc1tqXSArPSBvZmZzZXQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhbGlnbkp1c3RpZnkobWVhc3VyZW1lbnREYXRhKSB7XG4gIGNvbnN0IHdpZHRoID0gbWVhc3VyZW1lbnREYXRhLndpZHRoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1lYXN1cmVtZW50RGF0YS5saW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmUgPSBtZWFzdXJlbWVudERhdGEubGluZXNbaV07XG4gICAgbGV0IGluZHkgPSAwO1xuICAgIGxldCBzcGFjZUluZGV4ID0gbGluZS5zcGFjZXNJbmRleFtpbmR5KytdO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGNvbnN0IHRvdGFsU3BhY2VzID0gbGluZS5zcGFjZXNJbmRleC5sZW5ndGg7XG4gICAgY29uc3QgbmV3U3BhY2VXaWR0aCA9ICh3aWR0aCAtIGxpbmUud2lkdGgpIC8gdG90YWxTcGFjZXM7XG4gICAgY29uc3Qgc3BhY2VXaWR0aCA9IG5ld1NwYWNlV2lkdGg7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lLmNoYXJQb3NpdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChqID09PSBzcGFjZUluZGV4KSB7XG4gICAgICAgIHNwYWNlSW5kZXggPSBsaW5lLnNwYWNlc0luZGV4W2luZHkrK107XG4gICAgICAgIG9mZnNldCArPSBzcGFjZVdpZHRoO1xuICAgICAgfVxuICAgICAgbGluZS5jaGFyUG9zaXRpb25zW2pdICs9IG9mZnNldDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgZ2V0Qml0bWFwVGV4dExheW91dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0Qml0bWFwVGV4dExheW91dC5tanMubWFwXG4iLCJpbXBvcnQgeyBDYWNoZSB9IGZyb20gJy4uLy4uL2Fzc2V0cy9jYWNoZS9DYWNoZS5tanMnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIHY4XzBfMCB9IGZyb20gJy4uLy4uL3V0aWxzL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcbmltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi8uLi91dGlscy9sb2dnaW5nL3dhcm4ubWpzJztcbmltcG9ydCB7IFRleHRTdHlsZSB9IGZyb20gJy4uL3RleHQvVGV4dFN0eWxlLm1qcyc7XG5pbXBvcnQgeyBEeW5hbWljQml0bWFwRm9udCB9IGZyb20gJy4vRHluYW1pY0JpdG1hcEZvbnQubWpzJztcbmltcG9ydCB7IGdldEJpdG1hcFRleHRMYXlvdXQgfSBmcm9tICcuL3V0aWxzL2dldEJpdG1hcFRleHRMYXlvdXQubWpzJztcbmltcG9ydCB7IHJlc29sdmVDaGFyYWN0ZXJzIH0gZnJvbSAnLi91dGlscy9yZXNvbHZlQ2hhcmFjdGVycy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmxldCBmb250Q291bnQgPSAwO1xuY2xhc3MgQml0bWFwRm9udE1hbmFnZXJDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgICAqIFRoaXMgY2hhcmFjdGVyIHNldCBpbmNsdWRlcyBhbGwgdGhlIGxldHRlcnMgaW4gdGhlIGFscGhhYmV0IChib3RoIGxvd2VyLSBhbmQgdXBwZXItIGNhc2UpLlxuICAgICAqIEB0eXBlIHtzdHJpbmdbXVtdfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogQml0bWFwRm9udC5mcm9tKCdFeGFtcGxlRm9udCcsIHN0eWxlLCB7IGNoYXJzOiBCaXRtYXBGb250LkFMUEhBIH0pXG4gICAgICovXG4gICAgdGhpcy5BTFBIQSA9IFtbXCJhXCIsIFwielwiXSwgW1wiQVwiLCBcIlpcIl0sIFwiIFwiXTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGNoYXJhY3RlciBzZXQgaW5jbHVkZXMgYWxsIGRlY2ltYWwgZGlnaXRzIChmcm9tIDAgdG8gOSkuXG4gICAgICogQHR5cGUge3N0cmluZ1tdW119XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBCaXRtYXBGb250LmZyb20oJ0V4YW1wbGVGb250Jywgc3R5bGUsIHsgY2hhcnM6IEJpdG1hcEZvbnQuTlVNRVJJQyB9KVxuICAgICAqL1xuICAgIHRoaXMuTlVNRVJJQyA9IFtbXCIwXCIsIFwiOVwiXV07XG4gICAgLyoqXG4gICAgICogVGhpcyBjaGFyYWN0ZXIgc2V0IGlzIHRoZSB1bmlvbiBvZiBgQml0bWFwRm9udC5BTFBIQWAgYW5kIGBCaXRtYXBGb250Lk5VTUVSSUNgLlxuICAgICAqIEB0eXBlIHtzdHJpbmdbXVtdfVxuICAgICAqL1xuICAgIHRoaXMuQUxQSEFOVU1FUklDID0gW1tcImFcIiwgXCJ6XCJdLCBbXCJBXCIsIFwiWlwiXSwgW1wiMFwiLCBcIjlcIl0sIFwiIFwiXTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGNoYXJhY3RlciBzZXQgY29uc2lzdHMgb2YgYWxsIHRoZSBBU0NJSSB0YWJsZS5cbiAgICAgKiBAbWVtYmVyIHtzdHJpbmdbXVtdfVxuICAgICAqIEBzZWUgaHR0cDovL3d3dy5hc2NpaXRhYmxlLmNvbS9cbiAgICAgKi9cbiAgICB0aGlzLkFTQ0lJID0gW1tcIiBcIiwgXCJ+XCJdXTtcbiAgICAvKiogRGVmYXVsdCBvcHRpb25zIGZvciBpbnN0YWxsaW5nIGEgbmV3IEJpdG1hcEZvbnQuICovXG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGNoYXJzOiB0aGlzLkFMUEhBTlVNRVJJQyxcbiAgICAgIHJlc29sdXRpb246IDEsXG4gICAgICBwYWRkaW5nOiA0LFxuICAgICAgc2tpcEtlcm5pbmc6IGZhbHNlXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgZm9udCBmb3IgdGhlIHNwZWNpZmllZCB0ZXh0IGFuZCBzdHlsZS5cbiAgICogQHBhcmFtIHRleHQgLSBUaGUgdGV4dCB0byBnZXQgdGhlIGZvbnQgZm9yXG4gICAqIEBwYXJhbSBzdHlsZSAtIFRoZSBzdHlsZSB0byB1c2VcbiAgICovXG4gIGdldEZvbnQodGV4dCwgc3R5bGUpIHtcbiAgICBsZXQgZm9udEZhbWlseUtleSA9IGAke3N0eWxlLmZvbnRGYW1pbHl9LWJpdG1hcGA7XG4gICAgbGV0IG92ZXJyaWRlRmlsbCA9IHRydWU7XG4gICAgaWYgKHN0eWxlLl9maWxsLmZpbGwgJiYgIXN0eWxlLl9zdHJva2UpIHtcbiAgICAgIGZvbnRGYW1pbHlLZXkgKz0gc3R5bGUuX2ZpbGwuZmlsbC5zdHlsZUtleTtcbiAgICAgIG92ZXJyaWRlRmlsbCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUuX3N0cm9rZSB8fCBzdHlsZS5kcm9wU2hhZG93KSB7XG4gICAgICBsZXQga2V5ID0gc3R5bGUuc3R5bGVLZXk7XG4gICAgICBrZXkgPSBrZXkuc3Vic3RyaW5nKDAsIGtleS5sYXN0SW5kZXhPZihcIi1cIikpO1xuICAgICAgZm9udEZhbWlseUtleSA9IGAke2tleX0tYml0bWFwYDtcbiAgICAgIG92ZXJyaWRlRmlsbCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIUNhY2hlLmhhcyhmb250RmFtaWx5S2V5KSkge1xuICAgICAgY29uc3QgZm50ID0gbmV3IER5bmFtaWNCaXRtYXBGb250KHtcbiAgICAgICAgc3R5bGUsXG4gICAgICAgIG92ZXJyaWRlRmlsbCxcbiAgICAgICAgb3ZlcnJpZGVTaXplOiB0cnVlLFxuICAgICAgICAuLi50aGlzLmRlZmF1bHRPcHRpb25zXG4gICAgICB9KTtcbiAgICAgIGZvbnRDb3VudCsrO1xuICAgICAgaWYgKGZvbnRDb3VudCA+IDUwKSB7XG4gICAgICAgIHdhcm4oXCJCaXRtYXBUZXh0XCIsIGBZb3UgaGF2ZSBkeW5hbWljYWxseSBjcmVhdGVkICR7Zm9udENvdW50fSBiaXRtYXAgZm9udHMsIHRoaXMgY2FuIGJlIGluZWZmaWNpZW50LiBUcnkgcHJlIGluc3RhbGxpbmcgeW91ciBmb250IHN0eWxlcyB1c2luZyBcXGBCaXRtYXBGb250Lmluc3RhbGwoe25hbWU6XCJzdHlsZTFcIiwgc3R5bGV9KVxcYGApO1xuICAgICAgfVxuICAgICAgZm50Lm9uY2UoXCJkZXN0cm95XCIsICgpID0+IHtcbiAgICAgICAgZm9udENvdW50LS07XG4gICAgICAgIENhY2hlLnJlbW92ZShmb250RmFtaWx5S2V5KTtcbiAgICAgIH0pO1xuICAgICAgQ2FjaGUuc2V0KFxuICAgICAgICBmb250RmFtaWx5S2V5LFxuICAgICAgICBmbnRcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGR5bmFtaWNGb250ID0gQ2FjaGUuZ2V0KGZvbnRGYW1pbHlLZXkpO1xuICAgIGR5bmFtaWNGb250LmVuc3VyZUNoYXJhY3RlcnM/Lih0ZXh0KTtcbiAgICByZXR1cm4gZHluYW1pY0ZvbnQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbGF5b3V0IG9mIGEgdGV4dCBmb3IgdGhlIHNwZWNpZmllZCBzdHlsZS5cbiAgICogQHBhcmFtIHRleHQgLSBUaGUgdGV4dCB0byBnZXQgdGhlIGxheW91dCBmb3JcbiAgICogQHBhcmFtIHN0eWxlIC0gVGhlIHN0eWxlIHRvIHVzZVxuICAgKi9cbiAgZ2V0TGF5b3V0KHRleHQsIHN0eWxlKSB7XG4gICAgY29uc3QgYml0bWFwRm9udCA9IHRoaXMuZ2V0Rm9udCh0ZXh0LCBzdHlsZSk7XG4gICAgcmV0dXJuIGdldEJpdG1hcFRleHRMYXlvdXQoWy4uLnRleHRdLCBzdHlsZSwgYml0bWFwRm9udCk7XG4gIH1cbiAgLyoqXG4gICAqIE1lYXN1cmUgdGhlIHRleHQgdXNpbmcgdGhlIHNwZWNpZmllZCBzdHlsZS5cbiAgICogQHBhcmFtIHRleHQgLSBUaGUgdGV4dCB0byBtZWFzdXJlXG4gICAqIEBwYXJhbSBzdHlsZSAtIFRoZSBzdHlsZSB0byB1c2VcbiAgICovXG4gIG1lYXN1cmVUZXh0KHRleHQsIHN0eWxlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF5b3V0KHRleHQsIHN0eWxlKTtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICBpbnN0YWxsKC4uLmFyZ3MpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3NbMF07XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBuYW1lOiBvcHRpb25zLFxuICAgICAgICBzdHlsZTogYXJnc1sxXSxcbiAgICAgICAgY2hhcnM6IGFyZ3NbMl0/LmNoYXJzLFxuICAgICAgICByZXNvbHV0aW9uOiBhcmdzWzJdPy5yZXNvbHV0aW9uLFxuICAgICAgICBwYWRkaW5nOiBhcmdzWzJdPy5wYWRkaW5nLFxuICAgICAgICBza2lwS2VybmluZzogYXJnc1syXT8uc2tpcEtlcm5pbmdcbiAgICAgIH07XG4gICAgICBkZXByZWNhdGlvbih2OF8wXzAsIFwiQml0bWFwRm9udE1hbmFnZXIuaW5zdGFsbChuYW1lLCBzdHlsZSwgb3B0aW9ucykgaXMgZGVwcmVjYXRlZCwgdXNlIEJpdG1hcEZvbnRNYW5hZ2VyLmluc3RhbGwoe25hbWUsIHN0eWxlLCAuLi5vcHRpb25zfSlcIik7XG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSBvcHRpb25zPy5uYW1lO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW0JpdG1hcEZvbnRNYW5hZ2VyXSBQcm9wZXJ0eSBgbmFtZWAgaXMgcmVxdWlyZWQuXCIpO1xuICAgIH1cbiAgICBvcHRpb25zID0geyAuLi50aGlzLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgY29uc3QgdGV4dFN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgICBjb25zdCBzdHlsZSA9IHRleHRTdHlsZSBpbnN0YW5jZW9mIFRleHRTdHlsZSA/IHRleHRTdHlsZSA6IG5ldyBUZXh0U3R5bGUodGV4dFN0eWxlKTtcbiAgICBjb25zdCBvdmVycmlkZUZpbGwgPSBzdHlsZS5fZmlsbC5maWxsICE9PSBudWxsICYmIHN0eWxlLl9maWxsLmZpbGwgIT09IHZvaWQgMDtcbiAgICBjb25zdCBmb250ID0gbmV3IER5bmFtaWNCaXRtYXBGb250KHtcbiAgICAgIHN0eWxlLFxuICAgICAgb3ZlcnJpZGVGaWxsLFxuICAgICAgc2tpcEtlcm5pbmc6IG9wdGlvbnMuc2tpcEtlcm5pbmcsXG4gICAgICBwYWRkaW5nOiBvcHRpb25zLnBhZGRpbmcsXG4gICAgICByZXNvbHV0aW9uOiBvcHRpb25zLnJlc29sdXRpb24sXG4gICAgICBvdmVycmlkZVNpemU6IGZhbHNlXG4gICAgfSk7XG4gICAgY29uc3QgZmxhdENoYXJzID0gcmVzb2x2ZUNoYXJhY3RlcnMob3B0aW9ucy5jaGFycyk7XG4gICAgZm9udC5lbnN1cmVDaGFyYWN0ZXJzKGZsYXRDaGFycy5qb2luKFwiXCIpKTtcbiAgICBDYWNoZS5zZXQoYCR7bmFtZX0tYml0bWFwYCwgZm9udCk7XG4gICAgZm9udC5vbmNlKFwiZGVzdHJveVwiLCAoKSA9PiBDYWNoZS5yZW1vdmUoYCR7bmFtZX0tYml0bWFwYCkpO1xuICAgIHJldHVybiBmb250O1xuICB9XG4gIC8qKlxuICAgKiBVbmluc3RhbGxzIGEgYml0bWFwIGZvbnQgZnJvbSB0aGUgY2FjaGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGJpdG1hcCBmb250IHRvIHVuaW5zdGFsbC5cbiAgICovXG4gIHVuaW5zdGFsbChuYW1lKSB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBgJHtuYW1lfS1iaXRtYXBgO1xuICAgIGNvbnN0IGZvbnQgPSBDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgIGlmIChmb250KSB7XG4gICAgICBDYWNoZS5yZW1vdmUoY2FjaGVLZXkpO1xuICAgICAgZm9udC5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59XG5jb25zdCBCaXRtYXBGb250TWFuYWdlciA9IG5ldyBCaXRtYXBGb250TWFuYWdlckNsYXNzKCk7XG5cbmV4cG9ydCB7IEJpdG1hcEZvbnRNYW5hZ2VyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CaXRtYXBGb250TWFuYWdlci5tanMubWFwXG4iLCJpbXBvcnQgeyBDYWNoZSB9IGZyb20gJy4uLy4uL2Fzc2V0cy9jYWNoZS9DYWNoZS5tanMnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgQmlnUG9vbCB9IGZyb20gJy4uLy4uL3V0aWxzL3Bvb2wvUG9vbEdyb3VwLm1qcyc7XG5pbXBvcnQgeyBHcmFwaGljcyB9IGZyb20gJy4uL2dyYXBoaWNzL3NoYXJlZC9HcmFwaGljcy5tanMnO1xuaW1wb3J0IHsgU2RmU2hhZGVyIH0gZnJvbSAnLi4vdGV4dC9zZGZTaGFkZXIvU2RmU2hhZGVyLm1qcyc7XG5pbXBvcnQgeyBCaXRtYXBGb250TWFuYWdlciB9IGZyb20gJy4vQml0bWFwRm9udE1hbmFnZXIubWpzJztcbmltcG9ydCB7IGdldEJpdG1hcFRleHRMYXlvdXQgfSBmcm9tICcuL3V0aWxzL2dldEJpdG1hcFRleHRMYXlvdXQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBCaXRtYXBUZXh0UGlwZSB7XG4gIC8vIHByaXZhdGUgX3NkZlNoYWRlcjogU2RmU2hhZGVyO1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMuX2dwdUJpdG1hcFRleHQgPSB7fTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIHZhbGlkYXRlUmVuZGVyYWJsZShiaXRtYXBUZXh0KSB7XG4gICAgY29uc3QgZ3JhcGhpY3NSZW5kZXJhYmxlID0gdGhpcy5fZ2V0R3B1Qml0bWFwVGV4dChiaXRtYXBUZXh0KTtcbiAgICBpZiAoYml0bWFwVGV4dC5fZGlkVGV4dFVwZGF0ZSkge1xuICAgICAgYml0bWFwVGV4dC5fZGlkVGV4dFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fdXBkYXRlQ29udGV4dChiaXRtYXBUZXh0LCBncmFwaGljc1JlbmRlcmFibGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIucmVuZGVyUGlwZXMuZ3JhcGhpY3MudmFsaWRhdGVSZW5kZXJhYmxlKGdyYXBoaWNzUmVuZGVyYWJsZSk7XG4gIH1cbiAgYWRkUmVuZGVyYWJsZShiaXRtYXBUZXh0LCBpbnN0cnVjdGlvblNldCkge1xuICAgIGNvbnN0IGdyYXBoaWNzUmVuZGVyYWJsZSA9IHRoaXMuX2dldEdwdUJpdG1hcFRleHQoYml0bWFwVGV4dCk7XG4gICAgc3luY1dpdGhQcm94eShiaXRtYXBUZXh0LCBncmFwaGljc1JlbmRlcmFibGUpO1xuICAgIGlmIChiaXRtYXBUZXh0Ll9kaWRUZXh0VXBkYXRlKSB7XG4gICAgICBiaXRtYXBUZXh0Ll9kaWRUZXh0VXBkYXRlID0gZmFsc2U7XG4gICAgICB0aGlzLl91cGRhdGVDb250ZXh0KGJpdG1hcFRleHQsIGdyYXBoaWNzUmVuZGVyYWJsZSk7XG4gICAgfVxuICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzLmdyYXBoaWNzLmFkZFJlbmRlcmFibGUoZ3JhcGhpY3NSZW5kZXJhYmxlLCBpbnN0cnVjdGlvblNldCk7XG4gICAgaWYgKGdyYXBoaWNzUmVuZGVyYWJsZS5jb250ZXh0LmN1c3RvbVNoYWRlcikge1xuICAgICAgdGhpcy5fdXBkYXRlRGlzdGFuY2VGaWVsZChiaXRtYXBUZXh0KTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveVJlbmRlcmFibGUoYml0bWFwVGV4dCkge1xuICAgIHRoaXMuX2Rlc3Ryb3lSZW5kZXJhYmxlQnlVaWQoYml0bWFwVGV4dC51aWQpO1xuICB9XG4gIF9kZXN0cm95UmVuZGVyYWJsZUJ5VWlkKHJlbmRlcmFibGVVaWQpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5fZ3B1Qml0bWFwVGV4dFtyZW5kZXJhYmxlVWlkXS5jb250ZXh0O1xuICAgIGlmIChjb250ZXh0LmN1c3RvbVNoYWRlcikge1xuICAgICAgQmlnUG9vbC5yZXR1cm4oY29udGV4dC5jdXN0b21TaGFkZXIpO1xuICAgICAgY29udGV4dC5jdXN0b21TaGFkZXIgPSBudWxsO1xuICAgIH1cbiAgICBCaWdQb29sLnJldHVybih0aGlzLl9ncHVCaXRtYXBUZXh0W3JlbmRlcmFibGVVaWRdKTtcbiAgICB0aGlzLl9ncHVCaXRtYXBUZXh0W3JlbmRlcmFibGVVaWRdID0gbnVsbDtcbiAgfVxuICB1cGRhdGVSZW5kZXJhYmxlKGJpdG1hcFRleHQpIHtcbiAgICBjb25zdCBncmFwaGljc1JlbmRlcmFibGUgPSB0aGlzLl9nZXRHcHVCaXRtYXBUZXh0KGJpdG1hcFRleHQpO1xuICAgIHN5bmNXaXRoUHJveHkoYml0bWFwVGV4dCwgZ3JhcGhpY3NSZW5kZXJhYmxlKTtcbiAgICB0aGlzLl9yZW5kZXJlci5yZW5kZXJQaXBlcy5ncmFwaGljcy51cGRhdGVSZW5kZXJhYmxlKGdyYXBoaWNzUmVuZGVyYWJsZSk7XG4gICAgaWYgKGdyYXBoaWNzUmVuZGVyYWJsZS5jb250ZXh0LmN1c3RvbVNoYWRlcikge1xuICAgICAgdGhpcy5fdXBkYXRlRGlzdGFuY2VGaWVsZChiaXRtYXBUZXh0KTtcbiAgICB9XG4gIH1cbiAgX3VwZGF0ZUNvbnRleHQoYml0bWFwVGV4dCwgcHJveHlHcmFwaGljcykge1xuICAgIGNvbnN0IHsgY29udGV4dCB9ID0gcHJveHlHcmFwaGljcztcbiAgICBjb25zdCBiaXRtYXBGb250ID0gQml0bWFwRm9udE1hbmFnZXIuZ2V0Rm9udChiaXRtYXBUZXh0LnRleHQsIGJpdG1hcFRleHQuX3N0eWxlKTtcbiAgICBjb250ZXh0LmNsZWFyKCk7XG4gICAgaWYgKGJpdG1hcEZvbnQuZGlzdGFuY2VGaWVsZC50eXBlICE9PSBcIm5vbmVcIikge1xuICAgICAgaWYgKCFjb250ZXh0LmN1c3RvbVNoYWRlcikge1xuICAgICAgICBjb250ZXh0LmN1c3RvbVNoYWRlciA9IEJpZ1Bvb2wuZ2V0KFNkZlNoYWRlcik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNoYXJzID0gQXJyYXkuZnJvbShiaXRtYXBUZXh0LnRleHQpO1xuICAgIGNvbnN0IHN0eWxlID0gYml0bWFwVGV4dC5fc3R5bGU7XG4gICAgbGV0IGN1cnJlbnRZID0gYml0bWFwRm9udC5iYXNlTGluZU9mZnNldDtcbiAgICBjb25zdCBiaXRtYXBUZXh0TGF5b3V0ID0gZ2V0Qml0bWFwVGV4dExheW91dChjaGFycywgc3R5bGUsIGJpdG1hcEZvbnQpO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgY29uc3QgcGFkZGluZyA9IHN0eWxlLnBhZGRpbmc7XG4gICAgY29uc3Qgc2NhbGUgPSBiaXRtYXBUZXh0TGF5b3V0LnNjYWxlO1xuICAgIGxldCB0eCA9IGJpdG1hcFRleHRMYXlvdXQud2lkdGg7XG4gICAgbGV0IHR5ID0gYml0bWFwVGV4dExheW91dC5oZWlnaHQgKyBiaXRtYXBUZXh0TGF5b3V0Lm9mZnNldFk7XG4gICAgaWYgKHN0eWxlLl9zdHJva2UpIHtcbiAgICAgIHR4ICs9IHN0eWxlLl9zdHJva2Uud2lkdGggLyBzY2FsZTtcbiAgICAgIHR5ICs9IHN0eWxlLl9zdHJva2Uud2lkdGggLyBzY2FsZTtcbiAgICB9XG4gICAgY29udGV4dC50cmFuc2xhdGUoLWJpdG1hcFRleHQuX2FuY2hvci5feCAqIHR4IC0gcGFkZGluZywgLWJpdG1hcFRleHQuX2FuY2hvci5feSAqIHR5IC0gcGFkZGluZykuc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICBjb25zdCB0aW50ID0gYml0bWFwRm9udC5hcHBseUZpbGxBc1RpbnQgPyBzdHlsZS5fZmlsbC5jb2xvciA6IDE2Nzc3MjE1O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYml0bWFwVGV4dExheW91dC5saW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGluZSA9IGJpdG1hcFRleHRMYXlvdXQubGluZXNbaV07XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmUuY2hhclBvc2l0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBjaGFyID0gY2hhcnNbaW5kZXgrK107XG4gICAgICAgIGNvbnN0IGNoYXJEYXRhID0gYml0bWFwRm9udC5jaGFyc1tjaGFyXTtcbiAgICAgICAgaWYgKGNoYXJEYXRhPy50ZXh0dXJlKSB7XG4gICAgICAgICAgY29udGV4dC50ZXh0dXJlKFxuICAgICAgICAgICAgY2hhckRhdGEudGV4dHVyZSxcbiAgICAgICAgICAgIHRpbnQgPyB0aW50IDogXCJibGFja1wiLFxuICAgICAgICAgICAgTWF0aC5yb3VuZChsaW5lLmNoYXJQb3NpdGlvbnNbal0gKyBjaGFyRGF0YS54T2Zmc2V0KSxcbiAgICAgICAgICAgIE1hdGgucm91bmQoY3VycmVudFkgKyBjaGFyRGF0YS55T2Zmc2V0KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN1cnJlbnRZICs9IGJpdG1hcEZvbnQubGluZUhlaWdodDtcbiAgICB9XG4gIH1cbiAgX2dldEdwdUJpdG1hcFRleHQoYml0bWFwVGV4dCkge1xuICAgIHJldHVybiB0aGlzLl9ncHVCaXRtYXBUZXh0W2JpdG1hcFRleHQudWlkXSB8fCB0aGlzLmluaXRHcHVUZXh0KGJpdG1hcFRleHQpO1xuICB9XG4gIGluaXRHcHVUZXh0KGJpdG1hcFRleHQpIHtcbiAgICBjb25zdCBwcm94eVJlbmRlcmFibGUgPSBCaWdQb29sLmdldChHcmFwaGljcyk7XG4gICAgdGhpcy5fZ3B1Qml0bWFwVGV4dFtiaXRtYXBUZXh0LnVpZF0gPSBwcm94eVJlbmRlcmFibGU7XG4gICAgdGhpcy5fdXBkYXRlQ29udGV4dChiaXRtYXBUZXh0LCBwcm94eVJlbmRlcmFibGUpO1xuICAgIGJpdG1hcFRleHQub24oXCJkZXN0cm95ZWRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5kZXN0cm95UmVuZGVyYWJsZShiaXRtYXBUZXh0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fZ3B1Qml0bWFwVGV4dFtiaXRtYXBUZXh0LnVpZF07XG4gIH1cbiAgX3VwZGF0ZURpc3RhbmNlRmllbGQoYml0bWFwVGV4dCkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9nZXRHcHVCaXRtYXBUZXh0KGJpdG1hcFRleHQpLmNvbnRleHQ7XG4gICAgY29uc3QgZm9udEZhbWlseSA9IGJpdG1hcFRleHQuX3N0eWxlLmZvbnRGYW1pbHk7XG4gICAgY29uc3QgZHluYW1pY0ZvbnQgPSBDYWNoZS5nZXQoYCR7Zm9udEZhbWlseX0tYml0bWFwYCk7XG4gICAgY29uc3QgeyBhLCBiLCBjLCBkIH0gPSBiaXRtYXBUZXh0Lmdyb3VwVHJhbnNmb3JtO1xuICAgIGNvbnN0IGR4ID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICAgIGNvbnN0IGR5ID0gTWF0aC5zcXJ0KGMgKiBjICsgZCAqIGQpO1xuICAgIGNvbnN0IHdvcmxkU2NhbGUgPSAoTWF0aC5hYnMoZHgpICsgTWF0aC5hYnMoZHkpKSAvIDI7XG4gICAgY29uc3QgZm9udFNjYWxlID0gZHluYW1pY0ZvbnQuYmFzZVJlbmRlcmVkRm9udFNpemUgLyBiaXRtYXBUZXh0Ll9zdHlsZS5mb250U2l6ZTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IHdvcmxkU2NhbGUgKiBkeW5hbWljRm9udC5kaXN0YW5jZUZpZWxkLnJhbmdlICogKDEgLyBmb250U2NhbGUpO1xuICAgIGNvbnRleHQuY3VzdG9tU2hhZGVyLnJlc291cmNlcy5sb2NhbFVuaWZvcm1zLnVuaWZvcm1zLnVEaXN0YW5jZSA9IGRpc3RhbmNlO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCB1aWQgaW4gdGhpcy5fZ3B1Qml0bWFwVGV4dCkge1xuICAgICAgdGhpcy5fZGVzdHJveVJlbmRlcmFibGVCeVVpZCh1aWQpO1xuICAgIH1cbiAgICB0aGlzLl9ncHVCaXRtYXBUZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5CaXRtYXBUZXh0UGlwZS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1BpcGVzXG4gIF0sXG4gIG5hbWU6IFwiYml0bWFwVGV4dFwiXG59O1xuZnVuY3Rpb24gc3luY1dpdGhQcm94eShjb250YWluZXIsIHByb3h5KSB7XG4gIHByb3h5Lmdyb3VwVHJhbnNmb3JtID0gY29udGFpbmVyLmdyb3VwVHJhbnNmb3JtO1xuICBwcm94eS5ncm91cENvbG9yQWxwaGEgPSBjb250YWluZXIuZ3JvdXBDb2xvckFscGhhO1xuICBwcm94eS5ncm91cENvbG9yID0gY29udGFpbmVyLmdyb3VwQ29sb3I7XG4gIHByb3h5Lmdyb3VwQmxlbmRNb2RlID0gY29udGFpbmVyLmdyb3VwQmxlbmRNb2RlO1xuICBwcm94eS5nbG9iYWxEaXNwbGF5U3RhdHVzID0gY29udGFpbmVyLmdsb2JhbERpc3BsYXlTdGF0dXM7XG4gIHByb3h5Lmdyb3VwVHJhbnNmb3JtID0gY29udGFpbmVyLmdyb3VwVHJhbnNmb3JtO1xuICBwcm94eS5sb2NhbERpc3BsYXlTdGF0dXMgPSBjb250YWluZXIubG9jYWxEaXNwbGF5U3RhdHVzO1xuICBwcm94eS5ncm91cEFscGhhID0gY29udGFpbmVyLmdyb3VwQWxwaGE7XG4gIHByb3h5Ll9yb3VuZFBpeGVscyA9IGNvbnRhaW5lci5fcm91bmRQaXhlbHM7XG59XG5cbmV4cG9ydCB7IEJpdG1hcFRleHRQaXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CaXRtYXBUZXh0UGlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBleHRlbnNpb25zIH0gZnJvbSAnLi4vLi4vZXh0ZW5zaW9ucy9FeHRlbnNpb25zLm1qcyc7XG5pbXBvcnQgeyBCaXRtYXBUZXh0UGlwZSB9IGZyb20gJy4vQml0bWFwVGV4dFBpcGUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5leHRlbnNpb25zLmFkZChCaXRtYXBUZXh0UGlwZSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///928\n')},7900:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(4240);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs + 2 modules\nvar Texture = __webpack_require__(8518);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs\nvar updateQuadBounds = __webpack_require__(1080);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(2540);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs\nvar BatchableSprite = __webpack_require__(3976);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs\n\n\n\n\n\n\n"use strict";\nclass HTMLTextPipe {\n  constructor(renderer) {\n    this._gpuText = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    this._renderer.runners.resolutionChange.add(this);\n  }\n  resolutionChange() {\n    for (const i in this._gpuText) {\n      const gpuText = this._gpuText[i];\n      const text = gpuText.batchableSprite.renderable;\n      if (text._autoResolution) {\n        text._resolution = this._renderer.resolution;\n        text.onViewUpdate();\n      }\n    }\n  }\n  validateRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const newKey = htmlText._getKey();\n    if (gpuText.textureNeedsUploading) {\n      gpuText.textureNeedsUploading = false;\n      return true;\n    }\n    if (gpuText.currentKey !== newKey) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(htmlText, _instructionSet) {\n    const gpuText = this._getGpuText(htmlText);\n    const batchableSprite = gpuText.batchableSprite;\n    if (htmlText._didTextUpdate) {\n      this._updateText(htmlText);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n  }\n  updateRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const batchableSprite = gpuText.batchableSprite;\n    if (htmlText._didTextUpdate) {\n      this._updateText(htmlText);\n    }\n    batchableSprite.batcher.updateElement(batchableSprite);\n  }\n  destroyRenderable(htmlText) {\n    this._destroyRenderableById(htmlText.uid);\n  }\n  _destroyRenderableById(htmlTextUid) {\n    const gpuText = this._gpuText[htmlTextUid];\n    this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n    PoolGroup/* BigPool */.u.return(gpuText.batchableSprite);\n    this._gpuText[htmlTextUid] = null;\n  }\n  _updateText(htmlText) {\n    const newKey = htmlText._getKey();\n    const gpuText = this._getGpuText(htmlText);\n    const batchableSprite = gpuText.batchableSprite;\n    if (gpuText.currentKey !== newKey) {\n      this._updateGpuText(htmlText).catch((e) => {\n        console.error(e);\n      });\n    }\n    htmlText._didTextUpdate = false;\n    const padding = htmlText._style.padding;\n    (0,updateQuadBounds/* updateQuadBounds */.Q)(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n  }\n  async _updateGpuText(htmlText) {\n    htmlText._didTextUpdate = false;\n    const gpuText = this._getGpuText(htmlText);\n    if (gpuText.generatingTexture)\n      return;\n    const newKey = htmlText._getKey();\n    this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n    gpuText.generatingTexture = true;\n    gpuText.currentKey = newKey;\n    const resolution = htmlText.resolution ?? this._renderer.resolution;\n    const texture = await this._renderer.htmlText.getManagedTexture(\n      htmlText.text,\n      resolution,\n      htmlText._style,\n      htmlText._getKey()\n    );\n    const batchableSprite = gpuText.batchableSprite;\n    batchableSprite.texture = gpuText.texture = texture;\n    gpuText.generatingTexture = false;\n    gpuText.textureNeedsUploading = true;\n    htmlText.onViewUpdate();\n    const padding = htmlText._style.padding;\n    (0,updateQuadBounds/* updateQuadBounds */.Q)(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n  }\n  _getGpuText(htmlText) {\n    return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);\n  }\n  initGpuText(htmlText) {\n    const gpuTextData = {\n      texture: Texture/* Texture */.w.EMPTY,\n      currentKey: "--",\n      batchableSprite: PoolGroup/* BigPool */.u.get(BatchableSprite/* BatchableSprite */.a),\n      textureNeedsUploading: false,\n      generatingTexture: false\n    };\n    const batchableSprite = gpuTextData.batchableSprite;\n    batchableSprite.renderable = htmlText;\n    batchableSprite.texture = Texture/* Texture */.w.EMPTY;\n    batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    batchableSprite.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;\n    htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n    this._gpuText[htmlText.uid] = gpuTextData;\n    htmlText.on("destroyed", () => {\n      this.destroyRenderable(htmlText);\n    });\n    return gpuTextData;\n  }\n  destroy() {\n    for (const i in this._gpuText) {\n      this._destroyRenderableById(i);\n    }\n    this._gpuText = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nHTMLTextPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.y6.WebGLPipes,\n    Extensions/* ExtensionType */.y6.WebGPUPipes,\n    Extensions/* ExtensionType */.y6.CanvasPipes\n  ],\n  name: "htmlText"\n};\n\n\n//# sourceMappingURL=HTMLTextPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs\nvar TexturePool = __webpack_require__(6899);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/types.mjs\nvar types = __webpack_require__(8640);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/environment/adapter.mjs + 1 modules\nvar adapter = __webpack_require__(184);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/browser/isSafari.mjs\n\n\n"use strict";\nfunction isSafari() {\n  const { userAgent } = adapter/* DOMAdapter */.m.get().getNavigator();\n  return /^((?!chrome|android).)*safari/i.test(userAgent);\n}\n\n\n//# sourceMappingURL=isSafari.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/warn.mjs\nvar warn = __webpack_require__(8796);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs\nvar getPo2TextureFromSource = __webpack_require__(7080);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs\n\nconst nssvg = "http://www.w3.org/2000/svg";\nconst nsxhtml = "http://www.w3.org/1999/xhtml";\nclass HTMLTextRenderData {\n  constructor() {\n    this.svgRoot = document.createElementNS(nssvg, "svg");\n    this.foreignObject = document.createElementNS(nssvg, "foreignObject");\n    this.domElement = document.createElementNS(nsxhtml, "div");\n    this.styleElement = document.createElementNS(nsxhtml, "style");\n    this.image = new Image();\n    const { foreignObject, svgRoot, styleElement, domElement } = this;\n    foreignObject.setAttribute("width", "10000");\n    foreignObject.setAttribute("height", "10000");\n    foreignObject.style.overflow = "hidden";\n    svgRoot.appendChild(foreignObject);\n    foreignObject.appendChild(styleElement);\n    foreignObject.appendChild(domElement);\n  }\n}\n\n\n//# sourceMappingURL=HTMLTextRenderData.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/TextStyle.mjs\nvar TextStyle = __webpack_require__(9920);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs\nvar generateTextStyleKey = __webpack_require__(5040);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(5536);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.mjs\n\n\n"use strict";\nfunction textStyleToCSS(style) {\n  const stroke = style._stroke;\n  const fill = style._fill;\n  const cssStyleString = [\n    `color: ${Color/* Color */.g.shared.setValue(fill.color).toHex()}`,\n    `font-size: ${style.fontSize}px`,\n    `font-family: ${style.fontFamily}`,\n    `font-weight: ${style.fontWeight}`,\n    `font-style: ${style.fontStyle}`,\n    `font-variant: ${style.fontVariant}`,\n    `letter-spacing: ${style.letterSpacing}px`,\n    `text-align: ${style.align}`,\n    `padding: ${style.padding}px`,\n    `white-space: ${style.whiteSpace === "pre" && style.wordWrap ? "pre-wrap" : style.whiteSpace}`,\n    ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],\n    ...style.wordWrap ? [\n      `word-wrap: ${style.breakWords ? "break-all" : "break-word"}`,\n      `max-width: ${style.wordWrapWidth}px`\n    ] : [],\n    ...stroke ? [strokeToCSS(stroke)] : [],\n    ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],\n    ...style.cssOverrides\n  ].join(";");\n  const cssStyles = [`div { ${cssStyleString} }`];\n  tagStyleToCSS(style.tagStyles, cssStyles);\n  return cssStyles.join(" ");\n}\nfunction dropShadowToCSS(dropShadowStyle) {\n  const color = Color/* Color */.g.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();\n  const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);\n  const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);\n  const position = `${x}px ${y}px`;\n  if (dropShadowStyle.blur > 0) {\n    return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;\n  }\n  return `text-shadow: ${position} ${color}`;\n}\nfunction strokeToCSS(stroke) {\n  return [\n    `-webkit-text-stroke-width: ${stroke.width}px`,\n    `-webkit-text-stroke-color: ${Color/* Color */.g.shared.setValue(stroke.color).toHex()}`,\n    `text-stroke-width: ${stroke.width}px`,\n    `text-stroke-color: ${Color/* Color */.g.shared.setValue(stroke.color).toHex()}`,\n    "paint-order: stroke"\n  ].join(";");\n}\nconst templates = {\n  fontSize: `font-size: {{VALUE}}px`,\n  fontFamily: `font-family: {{VALUE}}`,\n  fontWeight: `font-weight: {{VALUE}}`,\n  fontStyle: `font-style: {{VALUE}}`,\n  fontVariant: `font-variant: {{VALUE}}`,\n  letterSpacing: `letter-spacing: {{VALUE}}px`,\n  align: `text-align: {{VALUE}}`,\n  padding: `padding: {{VALUE}}px`,\n  whiteSpace: `white-space: {{VALUE}}`,\n  lineHeight: `line-height: {{VALUE}}px`,\n  wordWrapWidth: `max-width: {{VALUE}}px`\n};\nconst transform = {\n  fill: (value) => `color: ${Color/* Color */.g.shared.setValue(value).toHex()}`,\n  breakWords: (value) => `word-wrap: ${value ? "break-all" : "break-word"}`,\n  stroke: strokeToCSS,\n  dropShadow: dropShadowToCSS\n};\nfunction tagStyleToCSS(tagStyles, out) {\n  for (const i in tagStyles) {\n    const tagStyle = tagStyles[i];\n    const cssTagStyle = [];\n    for (const j in tagStyle) {\n      if (transform[j]) {\n        cssTagStyle.push(transform[j](tagStyle[j]));\n      } else if (templates[j]) {\n        cssTagStyle.push(templates[j].replace("{{VALUE}}", tagStyle[j]));\n      }\n    }\n    out.push(`${i} { ${cssTagStyle.join(";")} }`);\n  }\n}\n\n\n//# sourceMappingURL=textStyleToCSS.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/HtmlTextStyle.mjs\n\n\n\n\n\n"use strict";\nclass HTMLTextStyle extends TextStyle/* TextStyle */.I {\n  constructor(options = {}) {\n    super(options);\n    this._cssOverrides = [];\n    this.cssOverrides ?? (this.cssOverrides = options.cssOverrides);\n    this.tagStyles = options.tagStyles ?? {};\n  }\n  /** List of style overrides that will be applied to the HTML text. */\n  set cssOverrides(value) {\n    this._cssOverrides = value instanceof Array ? value : [value];\n    this.update();\n  }\n  get cssOverrides() {\n    return this._cssOverrides;\n  }\n  _generateKey() {\n    this._styleKey = (0,generateTextStyleKey/* generateTextStyleKey */.Y)(this) + this._cssOverrides.join("-");\n    return this._styleKey;\n  }\n  update() {\n    this._cssStyle = null;\n    super.update();\n  }\n  /**\n   * Creates a new HTMLTextStyle object with the same values as this one.\n   * @returns New cloned HTMLTextStyle object\n   */\n  clone() {\n    return new HTMLTextStyle({\n      align: this.align,\n      breakWords: this.breakWords,\n      dropShadow: this.dropShadow ? { ...this.dropShadow } : null,\n      fill: this._fill,\n      fontFamily: this.fontFamily,\n      fontSize: this.fontSize,\n      fontStyle: this.fontStyle,\n      fontVariant: this.fontVariant,\n      fontWeight: this.fontWeight,\n      letterSpacing: this.letterSpacing,\n      lineHeight: this.lineHeight,\n      padding: this.padding,\n      stroke: this._stroke,\n      whiteSpace: this.whiteSpace,\n      wordWrap: this.wordWrap,\n      wordWrapWidth: this.wordWrapWidth,\n      cssOverrides: this.cssOverrides\n    });\n  }\n  get cssStyle() {\n    if (!this._cssStyle) {\n      this._cssStyle = textStyleToCSS(this);\n    }\n    return this._cssStyle;\n  }\n  /**\n   * Add a style override, this can be any CSS property\n   * it will override any built-in style. This is the\n   * property and the value as a string (e.g., `color: red`).\n   * This will override any other internal style.\n   * @param {string} value - CSS style(s) to add.\n   * @example\n   * style.addOverride(\'background-color: red\');\n   */\n  addOverride(...value) {\n    const toAdd = value.filter((v) => !this.cssOverrides.includes(v));\n    if (toAdd.length > 0) {\n      this.cssOverrides.push(...toAdd);\n      this.update();\n    }\n  }\n  /**\n   * Remove any overrides that match the value.\n   * @param {string} value - CSS style to remove.\n   * @example\n   * style.removeOverride(\'background-color: red\');\n   */\n  removeOverride(...value) {\n    const toRemove = value.filter((v) => this.cssOverrides.includes(v));\n    if (toRemove.length > 0) {\n      this.cssOverrides = this.cssOverrides.filter((v) => !toRemove.includes(v));\n      this.update();\n    }\n  }\n  set fill(value) {\n    if (typeof value !== "string" && typeof value !== "number") {\n      (0,warn/* warn */.m)("[HTMLTextStyle] only color fill is not supported by HTMLText");\n    }\n    super.fill = value;\n  }\n  set stroke(value) {\n    if (value && typeof value !== "string" && typeof value !== "number") {\n      (0,warn/* warn */.m)("[HTMLTextStyle] only color stroke is not supported by HTMLText");\n    }\n    super.stroke = value;\n  }\n}\n\n\n//# sourceMappingURL=HtmlTextStyle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs\n\nfunction extractFontFamilies(text, style) {\n  const fontFamily = style.fontFamily;\n  const fontFamilies = [];\n  const dedupe = {};\n  const regex = /font-family:([^;"\\s]+)/g;\n  const matches = text.match(regex);\n  function addFontFamily(fontFamily2) {\n    if (!dedupe[fontFamily2]) {\n      fontFamilies.push(fontFamily2);\n      dedupe[fontFamily2] = true;\n    }\n  }\n  if (Array.isArray(fontFamily)) {\n    for (let i = 0; i < fontFamily.length; i++) {\n      addFontFamily(fontFamily[i]);\n    }\n  } else {\n    addFontFamily(fontFamily);\n  }\n  if (matches) {\n    matches.forEach((match) => {\n      const fontFamily2 = match.split(":")[1].trim();\n      addFontFamily(fontFamily2);\n    });\n  }\n  for (const i in style.tagStyles) {\n    const fontFamily2 = style.tagStyles[i].fontFamily;\n    addFontFamily(fontFamily2);\n  }\n  return fontFamilies;\n}\n\n\n//# sourceMappingURL=extractFontFamilies.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/assets/cache/Cache.mjs\nvar Cache = __webpack_require__(5288);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs\n\n\n"use strict";\nasync function loadFontAsBase64(url) {\n  const response = await adapter/* DOMAdapter */.m.get().fetch(url);\n  const blob = await response.blob();\n  const reader = new FileReader();\n  const dataSrc = await new Promise((resolve, reject) => {\n    reader.onloadend = () => resolve(reader.result);\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n  return dataSrc;\n}\n\n\n//# sourceMappingURL=loadFontAsBase64.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs\n\n\n"use strict";\nasync function loadFontCSS(style, url) {\n  const dataSrc = await loadFontAsBase64(url);\n  return `@font-face {\n        font-family: "${style.fontFamily}";\n        src: url(\'${dataSrc}\');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n\n\n//# sourceMappingURL=loadFontCSS.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs\n\n\n\n"use strict";\nconst FontStylePromiseCache = /* @__PURE__ */ new Map();\nasync function getFontCss(fontFamilies, style, defaultOptions) {\n  const fontPromises = fontFamilies.filter((fontFamily) => Cache/* Cache */.u.has(`${fontFamily}-and-url`)).map((fontFamily, i) => {\n    if (!FontStylePromiseCache.has(fontFamily)) {\n      const { url } = Cache/* Cache */.u.get(`${fontFamily}-and-url`);\n      if (i === 0) {\n        FontStylePromiseCache.set(fontFamily, loadFontCSS({\n          fontWeight: style.fontWeight,\n          fontStyle: style.fontStyle,\n          fontFamily\n        }, url));\n      } else {\n        FontStylePromiseCache.set(fontFamily, loadFontCSS({\n          fontWeight: defaultOptions.fontWeight,\n          fontStyle: defaultOptions.fontStyle,\n          fontFamily\n        }, url));\n      }\n    }\n    return FontStylePromiseCache.get(fontFamily);\n  });\n  return (await Promise.all(fontPromises)).join("\\n");\n}\n\n\n//# sourceMappingURL=getFontCss.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs\n\nfunction getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {\n  const { domElement, styleElement, svgRoot } = htmlTextData;\n  domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n  domElement.setAttribute("style", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n  styleElement.textContent = fontCSS;\n  const { width, height } = htmlTextData.image;\n  svgRoot.setAttribute("width", width.toString());\n  svgRoot.setAttribute("height", height.toString());\n  return new XMLSerializer().serializeToString(svgRoot);\n}\n\n\n//# sourceMappingURL=getSVGUrl.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs\nvar CanvasPool = __webpack_require__(8168);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs\n\n\n"use strict";\nfunction getTemporaryCanvasFromImage(image, resolution) {\n  const canvasAndContext = CanvasPool/* CanvasPool */.G.getOptimalCanvasAndContext(\n    image.width,\n    image.height,\n    resolution\n  );\n  const { context } = canvasAndContext;\n  context.clearRect(0, 0, image.width, image.height);\n  context.drawImage(image, 0, 0);\n  CanvasPool/* CanvasPool */.G.returnCanvasAndContext(canvasAndContext);\n  return canvasAndContext.canvas;\n}\n\n\n//# sourceMappingURL=getTemporaryCanvasFromImage.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs\n\nfunction loadSVGImage(image, url, delay) {\n  return new Promise(async (resolve) => {\n    if (delay) {\n      await new Promise((resolve2) => setTimeout(resolve2, 100));\n    }\n    image.onload = () => {\n      resolve();\n    };\n    image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n    image.crossOrigin = "anonymous";\n  });\n}\n\n\n//# sourceMappingURL=loadSVGImage.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs\nvar CanvasTextMetrics = __webpack_require__(3768);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs\n\n\n\n"use strict";\nlet tempHTMLTextRenderData;\nfunction measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {\n  htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n  const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n  domElement.innerHTML = `<style>${style.cssStyle}</style><div>${text}</div>`;\n  domElement.setAttribute("style", "transform-origin: top left; display: inline-block");\n  if (fontStyleCSS) {\n    styleElement.textContent = fontStyleCSS;\n  }\n  document.body.appendChild(svgRoot);\n  const contentBounds = domElement.getBoundingClientRect();\n  svgRoot.remove();\n  const descenderPadding = CanvasTextMetrics/* CanvasTextMetrics */.y.measureFont(style.fontStyle).descent;\n  return {\n    width: contentBounds.width,\n    height: contentBounds.height + descenderPadding\n  };\n}\n\n\n//# sourceMappingURL=measureHtmlText.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass HTMLTextSystem {\n  constructor(renderer) {\n    this._activeTextures = {};\n    this._renderer = renderer;\n    this._createCanvas = renderer.type === types/* RendererType */.G.WEBGPU;\n  }\n  getTexture(options) {\n    return this._buildTexturePromise(\n      options.text,\n      options.resolution,\n      options.style\n    );\n  }\n  getManagedTexture(text, resolution, style, textKey) {\n    if (this._activeTextures[textKey]) {\n      this._increaseReferenceCount(textKey);\n      return this._activeTextures[textKey].promise;\n    }\n    const promise = this._buildTexturePromise(text, resolution, style).then((texture) => {\n      this._activeTextures[textKey].texture = texture;\n      return texture;\n    });\n    this._activeTextures[textKey] = {\n      texture: null,\n      promise,\n      usageCount: 1\n    };\n    return promise;\n  }\n  async _buildTexturePromise(text, resolution, style) {\n    const htmlTextData = PoolGroup/* BigPool */.u.get(HTMLTextRenderData);\n    const fontFamilies = extractFontFamilies(text, style);\n    const fontCSS = await getFontCss(\n      fontFamilies,\n      style,\n      HTMLTextStyle.defaultTextStyle\n    );\n    const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    const image = htmlTextData.image;\n    image.width = width | 0;\n    image.height = height | 0;\n    const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n    await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n    let resource = image;\n    if (this._createCanvas) {\n      resource = getTemporaryCanvasFromImage(image, resolution);\n    }\n    const texture = (0,getPo2TextureFromSource/* getPo2TextureFromSource */.s)(resource, image.width, image.height, resolution);\n    if (this._createCanvas) {\n      this._renderer.texture.initSource(texture.source);\n    }\n    PoolGroup/* BigPool */.u.return(htmlTextData);\n    return texture;\n  }\n  _increaseReferenceCount(textKey) {\n    this._activeTextures[textKey].usageCount++;\n  }\n  decreaseReferenceCount(textKey) {\n    const activeTexture = this._activeTextures[textKey];\n    if (!activeTexture)\n      return;\n    activeTexture.usageCount--;\n    if (activeTexture.usageCount === 0) {\n      if (activeTexture.texture) {\n        this._cleanUp(activeTexture);\n      } else {\n        activeTexture.promise.then((texture) => {\n          activeTexture.texture = texture;\n          this._cleanUp(activeTexture);\n        }).catch(() => {\n          (0,warn/* warn */.m)("HTMLTextSystem: Failed to clean texture");\n        });\n      }\n      this._activeTextures[textKey] = null;\n    }\n  }\n  _cleanUp(activeTexture) {\n    TexturePool/* TexturePool */.W.returnTexture(activeTexture.texture);\n    activeTexture.texture.source.resource = null;\n    activeTexture.texture.source.uploadMethodId = "unknown";\n  }\n  getReferenceCount(textKey) {\n    return this._activeTextures[textKey].usageCount;\n  }\n  destroy() {\n    this._activeTextures = null;\n  }\n}\n/** @ignore */\nHTMLTextSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.y6.WebGLSystem,\n    Extensions/* ExtensionType */.y6.WebGPUSystem,\n    Extensions/* ExtensionType */.y6.CanvasSystem\n  ],\n  name: "htmlText"\n};\nHTMLTextSystem.defaultFontOptions = {\n  fontFamily: "Arial",\n  fontStyle: "normal",\n  fontWeight: "normal"\n};\n\n\n//# sourceMappingURL=HTMLTextSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text-html/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Yt.add(HTMLTextSystem);\nExtensions/* extensions */.Yt.add(HTMLTextPipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWdCLFFBQVE7QUFDOUM7QUFDQTtBQUNBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQSxvQkFBb0IsMERBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLElBQUksd0JBQU87QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsVUFBVSxvQkFBSTtBQUNkLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw4QkFBVztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQ0FBYTtBQUNqQixJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEI7QUFDMUI7OztBQzNINkQ7QUFDWDtBQUNJOztBQUV0RDtBQUNBLDZCQUFVLEtBQUssY0FBYztBQUM3Qiw2QkFBVSxLQUFLLFlBQVk7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1odG1sL0hUTUxUZXh0UGlwZS5tanM/YjE0NyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvdXRpbHMvYnJvd3Nlci9pc1NhZmFyaS5tanM/MTk4OCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1odG1sL0hUTUxUZXh0UmVuZGVyRGF0YS5tanM/MDBhMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1odG1sL3V0aWxzL3RleHRTdHlsZVRvQ1NTLm1qcz9jY2QzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWh0bWwvSHRtbFRleHRTdHlsZS5tanM/ZmI0MCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC1odG1sL3V0aWxzL2V4dHJhY3RGb250RmFtaWxpZXMubWpzPzY5MDAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtaHRtbC91dGlscy9sb2FkRm9udEFzQmFzZTY0Lm1qcz84M2MwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvbG9hZEZvbnRDU1MubWpzP2Y4OWUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtaHRtbC91dGlscy9nZXRGb250Q3NzLm1qcz84YmJiIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvZ2V0U1ZHVXJsLm1qcz84MTZjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvZ2V0VGVtcG9yYXJ5Q2FudmFzRnJvbUltYWdlLm1qcz8zY2M5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvbG9hZFNWR0ltYWdlLm1qcz8xY2JlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWh0bWwvdXRpbHMvbWVhc3VyZUh0bWxUZXh0Lm1qcz8yMzAxIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9zY2VuZS90ZXh0LWh0bWwvSFRNTFRleHRTeXN0ZW0ubWpzP2I4N2MiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQtaHRtbC9pbml0Lm1qcz83YTRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmUubWpzJztcbmltcG9ydCB7IHVwZGF0ZVF1YWRCb3VuZHMgfSBmcm9tICcuLi8uLi91dGlscy9kYXRhL3VwZGF0ZVF1YWRCb3VuZHMubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgQmF0Y2hhYmxlU3ByaXRlIH0gZnJvbSAnLi4vc3ByaXRlL0JhdGNoYWJsZVNwcml0ZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIEhUTUxUZXh0UGlwZSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fZ3B1VGV4dCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5fcmVuZGVyZXIucnVubmVycy5yZXNvbHV0aW9uQ2hhbmdlLmFkZCh0aGlzKTtcbiAgfVxuICByZXNvbHV0aW9uQ2hhbmdlKCkge1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLl9ncHVUZXh0KSB7XG4gICAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ3B1VGV4dFtpXTtcbiAgICAgIGNvbnN0IHRleHQgPSBncHVUZXh0LmJhdGNoYWJsZVNwcml0ZS5yZW5kZXJhYmxlO1xuICAgICAgaWYgKHRleHQuX2F1dG9SZXNvbHV0aW9uKSB7XG4gICAgICAgIHRleHQuX3Jlc29sdXRpb24gPSB0aGlzLl9yZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgICAgICB0ZXh0Lm9uVmlld1VwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YWxpZGF0ZVJlbmRlcmFibGUoaHRtbFRleHQpIHtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ2V0R3B1VGV4dChodG1sVGV4dCk7XG4gICAgY29uc3QgbmV3S2V5ID0gaHRtbFRleHQuX2dldEtleSgpO1xuICAgIGlmIChncHVUZXh0LnRleHR1cmVOZWVkc1VwbG9hZGluZykge1xuICAgICAgZ3B1VGV4dC50ZXh0dXJlTmVlZHNVcGxvYWRpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZ3B1VGV4dC5jdXJyZW50S2V5ICE9PSBuZXdLZXkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYWRkUmVuZGVyYWJsZShodG1sVGV4dCwgX2luc3RydWN0aW9uU2V0KSB7XG4gICAgY29uc3QgZ3B1VGV4dCA9IHRoaXMuX2dldEdwdVRleHQoaHRtbFRleHQpO1xuICAgIGNvbnN0IGJhdGNoYWJsZVNwcml0ZSA9IGdwdVRleHQuYmF0Y2hhYmxlU3ByaXRlO1xuICAgIGlmIChodG1sVGV4dC5fZGlkVGV4dFVwZGF0ZSkge1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dChodG1sVGV4dCk7XG4gICAgfVxuICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlclBpcGVzLmJhdGNoLmFkZFRvQmF0Y2goYmF0Y2hhYmxlU3ByaXRlKTtcbiAgfVxuICB1cGRhdGVSZW5kZXJhYmxlKGh0bWxUZXh0KSB7XG4gICAgY29uc3QgZ3B1VGV4dCA9IHRoaXMuX2dldEdwdVRleHQoaHRtbFRleHQpO1xuICAgIGNvbnN0IGJhdGNoYWJsZVNwcml0ZSA9IGdwdVRleHQuYmF0Y2hhYmxlU3ByaXRlO1xuICAgIGlmIChodG1sVGV4dC5fZGlkVGV4dFVwZGF0ZSkge1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dChodG1sVGV4dCk7XG4gICAgfVxuICAgIGJhdGNoYWJsZVNwcml0ZS5iYXRjaGVyLnVwZGF0ZUVsZW1lbnQoYmF0Y2hhYmxlU3ByaXRlKTtcbiAgfVxuICBkZXN0cm95UmVuZGVyYWJsZShodG1sVGV4dCkge1xuICAgIHRoaXMuX2Rlc3Ryb3lSZW5kZXJhYmxlQnlJZChodG1sVGV4dC51aWQpO1xuICB9XG4gIF9kZXN0cm95UmVuZGVyYWJsZUJ5SWQoaHRtbFRleHRVaWQpIHtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ3B1VGV4dFtodG1sVGV4dFVpZF07XG4gICAgdGhpcy5fcmVuZGVyZXIuaHRtbFRleHQuZGVjcmVhc2VSZWZlcmVuY2VDb3VudChncHVUZXh0LmN1cnJlbnRLZXkpO1xuICAgIEJpZ1Bvb2wucmV0dXJuKGdwdVRleHQuYmF0Y2hhYmxlU3ByaXRlKTtcbiAgICB0aGlzLl9ncHVUZXh0W2h0bWxUZXh0VWlkXSA9IG51bGw7XG4gIH1cbiAgX3VwZGF0ZVRleHQoaHRtbFRleHQpIHtcbiAgICBjb25zdCBuZXdLZXkgPSBodG1sVGV4dC5fZ2V0S2V5KCk7XG4gICAgY29uc3QgZ3B1VGV4dCA9IHRoaXMuX2dldEdwdVRleHQoaHRtbFRleHQpO1xuICAgIGNvbnN0IGJhdGNoYWJsZVNwcml0ZSA9IGdwdVRleHQuYmF0Y2hhYmxlU3ByaXRlO1xuICAgIGlmIChncHVUZXh0LmN1cnJlbnRLZXkgIT09IG5ld0tleSkge1xuICAgICAgdGhpcy5fdXBkYXRlR3B1VGV4dChodG1sVGV4dCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBodG1sVGV4dC5fZGlkVGV4dFVwZGF0ZSA9IGZhbHNlO1xuICAgIGNvbnN0IHBhZGRpbmcgPSBodG1sVGV4dC5fc3R5bGUucGFkZGluZztcbiAgICB1cGRhdGVRdWFkQm91bmRzKGJhdGNoYWJsZVNwcml0ZS5ib3VuZHMsIGh0bWxUZXh0Ll9hbmNob3IsIGJhdGNoYWJsZVNwcml0ZS50ZXh0dXJlLCBwYWRkaW5nKTtcbiAgfVxuICBhc3luYyBfdXBkYXRlR3B1VGV4dChodG1sVGV4dCkge1xuICAgIGh0bWxUZXh0Ll9kaWRUZXh0VXBkYXRlID0gZmFsc2U7XG4gICAgY29uc3QgZ3B1VGV4dCA9IHRoaXMuX2dldEdwdVRleHQoaHRtbFRleHQpO1xuICAgIGlmIChncHVUZXh0LmdlbmVyYXRpbmdUZXh0dXJlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG5ld0tleSA9IGh0bWxUZXh0Ll9nZXRLZXkoKTtcbiAgICB0aGlzLl9yZW5kZXJlci5odG1sVGV4dC5kZWNyZWFzZVJlZmVyZW5jZUNvdW50KGdwdVRleHQuY3VycmVudEtleSk7XG4gICAgZ3B1VGV4dC5nZW5lcmF0aW5nVGV4dHVyZSA9IHRydWU7XG4gICAgZ3B1VGV4dC5jdXJyZW50S2V5ID0gbmV3S2V5O1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSBodG1sVGV4dC5yZXNvbHV0aW9uID8/IHRoaXMuX3JlbmRlcmVyLnJlc29sdXRpb247XG4gICAgY29uc3QgdGV4dHVyZSA9IGF3YWl0IHRoaXMuX3JlbmRlcmVyLmh0bWxUZXh0LmdldE1hbmFnZWRUZXh0dXJlKFxuICAgICAgaHRtbFRleHQudGV4dCxcbiAgICAgIHJlc29sdXRpb24sXG4gICAgICBodG1sVGV4dC5fc3R5bGUsXG4gICAgICBodG1sVGV4dC5fZ2V0S2V5KClcbiAgICApO1xuICAgIGNvbnN0IGJhdGNoYWJsZVNwcml0ZSA9IGdwdVRleHQuYmF0Y2hhYmxlU3ByaXRlO1xuICAgIGJhdGNoYWJsZVNwcml0ZS50ZXh0dXJlID0gZ3B1VGV4dC50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICBncHVUZXh0LmdlbmVyYXRpbmdUZXh0dXJlID0gZmFsc2U7XG4gICAgZ3B1VGV4dC50ZXh0dXJlTmVlZHNVcGxvYWRpbmcgPSB0cnVlO1xuICAgIGh0bWxUZXh0Lm9uVmlld1VwZGF0ZSgpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSBodG1sVGV4dC5fc3R5bGUucGFkZGluZztcbiAgICB1cGRhdGVRdWFkQm91bmRzKGJhdGNoYWJsZVNwcml0ZS5ib3VuZHMsIGh0bWxUZXh0Ll9hbmNob3IsIGJhdGNoYWJsZVNwcml0ZS50ZXh0dXJlLCBwYWRkaW5nKTtcbiAgfVxuICBfZ2V0R3B1VGV4dChodG1sVGV4dCkge1xuICAgIHJldHVybiB0aGlzLl9ncHVUZXh0W2h0bWxUZXh0LnVpZF0gfHwgdGhpcy5pbml0R3B1VGV4dChodG1sVGV4dCk7XG4gIH1cbiAgaW5pdEdwdVRleHQoaHRtbFRleHQpIHtcbiAgICBjb25zdCBncHVUZXh0RGF0YSA9IHtcbiAgICAgIHRleHR1cmU6IFRleHR1cmUuRU1QVFksXG4gICAgICBjdXJyZW50S2V5OiBcIi0tXCIsXG4gICAgICBiYXRjaGFibGVTcHJpdGU6IEJpZ1Bvb2wuZ2V0KEJhdGNoYWJsZVNwcml0ZSksXG4gICAgICB0ZXh0dXJlTmVlZHNVcGxvYWRpbmc6IGZhbHNlLFxuICAgICAgZ2VuZXJhdGluZ1RleHR1cmU6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBiYXRjaGFibGVTcHJpdGUgPSBncHVUZXh0RGF0YS5iYXRjaGFibGVTcHJpdGU7XG4gICAgYmF0Y2hhYmxlU3ByaXRlLnJlbmRlcmFibGUgPSBodG1sVGV4dDtcbiAgICBiYXRjaGFibGVTcHJpdGUudGV4dHVyZSA9IFRleHR1cmUuRU1QVFk7XG4gICAgYmF0Y2hhYmxlU3ByaXRlLmJvdW5kcyA9IHsgbWluWDogMCwgbWF4WDogMSwgbWluWTogMCwgbWF4WTogMCB9O1xuICAgIGJhdGNoYWJsZVNwcml0ZS5yb3VuZFBpeGVscyA9IHRoaXMuX3JlbmRlcmVyLl9yb3VuZFBpeGVscyB8IGh0bWxUZXh0Ll9yb3VuZFBpeGVscztcbiAgICBodG1sVGV4dC5fcmVzb2x1dGlvbiA9IGh0bWxUZXh0Ll9hdXRvUmVzb2x1dGlvbiA/IHRoaXMuX3JlbmRlcmVyLnJlc29sdXRpb24gOiBodG1sVGV4dC5yZXNvbHV0aW9uO1xuICAgIHRoaXMuX2dwdVRleHRbaHRtbFRleHQudWlkXSA9IGdwdVRleHREYXRhO1xuICAgIGh0bWxUZXh0Lm9uKFwiZGVzdHJveWVkXCIsICgpID0+IHtcbiAgICAgIHRoaXMuZGVzdHJveVJlbmRlcmFibGUoaHRtbFRleHQpO1xuICAgIH0pO1xuICAgIHJldHVybiBncHVUZXh0RGF0YTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLl9ncHVUZXh0KSB7XG4gICAgICB0aGlzLl9kZXN0cm95UmVuZGVyYWJsZUJ5SWQoaSk7XG4gICAgfVxuICAgIHRoaXMuX2dwdVRleHQgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkhUTUxUZXh0UGlwZS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1BpcGVzXG4gIF0sXG4gIG5hbWU6IFwiaHRtbFRleHRcIlxufTtcblxuZXhwb3J0IHsgSFRNTFRleHRQaXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IVE1MVGV4dFBpcGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgRE9NQWRhcHRlciB9IGZyb20gJy4uLy4uL2Vudmlyb25tZW50L2FkYXB0ZXIubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgY29uc3QgeyB1c2VyQWdlbnQgfSA9IERPTUFkYXB0ZXIuZ2V0KCkuZ2V0TmF2aWdhdG9yKCk7XG4gIHJldHVybiAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KHVzZXJBZ2VudCk7XG59XG5cbmV4cG9ydCB7IGlzU2FmYXJpIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1NhZmFyaS5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IG5zc3ZnID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuY29uc3QgbnN4aHRtbCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuY2xhc3MgSFRNTFRleHRSZW5kZXJEYXRhIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdmdSb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zc3ZnLCBcInN2Z1wiKTtcbiAgICB0aGlzLmZvcmVpZ25PYmplY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnNzdmcsIFwiZm9yZWlnbk9iamVjdFwiKTtcbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnN4aHRtbCwgXCJkaXZcIik7XG4gICAgdGhpcy5zdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnN4aHRtbCwgXCJzdHlsZVwiKTtcbiAgICB0aGlzLmltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgY29uc3QgeyBmb3JlaWduT2JqZWN0LCBzdmdSb290LCBzdHlsZUVsZW1lbnQsIGRvbUVsZW1lbnQgfSA9IHRoaXM7XG4gICAgZm9yZWlnbk9iamVjdC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjEwMDAwXCIpO1xuICAgIGZvcmVpZ25PYmplY3Quc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiMTAwMDBcIik7XG4gICAgZm9yZWlnbk9iamVjdC5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgc3ZnUm9vdC5hcHBlbmRDaGlsZChmb3JlaWduT2JqZWN0KTtcbiAgICBmb3JlaWduT2JqZWN0LmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG4gICAgZm9yZWlnbk9iamVjdC5hcHBlbmRDaGlsZChkb21FbGVtZW50KTtcbiAgfVxufVxuXG5leHBvcnQgeyBIVE1MVGV4dFJlbmRlckRhdGEsIG5zc3ZnLCBuc3hodG1sIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IVE1MVGV4dFJlbmRlckRhdGEubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi8uLi9jb2xvci9Db2xvci5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIHRleHRTdHlsZVRvQ1NTKHN0eWxlKSB7XG4gIGNvbnN0IHN0cm9rZSA9IHN0eWxlLl9zdHJva2U7XG4gIGNvbnN0IGZpbGwgPSBzdHlsZS5fZmlsbDtcbiAgY29uc3QgY3NzU3R5bGVTdHJpbmcgPSBbXG4gICAgYGNvbG9yOiAke0NvbG9yLnNoYXJlZC5zZXRWYWx1ZShmaWxsLmNvbG9yKS50b0hleCgpfWAsXG4gICAgYGZvbnQtc2l6ZTogJHtzdHlsZS5mb250U2l6ZX1weGAsXG4gICAgYGZvbnQtZmFtaWx5OiAke3N0eWxlLmZvbnRGYW1pbHl9YCxcbiAgICBgZm9udC13ZWlnaHQ6ICR7c3R5bGUuZm9udFdlaWdodH1gLFxuICAgIGBmb250LXN0eWxlOiAke3N0eWxlLmZvbnRTdHlsZX1gLFxuICAgIGBmb250LXZhcmlhbnQ6ICR7c3R5bGUuZm9udFZhcmlhbnR9YCxcbiAgICBgbGV0dGVyLXNwYWNpbmc6ICR7c3R5bGUubGV0dGVyU3BhY2luZ31weGAsXG4gICAgYHRleHQtYWxpZ246ICR7c3R5bGUuYWxpZ259YCxcbiAgICBgcGFkZGluZzogJHtzdHlsZS5wYWRkaW5nfXB4YCxcbiAgICBgd2hpdGUtc3BhY2U6ICR7c3R5bGUud2hpdGVTcGFjZSA9PT0gXCJwcmVcIiAmJiBzdHlsZS53b3JkV3JhcCA/IFwicHJlLXdyYXBcIiA6IHN0eWxlLndoaXRlU3BhY2V9YCxcbiAgICAuLi5zdHlsZS5saW5lSGVpZ2h0ID8gW2BsaW5lLWhlaWdodDogJHtzdHlsZS5saW5lSGVpZ2h0fXB4YF0gOiBbXSxcbiAgICAuLi5zdHlsZS53b3JkV3JhcCA/IFtcbiAgICAgIGB3b3JkLXdyYXA6ICR7c3R5bGUuYnJlYWtXb3JkcyA/IFwiYnJlYWstYWxsXCIgOiBcImJyZWFrLXdvcmRcIn1gLFxuICAgICAgYG1heC13aWR0aDogJHtzdHlsZS53b3JkV3JhcFdpZHRofXB4YFxuICAgIF0gOiBbXSxcbiAgICAuLi5zdHJva2UgPyBbc3Ryb2tlVG9DU1Moc3Ryb2tlKV0gOiBbXSxcbiAgICAuLi5zdHlsZS5kcm9wU2hhZG93ID8gW2Ryb3BTaGFkb3dUb0NTUyhzdHlsZS5kcm9wU2hhZG93KV0gOiBbXSxcbiAgICAuLi5zdHlsZS5jc3NPdmVycmlkZXNcbiAgXS5qb2luKFwiO1wiKTtcbiAgY29uc3QgY3NzU3R5bGVzID0gW2BkaXYgeyAke2Nzc1N0eWxlU3RyaW5nfSB9YF07XG4gIHRhZ1N0eWxlVG9DU1Moc3R5bGUudGFnU3R5bGVzLCBjc3NTdHlsZXMpO1xuICByZXR1cm4gY3NzU3R5bGVzLmpvaW4oXCIgXCIpO1xufVxuZnVuY3Rpb24gZHJvcFNoYWRvd1RvQ1NTKGRyb3BTaGFkb3dTdHlsZSkge1xuICBjb25zdCBjb2xvciA9IENvbG9yLnNoYXJlZC5zZXRWYWx1ZShkcm9wU2hhZG93U3R5bGUuY29sb3IpLnNldEFscGhhKGRyb3BTaGFkb3dTdHlsZS5hbHBoYSkudG9IZXhhKCk7XG4gIGNvbnN0IHggPSBNYXRoLnJvdW5kKE1hdGguY29zKGRyb3BTaGFkb3dTdHlsZS5hbmdsZSkgKiBkcm9wU2hhZG93U3R5bGUuZGlzdGFuY2UpO1xuICBjb25zdCB5ID0gTWF0aC5yb3VuZChNYXRoLnNpbihkcm9wU2hhZG93U3R5bGUuYW5nbGUpICogZHJvcFNoYWRvd1N0eWxlLmRpc3RhbmNlKTtcbiAgY29uc3QgcG9zaXRpb24gPSBgJHt4fXB4ICR7eX1weGA7XG4gIGlmIChkcm9wU2hhZG93U3R5bGUuYmx1ciA+IDApIHtcbiAgICByZXR1cm4gYHRleHQtc2hhZG93OiAke3Bvc2l0aW9ufSAke2Ryb3BTaGFkb3dTdHlsZS5ibHVyfXB4ICR7Y29sb3J9YDtcbiAgfVxuICByZXR1cm4gYHRleHQtc2hhZG93OiAke3Bvc2l0aW9ufSAke2NvbG9yfWA7XG59XG5mdW5jdGlvbiBzdHJva2VUb0NTUyhzdHJva2UpIHtcbiAgcmV0dXJuIFtcbiAgICBgLXdlYmtpdC10ZXh0LXN0cm9rZS13aWR0aDogJHtzdHJva2Uud2lkdGh9cHhgLFxuICAgIGAtd2Via2l0LXRleHQtc3Ryb2tlLWNvbG9yOiAke0NvbG9yLnNoYXJlZC5zZXRWYWx1ZShzdHJva2UuY29sb3IpLnRvSGV4KCl9YCxcbiAgICBgdGV4dC1zdHJva2Utd2lkdGg6ICR7c3Ryb2tlLndpZHRofXB4YCxcbiAgICBgdGV4dC1zdHJva2UtY29sb3I6ICR7Q29sb3Iuc2hhcmVkLnNldFZhbHVlKHN0cm9rZS5jb2xvcikudG9IZXgoKX1gLFxuICAgIFwicGFpbnQtb3JkZXI6IHN0cm9rZVwiXG4gIF0uam9pbihcIjtcIik7XG59XG5jb25zdCB0ZW1wbGF0ZXMgPSB7XG4gIGZvbnRTaXplOiBgZm9udC1zaXplOiB7e1ZBTFVFfX1weGAsXG4gIGZvbnRGYW1pbHk6IGBmb250LWZhbWlseToge3tWQUxVRX19YCxcbiAgZm9udFdlaWdodDogYGZvbnQtd2VpZ2h0OiB7e1ZBTFVFfX1gLFxuICBmb250U3R5bGU6IGBmb250LXN0eWxlOiB7e1ZBTFVFfX1gLFxuICBmb250VmFyaWFudDogYGZvbnQtdmFyaWFudDoge3tWQUxVRX19YCxcbiAgbGV0dGVyU3BhY2luZzogYGxldHRlci1zcGFjaW5nOiB7e1ZBTFVFfX1weGAsXG4gIGFsaWduOiBgdGV4dC1hbGlnbjoge3tWQUxVRX19YCxcbiAgcGFkZGluZzogYHBhZGRpbmc6IHt7VkFMVUV9fXB4YCxcbiAgd2hpdGVTcGFjZTogYHdoaXRlLXNwYWNlOiB7e1ZBTFVFfX1gLFxuICBsaW5lSGVpZ2h0OiBgbGluZS1oZWlnaHQ6IHt7VkFMVUV9fXB4YCxcbiAgd29yZFdyYXBXaWR0aDogYG1heC13aWR0aDoge3tWQUxVRX19cHhgXG59O1xuY29uc3QgdHJhbnNmb3JtID0ge1xuICBmaWxsOiAodmFsdWUpID0+IGBjb2xvcjogJHtDb2xvci5zaGFyZWQuc2V0VmFsdWUodmFsdWUpLnRvSGV4KCl9YCxcbiAgYnJlYWtXb3JkczogKHZhbHVlKSA9PiBgd29yZC13cmFwOiAke3ZhbHVlID8gXCJicmVhay1hbGxcIiA6IFwiYnJlYWstd29yZFwifWAsXG4gIHN0cm9rZTogc3Ryb2tlVG9DU1MsXG4gIGRyb3BTaGFkb3c6IGRyb3BTaGFkb3dUb0NTU1xufTtcbmZ1bmN0aW9uIHRhZ1N0eWxlVG9DU1ModGFnU3R5bGVzLCBvdXQpIHtcbiAgZm9yIChjb25zdCBpIGluIHRhZ1N0eWxlcykge1xuICAgIGNvbnN0IHRhZ1N0eWxlID0gdGFnU3R5bGVzW2ldO1xuICAgIGNvbnN0IGNzc1RhZ1N0eWxlID0gW107XG4gICAgZm9yIChjb25zdCBqIGluIHRhZ1N0eWxlKSB7XG4gICAgICBpZiAodHJhbnNmb3JtW2pdKSB7XG4gICAgICAgIGNzc1RhZ1N0eWxlLnB1c2godHJhbnNmb3JtW2pdKHRhZ1N0eWxlW2pdKSk7XG4gICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlc1tqXSkge1xuICAgICAgICBjc3NUYWdTdHlsZS5wdXNoKHRlbXBsYXRlc1tqXS5yZXBsYWNlKFwie3tWQUxVRX19XCIsIHRhZ1N0eWxlW2pdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIG91dC5wdXNoKGAke2l9IHsgJHtjc3NUYWdTdHlsZS5qb2luKFwiO1wiKX0gfWApO1xuICB9XG59XG5cbmV4cG9ydCB7IHRleHRTdHlsZVRvQ1NTIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXh0U3R5bGVUb0NTUy5tanMubWFwXG4iLCJpbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9nZ2luZy93YXJuLm1qcyc7XG5pbXBvcnQgeyBUZXh0U3R5bGUgfSBmcm9tICcuLi90ZXh0L1RleHRTdHlsZS5tanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVUZXh0U3R5bGVLZXkgfSBmcm9tICcuLi90ZXh0L3V0aWxzL2dlbmVyYXRlVGV4dFN0eWxlS2V5Lm1qcyc7XG5pbXBvcnQgeyB0ZXh0U3R5bGVUb0NTUyB9IGZyb20gJy4vdXRpbHMvdGV4dFN0eWxlVG9DU1MubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBIVE1MVGV4dFN0eWxlIGV4dGVuZHMgVGV4dFN0eWxlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgdGhpcy5fY3NzT3ZlcnJpZGVzID0gW107XG4gICAgdGhpcy5jc3NPdmVycmlkZXMgPz8gKHRoaXMuY3NzT3ZlcnJpZGVzID0gb3B0aW9ucy5jc3NPdmVycmlkZXMpO1xuICAgIHRoaXMudGFnU3R5bGVzID0gb3B0aW9ucy50YWdTdHlsZXMgPz8ge307XG4gIH1cbiAgLyoqIExpc3Qgb2Ygc3R5bGUgb3ZlcnJpZGVzIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBIVE1MIHRleHQuICovXG4gIHNldCBjc3NPdmVycmlkZXModmFsdWUpIHtcbiAgICB0aGlzLl9jc3NPdmVycmlkZXMgPSB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5ID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgZ2V0IGNzc092ZXJyaWRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fY3NzT3ZlcnJpZGVzO1xuICB9XG4gIF9nZW5lcmF0ZUtleSgpIHtcbiAgICB0aGlzLl9zdHlsZUtleSA9IGdlbmVyYXRlVGV4dFN0eWxlS2V5KHRoaXMpICsgdGhpcy5fY3NzT3ZlcnJpZGVzLmpvaW4oXCItXCIpO1xuICAgIHJldHVybiB0aGlzLl9zdHlsZUtleTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5fY3NzU3R5bGUgPSBudWxsO1xuICAgIHN1cGVyLnVwZGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEhUTUxUZXh0U3R5bGUgb2JqZWN0IHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIHRoaXMgb25lLlxuICAgKiBAcmV0dXJucyBOZXcgY2xvbmVkIEhUTUxUZXh0U3R5bGUgb2JqZWN0XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IEhUTUxUZXh0U3R5bGUoe1xuICAgICAgYWxpZ246IHRoaXMuYWxpZ24sXG4gICAgICBicmVha1dvcmRzOiB0aGlzLmJyZWFrV29yZHMsXG4gICAgICBkcm9wU2hhZG93OiB0aGlzLmRyb3BTaGFkb3cgPyB7IC4uLnRoaXMuZHJvcFNoYWRvdyB9IDogbnVsbCxcbiAgICAgIGZpbGw6IHRoaXMuX2ZpbGwsXG4gICAgICBmb250RmFtaWx5OiB0aGlzLmZvbnRGYW1pbHksXG4gICAgICBmb250U2l6ZTogdGhpcy5mb250U2l6ZSxcbiAgICAgIGZvbnRTdHlsZTogdGhpcy5mb250U3R5bGUsXG4gICAgICBmb250VmFyaWFudDogdGhpcy5mb250VmFyaWFudCxcbiAgICAgIGZvbnRXZWlnaHQ6IHRoaXMuZm9udFdlaWdodCxcbiAgICAgIGxldHRlclNwYWNpbmc6IHRoaXMubGV0dGVyU3BhY2luZyxcbiAgICAgIGxpbmVIZWlnaHQ6IHRoaXMubGluZUhlaWdodCxcbiAgICAgIHBhZGRpbmc6IHRoaXMucGFkZGluZyxcbiAgICAgIHN0cm9rZTogdGhpcy5fc3Ryb2tlLFxuICAgICAgd2hpdGVTcGFjZTogdGhpcy53aGl0ZVNwYWNlLFxuICAgICAgd29yZFdyYXA6IHRoaXMud29yZFdyYXAsXG4gICAgICB3b3JkV3JhcFdpZHRoOiB0aGlzLndvcmRXcmFwV2lkdGgsXG4gICAgICBjc3NPdmVycmlkZXM6IHRoaXMuY3NzT3ZlcnJpZGVzXG4gICAgfSk7XG4gIH1cbiAgZ2V0IGNzc1N0eWxlKCkge1xuICAgIGlmICghdGhpcy5fY3NzU3R5bGUpIHtcbiAgICAgIHRoaXMuX2Nzc1N0eWxlID0gdGV4dFN0eWxlVG9DU1ModGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jc3NTdHlsZTtcbiAgfVxuICAvKipcbiAgICogQWRkIGEgc3R5bGUgb3ZlcnJpZGUsIHRoaXMgY2FuIGJlIGFueSBDU1MgcHJvcGVydHlcbiAgICogaXQgd2lsbCBvdmVycmlkZSBhbnkgYnVpbHQtaW4gc3R5bGUuIFRoaXMgaXMgdGhlXG4gICAqIHByb3BlcnR5IGFuZCB0aGUgdmFsdWUgYXMgYSBzdHJpbmcgKGUuZy4sIGBjb2xvcjogcmVkYCkuXG4gICAqIFRoaXMgd2lsbCBvdmVycmlkZSBhbnkgb3RoZXIgaW50ZXJuYWwgc3R5bGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIENTUyBzdHlsZShzKSB0byBhZGQuXG4gICAqIEBleGFtcGxlXG4gICAqIHN0eWxlLmFkZE92ZXJyaWRlKCdiYWNrZ3JvdW5kLWNvbG9yOiByZWQnKTtcbiAgICovXG4gIGFkZE92ZXJyaWRlKC4uLnZhbHVlKSB7XG4gICAgY29uc3QgdG9BZGQgPSB2YWx1ZS5maWx0ZXIoKHYpID0+ICF0aGlzLmNzc092ZXJyaWRlcy5pbmNsdWRlcyh2KSk7XG4gICAgaWYgKHRvQWRkLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuY3NzT3ZlcnJpZGVzLnB1c2goLi4udG9BZGQpO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhbnkgb3ZlcnJpZGVzIHRoYXQgbWF0Y2ggdGhlIHZhbHVlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBDU1Mgc3R5bGUgdG8gcmVtb3ZlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBzdHlsZS5yZW1vdmVPdmVycmlkZSgnYmFja2dyb3VuZC1jb2xvcjogcmVkJyk7XG4gICAqL1xuICByZW1vdmVPdmVycmlkZSguLi52YWx1ZSkge1xuICAgIGNvbnN0IHRvUmVtb3ZlID0gdmFsdWUuZmlsdGVyKCh2KSA9PiB0aGlzLmNzc092ZXJyaWRlcy5pbmNsdWRlcyh2KSk7XG4gICAgaWYgKHRvUmVtb3ZlLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuY3NzT3ZlcnJpZGVzID0gdGhpcy5jc3NPdmVycmlkZXMuZmlsdGVyKCh2KSA9PiAhdG9SZW1vdmUuaW5jbHVkZXModikpO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgc2V0IGZpbGwodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgd2FybihcIltIVE1MVGV4dFN0eWxlXSBvbmx5IGNvbG9yIGZpbGwgaXMgbm90IHN1cHBvcnRlZCBieSBIVE1MVGV4dFwiKTtcbiAgICB9XG4gICAgc3VwZXIuZmlsbCA9IHZhbHVlO1xuICB9XG4gIHNldCBzdHJva2UodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgd2FybihcIltIVE1MVGV4dFN0eWxlXSBvbmx5IGNvbG9yIHN0cm9rZSBpcyBub3Qgc3VwcG9ydGVkIGJ5IEhUTUxUZXh0XCIpO1xuICAgIH1cbiAgICBzdXBlci5zdHJva2UgPSB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgeyBIVE1MVGV4dFN0eWxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IdG1sVGV4dFN0eWxlLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZXh0cmFjdEZvbnRGYW1pbGllcyh0ZXh0LCBzdHlsZSkge1xuICBjb25zdCBmb250RmFtaWx5ID0gc3R5bGUuZm9udEZhbWlseTtcbiAgY29uc3QgZm9udEZhbWlsaWVzID0gW107XG4gIGNvbnN0IGRlZHVwZSA9IHt9O1xuICBjb25zdCByZWdleCA9IC9mb250LWZhbWlseTooW147XCJcXHNdKykvZztcbiAgY29uc3QgbWF0Y2hlcyA9IHRleHQubWF0Y2gocmVnZXgpO1xuICBmdW5jdGlvbiBhZGRGb250RmFtaWx5KGZvbnRGYW1pbHkyKSB7XG4gICAgaWYgKCFkZWR1cGVbZm9udEZhbWlseTJdKSB7XG4gICAgICBmb250RmFtaWxpZXMucHVzaChmb250RmFtaWx5Mik7XG4gICAgICBkZWR1cGVbZm9udEZhbWlseTJdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZm9udEZhbWlseSkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvbnRGYW1pbHkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFkZEZvbnRGYW1pbHkoZm9udEZhbWlseVtpXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFkZEZvbnRGYW1pbHkoZm9udEZhbWlseSk7XG4gIH1cbiAgaWYgKG1hdGNoZXMpIHtcbiAgICBtYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4gICAgICBjb25zdCBmb250RmFtaWx5MiA9IG1hdGNoLnNwbGl0KFwiOlwiKVsxXS50cmltKCk7XG4gICAgICBhZGRGb250RmFtaWx5KGZvbnRGYW1pbHkyKTtcbiAgICB9KTtcbiAgfVxuICBmb3IgKGNvbnN0IGkgaW4gc3R5bGUudGFnU3R5bGVzKSB7XG4gICAgY29uc3QgZm9udEZhbWlseTIgPSBzdHlsZS50YWdTdHlsZXNbaV0uZm9udEZhbWlseTtcbiAgICBhZGRGb250RmFtaWx5KGZvbnRGYW1pbHkyKTtcbiAgfVxuICByZXR1cm4gZm9udEZhbWlsaWVzO1xufVxuXG5leHBvcnQgeyBleHRyYWN0Rm9udEZhbWlsaWVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0Rm9udEZhbWlsaWVzLm1qcy5tYXBcbiIsImltcG9ydCB7IERPTUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi9lbnZpcm9ubWVudC9hZGFwdGVyLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuYXN5bmMgZnVuY3Rpb24gbG9hZEZvbnRBc0Jhc2U2NCh1cmwpIHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBET01BZGFwdGVyLmdldCgpLmZldGNoKHVybCk7XG4gIGNvbnN0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gIGNvbnN0IGRhdGFTcmMgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVhZGVyLm9ubG9hZGVuZCA9ICgpID0+IHJlc29sdmUocmVhZGVyLnJlc3VsdCk7XG4gICAgcmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gIH0pO1xuICByZXR1cm4gZGF0YVNyYztcbn1cblxuZXhwb3J0IHsgbG9hZEZvbnRBc0Jhc2U2NCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZEZvbnRBc0Jhc2U2NC5tanMubWFwXG4iLCJpbXBvcnQgeyBsb2FkRm9udEFzQmFzZTY0IH0gZnJvbSAnLi9sb2FkRm9udEFzQmFzZTY0Lm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuYXN5bmMgZnVuY3Rpb24gbG9hZEZvbnRDU1Moc3R5bGUsIHVybCkge1xuICBjb25zdCBkYXRhU3JjID0gYXdhaXQgbG9hZEZvbnRBc0Jhc2U2NCh1cmwpO1xuICByZXR1cm4gYEBmb250LWZhY2Uge1xuICAgICAgICBmb250LWZhbWlseTogXCIke3N0eWxlLmZvbnRGYW1pbHl9XCI7XG4gICAgICAgIHNyYzogdXJsKCcke2RhdGFTcmN9Jyk7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiAke3N0eWxlLmZvbnRXZWlnaHR9O1xuICAgICAgICBmb250LXN0eWxlOiAke3N0eWxlLmZvbnRTdHlsZX07XG4gICAgfWA7XG59XG5cbmV4cG9ydCB7IGxvYWRGb250Q1NTIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkRm9udENTUy5tanMubWFwXG4iLCJpbXBvcnQgeyBDYWNoZSB9IGZyb20gJy4uLy4uLy4uL2Fzc2V0cy9jYWNoZS9DYWNoZS5tanMnO1xuaW1wb3J0IHsgbG9hZEZvbnRDU1MgfSBmcm9tICcuL2xvYWRGb250Q1NTLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuY29uc3QgRm9udFN0eWxlUHJvbWlzZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmFzeW5jIGZ1bmN0aW9uIGdldEZvbnRDc3MoZm9udEZhbWlsaWVzLCBzdHlsZSwgZGVmYXVsdE9wdGlvbnMpIHtcbiAgY29uc3QgZm9udFByb21pc2VzID0gZm9udEZhbWlsaWVzLmZpbHRlcigoZm9udEZhbWlseSkgPT4gQ2FjaGUuaGFzKGAke2ZvbnRGYW1pbHl9LWFuZC11cmxgKSkubWFwKChmb250RmFtaWx5LCBpKSA9PiB7XG4gICAgaWYgKCFGb250U3R5bGVQcm9taXNlQ2FjaGUuaGFzKGZvbnRGYW1pbHkpKSB7XG4gICAgICBjb25zdCB7IHVybCB9ID0gQ2FjaGUuZ2V0KGAke2ZvbnRGYW1pbHl9LWFuZC11cmxgKTtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIEZvbnRTdHlsZVByb21pc2VDYWNoZS5zZXQoZm9udEZhbWlseSwgbG9hZEZvbnRDU1Moe1xuICAgICAgICAgIGZvbnRXZWlnaHQ6IHN0eWxlLmZvbnRXZWlnaHQsXG4gICAgICAgICAgZm9udFN0eWxlOiBzdHlsZS5mb250U3R5bGUsXG4gICAgICAgICAgZm9udEZhbWlseVxuICAgICAgICB9LCB1cmwpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEZvbnRTdHlsZVByb21pc2VDYWNoZS5zZXQoZm9udEZhbWlseSwgbG9hZEZvbnRDU1Moe1xuICAgICAgICAgIGZvbnRXZWlnaHQ6IGRlZmF1bHRPcHRpb25zLmZvbnRXZWlnaHQsXG4gICAgICAgICAgZm9udFN0eWxlOiBkZWZhdWx0T3B0aW9ucy5mb250U3R5bGUsXG4gICAgICAgICAgZm9udEZhbWlseVxuICAgICAgICB9LCB1cmwpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEZvbnRTdHlsZVByb21pc2VDYWNoZS5nZXQoZm9udEZhbWlseSk7XG4gIH0pO1xuICByZXR1cm4gKGF3YWl0IFByb21pc2UuYWxsKGZvbnRQcm9taXNlcykpLmpvaW4oXCJcXG5cIik7XG59XG5cbmV4cG9ydCB7IEZvbnRTdHlsZVByb21pc2VDYWNoZSwgZ2V0Rm9udENzcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0Rm9udENzcy5tanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGdldFNWR1VybCh0ZXh0LCBzdHlsZSwgcmVzb2x1dGlvbiwgZm9udENTUywgaHRtbFRleHREYXRhKSB7XG4gIGNvbnN0IHsgZG9tRWxlbWVudCwgc3R5bGVFbGVtZW50LCBzdmdSb290IH0gPSBodG1sVGV4dERhdGE7XG4gIGRvbUVsZW1lbnQuaW5uZXJIVE1MID0gYDxzdHlsZT4ke3N0eWxlLmNzc1N0eWxlfTwvc3R5bGU+PGRpdj4ke3RleHR9PC9kaXY+YDtcbiAgZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBgdHJhbnNmb3JtOiBzY2FsZSgke3Jlc29sdXRpb259KTt0cmFuc2Zvcm0tb3JpZ2luOiB0b3AgbGVmdDsgZGlzcGxheTogaW5saW5lLWJsb2NrYCk7XG4gIHN0eWxlRWxlbWVudC50ZXh0Q29udGVudCA9IGZvbnRDU1M7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gaHRtbFRleHREYXRhLmltYWdlO1xuICBzdmdSb290LnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHdpZHRoLnRvU3RyaW5nKCkpO1xuICBzdmdSb290LnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBoZWlnaHQudG9TdHJpbmcoKSk7XG4gIHJldHVybiBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHN2Z1Jvb3QpO1xufVxuXG5leHBvcnQgeyBnZXRTVkdVcmwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFNWR1VybC5tanMubWFwXG4iLCJpbXBvcnQgeyBDYW52YXNQb29sIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9DYW52YXNQb29sLm1qcyc7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZ2V0VGVtcG9yYXJ5Q2FudmFzRnJvbUltYWdlKGltYWdlLCByZXNvbHV0aW9uKSB7XG4gIGNvbnN0IGNhbnZhc0FuZENvbnRleHQgPSBDYW52YXNQb29sLmdldE9wdGltYWxDYW52YXNBbmRDb250ZXh0KFxuICAgIGltYWdlLndpZHRoLFxuICAgIGltYWdlLmhlaWdodCxcbiAgICByZXNvbHV0aW9uXG4gICk7XG4gIGNvbnN0IHsgY29udGV4dCB9ID0gY2FudmFzQW5kQ29udGV4dDtcbiAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG4gIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwKTtcbiAgQ2FudmFzUG9vbC5yZXR1cm5DYW52YXNBbmRDb250ZXh0KGNhbnZhc0FuZENvbnRleHQpO1xuICByZXR1cm4gY2FudmFzQW5kQ29udGV4dC5jYW52YXM7XG59XG5cbmV4cG9ydCB7IGdldFRlbXBvcmFyeUNhbnZhc0Zyb21JbWFnZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0VGVtcG9yYXJ5Q2FudmFzRnJvbUltYWdlLm1qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gbG9hZFNWR0ltYWdlKGltYWdlLCB1cmwsIGRlbGF5KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgIGlmIChkZWxheSkge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUyKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUyLCAxMDApKTtcbiAgICB9XG4gICAgaW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH07XG4gICAgaW1hZ2Uuc3JjID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0ZjgsJHtlbmNvZGVVUklDb21wb25lbnQodXJsKX1gO1xuICAgIGltYWdlLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIjtcbiAgfSk7XG59XG5cbmV4cG9ydCB7IGxvYWRTVkdJbWFnZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZFNWR0ltYWdlLm1qcy5tYXBcbiIsImltcG9ydCB7IENhbnZhc1RleHRNZXRyaWNzIH0gZnJvbSAnLi4vLi4vdGV4dC9jYW52YXMvQ2FudmFzVGV4dE1ldHJpY3MubWpzJztcbmltcG9ydCB7IEhUTUxUZXh0UmVuZGVyRGF0YSB9IGZyb20gJy4uL0hUTUxUZXh0UmVuZGVyRGF0YS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmxldCB0ZW1wSFRNTFRleHRSZW5kZXJEYXRhO1xuZnVuY3Rpb24gbWVhc3VyZUh0bWxUZXh0KHRleHQsIHN0eWxlLCBmb250U3R5bGVDU1MsIGh0bWxUZXh0UmVuZGVyRGF0YSkge1xuICBodG1sVGV4dFJlbmRlckRhdGEgPSBodG1sVGV4dFJlbmRlckRhdGEgfHwgdGVtcEhUTUxUZXh0UmVuZGVyRGF0YSB8fCAodGVtcEhUTUxUZXh0UmVuZGVyRGF0YSA9IG5ldyBIVE1MVGV4dFJlbmRlckRhdGEoKSk7XG4gIGNvbnN0IHsgZG9tRWxlbWVudCwgc3R5bGVFbGVtZW50LCBzdmdSb290IH0gPSBodG1sVGV4dFJlbmRlckRhdGE7XG4gIGRvbUVsZW1lbnQuaW5uZXJIVE1MID0gYDxzdHlsZT4ke3N0eWxlLmNzc1N0eWxlfTwvc3R5bGU+PGRpdj4ke3RleHR9PC9kaXY+YDtcbiAgZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcInRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0OyBkaXNwbGF5OiBpbmxpbmUtYmxvY2tcIik7XG4gIGlmIChmb250U3R5bGVDU1MpIHtcbiAgICBzdHlsZUVsZW1lbnQudGV4dENvbnRlbnQgPSBmb250U3R5bGVDU1M7XG4gIH1cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdmdSb290KTtcbiAgY29uc3QgY29udGVudEJvdW5kcyA9IGRvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHN2Z1Jvb3QucmVtb3ZlKCk7XG4gIGNvbnN0IGRlc2NlbmRlclBhZGRpbmcgPSBDYW52YXNUZXh0TWV0cmljcy5tZWFzdXJlRm9udChzdHlsZS5mb250U3R5bGUpLmRlc2NlbnQ7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IGNvbnRlbnRCb3VuZHMud2lkdGgsXG4gICAgaGVpZ2h0OiBjb250ZW50Qm91bmRzLmhlaWdodCArIGRlc2NlbmRlclBhZGRpbmdcbiAgfTtcbn1cblxuZXhwb3J0IHsgbWVhc3VyZUh0bWxUZXh0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZWFzdXJlSHRtbFRleHQubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgVGV4dHVyZVBvb2wgfSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmVQb29sLm1qcyc7XG5pbXBvcnQgeyBSZW5kZXJlclR5cGUgfSBmcm9tICcuLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3R5cGVzLm1qcyc7XG5pbXBvcnQgeyBpc1NhZmFyaSB9IGZyb20gJy4uLy4uL3V0aWxzL2Jyb3dzZXIvaXNTYWZhcmkubWpzJztcbmltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi8uLi91dGlscy9sb2dnaW5nL3dhcm4ubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgZ2V0UG8yVGV4dHVyZUZyb21Tb3VyY2UgfSBmcm9tICcuLi90ZXh0L3V0aWxzL2dldFBvMlRleHR1cmVGcm9tU291cmNlLm1qcyc7XG5pbXBvcnQgeyBIVE1MVGV4dFJlbmRlckRhdGEgfSBmcm9tICcuL0hUTUxUZXh0UmVuZGVyRGF0YS5tanMnO1xuaW1wb3J0IHsgSFRNTFRleHRTdHlsZSB9IGZyb20gJy4vSHRtbFRleHRTdHlsZS5tanMnO1xuaW1wb3J0IHsgZXh0cmFjdEZvbnRGYW1pbGllcyB9IGZyb20gJy4vdXRpbHMvZXh0cmFjdEZvbnRGYW1pbGllcy5tanMnO1xuaW1wb3J0IHsgZ2V0Rm9udENzcyB9IGZyb20gJy4vdXRpbHMvZ2V0Rm9udENzcy5tanMnO1xuaW1wb3J0IHsgZ2V0U1ZHVXJsIH0gZnJvbSAnLi91dGlscy9nZXRTVkdVcmwubWpzJztcbmltcG9ydCB7IGdldFRlbXBvcmFyeUNhbnZhc0Zyb21JbWFnZSB9IGZyb20gJy4vdXRpbHMvZ2V0VGVtcG9yYXJ5Q2FudmFzRnJvbUltYWdlLm1qcyc7XG5pbXBvcnQgeyBsb2FkU1ZHSW1hZ2UgfSBmcm9tICcuL3V0aWxzL2xvYWRTVkdJbWFnZS5tanMnO1xuaW1wb3J0IHsgbWVhc3VyZUh0bWxUZXh0IH0gZnJvbSAnLi91dGlscy9tZWFzdXJlSHRtbFRleHQubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBIVE1MVGV4dFN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fYWN0aXZlVGV4dHVyZXMgPSB7fTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMuX2NyZWF0ZUNhbnZhcyA9IHJlbmRlcmVyLnR5cGUgPT09IFJlbmRlcmVyVHlwZS5XRUJHUFU7XG4gIH1cbiAgZ2V0VGV4dHVyZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX2J1aWxkVGV4dHVyZVByb21pc2UoXG4gICAgICBvcHRpb25zLnRleHQsXG4gICAgICBvcHRpb25zLnJlc29sdXRpb24sXG4gICAgICBvcHRpb25zLnN0eWxlXG4gICAgKTtcbiAgfVxuICBnZXRNYW5hZ2VkVGV4dHVyZSh0ZXh0LCByZXNvbHV0aW9uLCBzdHlsZSwgdGV4dEtleSkge1xuICAgIGlmICh0aGlzLl9hY3RpdmVUZXh0dXJlc1t0ZXh0S2V5XSkge1xuICAgICAgdGhpcy5faW5jcmVhc2VSZWZlcmVuY2VDb3VudCh0ZXh0S2V5KTtcbiAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVUZXh0dXJlc1t0ZXh0S2V5XS5wcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5fYnVpbGRUZXh0dXJlUHJvbWlzZSh0ZXh0LCByZXNvbHV0aW9uLCBzdHlsZSkudGhlbigodGV4dHVyZSkgPT4ge1xuICAgICAgdGhpcy5fYWN0aXZlVGV4dHVyZXNbdGV4dEtleV0udGV4dHVyZSA9IHRleHR1cmU7XG4gICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9KTtcbiAgICB0aGlzLl9hY3RpdmVUZXh0dXJlc1t0ZXh0S2V5XSA9IHtcbiAgICAgIHRleHR1cmU6IG51bGwsXG4gICAgICBwcm9taXNlLFxuICAgICAgdXNhZ2VDb3VudDogMVxuICAgIH07XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgYXN5bmMgX2J1aWxkVGV4dHVyZVByb21pc2UodGV4dCwgcmVzb2x1dGlvbiwgc3R5bGUpIHtcbiAgICBjb25zdCBodG1sVGV4dERhdGEgPSBCaWdQb29sLmdldChIVE1MVGV4dFJlbmRlckRhdGEpO1xuICAgIGNvbnN0IGZvbnRGYW1pbGllcyA9IGV4dHJhY3RGb250RmFtaWxpZXModGV4dCwgc3R5bGUpO1xuICAgIGNvbnN0IGZvbnRDU1MgPSBhd2FpdCBnZXRGb250Q3NzKFxuICAgICAgZm9udEZhbWlsaWVzLFxuICAgICAgc3R5bGUsXG4gICAgICBIVE1MVGV4dFN0eWxlLmRlZmF1bHRUZXh0U3R5bGVcbiAgICApO1xuICAgIGNvbnN0IG1lYXN1cmVkID0gbWVhc3VyZUh0bWxUZXh0KHRleHQsIHN0eWxlLCBmb250Q1NTLCBodG1sVGV4dERhdGEpO1xuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5jZWlsKE1hdGguY2VpbChNYXRoLm1heCgxLCBtZWFzdXJlZC53aWR0aCkgKyBzdHlsZS5wYWRkaW5nICogMikgKiByZXNvbHV0aW9uKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5jZWlsKE1hdGgubWF4KDEsIG1lYXN1cmVkLmhlaWdodCkgKyBzdHlsZS5wYWRkaW5nICogMikgKiByZXNvbHV0aW9uKTtcbiAgICBjb25zdCBpbWFnZSA9IGh0bWxUZXh0RGF0YS5pbWFnZTtcbiAgICBpbWFnZS53aWR0aCA9IHdpZHRoIHwgMDtcbiAgICBpbWFnZS5oZWlnaHQgPSBoZWlnaHQgfCAwO1xuICAgIGNvbnN0IHN2Z1VSTCA9IGdldFNWR1VybCh0ZXh0LCBzdHlsZSwgcmVzb2x1dGlvbiwgZm9udENTUywgaHRtbFRleHREYXRhKTtcbiAgICBhd2FpdCBsb2FkU1ZHSW1hZ2UoaW1hZ2UsIHN2Z1VSTCwgaXNTYWZhcmkoKSAmJiBmb250RmFtaWxpZXMubGVuZ3RoID4gMCk7XG4gICAgbGV0IHJlc291cmNlID0gaW1hZ2U7XG4gICAgaWYgKHRoaXMuX2NyZWF0ZUNhbnZhcykge1xuICAgICAgcmVzb3VyY2UgPSBnZXRUZW1wb3JhcnlDYW52YXNGcm9tSW1hZ2UoaW1hZ2UsIHJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0dXJlID0gZ2V0UG8yVGV4dHVyZUZyb21Tb3VyY2UocmVzb3VyY2UsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIHJlc29sdXRpb24pO1xuICAgIGlmICh0aGlzLl9jcmVhdGVDYW52YXMpIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnRleHR1cmUuaW5pdFNvdXJjZSh0ZXh0dXJlLnNvdXJjZSk7XG4gICAgfVxuICAgIEJpZ1Bvb2wucmV0dXJuKGh0bWxUZXh0RGF0YSk7XG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH1cbiAgX2luY3JlYXNlUmVmZXJlbmNlQ291bnQodGV4dEtleSkge1xuICAgIHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldLnVzYWdlQ291bnQrKztcbiAgfVxuICBkZWNyZWFzZVJlZmVyZW5jZUNvdW50KHRleHRLZXkpIHtcbiAgICBjb25zdCBhY3RpdmVUZXh0dXJlID0gdGhpcy5fYWN0aXZlVGV4dHVyZXNbdGV4dEtleV07XG4gICAgaWYgKCFhY3RpdmVUZXh0dXJlKVxuICAgICAgcmV0dXJuO1xuICAgIGFjdGl2ZVRleHR1cmUudXNhZ2VDb3VudC0tO1xuICAgIGlmIChhY3RpdmVUZXh0dXJlLnVzYWdlQ291bnQgPT09IDApIHtcbiAgICAgIGlmIChhY3RpdmVUZXh0dXJlLnRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5fY2xlYW5VcChhY3RpdmVUZXh0dXJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2ZVRleHR1cmUucHJvbWlzZS50aGVuKCh0ZXh0dXJlKSA9PiB7XG4gICAgICAgICAgYWN0aXZlVGV4dHVyZS50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICAgICAgICB0aGlzLl9jbGVhblVwKGFjdGl2ZVRleHR1cmUpO1xuICAgICAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgd2FybihcIkhUTUxUZXh0U3lzdGVtOiBGYWlsZWQgdG8gY2xlYW4gdGV4dHVyZVwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9hY3RpdmVUZXh0dXJlc1t0ZXh0S2V5XSA9IG51bGw7XG4gICAgfVxuICB9XG4gIF9jbGVhblVwKGFjdGl2ZVRleHR1cmUpIHtcbiAgICBUZXh0dXJlUG9vbC5yZXR1cm5UZXh0dXJlKGFjdGl2ZVRleHR1cmUudGV4dHVyZSk7XG4gICAgYWN0aXZlVGV4dHVyZS50ZXh0dXJlLnNvdXJjZS5yZXNvdXJjZSA9IG51bGw7XG4gICAgYWN0aXZlVGV4dHVyZS50ZXh0dXJlLnNvdXJjZS51cGxvYWRNZXRob2RJZCA9IFwidW5rbm93blwiO1xuICB9XG4gIGdldFJlZmVyZW5jZUNvdW50KHRleHRLZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlVGV4dHVyZXNbdGV4dEtleV0udXNhZ2VDb3VudDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX2FjdGl2ZVRleHR1cmVzID0gbnVsbDtcbiAgfVxufVxuLyoqIEBpZ25vcmUgKi9cbkhUTUxUZXh0U3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJodG1sVGV4dFwiXG59O1xuSFRNTFRleHRTeXN0ZW0uZGVmYXVsdEZvbnRPcHRpb25zID0ge1xuICBmb250RmFtaWx5OiBcIkFyaWFsXCIsXG4gIGZvbnRTdHlsZTogXCJub3JtYWxcIixcbiAgZm9udFdlaWdodDogXCJub3JtYWxcIlxufTtcblxuZXhwb3J0IHsgSFRNTFRleHRTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhUTUxUZXh0U3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IGV4dGVuc2lvbnMgfSBmcm9tICcuLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IEhUTUxUZXh0UGlwZSB9IGZyb20gJy4vSFRNTFRleHRQaXBlLm1qcyc7XG5pbXBvcnQgeyBIVE1MVGV4dFN5c3RlbSB9IGZyb20gJy4vSFRNTFRleHRTeXN0ZW0ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5leHRlbnNpb25zLmFkZChIVE1MVGV4dFN5c3RlbSk7XG5leHRlbnNpb25zLmFkZChIVE1MVGV4dFBpcGUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5pdC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7900\n')},3480:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S: () => (/* binding */ getCanvasFillStyle)\n/* harmony export */ });\n/* harmony import */ var _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5536);\n/* harmony import */ var _maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(328);\n/* harmony import */ var _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8518);\n/* harmony import */ var _utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8796);\n/* harmony import */ var _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8208);\n/* harmony import */ var _graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4740);\n\n\n\n\n\n\n\n"use strict";\nfunction getCanvasFillStyle(fillStyle, context) {\n  if (fillStyle.texture === _rendering_renderers_shared_texture_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Texture */ .w.WHITE && !fillStyle.fill) {\n    return _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Color */ .g.shared.setValue(fillStyle.color).toHex();\n  } else if (!fillStyle.fill) {\n    const pattern = context.createPattern(fillStyle.texture.source.resource, "repeat");\n    const tempMatrix = fillStyle.matrix.copyTo(_maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Matrix */ .W.shared);\n    tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n    pattern.setTransform(tempMatrix);\n    return pattern;\n  } else if (fillStyle.fill instanceof _graphics_shared_fill_FillPattern_mjs__WEBPACK_IMPORTED_MODULE_3__/* .FillPattern */ .Q) {\n    const fillPattern = fillStyle.fill;\n    const pattern = context.createPattern(fillPattern.texture.source.resource, "repeat");\n    const tempMatrix = fillPattern.transform.copyTo(_maths_matrix_Matrix_mjs__WEBPACK_IMPORTED_MODULE_2__/* .Matrix */ .W.shared);\n    tempMatrix.scale(\n      fillPattern.texture.frame.width,\n      fillPattern.texture.frame.height\n    );\n    pattern.setTransform(tempMatrix);\n    return pattern;\n  } else if (fillStyle.fill instanceof _graphics_shared_fill_FillGradient_mjs__WEBPACK_IMPORTED_MODULE_4__/* .FillGradient */ .M) {\n    const fillGradient = fillStyle.fill;\n    if (fillGradient.type === "linear") {\n      const gradient = context.createLinearGradient(\n        fillGradient.x0,\n        fillGradient.y0,\n        fillGradient.x1,\n        fillGradient.y1\n      );\n      fillGradient.gradientStops.forEach((stop) => {\n        gradient.addColorStop(stop.offset, _color_Color_mjs__WEBPACK_IMPORTED_MODULE_1__/* .Color */ .g.shared.setValue(stop.color).toHex());\n      });\n      return gradient;\n    }\n  }\n  (0,_utils_logging_warn_mjs__WEBPACK_IMPORTED_MODULE_5__/* .warn */ .m)("FillStyle not recognised", fillStyle);\n  return "red";\n}\n\n\n//# sourceMappingURL=getCanvasFillStyle.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ4MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0Q7QUFDUztBQUN3QjtBQUMzQjtBQUNvQjtBQUNGOztBQUU1RTtBQUNBO0FBQ0EsNEJBQTRCLDZGQUFPO0FBQ25DLFdBQVcsNERBQUs7QUFDaEIsSUFBSTtBQUNKO0FBQ0EsK0NBQStDLHFFQUFNO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLElBQUksbUNBQW1DLHVGQUFXO0FBQ2xEO0FBQ0E7QUFDQSxvREFBb0QscUVBQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtQ0FBbUMseUZBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDREQUFLO0FBQ2hELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxFQUFFLHNFQUFJO0FBQ047QUFDQTs7QUFFOEI7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC9jYW52YXMvdXRpbHMvZ2V0Q2FudmFzRmlsbFN0eWxlLm1qcz9kMzVkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29sb3IvQ29sb3IubWpzJztcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGhzL21hdHJpeC9NYXRyaXgubWpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi8uLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmUubWpzJztcbmltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9sb2dnaW5nL3dhcm4ubWpzJztcbmltcG9ydCB7IEZpbGxHcmFkaWVudCB9IGZyb20gJy4uLy4uLy4uL2dyYXBoaWNzL3NoYXJlZC9maWxsL0ZpbGxHcmFkaWVudC5tanMnO1xuaW1wb3J0IHsgRmlsbFBhdHRlcm4gfSBmcm9tICcuLi8uLi8uLi9ncmFwaGljcy9zaGFyZWQvZmlsbC9GaWxsUGF0dGVybi5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGdldENhbnZhc0ZpbGxTdHlsZShmaWxsU3R5bGUsIGNvbnRleHQpIHtcbiAgaWYgKGZpbGxTdHlsZS50ZXh0dXJlID09PSBUZXh0dXJlLldISVRFICYmICFmaWxsU3R5bGUuZmlsbCkge1xuICAgIHJldHVybiBDb2xvci5zaGFyZWQuc2V0VmFsdWUoZmlsbFN0eWxlLmNvbG9yKS50b0hleCgpO1xuICB9IGVsc2UgaWYgKCFmaWxsU3R5bGUuZmlsbCkge1xuICAgIGNvbnN0IHBhdHRlcm4gPSBjb250ZXh0LmNyZWF0ZVBhdHRlcm4oZmlsbFN0eWxlLnRleHR1cmUuc291cmNlLnJlc291cmNlLCBcInJlcGVhdFwiKTtcbiAgICBjb25zdCB0ZW1wTWF0cml4ID0gZmlsbFN0eWxlLm1hdHJpeC5jb3B5VG8oTWF0cml4LnNoYXJlZCk7XG4gICAgdGVtcE1hdHJpeC5zY2FsZShmaWxsU3R5bGUudGV4dHVyZS5mcmFtZS53aWR0aCwgZmlsbFN0eWxlLnRleHR1cmUuZnJhbWUuaGVpZ2h0KTtcbiAgICBwYXR0ZXJuLnNldFRyYW5zZm9ybSh0ZW1wTWF0cml4KTtcbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfSBlbHNlIGlmIChmaWxsU3R5bGUuZmlsbCBpbnN0YW5jZW9mIEZpbGxQYXR0ZXJuKSB7XG4gICAgY29uc3QgZmlsbFBhdHRlcm4gPSBmaWxsU3R5bGUuZmlsbDtcbiAgICBjb25zdCBwYXR0ZXJuID0gY29udGV4dC5jcmVhdGVQYXR0ZXJuKGZpbGxQYXR0ZXJuLnRleHR1cmUuc291cmNlLnJlc291cmNlLCBcInJlcGVhdFwiKTtcbiAgICBjb25zdCB0ZW1wTWF0cml4ID0gZmlsbFBhdHRlcm4udHJhbnNmb3JtLmNvcHlUbyhNYXRyaXguc2hhcmVkKTtcbiAgICB0ZW1wTWF0cml4LnNjYWxlKFxuICAgICAgZmlsbFBhdHRlcm4udGV4dHVyZS5mcmFtZS53aWR0aCxcbiAgICAgIGZpbGxQYXR0ZXJuLnRleHR1cmUuZnJhbWUuaGVpZ2h0XG4gICAgKTtcbiAgICBwYXR0ZXJuLnNldFRyYW5zZm9ybSh0ZW1wTWF0cml4KTtcbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfSBlbHNlIGlmIChmaWxsU3R5bGUuZmlsbCBpbnN0YW5jZW9mIEZpbGxHcmFkaWVudCkge1xuICAgIGNvbnN0IGZpbGxHcmFkaWVudCA9IGZpbGxTdHlsZS5maWxsO1xuICAgIGlmIChmaWxsR3JhZGllbnQudHlwZSA9PT0gXCJsaW5lYXJcIikge1xuICAgICAgY29uc3QgZ3JhZGllbnQgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KFxuICAgICAgICBmaWxsR3JhZGllbnQueDAsXG4gICAgICAgIGZpbGxHcmFkaWVudC55MCxcbiAgICAgICAgZmlsbEdyYWRpZW50LngxLFxuICAgICAgICBmaWxsR3JhZGllbnQueTFcbiAgICAgICk7XG4gICAgICBmaWxsR3JhZGllbnQuZ3JhZGllbnRTdG9wcy5mb3JFYWNoKChzdG9wKSA9PiB7XG4gICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wLm9mZnNldCwgQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHN0b3AuY29sb3IpLnRvSGV4KCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZ3JhZGllbnQ7XG4gICAgfVxuICB9XG4gIHdhcm4oXCJGaWxsU3R5bGUgbm90IHJlY29nbmlzZWRcIiwgZmlsbFN0eWxlKTtcbiAgcmV0dXJuIFwicmVkXCI7XG59XG5cbmV4cG9ydCB7IGdldENhbnZhc0ZpbGxTdHlsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0Q2FudmFzRmlsbFN0eWxlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3480\n')},6813:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/extensions/Extensions.mjs\nvar Extensions = __webpack_require__(4240);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs\nvar updateQuadBounds = __webpack_require__(1080);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs\nvar PoolGroup = __webpack_require__(2540);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs\nvar BatchableSprite = __webpack_require__(3976);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs\n\n\n\n\n\n"use strict";\nclass CanvasTextPipe {\n  constructor(renderer) {\n    this._gpuText = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    this._renderer.runners.resolutionChange.add(this);\n  }\n  resolutionChange() {\n    for (const i in this._gpuText) {\n      const gpuText = this._gpuText[i];\n      const text = gpuText.batchableSprite.renderable;\n      if (text._autoResolution) {\n        text._resolution = this._renderer.resolution;\n        text.onViewUpdate();\n      }\n    }\n  }\n  validateRenderable(text) {\n    const gpuText = this._getGpuText(text);\n    const newKey = text._getKey();\n    if (gpuText.currentKey !== newKey) {\n      const { width, height } = this._renderer.canvasText.getTextureSize(\n        text.text,\n        text.resolution,\n        text._style\n      );\n      if (\n        // is only being used by this text:\n        this._renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1 && width === gpuText.texture._source.width && height === gpuText.texture._source.height\n      ) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  }\n  addRenderable(text, _instructionSet) {\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (text._didTextUpdate) {\n      this._updateText(text);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableSprite);\n  }\n  updateRenderable(text) {\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (text._didTextUpdate) {\n      this._updateText(text);\n    }\n    batchableSprite.batcher.updateElement(batchableSprite);\n  }\n  destroyRenderable(text) {\n    this._destroyRenderableById(text.uid);\n  }\n  _destroyRenderableById(textUid) {\n    const gpuText = this._gpuText[textUid];\n    this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n    PoolGroup/* BigPool */.u.return(gpuText.batchableSprite);\n    this._gpuText[textUid] = null;\n  }\n  _updateText(text) {\n    const newKey = text._getKey();\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (gpuText.currentKey !== newKey) {\n      this._updateGpuText(text);\n    }\n    text._didTextUpdate = false;\n    const padding = text._style.padding;\n    (0,updateQuadBounds/* updateQuadBounds */.Q)(batchableSprite.bounds, text._anchor, batchableSprite.texture, padding);\n  }\n  _updateGpuText(text) {\n    const gpuText = this._getGpuText(text);\n    const batchableSprite = gpuText.batchableSprite;\n    if (gpuText.texture) {\n      this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n    }\n    gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getManagedTexture(text);\n    gpuText.currentKey = text._getKey();\n    batchableSprite.texture = gpuText.texture;\n  }\n  _getGpuText(text) {\n    return this._gpuText[text.uid] || this.initGpuText(text);\n  }\n  initGpuText(text) {\n    const gpuTextData = {\n      texture: null,\n      currentKey: "--",\n      batchableSprite: PoolGroup/* BigPool */.u.get(BatchableSprite/* BatchableSprite */.a)\n    };\n    gpuTextData.batchableSprite.renderable = text;\n    gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    gpuTextData.batchableSprite.roundPixels = this._renderer._roundPixels | text._roundPixels;\n    this._gpuText[text.uid] = gpuTextData;\n    text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n    this._updateText(text);\n    text.on("destroyed", () => {\n      this.destroyRenderable(text);\n    });\n    return gpuTextData;\n  }\n  destroy() {\n    for (const i in this._gpuText) {\n      this._destroyRenderableById(i);\n    }\n    this._gpuText = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nCanvasTextPipe.extension = {\n  type: [\n    Extensions/* ExtensionType */.y6.WebGLPipes,\n    Extensions/* ExtensionType */.y6.WebGPUPipes,\n    Extensions/* ExtensionType */.y6.CanvasPipes\n  ],\n  name: "text"\n};\n\n\n//# sourceMappingURL=CanvasTextPipe.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/color/Color.mjs + 2 modules\nvar Color = __webpack_require__(5536);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/misc/pow2.mjs\nvar pow2 = __webpack_require__(8152);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs\nvar CanvasPool = __webpack_require__(8168);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs\nvar TexturePool = __webpack_require__(6899);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs\nvar Rectangle = __webpack_require__(5520);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs\n\n\n"use strict";\nfunction checkRow(data, width, y) {\n  for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4) {\n    if (data[index + 3] !== 0)\n      return false;\n  }\n  return true;\n}\nfunction checkColumn(data, width, x, top, bottom) {\n  const stride = 4 * width;\n  for (let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride) {\n    if (data[index + 3] !== 0)\n      return false;\n  }\n  return true;\n}\nfunction getCanvasBoundingBox(canvas, resolution = 1) {\n  const { width, height } = canvas;\n  const context = canvas.getContext("2d", {\n    willReadFrequently: true\n  });\n  if (context === null) {\n    throw new TypeError("Failed to get canvas 2D context");\n  }\n  const imageData = context.getImageData(0, 0, width, height);\n  const data = imageData.data;\n  let left = 0;\n  let top = 0;\n  let right = width - 1;\n  let bottom = height - 1;\n  while (top < height && checkRow(data, width, top))\n    ++top;\n  if (top === height)\n    return Rectangle/* Rectangle */.Y.EMPTY;\n  while (checkRow(data, width, bottom))\n    --bottom;\n  while (checkColumn(data, width, left, top, bottom))\n    ++left;\n  while (checkColumn(data, width, right, top, bottom))\n    --right;\n  ++right;\n  ++bottom;\n  return new Rectangle/* Rectangle */.Y(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n}\n\n\n//# sourceMappingURL=getCanvasBoundingBox.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/utils/logging/deprecation.mjs\nvar deprecation = __webpack_require__(8592);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/TextStyle.mjs\nvar TextStyle = __webpack_require__(9920);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs\nvar getPo2TextureFromSource = __webpack_require__(7080);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs\nvar CanvasTextMetrics = __webpack_require__(3768);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs\nvar fontStringFromTextStyle = __webpack_require__(5844);\n// EXTERNAL MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs\nvar getCanvasFillStyle = __webpack_require__(3480);\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n"use strict";\nclass CanvasTextSystem {\n  constructor(_renderer) {\n    this._activeTextures = {};\n    this._renderer = _renderer;\n  }\n  getTextureSize(text, resolution, style) {\n    const measured = CanvasTextMetrics/* CanvasTextMetrics */.y.measureText(text || " ", style);\n    let width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    let height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    width = Math.ceil(width - 1e-6);\n    height = Math.ceil(height - 1e-6);\n    width = (0,pow2/* nextPow2 */.W8)(width);\n    height = (0,pow2/* nextPow2 */.W8)(height);\n    return { width, height };\n  }\n  getTexture(options, resolution, style, _textKey) {\n    if (typeof options === "string") {\n      (0,deprecation/* deprecation */.e)("8.0.0", "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments");\n      options = {\n        text: options,\n        style,\n        resolution\n      };\n    }\n    if (!(options.style instanceof TextStyle/* TextStyle */.I)) {\n      options.style = new TextStyle/* TextStyle */.I(options.style);\n    }\n    const { texture, canvasAndContext } = this.createTextureAndCanvas(\n      options\n    );\n    this._renderer.texture.initSource(texture._source);\n    CanvasPool/* CanvasPool */.G.returnCanvasAndContext(canvasAndContext);\n    return texture;\n  }\n  createTextureAndCanvas(options) {\n    const { text, style } = options;\n    const resolution = options.resolution ?? this._renderer.resolution;\n    const measured = CanvasTextMetrics/* CanvasTextMetrics */.y.measureText(text || " ", style);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    const canvasAndContext = CanvasPool/* CanvasPool */.G.getOptimalCanvasAndContext(width, height);\n    const { canvas } = canvasAndContext;\n    this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n    const texture = (0,getPo2TextureFromSource/* getPo2TextureFromSource */.s)(canvas, width, height, resolution);\n    if (style.trim) {\n      const trimmed = getCanvasBoundingBox(canvas, resolution);\n      texture.frame.copyFrom(trimmed);\n      texture.updateUvs();\n    }\n    return { texture, canvasAndContext };\n  }\n  getManagedTexture(text) {\n    text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n    const textKey = text._getKey();\n    if (this._activeTextures[textKey]) {\n      this._increaseReferenceCount(textKey);\n      return this._activeTextures[textKey].texture;\n    }\n    const { texture, canvasAndContext } = this.createTextureAndCanvas(text);\n    this._activeTextures[textKey] = {\n      canvasAndContext,\n      texture,\n      usageCount: 1\n    };\n    return texture;\n  }\n  _increaseReferenceCount(textKey) {\n    this._activeTextures[textKey].usageCount++;\n  }\n  decreaseReferenceCount(textKey) {\n    const activeTexture = this._activeTextures[textKey];\n    activeTexture.usageCount--;\n    if (activeTexture.usageCount === 0) {\n      CanvasPool/* CanvasPool */.G.returnCanvasAndContext(activeTexture.canvasAndContext);\n      TexturePool/* TexturePool */.W.returnTexture(activeTexture.texture);\n      const source = activeTexture.texture.source;\n      source.resource = null;\n      source.uploadMethodId = "unknown";\n      source.alphaMode = "no-premultiply-alpha";\n      this._activeTextures[textKey] = null;\n    }\n  }\n  getReferenceCount(textKey) {\n    return this._activeTextures[textKey].usageCount;\n  }\n  /**\n   * Renders text to its canvas, and updates its texture.\n   *\n   * By default this is used internally to ensure the texture is correct before rendering,\n   * but it can be used called externally, for example from this class to \'pre-generate\' the texture from a piece of text,\n   * and then shared across multiple Sprites.\n   * @param text\n   * @param style\n   * @param resolution\n   * @param canvasAndContext\n   */\n  renderTextToCanvas(text, style, resolution, canvasAndContext) {\n    const { canvas, context } = canvasAndContext;\n    const font = (0,fontStringFromTextStyle/* fontStringFromTextStyle */.y)(style);\n    const measured = CanvasTextMetrics/* CanvasTextMetrics */.y.measureText(text || " ", style);\n    const lines = measured.lines;\n    const lineHeight = measured.lineHeight;\n    const lineWidths = measured.lineWidths;\n    const maxLineWidth = measured.maxLineWidth;\n    const fontProperties = measured.fontProperties;\n    const height = canvas.height;\n    context.resetTransform();\n    context.scale(resolution, resolution);\n    const padding = style.padding * 2;\n    context.clearRect(0, 0, measured.width + 4 + padding, measured.height + 4 + padding);\n    if (style._stroke?.width) {\n      const strokeStyle = style._stroke;\n      context.lineWidth = strokeStyle.width;\n      context.miterLimit = strokeStyle.miterLimit;\n      context.lineJoin = strokeStyle.join;\n      context.lineCap = strokeStyle.cap;\n    }\n    context.font = font;\n    let linePositionX;\n    let linePositionY;\n    const passesCount = style.dropShadow ? 2 : 1;\n    for (let i = 0; i < passesCount; ++i) {\n      const isShadowPass = style.dropShadow && i === 0;\n      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;\n      const dsOffsetShadow = dsOffsetText * resolution;\n      if (isShadowPass) {\n        context.fillStyle = "black";\n        context.strokeStyle = "black";\n        const shadowOptions = style.dropShadow;\n        const dropShadowColor = shadowOptions.color;\n        const dropShadowAlpha = shadowOptions.alpha;\n        context.shadowColor = Color/* Color */.g.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();\n        const dropShadowBlur = shadowOptions.blur * resolution;\n        const dropShadowDistance = shadowOptions.distance * resolution;\n        context.shadowBlur = dropShadowBlur;\n        context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n        context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;\n      } else {\n        context.globalAlpha = style._fill?.alpha ?? 1;\n        context.fillStyle = style._fill ? (0,getCanvasFillStyle/* getCanvasFillStyle */.S)(style._fill, context) : null;\n        if (style._stroke?.width) {\n          context.strokeStyle = (0,getCanvasFillStyle/* getCanvasFillStyle */.S)(style._stroke, context);\n        }\n        context.shadowColor = "black";\n      }\n      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n      if (lineHeight - fontProperties.fontSize < 0) {\n        linePositionYShift = 0;\n      }\n      const strokeWidth = style._stroke?.width ?? 0;\n      for (let i2 = 0; i2 < lines.length; i2++) {\n        linePositionX = strokeWidth / 2;\n        linePositionY = strokeWidth / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;\n        if (style.align === "right") {\n          linePositionX += maxLineWidth - lineWidths[i2];\n        } else if (style.align === "center") {\n          linePositionX += (maxLineWidth - lineWidths[i2]) / 2;\n        }\n        if (style._stroke?.width) {\n          this._drawLetterSpacing(\n            lines[i2],\n            style,\n            canvasAndContext,\n            linePositionX + style.padding,\n            linePositionY + style.padding - dsOffsetText,\n            true\n          );\n        }\n        if (style._fill !== void 0) {\n          this._drawLetterSpacing(\n            lines[i2],\n            style,\n            canvasAndContext,\n            linePositionX + style.padding,\n            linePositionY + style.padding - dsOffsetText\n          );\n        }\n      }\n    }\n  }\n  /**\n   * Render the text with letter-spacing.\n   * @param text - The text to draw\n   * @param style\n   * @param canvasAndContext\n   * @param x - Horizontal position to draw the text\n   * @param y - Vertical position to draw the text\n   * @param isStroke - Is this drawing for the outside stroke of the\n   *  text? If not, it\'s for the inside fill\n   */\n  _drawLetterSpacing(text, style, canvasAndContext, x, y, isStroke = false) {\n    const { context } = canvasAndContext;\n    const letterSpacing = style.letterSpacing;\n    let useExperimentalLetterSpacing = false;\n    if (CanvasTextMetrics/* CanvasTextMetrics */.y.experimentalLetterSpacingSupported) {\n      if (CanvasTextMetrics/* CanvasTextMetrics */.y.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = "0px";\n        context.textLetterSpacing = "0px";\n      }\n    }\n    if (letterSpacing === 0 || useExperimentalLetterSpacing) {\n      if (isStroke) {\n        context.strokeText(text, x, y);\n      } else {\n        context.fillText(text, x, y);\n      }\n      return;\n    }\n    let currentPosition = x;\n    const stringArray = CanvasTextMetrics/* CanvasTextMetrics */.y.graphemeSegmenter(text);\n    let previousWidth = context.measureText(text).width;\n    let currentWidth = 0;\n    for (let i = 0; i < stringArray.length; ++i) {\n      const currentChar = stringArray[i];\n      if (isStroke) {\n        context.strokeText(currentChar, currentPosition, y);\n      } else {\n        context.fillText(currentChar, currentPosition, y);\n      }\n      let textStr = "";\n      for (let j = i + 1; j < stringArray.length; ++j) {\n        textStr += stringArray[j];\n      }\n      currentWidth = context.measureText(textStr).width;\n      currentPosition += previousWidth - currentWidth + letterSpacing;\n      previousWidth = currentWidth;\n    }\n  }\n  destroy() {\n    this._activeTextures = null;\n  }\n}\n/** @ignore */\nCanvasTextSystem.extension = {\n  type: [\n    Extensions/* ExtensionType */.y6.WebGLSystem,\n    Extensions/* ExtensionType */.y6.WebGPUSystem,\n    Extensions/* ExtensionType */.y6.CanvasSystem\n  ],\n  name: "canvasText"\n};\n\n\n//# sourceMappingURL=CanvasTextSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/scene/text/init.mjs\n\n\n\n\n"use strict";\nExtensions/* extensions */.Yt.add(CanvasTextSystem);\nExtensions/* extensions */.Yt.add(CanvasTextPipe);\n//# sourceMappingURL=init.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQSx3QkFBd0IsMENBQWlCO0FBQ3pDO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0JBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdDQUFhO0FBQ2pCLElBQUksZ0NBQWE7QUFDakIsSUFBSSxnQ0FBYTtBQUNqQjtBQUNBO0FBQ0E7O0FBRTRCO0FBQzVCOzs7QUNyUTZEO0FBQ0E7QUFDSTs7QUFFakU7QUFDQSw2QkFBVSxLQUFLLGdCQUFnQjtBQUMvQiw2QkFBVSxLQUFLLGNBQWM7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC9jYW52YXMvQ2FudmFzVGV4dFBpcGUubWpzPzM4MWQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3V0aWxzL2NhbnZhcy9nZXRDYW52YXNCb3VuZGluZ0JveC5tanM/OTE0YyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC9jYW52YXMvQ2FudmFzVGV4dFN5c3RlbS5tanM/ZmE0OSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvc2NlbmUvdGV4dC9pbml0Lm1qcz9iZTlhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvblR5cGUgfSBmcm9tICcuLi8uLi8uLi9leHRlbnNpb25zL0V4dGVuc2lvbnMubWpzJztcbmltcG9ydCB7IHVwZGF0ZVF1YWRCb3VuZHMgfSBmcm9tICcuLi8uLi8uLi91dGlscy9kYXRhL3VwZGF0ZVF1YWRCb3VuZHMubWpzJztcbmltcG9ydCB7IEJpZ1Bvb2wgfSBmcm9tICcuLi8uLi8uLi91dGlscy9wb29sL1Bvb2xHcm91cC5tanMnO1xuaW1wb3J0IHsgQmF0Y2hhYmxlU3ByaXRlIH0gZnJvbSAnLi4vLi4vc3ByaXRlL0JhdGNoYWJsZVNwcml0ZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNsYXNzIENhbnZhc1RleHRQaXBlIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9ncHVUZXh0ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLl9yZW5kZXJlci5ydW5uZXJzLnJlc29sdXRpb25DaGFuZ2UuYWRkKHRoaXMpO1xuICB9XG4gIHJlc29sdXRpb25DaGFuZ2UoKSB7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2dwdVRleHQpIHtcbiAgICAgIGNvbnN0IGdwdVRleHQgPSB0aGlzLl9ncHVUZXh0W2ldO1xuICAgICAgY29uc3QgdGV4dCA9IGdwdVRleHQuYmF0Y2hhYmxlU3ByaXRlLnJlbmRlcmFibGU7XG4gICAgICBpZiAodGV4dC5fYXV0b1Jlc29sdXRpb24pIHtcbiAgICAgICAgdGV4dC5fcmVzb2x1dGlvbiA9IHRoaXMuX3JlbmRlcmVyLnJlc29sdXRpb247XG4gICAgICAgIHRleHQub25WaWV3VXBkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhbGlkYXRlUmVuZGVyYWJsZSh0ZXh0KSB7XG4gICAgY29uc3QgZ3B1VGV4dCA9IHRoaXMuX2dldEdwdVRleHQodGV4dCk7XG4gICAgY29uc3QgbmV3S2V5ID0gdGV4dC5fZ2V0S2V5KCk7XG4gICAgaWYgKGdwdVRleHQuY3VycmVudEtleSAhPT0gbmV3S2V5KSB7XG4gICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuX3JlbmRlcmVyLmNhbnZhc1RleHQuZ2V0VGV4dHVyZVNpemUoXG4gICAgICAgIHRleHQudGV4dCxcbiAgICAgICAgdGV4dC5yZXNvbHV0aW9uLFxuICAgICAgICB0ZXh0Ll9zdHlsZVxuICAgICAgKTtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gaXMgb25seSBiZWluZyB1c2VkIGJ5IHRoaXMgdGV4dDpcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuY2FudmFzVGV4dC5nZXRSZWZlcmVuY2VDb3VudChncHVUZXh0LmN1cnJlbnRLZXkpID09PSAxICYmIHdpZHRoID09PSBncHVUZXh0LnRleHR1cmUuX3NvdXJjZS53aWR0aCAmJiBoZWlnaHQgPT09IGdwdVRleHQudGV4dHVyZS5fc291cmNlLmhlaWdodFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYWRkUmVuZGVyYWJsZSh0ZXh0LCBfaW5zdHJ1Y3Rpb25TZXQpIHtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ2V0R3B1VGV4dCh0ZXh0KTtcbiAgICBjb25zdCBiYXRjaGFibGVTcHJpdGUgPSBncHVUZXh0LmJhdGNoYWJsZVNwcml0ZTtcbiAgICBpZiAodGV4dC5fZGlkVGV4dFVwZGF0ZSkge1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dCh0ZXh0KTtcbiAgICB9XG4gICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyUGlwZXMuYmF0Y2guYWRkVG9CYXRjaChiYXRjaGFibGVTcHJpdGUpO1xuICB9XG4gIHVwZGF0ZVJlbmRlcmFibGUodGV4dCkge1xuICAgIGNvbnN0IGdwdVRleHQgPSB0aGlzLl9nZXRHcHVUZXh0KHRleHQpO1xuICAgIGNvbnN0IGJhdGNoYWJsZVNwcml0ZSA9IGdwdVRleHQuYmF0Y2hhYmxlU3ByaXRlO1xuICAgIGlmICh0ZXh0Ll9kaWRUZXh0VXBkYXRlKSB7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0KHRleHQpO1xuICAgIH1cbiAgICBiYXRjaGFibGVTcHJpdGUuYmF0Y2hlci51cGRhdGVFbGVtZW50KGJhdGNoYWJsZVNwcml0ZSk7XG4gIH1cbiAgZGVzdHJveVJlbmRlcmFibGUodGV4dCkge1xuICAgIHRoaXMuX2Rlc3Ryb3lSZW5kZXJhYmxlQnlJZCh0ZXh0LnVpZCk7XG4gIH1cbiAgX2Rlc3Ryb3lSZW5kZXJhYmxlQnlJZCh0ZXh0VWlkKSB7XG4gICAgY29uc3QgZ3B1VGV4dCA9IHRoaXMuX2dwdVRleHRbdGV4dFVpZF07XG4gICAgdGhpcy5fcmVuZGVyZXIuY2FudmFzVGV4dC5kZWNyZWFzZVJlZmVyZW5jZUNvdW50KGdwdVRleHQuY3VycmVudEtleSk7XG4gICAgQmlnUG9vbC5yZXR1cm4oZ3B1VGV4dC5iYXRjaGFibGVTcHJpdGUpO1xuICAgIHRoaXMuX2dwdVRleHRbdGV4dFVpZF0gPSBudWxsO1xuICB9XG4gIF91cGRhdGVUZXh0KHRleHQpIHtcbiAgICBjb25zdCBuZXdLZXkgPSB0ZXh0Ll9nZXRLZXkoKTtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ2V0R3B1VGV4dCh0ZXh0KTtcbiAgICBjb25zdCBiYXRjaGFibGVTcHJpdGUgPSBncHVUZXh0LmJhdGNoYWJsZVNwcml0ZTtcbiAgICBpZiAoZ3B1VGV4dC5jdXJyZW50S2V5ICE9PSBuZXdLZXkpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUdwdVRleHQodGV4dCk7XG4gICAgfVxuICAgIHRleHQuX2RpZFRleHRVcGRhdGUgPSBmYWxzZTtcbiAgICBjb25zdCBwYWRkaW5nID0gdGV4dC5fc3R5bGUucGFkZGluZztcbiAgICB1cGRhdGVRdWFkQm91bmRzKGJhdGNoYWJsZVNwcml0ZS5ib3VuZHMsIHRleHQuX2FuY2hvciwgYmF0Y2hhYmxlU3ByaXRlLnRleHR1cmUsIHBhZGRpbmcpO1xuICB9XG4gIF91cGRhdGVHcHVUZXh0KHRleHQpIHtcbiAgICBjb25zdCBncHVUZXh0ID0gdGhpcy5fZ2V0R3B1VGV4dCh0ZXh0KTtcbiAgICBjb25zdCBiYXRjaGFibGVTcHJpdGUgPSBncHVUZXh0LmJhdGNoYWJsZVNwcml0ZTtcbiAgICBpZiAoZ3B1VGV4dC50ZXh0dXJlKSB7XG4gICAgICB0aGlzLl9yZW5kZXJlci5jYW52YXNUZXh0LmRlY3JlYXNlUmVmZXJlbmNlQ291bnQoZ3B1VGV4dC5jdXJyZW50S2V5KTtcbiAgICB9XG4gICAgZ3B1VGV4dC50ZXh0dXJlID0gYmF0Y2hhYmxlU3ByaXRlLnRleHR1cmUgPSB0aGlzLl9yZW5kZXJlci5jYW52YXNUZXh0LmdldE1hbmFnZWRUZXh0dXJlKHRleHQpO1xuICAgIGdwdVRleHQuY3VycmVudEtleSA9IHRleHQuX2dldEtleSgpO1xuICAgIGJhdGNoYWJsZVNwcml0ZS50ZXh0dXJlID0gZ3B1VGV4dC50ZXh0dXJlO1xuICB9XG4gIF9nZXRHcHVUZXh0KHRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3B1VGV4dFt0ZXh0LnVpZF0gfHwgdGhpcy5pbml0R3B1VGV4dCh0ZXh0KTtcbiAgfVxuICBpbml0R3B1VGV4dCh0ZXh0KSB7XG4gICAgY29uc3QgZ3B1VGV4dERhdGEgPSB7XG4gICAgICB0ZXh0dXJlOiBudWxsLFxuICAgICAgY3VycmVudEtleTogXCItLVwiLFxuICAgICAgYmF0Y2hhYmxlU3ByaXRlOiBCaWdQb29sLmdldChCYXRjaGFibGVTcHJpdGUpXG4gICAgfTtcbiAgICBncHVUZXh0RGF0YS5iYXRjaGFibGVTcHJpdGUucmVuZGVyYWJsZSA9IHRleHQ7XG4gICAgZ3B1VGV4dERhdGEuYmF0Y2hhYmxlU3ByaXRlLmJvdW5kcyA9IHsgbWluWDogMCwgbWF4WDogMSwgbWluWTogMCwgbWF4WTogMCB9O1xuICAgIGdwdVRleHREYXRhLmJhdGNoYWJsZVNwcml0ZS5yb3VuZFBpeGVscyA9IHRoaXMuX3JlbmRlcmVyLl9yb3VuZFBpeGVscyB8IHRleHQuX3JvdW5kUGl4ZWxzO1xuICAgIHRoaXMuX2dwdVRleHRbdGV4dC51aWRdID0gZ3B1VGV4dERhdGE7XG4gICAgdGV4dC5fcmVzb2x1dGlvbiA9IHRleHQuX2F1dG9SZXNvbHV0aW9uID8gdGhpcy5fcmVuZGVyZXIucmVzb2x1dGlvbiA6IHRleHQucmVzb2x1dGlvbjtcbiAgICB0aGlzLl91cGRhdGVUZXh0KHRleHQpO1xuICAgIHRleHQub24oXCJkZXN0cm95ZWRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5kZXN0cm95UmVuZGVyYWJsZSh0ZXh0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZ3B1VGV4dERhdGE7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5fZ3B1VGV4dCkge1xuICAgICAgdGhpcy5fZGVzdHJveVJlbmRlcmFibGVCeUlkKGkpO1xuICAgIH1cbiAgICB0aGlzLl9ncHVUZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5DYW52YXNUZXh0UGlwZS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLldlYkdMUGlwZXMsXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVQaXBlcyxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1BpcGVzXG4gIF0sXG4gIG5hbWU6IFwidGV4dFwiXG59O1xuXG5leHBvcnQgeyBDYW52YXNUZXh0UGlwZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FudmFzVGV4dFBpcGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi4vLi4vbWF0aHMvc2hhcGVzL1JlY3RhbmdsZS5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGNoZWNrUm93KGRhdGEsIHdpZHRoLCB5KSB7XG4gIGZvciAobGV0IHggPSAwLCBpbmRleCA9IDQgKiB5ICogd2lkdGg7IHggPCB3aWR0aDsgKyt4LCBpbmRleCArPSA0KSB7XG4gICAgaWYgKGRhdGFbaW5kZXggKyAzXSAhPT0gMClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrQ29sdW1uKGRhdGEsIHdpZHRoLCB4LCB0b3AsIGJvdHRvbSkge1xuICBjb25zdCBzdHJpZGUgPSA0ICogd2lkdGg7XG4gIGZvciAobGV0IHkgPSB0b3AsIGluZGV4ID0gdG9wICogc3RyaWRlICsgNCAqIHg7IHkgPD0gYm90dG9tOyArK3ksIGluZGV4ICs9IHN0cmlkZSkge1xuICAgIGlmIChkYXRhW2luZGV4ICsgM10gIT09IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRDYW52YXNCb3VuZGluZ0JveChjYW52YXMsIHJlc29sdXRpb24gPSAxKSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY2FudmFzO1xuICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlXG4gIH0pO1xuICBpZiAoY29udGV4dCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gZ2V0IGNhbnZhcyAyRCBjb250ZXh0XCIpO1xuICB9XG4gIGNvbnN0IGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICBjb25zdCBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG4gIGxldCBsZWZ0ID0gMDtcbiAgbGV0IHRvcCA9IDA7XG4gIGxldCByaWdodCA9IHdpZHRoIC0gMTtcbiAgbGV0IGJvdHRvbSA9IGhlaWdodCAtIDE7XG4gIHdoaWxlICh0b3AgPCBoZWlnaHQgJiYgY2hlY2tSb3coZGF0YSwgd2lkdGgsIHRvcCkpXG4gICAgKyt0b3A7XG4gIGlmICh0b3AgPT09IGhlaWdodClcbiAgICByZXR1cm4gUmVjdGFuZ2xlLkVNUFRZO1xuICB3aGlsZSAoY2hlY2tSb3coZGF0YSwgd2lkdGgsIGJvdHRvbSkpXG4gICAgLS1ib3R0b207XG4gIHdoaWxlIChjaGVja0NvbHVtbihkYXRhLCB3aWR0aCwgbGVmdCwgdG9wLCBib3R0b20pKVxuICAgICsrbGVmdDtcbiAgd2hpbGUgKGNoZWNrQ29sdW1uKGRhdGEsIHdpZHRoLCByaWdodCwgdG9wLCBib3R0b20pKVxuICAgIC0tcmlnaHQ7XG4gICsrcmlnaHQ7XG4gICsrYm90dG9tO1xuICByZXR1cm4gbmV3IFJlY3RhbmdsZShsZWZ0IC8gcmVzb2x1dGlvbiwgdG9wIC8gcmVzb2x1dGlvbiwgKHJpZ2h0IC0gbGVmdCkgLyByZXNvbHV0aW9uLCAoYm90dG9tIC0gdG9wKSAvIHJlc29sdXRpb24pO1xufVxuXG5leHBvcnQgeyBnZXRDYW52YXNCb3VuZGluZ0JveCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0Q2FudmFzQm91bmRpbmdCb3gubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi8uLi9jb2xvci9Db2xvci5tanMnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgbmV4dFBvdzIgfSBmcm9tICcuLi8uLi8uLi9tYXRocy9taXNjL3BvdzIubWpzJztcbmltcG9ydCB7IENhbnZhc1Bvb2wgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL0NhbnZhc1Bvb2wubWpzJztcbmltcG9ydCB7IFRleHR1cmVQb29sIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyaW5nL3JlbmRlcmVycy9zaGFyZWQvdGV4dHVyZS9UZXh0dXJlUG9vbC5tanMnO1xuaW1wb3J0IHsgZ2V0Q2FudmFzQm91bmRpbmdCb3ggfSBmcm9tICcuLi8uLi8uLi91dGlscy9jYW52YXMvZ2V0Q2FudmFzQm91bmRpbmdCb3gubWpzJztcbmltcG9ydCB7IGRlcHJlY2F0aW9uIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvbG9nZ2luZy9kZXByZWNhdGlvbi5tanMnO1xuaW1wb3J0IHsgVGV4dFN0eWxlIH0gZnJvbSAnLi4vVGV4dFN0eWxlLm1qcyc7XG5pbXBvcnQgeyBnZXRQbzJUZXh0dXJlRnJvbVNvdXJjZSB9IGZyb20gJy4uL3V0aWxzL2dldFBvMlRleHR1cmVGcm9tU291cmNlLm1qcyc7XG5pbXBvcnQgeyBDYW52YXNUZXh0TWV0cmljcyB9IGZyb20gJy4vQ2FudmFzVGV4dE1ldHJpY3MubWpzJztcbmltcG9ydCB7IGZvbnRTdHJpbmdGcm9tVGV4dFN0eWxlIH0gZnJvbSAnLi91dGlscy9mb250U3RyaW5nRnJvbVRleHRTdHlsZS5tanMnO1xuaW1wb3J0IHsgZ2V0Q2FudmFzRmlsbFN0eWxlIH0gZnJvbSAnLi91dGlscy9nZXRDYW52YXNGaWxsU3R5bGUubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBDYW52YXNUZXh0U3lzdGVtIHtcbiAgY29uc3RydWN0b3IoX3JlbmRlcmVyKSB7XG4gICAgdGhpcy5fYWN0aXZlVGV4dHVyZXMgPSB7fTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgfVxuICBnZXRUZXh0dXJlU2l6ZSh0ZXh0LCByZXNvbHV0aW9uLCBzdHlsZSkge1xuICAgIGNvbnN0IG1lYXN1cmVkID0gQ2FudmFzVGV4dE1ldHJpY3MubWVhc3VyZVRleHQodGV4dCB8fCBcIiBcIiwgc3R5bGUpO1xuICAgIGxldCB3aWR0aCA9IE1hdGguY2VpbChNYXRoLmNlaWwoTWF0aC5tYXgoMSwgbWVhc3VyZWQud2lkdGgpICsgc3R5bGUucGFkZGluZyAqIDIpICogcmVzb2x1dGlvbik7XG4gICAgbGV0IGhlaWdodCA9IE1hdGguY2VpbChNYXRoLmNlaWwoTWF0aC5tYXgoMSwgbWVhc3VyZWQuaGVpZ2h0KSArIHN0eWxlLnBhZGRpbmcgKiAyKSAqIHJlc29sdXRpb24pO1xuICAgIHdpZHRoID0gTWF0aC5jZWlsKHdpZHRoIC0gMWUtNik7XG4gICAgaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCAtIDFlLTYpO1xuICAgIHdpZHRoID0gbmV4dFBvdzIod2lkdGgpO1xuICAgIGhlaWdodCA9IG5leHRQb3cyKGhlaWdodCk7XG4gICAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCB9O1xuICB9XG4gIGdldFRleHR1cmUob3B0aW9ucywgcmVzb2x1dGlvbiwgc3R5bGUsIF90ZXh0S2V5KSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBkZXByZWNhdGlvbihcIjguMC4wXCIsIFwiQ2FudmFzVGV4dFN5c3RlbS5nZXRUZXh0dXJlOiBVc2Ugb2JqZWN0IFRleHRPcHRpb25zIGluc3RlYWQgb2Ygc2VwYXJhdGUgYXJndW1lbnRzXCIpO1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgdGV4dDogb3B0aW9ucyxcbiAgICAgICAgc3R5bGUsXG4gICAgICAgIHJlc29sdXRpb25cbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghKG9wdGlvbnMuc3R5bGUgaW5zdGFuY2VvZiBUZXh0U3R5bGUpKSB7XG4gICAgICBvcHRpb25zLnN0eWxlID0gbmV3IFRleHRTdHlsZShvcHRpb25zLnN0eWxlKTtcbiAgICB9XG4gICAgY29uc3QgeyB0ZXh0dXJlLCBjYW52YXNBbmRDb250ZXh0IH0gPSB0aGlzLmNyZWF0ZVRleHR1cmVBbmRDYW52YXMoXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICB0aGlzLl9yZW5kZXJlci50ZXh0dXJlLmluaXRTb3VyY2UodGV4dHVyZS5fc291cmNlKTtcbiAgICBDYW52YXNQb29sLnJldHVybkNhbnZhc0FuZENvbnRleHQoY2FudmFzQW5kQ29udGV4dCk7XG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH1cbiAgY3JlYXRlVGV4dHVyZUFuZENhbnZhcyhvcHRpb25zKSB7XG4gICAgY29uc3QgeyB0ZXh0LCBzdHlsZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCByZXNvbHV0aW9uID0gb3B0aW9ucy5yZXNvbHV0aW9uID8/IHRoaXMuX3JlbmRlcmVyLnJlc29sdXRpb247XG4gICAgY29uc3QgbWVhc3VyZWQgPSBDYW52YXNUZXh0TWV0cmljcy5tZWFzdXJlVGV4dCh0ZXh0IHx8IFwiIFwiLCBzdHlsZSk7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLmNlaWwoTWF0aC5jZWlsKE1hdGgubWF4KDEsIG1lYXN1cmVkLndpZHRoKSArIHN0eWxlLnBhZGRpbmcgKiAyKSAqIHJlc29sdXRpb24pO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGguY2VpbChNYXRoLmNlaWwoTWF0aC5tYXgoMSwgbWVhc3VyZWQuaGVpZ2h0KSArIHN0eWxlLnBhZGRpbmcgKiAyKSAqIHJlc29sdXRpb24pO1xuICAgIGNvbnN0IGNhbnZhc0FuZENvbnRleHQgPSBDYW52YXNQb29sLmdldE9wdGltYWxDYW52YXNBbmRDb250ZXh0KHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHsgY2FudmFzIH0gPSBjYW52YXNBbmRDb250ZXh0O1xuICAgIHRoaXMucmVuZGVyVGV4dFRvQ2FudmFzKHRleHQsIHN0eWxlLCByZXNvbHV0aW9uLCBjYW52YXNBbmRDb250ZXh0KTtcbiAgICBjb25zdCB0ZXh0dXJlID0gZ2V0UG8yVGV4dHVyZUZyb21Tb3VyY2UoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uKTtcbiAgICBpZiAoc3R5bGUudHJpbSkge1xuICAgICAgY29uc3QgdHJpbW1lZCA9IGdldENhbnZhc0JvdW5kaW5nQm94KGNhbnZhcywgcmVzb2x1dGlvbik7XG4gICAgICB0ZXh0dXJlLmZyYW1lLmNvcHlGcm9tKHRyaW1tZWQpO1xuICAgICAgdGV4dHVyZS51cGRhdGVVdnMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdGV4dHVyZSwgY2FudmFzQW5kQ29udGV4dCB9O1xuICB9XG4gIGdldE1hbmFnZWRUZXh0dXJlKHRleHQpIHtcbiAgICB0ZXh0Ll9yZXNvbHV0aW9uID0gdGV4dC5fYXV0b1Jlc29sdXRpb24gPyB0aGlzLl9yZW5kZXJlci5yZXNvbHV0aW9uIDogdGV4dC5yZXNvbHV0aW9uO1xuICAgIGNvbnN0IHRleHRLZXkgPSB0ZXh0Ll9nZXRLZXkoKTtcbiAgICBpZiAodGhpcy5fYWN0aXZlVGV4dHVyZXNbdGV4dEtleV0pIHtcbiAgICAgIHRoaXMuX2luY3JlYXNlUmVmZXJlbmNlQ291bnQodGV4dEtleSk7XG4gICAgICByZXR1cm4gdGhpcy5fYWN0aXZlVGV4dHVyZXNbdGV4dEtleV0udGV4dHVyZTtcbiAgICB9XG4gICAgY29uc3QgeyB0ZXh0dXJlLCBjYW52YXNBbmRDb250ZXh0IH0gPSB0aGlzLmNyZWF0ZVRleHR1cmVBbmRDYW52YXModGV4dCk7XG4gICAgdGhpcy5fYWN0aXZlVGV4dHVyZXNbdGV4dEtleV0gPSB7XG4gICAgICBjYW52YXNBbmRDb250ZXh0LFxuICAgICAgdGV4dHVyZSxcbiAgICAgIHVzYWdlQ291bnQ6IDFcbiAgICB9O1xuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9XG4gIF9pbmNyZWFzZVJlZmVyZW5jZUNvdW50KHRleHRLZXkpIHtcbiAgICB0aGlzLl9hY3RpdmVUZXh0dXJlc1t0ZXh0S2V5XS51c2FnZUNvdW50Kys7XG4gIH1cbiAgZGVjcmVhc2VSZWZlcmVuY2VDb3VudCh0ZXh0S2V5KSB7XG4gICAgY29uc3QgYWN0aXZlVGV4dHVyZSA9IHRoaXMuX2FjdGl2ZVRleHR1cmVzW3RleHRLZXldO1xuICAgIGFjdGl2ZVRleHR1cmUudXNhZ2VDb3VudC0tO1xuICAgIGlmIChhY3RpdmVUZXh0dXJlLnVzYWdlQ291bnQgPT09IDApIHtcbiAgICAgIENhbnZhc1Bvb2wucmV0dXJuQ2FudmFzQW5kQ29udGV4dChhY3RpdmVUZXh0dXJlLmNhbnZhc0FuZENvbnRleHQpO1xuICAgICAgVGV4dHVyZVBvb2wucmV0dXJuVGV4dHVyZShhY3RpdmVUZXh0dXJlLnRleHR1cmUpO1xuICAgICAgY29uc3Qgc291cmNlID0gYWN0aXZlVGV4dHVyZS50ZXh0dXJlLnNvdXJjZTtcbiAgICAgIHNvdXJjZS5yZXNvdXJjZSA9IG51bGw7XG4gICAgICBzb3VyY2UudXBsb2FkTWV0aG9kSWQgPSBcInVua25vd25cIjtcbiAgICAgIHNvdXJjZS5hbHBoYU1vZGUgPSBcIm5vLXByZW11bHRpcGx5LWFscGhhXCI7XG4gICAgICB0aGlzLl9hY3RpdmVUZXh0dXJlc1t0ZXh0S2V5XSA9IG51bGw7XG4gICAgfVxuICB9XG4gIGdldFJlZmVyZW5jZUNvdW50KHRleHRLZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlVGV4dHVyZXNbdGV4dEtleV0udXNhZ2VDb3VudDtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyB0ZXh0IHRvIGl0cyBjYW52YXMsIGFuZCB1cGRhdGVzIGl0cyB0ZXh0dXJlLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0IHRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IHRvIGVuc3VyZSB0aGUgdGV4dHVyZSBpcyBjb3JyZWN0IGJlZm9yZSByZW5kZXJpbmcsXG4gICAqIGJ1dCBpdCBjYW4gYmUgdXNlZCBjYWxsZWQgZXh0ZXJuYWxseSwgZm9yIGV4YW1wbGUgZnJvbSB0aGlzIGNsYXNzIHRvICdwcmUtZ2VuZXJhdGUnIHRoZSB0ZXh0dXJlIGZyb20gYSBwaWVjZSBvZiB0ZXh0LFxuICAgKiBhbmQgdGhlbiBzaGFyZWQgYWNyb3NzIG11bHRpcGxlIFNwcml0ZXMuXG4gICAqIEBwYXJhbSB0ZXh0XG4gICAqIEBwYXJhbSBzdHlsZVxuICAgKiBAcGFyYW0gcmVzb2x1dGlvblxuICAgKiBAcGFyYW0gY2FudmFzQW5kQ29udGV4dFxuICAgKi9cbiAgcmVuZGVyVGV4dFRvQ2FudmFzKHRleHQsIHN0eWxlLCByZXNvbHV0aW9uLCBjYW52YXNBbmRDb250ZXh0KSB7XG4gICAgY29uc3QgeyBjYW52YXMsIGNvbnRleHQgfSA9IGNhbnZhc0FuZENvbnRleHQ7XG4gICAgY29uc3QgZm9udCA9IGZvbnRTdHJpbmdGcm9tVGV4dFN0eWxlKHN0eWxlKTtcbiAgICBjb25zdCBtZWFzdXJlZCA9IENhbnZhc1RleHRNZXRyaWNzLm1lYXN1cmVUZXh0KHRleHQgfHwgXCIgXCIsIHN0eWxlKTtcbiAgICBjb25zdCBsaW5lcyA9IG1lYXN1cmVkLmxpbmVzO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBtZWFzdXJlZC5saW5lSGVpZ2h0O1xuICAgIGNvbnN0IGxpbmVXaWR0aHMgPSBtZWFzdXJlZC5saW5lV2lkdGhzO1xuICAgIGNvbnN0IG1heExpbmVXaWR0aCA9IG1lYXN1cmVkLm1heExpbmVXaWR0aDtcbiAgICBjb25zdCBmb250UHJvcGVydGllcyA9IG1lYXN1cmVkLmZvbnRQcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgY29udGV4dC5yZXNldFRyYW5zZm9ybSgpO1xuICAgIGNvbnRleHQuc2NhbGUocmVzb2x1dGlvbiwgcmVzb2x1dGlvbik7XG4gICAgY29uc3QgcGFkZGluZyA9IHN0eWxlLnBhZGRpbmcgKiAyO1xuICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIG1lYXN1cmVkLndpZHRoICsgNCArIHBhZGRpbmcsIG1lYXN1cmVkLmhlaWdodCArIDQgKyBwYWRkaW5nKTtcbiAgICBpZiAoc3R5bGUuX3N0cm9rZT8ud2lkdGgpIHtcbiAgICAgIGNvbnN0IHN0cm9rZVN0eWxlID0gc3R5bGUuX3N0cm9rZTtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gc3Ryb2tlU3R5bGUud2lkdGg7XG4gICAgICBjb250ZXh0Lm1pdGVyTGltaXQgPSBzdHJva2VTdHlsZS5taXRlckxpbWl0O1xuICAgICAgY29udGV4dC5saW5lSm9pbiA9IHN0cm9rZVN0eWxlLmpvaW47XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSBzdHJva2VTdHlsZS5jYXA7XG4gICAgfVxuICAgIGNvbnRleHQuZm9udCA9IGZvbnQ7XG4gICAgbGV0IGxpbmVQb3NpdGlvblg7XG4gICAgbGV0IGxpbmVQb3NpdGlvblk7XG4gICAgY29uc3QgcGFzc2VzQ291bnQgPSBzdHlsZS5kcm9wU2hhZG93ID8gMiA6IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXNzZXNDb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBpc1NoYWRvd1Bhc3MgPSBzdHlsZS5kcm9wU2hhZG93ICYmIGkgPT09IDA7XG4gICAgICBjb25zdCBkc09mZnNldFRleHQgPSBpc1NoYWRvd1Bhc3MgPyBNYXRoLmNlaWwoTWF0aC5tYXgoMSwgaGVpZ2h0KSArIHN0eWxlLnBhZGRpbmcgKiAyKSA6IDA7XG4gICAgICBjb25zdCBkc09mZnNldFNoYWRvdyA9IGRzT2Zmc2V0VGV4dCAqIHJlc29sdXRpb247XG4gICAgICBpZiAoaXNTaGFkb3dQYXNzKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCJibGFja1wiO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gXCJibGFja1wiO1xuICAgICAgICBjb25zdCBzaGFkb3dPcHRpb25zID0gc3R5bGUuZHJvcFNoYWRvdztcbiAgICAgICAgY29uc3QgZHJvcFNoYWRvd0NvbG9yID0gc2hhZG93T3B0aW9ucy5jb2xvcjtcbiAgICAgICAgY29uc3QgZHJvcFNoYWRvd0FscGhhID0gc2hhZG93T3B0aW9ucy5hbHBoYTtcbiAgICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9IENvbG9yLnNoYXJlZC5zZXRWYWx1ZShkcm9wU2hhZG93Q29sb3IpLnNldEFscGhhKGRyb3BTaGFkb3dBbHBoYSkudG9SZ2JhU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGRyb3BTaGFkb3dCbHVyID0gc2hhZG93T3B0aW9ucy5ibHVyICogcmVzb2x1dGlvbjtcbiAgICAgICAgY29uc3QgZHJvcFNoYWRvd0Rpc3RhbmNlID0gc2hhZG93T3B0aW9ucy5kaXN0YW5jZSAqIHJlc29sdXRpb247XG4gICAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IGRyb3BTaGFkb3dCbHVyO1xuICAgICAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSBNYXRoLmNvcyhzaGFkb3dPcHRpb25zLmFuZ2xlKSAqIGRyb3BTaGFkb3dEaXN0YW5jZTtcbiAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gTWF0aC5zaW4oc2hhZG93T3B0aW9ucy5hbmdsZSkgKiBkcm9wU2hhZG93RGlzdGFuY2UgKyBkc09mZnNldFNoYWRvdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBzdHlsZS5fZmlsbD8uYWxwaGEgPz8gMTtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBzdHlsZS5fZmlsbCA/IGdldENhbnZhc0ZpbGxTdHlsZShzdHlsZS5fZmlsbCwgY29udGV4dCkgOiBudWxsO1xuICAgICAgICBpZiAoc3R5bGUuX3N0cm9rZT8ud2lkdGgpIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gZ2V0Q2FudmFzRmlsbFN0eWxlKHN0eWxlLl9zdHJva2UsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBcImJsYWNrXCI7XG4gICAgICB9XG4gICAgICBsZXQgbGluZVBvc2l0aW9uWVNoaWZ0ID0gKGxpbmVIZWlnaHQgLSBmb250UHJvcGVydGllcy5mb250U2l6ZSkgLyAyO1xuICAgICAgaWYgKGxpbmVIZWlnaHQgLSBmb250UHJvcGVydGllcy5mb250U2l6ZSA8IDApIHtcbiAgICAgICAgbGluZVBvc2l0aW9uWVNoaWZ0ID0gMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gc3R5bGUuX3N0cm9rZT8ud2lkdGggPz8gMDtcbiAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBsaW5lcy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgbGluZVBvc2l0aW9uWCA9IHN0cm9rZVdpZHRoIC8gMjtcbiAgICAgICAgbGluZVBvc2l0aW9uWSA9IHN0cm9rZVdpZHRoIC8gMiArIGkyICogbGluZUhlaWdodCArIGZvbnRQcm9wZXJ0aWVzLmFzY2VudCArIGxpbmVQb3NpdGlvbllTaGlmdDtcbiAgICAgICAgaWYgKHN0eWxlLmFsaWduID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICBsaW5lUG9zaXRpb25YICs9IG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaTJdO1xuICAgICAgICB9IGVsc2UgaWYgKHN0eWxlLmFsaWduID09PSBcImNlbnRlclwiKSB7XG4gICAgICAgICAgbGluZVBvc2l0aW9uWCArPSAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpMl0pIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGUuX3N0cm9rZT8ud2lkdGgpIHtcbiAgICAgICAgICB0aGlzLl9kcmF3TGV0dGVyU3BhY2luZyhcbiAgICAgICAgICAgIGxpbmVzW2kyXSxcbiAgICAgICAgICAgIHN0eWxlLFxuICAgICAgICAgICAgY2FudmFzQW5kQ29udGV4dCxcbiAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKyBzdHlsZS5wYWRkaW5nLFxuICAgICAgICAgICAgbGluZVBvc2l0aW9uWSArIHN0eWxlLnBhZGRpbmcgLSBkc09mZnNldFRleHQsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGUuX2ZpbGwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRoaXMuX2RyYXdMZXR0ZXJTcGFjaW5nKFxuICAgICAgICAgICAgbGluZXNbaTJdLFxuICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICBjYW52YXNBbmRDb250ZXh0LFxuICAgICAgICAgICAgbGluZVBvc2l0aW9uWCArIHN0eWxlLnBhZGRpbmcsXG4gICAgICAgICAgICBsaW5lUG9zaXRpb25ZICsgc3R5bGUucGFkZGluZyAtIGRzT2Zmc2V0VGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgdGV4dCB3aXRoIGxldHRlci1zcGFjaW5nLlxuICAgKiBAcGFyYW0gdGV4dCAtIFRoZSB0ZXh0IHRvIGRyYXdcbiAgICogQHBhcmFtIHN0eWxlXG4gICAqIEBwYXJhbSBjYW52YXNBbmRDb250ZXh0XG4gICAqIEBwYXJhbSB4IC0gSG9yaXpvbnRhbCBwb3NpdGlvbiB0byBkcmF3IHRoZSB0ZXh0XG4gICAqIEBwYXJhbSB5IC0gVmVydGljYWwgcG9zaXRpb24gdG8gZHJhdyB0aGUgdGV4dFxuICAgKiBAcGFyYW0gaXNTdHJva2UgLSBJcyB0aGlzIGRyYXdpbmcgZm9yIHRoZSBvdXRzaWRlIHN0cm9rZSBvZiB0aGVcbiAgICogIHRleHQ/IElmIG5vdCwgaXQncyBmb3IgdGhlIGluc2lkZSBmaWxsXG4gICAqL1xuICBfZHJhd0xldHRlclNwYWNpbmcodGV4dCwgc3R5bGUsIGNhbnZhc0FuZENvbnRleHQsIHgsIHksIGlzU3Ryb2tlID0gZmFsc2UpIHtcbiAgICBjb25zdCB7IGNvbnRleHQgfSA9IGNhbnZhc0FuZENvbnRleHQ7XG4gICAgY29uc3QgbGV0dGVyU3BhY2luZyA9IHN0eWxlLmxldHRlclNwYWNpbmc7XG4gICAgbGV0IHVzZUV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcgPSBmYWxzZTtcbiAgICBpZiAoQ2FudmFzVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZ1N1cHBvcnRlZCkge1xuICAgICAgaWYgKENhbnZhc1RleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcpIHtcbiAgICAgICAgY29udGV4dC5sZXR0ZXJTcGFjaW5nID0gYCR7bGV0dGVyU3BhY2luZ31weGA7XG4gICAgICAgIGNvbnRleHQudGV4dExldHRlclNwYWNpbmcgPSBgJHtsZXR0ZXJTcGFjaW5nfXB4YDtcbiAgICAgICAgdXNlRXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmxldHRlclNwYWNpbmcgPSBcIjBweFwiO1xuICAgICAgICBjb250ZXh0LnRleHRMZXR0ZXJTcGFjaW5nID0gXCIwcHhcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxldHRlclNwYWNpbmcgPT09IDAgfHwgdXNlRXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZykge1xuICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dCh0ZXh0LCB4LCB5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQodGV4dCwgeCwgeSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjdXJyZW50UG9zaXRpb24gPSB4O1xuICAgIGNvbnN0IHN0cmluZ0FycmF5ID0gQ2FudmFzVGV4dE1ldHJpY3MuZ3JhcGhlbWVTZWdtZW50ZXIodGV4dCk7XG4gICAgbGV0IHByZXZpb3VzV2lkdGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgIGxldCBjdXJyZW50V2lkdGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRDaGFyID0gc3RyaW5nQXJyYXlbaV07XG4gICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KGN1cnJlbnRDaGFyLCBjdXJyZW50UG9zaXRpb24sIHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5maWxsVGV4dChjdXJyZW50Q2hhciwgY3VycmVudFBvc2l0aW9uLCB5KTtcbiAgICAgIH1cbiAgICAgIGxldCB0ZXh0U3RyID0gXCJcIjtcbiAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHN0cmluZ0FycmF5Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHRleHRTdHIgKz0gc3RyaW5nQXJyYXlbal07XG4gICAgICB9XG4gICAgICBjdXJyZW50V2lkdGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHRTdHIpLndpZHRoO1xuICAgICAgY3VycmVudFBvc2l0aW9uICs9IHByZXZpb3VzV2lkdGggLSBjdXJyZW50V2lkdGggKyBsZXR0ZXJTcGFjaW5nO1xuICAgICAgcHJldmlvdXNXaWR0aCA9IGN1cnJlbnRXaWR0aDtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9hY3RpdmVUZXh0dXJlcyA9IG51bGw7XG4gIH1cbn1cbi8qKiBAaWdub3JlICovXG5DYW52YXNUZXh0U3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuV2ViR0xTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5XZWJHUFVTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJjYW52YXNUZXh0XCJcbn07XG5cbmV4cG9ydCB7IENhbnZhc1RleHRTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbnZhc1RleHRTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgZXh0ZW5zaW9ucyB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbnMvRXh0ZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgQ2FudmFzVGV4dFBpcGUgfSBmcm9tICcuL2NhbnZhcy9DYW52YXNUZXh0UGlwZS5tanMnO1xuaW1wb3J0IHsgQ2FudmFzVGV4dFN5c3RlbSB9IGZyb20gJy4vY2FudmFzL0NhbnZhc1RleHRTeXN0ZW0ubWpzJztcblxuXCJ1c2Ugc3RyaWN0XCI7XG5leHRlbnNpb25zLmFkZChDYW52YXNUZXh0U3lzdGVtKTtcbmV4dGVuc2lvbnMuYWRkKENhbnZhc1RleHRQaXBlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaXQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6813\n')},7080:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   s: () => (/* binding */ getPo2TextureFromSource)\n/* harmony export */ });\n/* harmony import */ var _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6899);\n/* harmony import */ var _container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5008);\n\n\n\n"use strict";\nconst tempBounds = new _container_bounds_Bounds_mjs__WEBPACK_IMPORTED_MODULE_0__/* .Bounds */ .Q();\nfunction getPo2TextureFromSource(image, width, height, resolution) {\n  const bounds = tempBounds;\n  bounds.minX = 0;\n  bounds.minY = 0;\n  bounds.maxX = image.width / resolution | 0;\n  bounds.maxY = image.height / resolution | 0;\n  const texture = _rendering_renderers_shared_texture_TexturePool_mjs__WEBPACK_IMPORTED_MODULE_1__/* .TexturePool */ .W.getOptimalTexture(\n    bounds.width,\n    bounds.height,\n    resolution,\n    false\n  );\n  texture.source.uploadMethodId = "image";\n  texture.source.resource = image;\n  texture.source.alphaMode = "premultiply-alpha-on-upload";\n  texture.frame.width = width / resolution;\n  texture.frame.height = height / resolution;\n  texture.source.emit("update", texture.source);\n  texture.updateUvs();\n  return texture;\n}\n\n\n//# sourceMappingURL=getPo2TextureFromSource.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA4MC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwRjtBQUMvQjs7QUFFM0Q7QUFDQSx1QkFBdUIseUVBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFHQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1DO0FBQ25DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL3BpeGkuanMvbGliL3NjZW5lL3RleHQvdXRpbHMvZ2V0UG8yVGV4dHVyZUZyb21Tb3VyY2UubWpzP2NhYmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGV4dHVyZVBvb2wgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXJpbmcvcmVuZGVyZXJzL3NoYXJlZC90ZXh0dXJlL1RleHR1cmVQb29sLm1qcyc7XG5pbXBvcnQgeyBCb3VuZHMgfSBmcm9tICcuLi8uLi9jb250YWluZXIvYm91bmRzL0JvdW5kcy5tanMnO1xuXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHRlbXBCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG5mdW5jdGlvbiBnZXRQbzJUZXh0dXJlRnJvbVNvdXJjZShpbWFnZSwgd2lkdGgsIGhlaWdodCwgcmVzb2x1dGlvbikge1xuICBjb25zdCBib3VuZHMgPSB0ZW1wQm91bmRzO1xuICBib3VuZHMubWluWCA9IDA7XG4gIGJvdW5kcy5taW5ZID0gMDtcbiAgYm91bmRzLm1heFggPSBpbWFnZS53aWR0aCAvIHJlc29sdXRpb24gfCAwO1xuICBib3VuZHMubWF4WSA9IGltYWdlLmhlaWdodCAvIHJlc29sdXRpb24gfCAwO1xuICBjb25zdCB0ZXh0dXJlID0gVGV4dHVyZVBvb2wuZ2V0T3B0aW1hbFRleHR1cmUoXG4gICAgYm91bmRzLndpZHRoLFxuICAgIGJvdW5kcy5oZWlnaHQsXG4gICAgcmVzb2x1dGlvbixcbiAgICBmYWxzZVxuICApO1xuICB0ZXh0dXJlLnNvdXJjZS51cGxvYWRNZXRob2RJZCA9IFwiaW1hZ2VcIjtcbiAgdGV4dHVyZS5zb3VyY2UucmVzb3VyY2UgPSBpbWFnZTtcbiAgdGV4dHVyZS5zb3VyY2UuYWxwaGFNb2RlID0gXCJwcmVtdWx0aXBseS1hbHBoYS1vbi11cGxvYWRcIjtcbiAgdGV4dHVyZS5mcmFtZS53aWR0aCA9IHdpZHRoIC8gcmVzb2x1dGlvbjtcbiAgdGV4dHVyZS5mcmFtZS5oZWlnaHQgPSBoZWlnaHQgLyByZXNvbHV0aW9uO1xuICB0ZXh0dXJlLnNvdXJjZS5lbWl0KFwidXBkYXRlXCIsIHRleHR1cmUuc291cmNlKTtcbiAgdGV4dHVyZS51cGRhdGVVdnMoKTtcbiAgcmV0dXJuIHRleHR1cmU7XG59XG5cbmV4cG9ydCB7IGdldFBvMlRleHR1cmVGcm9tU291cmNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRQbzJUZXh0dXJlRnJvbVNvdXJjZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7080\n')}}]);