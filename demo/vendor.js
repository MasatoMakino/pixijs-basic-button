(self.webpackChunk_masatomakino_pixijs_basic_button=self.webpackChunk_masatomakino_pixijs_basic_button||[]).push([[736],{720:module=>{"use strict";eval("\n\nmodule.exports = earcut;\nmodule.exports[\"default\"] = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    var p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    var bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    var bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = 0;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlDQUF5QztBQUMzRDs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDLHdCQUF3QixvQkFBb0I7QUFDNUMsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9lYXJjdXQvc3JjL2VhcmN1dC5qcz85ZTU2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBlYXJjdXQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZWFyY3V0O1xuXG5mdW5jdGlvbiBlYXJjdXQoZGF0YSwgaG9sZUluZGljZXMsIGRpbSkge1xuXG4gICAgZGltID0gZGltIHx8IDI7XG5cbiAgICB2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGgsXG4gICAgICAgIG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IGRhdGEubGVuZ3RoLFxuICAgICAgICBvdXRlck5vZGUgPSBsaW5rZWRMaXN0KGRhdGEsIDAsIG91dGVyTGVuLCBkaW0sIHRydWUpLFxuICAgICAgICB0cmlhbmdsZXMgPSBbXTtcblxuICAgIGlmICghb3V0ZXJOb2RlIHx8IG91dGVyTm9kZS5uZXh0ID09PSBvdXRlck5vZGUucHJldikgcmV0dXJuIHRyaWFuZ2xlcztcblxuICAgIHZhciBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCB4LCB5LCBpbnZTaXplO1xuXG4gICAgaWYgKGhhc0hvbGVzKSBvdXRlck5vZGUgPSBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pO1xuXG4gICAgLy8gaWYgdGhlIHNoYXBlIGlzIG5vdCB0b28gc2ltcGxlLCB3ZSdsbCB1c2Ugei1vcmRlciBjdXJ2ZSBoYXNoIGxhdGVyOyBjYWxjdWxhdGUgcG9seWdvbiBiYm94XG4gICAgaWYgKGRhdGEubGVuZ3RoID4gODAgKiBkaW0pIHtcbiAgICAgICAgbWluWCA9IG1heFggPSBkYXRhWzBdO1xuICAgICAgICBtaW5ZID0gbWF4WSA9IGRhdGFbMV07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGRpbTsgaSA8IG91dGVyTGVuOyBpICs9IGRpbSkge1xuICAgICAgICAgICAgeCA9IGRhdGFbaV07XG4gICAgICAgICAgICB5ID0gZGF0YVtpICsgMV07XG4gICAgICAgICAgICBpZiAoeCA8IG1pblgpIG1pblggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPCBtaW5ZKSBtaW5ZID0geTtcbiAgICAgICAgICAgIGlmICh4ID4gbWF4WCkgbWF4WCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA+IG1heFkpIG1heFkgPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWluWCwgbWluWSBhbmQgaW52U2l6ZSBhcmUgbGF0ZXIgdXNlZCB0byB0cmFuc2Zvcm0gY29vcmRzIGludG8gaW50ZWdlcnMgZm9yIHotb3JkZXIgY2FsY3VsYXRpb25cbiAgICAgICAgaW52U2l6ZSA9IE1hdGgubWF4KG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XG4gICAgICAgIGludlNpemUgPSBpbnZTaXplICE9PSAwID8gMzI3NjcgLyBpbnZTaXplIDogMDtcbiAgICB9XG5cbiAgICBlYXJjdXRMaW5rZWQob3V0ZXJOb2RlLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCk7XG5cbiAgICByZXR1cm4gdHJpYW5nbGVzO1xufVxuXG4vLyBjcmVhdGUgYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QgZnJvbSBwb2x5Z29uIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcbmZ1bmN0aW9uIGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBjbG9ja3dpc2UpIHtcbiAgICB2YXIgaSwgbGFzdDtcblxuICAgIGlmIChjbG9ja3dpc2UgPT09IChzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkgPiAwKSkge1xuICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSBlbmQgLSBkaW07IGkgPj0gc3RhcnQ7IGkgLT0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gICAgfVxuXG4gICAgaWYgKGxhc3QgJiYgZXF1YWxzKGxhc3QsIGxhc3QubmV4dCkpIHtcbiAgICAgICAgcmVtb3ZlTm9kZShsYXN0KTtcbiAgICAgICAgbGFzdCA9IGxhc3QubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gbGFzdDtcbn1cblxuLy8gZWxpbWluYXRlIGNvbGluZWFyIG9yIGR1cGxpY2F0ZSBwb2ludHNcbmZ1bmN0aW9uIGZpbHRlclBvaW50cyhzdGFydCwgZW5kKSB7XG4gICAgaWYgKCFzdGFydCkgcmV0dXJuIHN0YXJ0O1xuICAgIGlmICghZW5kKSBlbmQgPSBzdGFydDtcblxuICAgIHZhciBwID0gc3RhcnQsXG4gICAgICAgIGFnYWluO1xuICAgIGRvIHtcbiAgICAgICAgYWdhaW4gPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXAuc3RlaW5lciAmJiAoZXF1YWxzKHAsIHAubmV4dCkgfHwgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPT09IDApKSB7XG4gICAgICAgICAgICByZW1vdmVOb2RlKHApO1xuICAgICAgICAgICAgcCA9IGVuZCA9IHAucHJldjtcbiAgICAgICAgICAgIGlmIChwID09PSBwLm5leHQpIGJyZWFrO1xuICAgICAgICAgICAgYWdhaW4gPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAoYWdhaW4gfHwgcCAhPT0gZW5kKTtcblxuICAgIHJldHVybiBlbmQ7XG59XG5cbi8vIG1haW4gZWFyIHNsaWNpbmcgbG9vcCB3aGljaCB0cmlhbmd1bGF0ZXMgYSBwb2x5Z29uIChnaXZlbiBhcyBhIGxpbmtlZCBsaXN0KVxuZnVuY3Rpb24gZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIHBhc3MpIHtcbiAgICBpZiAoIWVhcikgcmV0dXJuO1xuXG4gICAgLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuICAgIGlmICghcGFzcyAmJiBpbnZTaXplKSBpbmRleEN1cnZlKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG5cbiAgICB2YXIgc3RvcCA9IGVhcixcbiAgICAgICAgcHJldiwgbmV4dDtcblxuICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBlYXJzLCBzbGljaW5nIHRoZW0gb25lIGJ5IG9uZVxuICAgIHdoaWxlIChlYXIucHJldiAhPT0gZWFyLm5leHQpIHtcbiAgICAgICAgcHJldiA9IGVhci5wcmV2O1xuICAgICAgICBuZXh0ID0gZWFyLm5leHQ7XG5cbiAgICAgICAgaWYgKGludlNpemUgPyBpc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIGludlNpemUpIDogaXNFYXIoZWFyKSkge1xuICAgICAgICAgICAgLy8gY3V0IG9mZiB0aGUgdHJpYW5nbGVcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHByZXYuaSAvIGRpbSB8IDApO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goZWFyLmkgLyBkaW0gfCAwKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKG5leHQuaSAvIGRpbSB8IDApO1xuXG4gICAgICAgICAgICByZW1vdmVOb2RlKGVhcik7XG5cbiAgICAgICAgICAgIC8vIHNraXBwaW5nIHRoZSBuZXh0IHZlcnRleCBsZWFkcyB0byBsZXNzIHNsaXZlciB0cmlhbmdsZXNcbiAgICAgICAgICAgIGVhciA9IG5leHQubmV4dDtcbiAgICAgICAgICAgIHN0b3AgPSBuZXh0Lm5leHQ7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWFyID0gbmV4dDtcblxuICAgICAgICAvLyBpZiB3ZSBsb29wZWQgdGhyb3VnaCB0aGUgd2hvbGUgcmVtYWluaW5nIHBvbHlnb24gYW5kIGNhbid0IGZpbmQgYW55IG1vcmUgZWFyc1xuICAgICAgICBpZiAoZWFyID09PSBzdG9wKSB7XG4gICAgICAgICAgICAvLyB0cnkgZmlsdGVyaW5nIHBvaW50cyBhbmQgc2xpY2luZyBhZ2FpblxuICAgICAgICAgICAgaWYgKCFwYXNzKSB7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGZpbHRlclBvaW50cyhlYXIpLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlkbid0IHdvcmssIHRyeSBjdXJpbmcgYWxsIHNtYWxsIHNlbGYtaW50ZXJzZWN0aW9ucyBsb2NhbGx5XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBlYXIgPSBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKGZpbHRlclBvaW50cyhlYXIpLCB0cmlhbmdsZXMsIGRpbSk7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDIpO1xuXG4gICAgICAgICAgICAvLyBhcyBhIGxhc3QgcmVzb3J0LCB0cnkgc3BsaXR0aW5nIHRoZSByZW1haW5pbmcgcG9seWdvbiBpbnRvIHR3b1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAyKSB7XG4gICAgICAgICAgICAgICAgc3BsaXRFYXJjdXQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBjaGVjayB3aGV0aGVyIGEgcG9seWdvbiBub2RlIGZvcm1zIGEgdmFsaWQgZWFyIHdpdGggYWRqYWNlbnQgbm9kZXNcbmZ1bmN0aW9uIGlzRWFyKGVhcikge1xuICAgIHZhciBhID0gZWFyLnByZXYsXG4gICAgICAgIGIgPSBlYXIsXG4gICAgICAgIGMgPSBlYXIubmV4dDtcblxuICAgIGlmIChhcmVhKGEsIGIsIGMpID49IDApIHJldHVybiBmYWxzZTsgLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcblxuICAgIC8vIG5vdyBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBvdGhlciBwb2ludHMgaW5zaWRlIHRoZSBwb3RlbnRpYWwgZWFyXG4gICAgdmFyIGF4ID0gYS54LCBieCA9IGIueCwgY3ggPSBjLngsIGF5ID0gYS55LCBieSA9IGIueSwgY3kgPSBjLnk7XG5cbiAgICAvLyB0cmlhbmdsZSBiYm94OyBtaW4gJiBtYXggYXJlIGNhbGN1bGF0ZWQgbGlrZSB0aGlzIGZvciBzcGVlZFxuICAgIHZhciB4MCA9IGF4IDwgYnggPyAoYXggPCBjeCA/IGF4IDogY3gpIDogKGJ4IDwgY3ggPyBieCA6IGN4KSxcbiAgICAgICAgeTAgPSBheSA8IGJ5ID8gKGF5IDwgY3kgPyBheSA6IGN5KSA6IChieSA8IGN5ID8gYnkgOiBjeSksXG4gICAgICAgIHgxID0gYXggPiBieCA/IChheCA+IGN4ID8gYXggOiBjeCkgOiAoYnggPiBjeCA/IGJ4IDogY3gpLFxuICAgICAgICB5MSA9IGF5ID4gYnkgPyAoYXkgPiBjeSA/IGF5IDogY3kpIDogKGJ5ID4gY3kgPyBieSA6IGN5KTtcblxuICAgIHZhciBwID0gYy5uZXh0O1xuICAgIHdoaWxlIChwICE9PSBhKSB7XG4gICAgICAgIGlmIChwLnggPj0geDAgJiYgcC54IDw9IHgxICYmIHAueSA+PSB5MCAmJiBwLnkgPD0geTEgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgdmFyIGEgPSBlYXIucHJldixcbiAgICAgICAgYiA9IGVhcixcbiAgICAgICAgYyA9IGVhci5uZXh0O1xuXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgdmFyIGF4ID0gYS54LCBieCA9IGIueCwgY3ggPSBjLngsIGF5ID0gYS55LCBieSA9IGIueSwgY3kgPSBjLnk7XG5cbiAgICAvLyB0cmlhbmdsZSBiYm94OyBtaW4gJiBtYXggYXJlIGNhbGN1bGF0ZWQgbGlrZSB0aGlzIGZvciBzcGVlZFxuICAgIHZhciB4MCA9IGF4IDwgYnggPyAoYXggPCBjeCA/IGF4IDogY3gpIDogKGJ4IDwgY3ggPyBieCA6IGN4KSxcbiAgICAgICAgeTAgPSBheSA8IGJ5ID8gKGF5IDwgY3kgPyBheSA6IGN5KSA6IChieSA8IGN5ID8gYnkgOiBjeSksXG4gICAgICAgIHgxID0gYXggPiBieCA/IChheCA+IGN4ID8gYXggOiBjeCkgOiAoYnggPiBjeCA/IGJ4IDogY3gpLFxuICAgICAgICB5MSA9IGF5ID4gYnkgPyAoYXkgPiBjeSA/IGF5IDogY3kpIDogKGJ5ID4gY3kgPyBieSA6IGN5KTtcblxuICAgIC8vIHotb3JkZXIgcmFuZ2UgZm9yIHRoZSBjdXJyZW50IHRyaWFuZ2xlIGJib3g7XG4gICAgdmFyIG1pblogPSB6T3JkZXIoeDAsIHkwLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSxcbiAgICAgICAgbWF4WiA9IHpPcmRlcih4MSwgeTEsIG1pblgsIG1pblksIGludlNpemUpO1xuXG4gICAgdmFyIHAgPSBlYXIucHJldlosXG4gICAgICAgIG4gPSBlYXIubmV4dFo7XG5cbiAgICAvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBpbiBib3RoIGRpcmVjdGlvbnNcbiAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWiAmJiBuICYmIG4ueiA8PSBtYXhaKSB7XG4gICAgICAgIGlmIChwLnggPj0geDAgJiYgcC54IDw9IHgxICYmIHAueSA+PSB5MCAmJiBwLnkgPD0geTEgJiYgcCAhPT0gYSAmJiBwICE9PSBjICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcC54LCBwLnkpICYmIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAucHJldlo7XG5cbiAgICAgICAgaWYgKG4ueCA+PSB4MCAmJiBuLnggPD0geDEgJiYgbi55ID49IHkwICYmIG4ueSA8PSB5MSAmJiBuICE9PSBhICYmIG4gIT09IGMgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBuLngsIG4ueSkgJiYgYXJlYShuLnByZXYsIG4sIG4ubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBuID0gbi5uZXh0WjtcbiAgICB9XG5cbiAgICAvLyBsb29rIGZvciByZW1haW5pbmcgcG9pbnRzIGluIGRlY3JlYXNpbmcgei1vcmRlclxuICAgIHdoaWxlIChwICYmIHAueiA+PSBtaW5aKSB7XG4gICAgICAgIGlmIChwLnggPj0geDAgJiYgcC54IDw9IHgxICYmIHAueSA+PSB5MCAmJiBwLnkgPD0geTEgJiYgcCAhPT0gYSAmJiBwICE9PSBjICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcC54LCBwLnkpICYmIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAucHJldlo7XG4gICAgfVxuXG4gICAgLy8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBpbmNyZWFzaW5nIHotb3JkZXJcbiAgICB3aGlsZSAobiAmJiBuLnogPD0gbWF4Wikge1xuICAgICAgICBpZiAobi54ID49IHgwICYmIG4ueCA8PSB4MSAmJiBuLnkgPj0geTAgJiYgbi55IDw9IHkxICYmIG4gIT09IGEgJiYgbiAhPT0gYyAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIG4ueCwgbi55KSAmJiBhcmVhKG4ucHJldiwgbiwgbi5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIG4gPSBuLm5leHRaO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vLyBnbyB0aHJvdWdoIGFsbCBwb2x5Z29uIG5vZGVzIGFuZCBjdXJlIHNtYWxsIGxvY2FsIHNlbGYtaW50ZXJzZWN0aW9uc1xuZnVuY3Rpb24gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhzdGFydCwgdHJpYW5nbGVzLCBkaW0pIHtcbiAgICB2YXIgcCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIGEgPSBwLnByZXYsXG4gICAgICAgICAgICBiID0gcC5uZXh0Lm5leHQ7XG5cbiAgICAgICAgaWYgKCFlcXVhbHMoYSwgYikgJiYgaW50ZXJzZWN0cyhhLCBwLCBwLm5leHQsIGIpICYmIGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSkge1xuXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChhLmkgLyBkaW0gfCAwKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHAuaSAvIGRpbSB8IDApO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goYi5pIC8gZGltIHwgMCk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0d28gbm9kZXMgaW52b2x2ZWRcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocCk7XG4gICAgICAgICAgICByZW1vdmVOb2RlKHAubmV4dCk7XG5cbiAgICAgICAgICAgIHAgPSBzdGFydCA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gZmlsdGVyUG9pbnRzKHApO1xufVxuXG4vLyB0cnkgc3BsaXR0aW5nIHBvbHlnb24gaW50byB0d28gYW5kIHRyaWFuZ3VsYXRlIHRoZW0gaW5kZXBlbmRlbnRseVxuZnVuY3Rpb24gc3BsaXRFYXJjdXQoc3RhcnQsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgLy8gbG9vayBmb3IgYSB2YWxpZCBkaWFnb25hbCB0aGF0IGRpdmlkZXMgdGhlIHBvbHlnb24gaW50byB0d29cbiAgICB2YXIgYSA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIGIgPSBhLm5leHQubmV4dDtcbiAgICAgICAgd2hpbGUgKGIgIT09IGEucHJldikge1xuICAgICAgICAgICAgaWYgKGEuaSAhPT0gYi5pICYmIGlzVmFsaWREaWFnb25hbChhLCBiKSkge1xuICAgICAgICAgICAgICAgIC8vIHNwbGl0IHRoZSBwb2x5Z29uIGluIHR3byBieSB0aGUgZGlhZ29uYWxcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHNwbGl0UG9seWdvbihhLCBiKTtcblxuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBjb2xpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXG4gICAgICAgICAgICAgICAgYSA9IGZpbHRlclBvaW50cyhhLCBhLm5leHQpO1xuICAgICAgICAgICAgICAgIGMgPSBmaWx0ZXJQb2ludHMoYywgYy5uZXh0KTtcblxuICAgICAgICAgICAgICAgIC8vIHJ1biBlYXJjdXQgb24gZWFjaCBoYWxmXG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGEsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAwKTtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYywgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIgPSBiLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgYSA9IGEubmV4dDtcbiAgICB9IHdoaWxlIChhICE9PSBzdGFydCk7XG59XG5cbi8vIGxpbmsgZXZlcnkgaG9sZSBpbnRvIHRoZSBvdXRlciBsb29wLCBwcm9kdWNpbmcgYSBzaW5nbGUtcmluZyBwb2x5Z29uIHdpdGhvdXQgaG9sZXNcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSkge1xuICAgIHZhciBxdWV1ZSA9IFtdLFxuICAgICAgICBpLCBsZW4sIHN0YXJ0LCBlbmQsIGxpc3Q7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xuICAgICAgICBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICBsaXN0ID0gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGZhbHNlKTtcbiAgICAgICAgaWYgKGxpc3QgPT09IGxpc3QubmV4dCkgbGlzdC5zdGVpbmVyID0gdHJ1ZTtcbiAgICAgICAgcXVldWUucHVzaChnZXRMZWZ0bW9zdChsaXN0KSk7XG4gICAgfVxuXG4gICAgcXVldWUuc29ydChjb21wYXJlWCk7XG5cbiAgICAvLyBwcm9jZXNzIGhvbGVzIGZyb20gbGVmdCB0byByaWdodFxuICAgIGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXRlck5vZGUgPSBlbGltaW5hdGVIb2xlKHF1ZXVlW2ldLCBvdXRlck5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRlck5vZGU7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVYKGEsIGIpIHtcbiAgICByZXR1cm4gYS54IC0gYi54O1xufVxuXG4vLyBmaW5kIGEgYnJpZGdlIGJldHdlZW4gdmVydGljZXMgdGhhdCBjb25uZWN0cyBob2xlIHdpdGggYW4gb3V0ZXIgcmluZyBhbmQgYW5kIGxpbmsgaXRcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGUoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gICAgdmFyIGJyaWRnZSA9IGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSk7XG4gICAgaWYgKCFicmlkZ2UpIHtcbiAgICAgICAgcmV0dXJuIG91dGVyTm9kZTtcbiAgICB9XG5cbiAgICB2YXIgYnJpZGdlUmV2ZXJzZSA9IHNwbGl0UG9seWdvbihicmlkZ2UsIGhvbGUpO1xuXG4gICAgLy8gZmlsdGVyIGNvbGxpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXG4gICAgZmlsdGVyUG9pbnRzKGJyaWRnZVJldmVyc2UsIGJyaWRnZVJldmVyc2UubmV4dCk7XG4gICAgcmV0dXJuIGZpbHRlclBvaW50cyhicmlkZ2UsIGJyaWRnZS5uZXh0KTtcbn1cblxuLy8gRGF2aWQgRWJlcmx5J3MgYWxnb3JpdGhtIGZvciBmaW5kaW5nIGEgYnJpZGdlIGJldHdlZW4gaG9sZSBhbmQgb3V0ZXIgcG9seWdvblxuZnVuY3Rpb24gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gICAgdmFyIHAgPSBvdXRlck5vZGUsXG4gICAgICAgIGh4ID0gaG9sZS54LFxuICAgICAgICBoeSA9IGhvbGUueSxcbiAgICAgICAgcXggPSAtSW5maW5pdHksXG4gICAgICAgIG07XG5cbiAgICAvLyBmaW5kIGEgc2VnbWVudCBpbnRlcnNlY3RlZCBieSBhIHJheSBmcm9tIHRoZSBob2xlJ3MgbGVmdG1vc3QgcG9pbnQgdG8gdGhlIGxlZnQ7XG4gICAgLy8gc2VnbWVudCdzIGVuZHBvaW50IHdpdGggbGVzc2VyIHggd2lsbCBiZSBwb3RlbnRpYWwgY29ubmVjdGlvbiBwb2ludFxuICAgIGRvIHtcbiAgICAgICAgaWYgKGh5IDw9IHAueSAmJiBoeSA+PSBwLm5leHQueSAmJiBwLm5leHQueSAhPT0gcC55KSB7XG4gICAgICAgICAgICB2YXIgeCA9IHAueCArIChoeSAtIHAueSkgKiAocC5uZXh0LnggLSBwLngpIC8gKHAubmV4dC55IC0gcC55KTtcbiAgICAgICAgICAgIGlmICh4IDw9IGh4ICYmIHggPiBxeCkge1xuICAgICAgICAgICAgICAgIHF4ID0geDtcbiAgICAgICAgICAgICAgICBtID0gcC54IDwgcC5uZXh0LnggPyBwIDogcC5uZXh0O1xuICAgICAgICAgICAgICAgIGlmICh4ID09PSBoeCkgcmV0dXJuIG07IC8vIGhvbGUgdG91Y2hlcyBvdXRlciBzZWdtZW50OyBwaWNrIGxlZnRtb3N0IGVuZHBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBvdXRlck5vZGUpO1xuXG4gICAgaWYgKCFtKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIG9mIGhvbGUgcG9pbnQsIHNlZ21lbnQgaW50ZXJzZWN0aW9uIGFuZCBlbmRwb2ludDtcbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gcG9pbnRzIGZvdW5kLCB3ZSBoYXZlIGEgdmFsaWQgY29ubmVjdGlvbjtcbiAgICAvLyBvdGhlcndpc2UgY2hvb3NlIHRoZSBwb2ludCBvZiB0aGUgbWluaW11bSBhbmdsZSB3aXRoIHRoZSByYXkgYXMgY29ubmVjdGlvbiBwb2ludFxuXG4gICAgdmFyIHN0b3AgPSBtLFxuICAgICAgICBteCA9IG0ueCxcbiAgICAgICAgbXkgPSBtLnksXG4gICAgICAgIHRhbk1pbiA9IEluZmluaXR5LFxuICAgICAgICB0YW47XG5cbiAgICBwID0gbTtcblxuICAgIGRvIHtcbiAgICAgICAgaWYgKGh4ID49IHAueCAmJiBwLnggPj0gbXggJiYgaHggIT09IHAueCAmJlxuICAgICAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShoeSA8IG15ID8gaHggOiBxeCwgaHksIG14LCBteSwgaHkgPCBteSA/IHF4IDogaHgsIGh5LCBwLngsIHAueSkpIHtcblxuICAgICAgICAgICAgdGFuID0gTWF0aC5hYnMoaHkgLSBwLnkpIC8gKGh4IC0gcC54KTsgLy8gdGFuZ2VudGlhbFxuXG4gICAgICAgICAgICBpZiAobG9jYWxseUluc2lkZShwLCBob2xlKSAmJlxuICAgICAgICAgICAgICAgICh0YW4gPCB0YW5NaW4gfHwgKHRhbiA9PT0gdGFuTWluICYmIChwLnggPiBtLnggfHwgKHAueCA9PT0gbS54ICYmIHNlY3RvckNvbnRhaW5zU2VjdG9yKG0sIHApKSkpKSkge1xuICAgICAgICAgICAgICAgIG0gPSBwO1xuICAgICAgICAgICAgICAgIHRhbk1pbiA9IHRhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RvcCk7XG5cbiAgICByZXR1cm4gbTtcbn1cblxuLy8gd2hldGhlciBzZWN0b3IgaW4gdmVydGV4IG0gY29udGFpbnMgc2VjdG9yIGluIHZlcnRleCBwIGluIHRoZSBzYW1lIGNvb3JkaW5hdGVzXG5mdW5jdGlvbiBzZWN0b3JDb250YWluc1NlY3RvcihtLCBwKSB7XG4gICAgcmV0dXJuIGFyZWEobS5wcmV2LCBtLCBwLnByZXYpIDwgMCAmJiBhcmVhKHAubmV4dCwgbSwgbS5uZXh0KSA8IDA7XG59XG5cbi8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbmZ1bmN0aW9uIGluZGV4Q3VydmUoc3RhcnQsIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICB2YXIgcCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAueiA9PT0gMCkgcC56ID0gek9yZGVyKHAueCwgcC55LCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgcC5wcmV2WiA9IHAucHJldjtcbiAgICAgICAgcC5uZXh0WiA9IHAubmV4dDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICBwLnByZXZaLm5leHRaID0gbnVsbDtcbiAgICBwLnByZXZaID0gbnVsbDtcblxuICAgIHNvcnRMaW5rZWQocCk7XG59XG5cbi8vIFNpbW9uIFRhdGhhbSdzIGxpbmtlZCBsaXN0IG1lcmdlIHNvcnQgYWxnb3JpdGhtXG4vLyBodHRwOi8vd3d3LmNoaWFyay5ncmVlbmVuZC5vcmcudWsvfnNndGF0aGFtL2FsZ29yaXRobXMvbGlzdHNvcnQuaHRtbFxuZnVuY3Rpb24gc29ydExpbmtlZChsaXN0KSB7XG4gICAgdmFyIGksIHAsIHEsIGUsIHRhaWwsIG51bU1lcmdlcywgcFNpemUsIHFTaXplLFxuICAgICAgICBpblNpemUgPSAxO1xuXG4gICAgZG8ge1xuICAgICAgICBwID0gbGlzdDtcbiAgICAgICAgbGlzdCA9IG51bGw7XG4gICAgICAgIHRhaWwgPSBudWxsO1xuICAgICAgICBudW1NZXJnZXMgPSAwO1xuXG4gICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICBudW1NZXJnZXMrKztcbiAgICAgICAgICAgIHEgPSBwO1xuICAgICAgICAgICAgcFNpemUgPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcFNpemUrKztcbiAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICBpZiAoIXEpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcVNpemUgPSBpblNpemU7XG5cbiAgICAgICAgICAgIHdoaWxlIChwU2l6ZSA+IDAgfHwgKHFTaXplID4gMCAmJiBxKSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHBTaXplICE9PSAwICYmIChxU2l6ZSA9PT0gMCB8fCAhcSB8fCBwLnogPD0gcS56KSkge1xuICAgICAgICAgICAgICAgICAgICBlID0gcDtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHBTaXplLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHE7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBxU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0YWlsKSB0YWlsLm5leHRaID0gZTtcbiAgICAgICAgICAgICAgICBlbHNlIGxpc3QgPSBlO1xuXG4gICAgICAgICAgICAgICAgZS5wcmV2WiA9IHRhaWw7XG4gICAgICAgICAgICAgICAgdGFpbCA9IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAgPSBxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFpbC5uZXh0WiA9IG51bGw7XG4gICAgICAgIGluU2l6ZSAqPSAyO1xuXG4gICAgfSB3aGlsZSAobnVtTWVyZ2VzID4gMSk7XG5cbiAgICByZXR1cm4gbGlzdDtcbn1cblxuLy8gei1vcmRlciBvZiBhIHBvaW50IGdpdmVuIGNvb3JkcyBhbmQgaW52ZXJzZSBvZiB0aGUgbG9uZ2VyIHNpZGUgb2YgZGF0YSBiYm94XG5mdW5jdGlvbiB6T3JkZXIoeCwgeSwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIC8vIGNvb3JkcyBhcmUgdHJhbnNmb3JtZWQgaW50byBub24tbmVnYXRpdmUgMTUtYml0IGludGVnZXIgcmFuZ2VcbiAgICB4ID0gKHggLSBtaW5YKSAqIGludlNpemUgfCAwO1xuICAgIHkgPSAoeSAtIG1pblkpICogaW52U2l6ZSB8IDA7XG5cbiAgICB4ID0gKHggfCAoeCA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgIHggPSAoeCB8ICh4IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgeCA9ICh4IHwgKHggPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICB4ID0gKHggfCAoeCA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgeSA9ICh5IHwgKHkgPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICB5ID0gKHkgfCAoeSA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgIHkgPSAoeSB8ICh5IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gICAgeSA9ICh5IHwgKHkgPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICAgIHJldHVybiB4IHwgKHkgPDwgMSk7XG59XG5cbi8vIGZpbmQgdGhlIGxlZnRtb3N0IG5vZGUgb2YgYSBwb2x5Z29uIHJpbmdcbmZ1bmN0aW9uIGdldExlZnRtb3N0KHN0YXJ0KSB7XG4gICAgdmFyIHAgPSBzdGFydCxcbiAgICAgICAgbGVmdG1vc3QgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLnggPCBsZWZ0bW9zdC54IHx8IChwLnggPT09IGxlZnRtb3N0LnggJiYgcC55IDwgbGVmdG1vc3QueSkpIGxlZnRtb3N0ID0gcDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gbGVmdG1vc3Q7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9pbnQgbGllcyB3aXRoaW4gYSBjb252ZXggdHJpYW5nbGVcbmZ1bmN0aW9uIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBweCwgcHkpIHtcbiAgICByZXR1cm4gKGN4IC0gcHgpICogKGF5IC0gcHkpID49IChheCAtIHB4KSAqIChjeSAtIHB5KSAmJlxuICAgICAgICAgICAoYXggLSBweCkgKiAoYnkgLSBweSkgPj0gKGJ4IC0gcHgpICogKGF5IC0gcHkpICYmXG4gICAgICAgICAgIChieCAtIHB4KSAqIChjeSAtIHB5KSA+PSAoY3ggLSBweCkgKiAoYnkgLSBweSk7XG59XG5cbi8vIGNoZWNrIGlmIGEgZGlhZ29uYWwgYmV0d2VlbiB0d28gcG9seWdvbiBub2RlcyBpcyB2YWxpZCAobGllcyBpbiBwb2x5Z29uIGludGVyaW9yKVxuZnVuY3Rpb24gaXNWYWxpZERpYWdvbmFsKGEsIGIpIHtcbiAgICByZXR1cm4gYS5uZXh0LmkgIT09IGIuaSAmJiBhLnByZXYuaSAhPT0gYi5pICYmICFpbnRlcnNlY3RzUG9seWdvbihhLCBiKSAmJiAvLyBkb25lcyd0IGludGVyc2VjdCBvdGhlciBlZGdlc1xuICAgICAgICAgICAobG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpICYmIG1pZGRsZUluc2lkZShhLCBiKSAmJiAvLyBsb2NhbGx5IHZpc2libGVcbiAgICAgICAgICAgIChhcmVhKGEucHJldiwgYSwgYi5wcmV2KSB8fCBhcmVhKGEsIGIucHJldiwgYikpIHx8IC8vIGRvZXMgbm90IGNyZWF0ZSBvcHBvc2l0ZS1mYWNpbmcgc2VjdG9yc1xuICAgICAgICAgICAgZXF1YWxzKGEsIGIpICYmIGFyZWEoYS5wcmV2LCBhLCBhLm5leHQpID4gMCAmJiBhcmVhKGIucHJldiwgYiwgYi5uZXh0KSA+IDApOyAvLyBzcGVjaWFsIHplcm8tbGVuZ3RoIGNhc2Vcbn1cblxuLy8gc2lnbmVkIGFyZWEgb2YgYSB0cmlhbmdsZVxuZnVuY3Rpb24gYXJlYShwLCBxLCByKSB7XG4gICAgcmV0dXJuIChxLnkgLSBwLnkpICogKHIueCAtIHEueCkgLSAocS54IC0gcC54KSAqIChyLnkgLSBxLnkpO1xufVxuXG4vLyBjaGVjayBpZiB0d28gcG9pbnRzIGFyZSBlcXVhbFxuZnVuY3Rpb24gZXF1YWxzKHAxLCBwMikge1xuICAgIHJldHVybiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnk7XG59XG5cbi8vIGNoZWNrIGlmIHR3byBzZWdtZW50cyBpbnRlcnNlY3RcbmZ1bmN0aW9uIGludGVyc2VjdHMocDEsIHExLCBwMiwgcTIpIHtcbiAgICB2YXIgbzEgPSBzaWduKGFyZWEocDEsIHExLCBwMikpO1xuICAgIHZhciBvMiA9IHNpZ24oYXJlYShwMSwgcTEsIHEyKSk7XG4gICAgdmFyIG8zID0gc2lnbihhcmVhKHAyLCBxMiwgcDEpKTtcbiAgICB2YXIgbzQgPSBzaWduKGFyZWEocDIsIHEyLCBxMSkpO1xuXG4gICAgaWYgKG8xICE9PSBvMiAmJiBvMyAhPT0gbzQpIHJldHVybiB0cnVlOyAvLyBnZW5lcmFsIGNhc2VcblxuICAgIGlmIChvMSA9PT0gMCAmJiBvblNlZ21lbnQocDEsIHAyLCBxMSkpIHJldHVybiB0cnVlOyAvLyBwMSwgcTEgYW5kIHAyIGFyZSBjb2xsaW5lYXIgYW5kIHAyIGxpZXMgb24gcDFxMVxuICAgIGlmIChvMiA9PT0gMCAmJiBvblNlZ21lbnQocDEsIHEyLCBxMSkpIHJldHVybiB0cnVlOyAvLyBwMSwgcTEgYW5kIHEyIGFyZSBjb2xsaW5lYXIgYW5kIHEyIGxpZXMgb24gcDFxMVxuICAgIGlmIChvMyA9PT0gMCAmJiBvblNlZ21lbnQocDIsIHAxLCBxMikpIHJldHVybiB0cnVlOyAvLyBwMiwgcTIgYW5kIHAxIGFyZSBjb2xsaW5lYXIgYW5kIHAxIGxpZXMgb24gcDJxMlxuICAgIGlmIChvNCA9PT0gMCAmJiBvblNlZ21lbnQocDIsIHExLCBxMikpIHJldHVybiB0cnVlOyAvLyBwMiwgcTIgYW5kIHExIGFyZSBjb2xsaW5lYXIgYW5kIHExIGxpZXMgb24gcDJxMlxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBmb3IgY29sbGluZWFyIHBvaW50cyBwLCBxLCByLCBjaGVjayBpZiBwb2ludCBxIGxpZXMgb24gc2VnbWVudCBwclxuZnVuY3Rpb24gb25TZWdtZW50KHAsIHEsIHIpIHtcbiAgICByZXR1cm4gcS54IDw9IE1hdGgubWF4KHAueCwgci54KSAmJiBxLnggPj0gTWF0aC5taW4ocC54LCByLngpICYmIHEueSA8PSBNYXRoLm1heChwLnksIHIueSkgJiYgcS55ID49IE1hdGgubWluKHAueSwgci55KTtcbn1cblxuZnVuY3Rpb24gc2lnbihudW0pIHtcbiAgICByZXR1cm4gbnVtID4gMCA/IDEgOiBudW0gPCAwID8gLTEgOiAwO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBzZWdtZW50c1xuZnVuY3Rpb24gaW50ZXJzZWN0c1BvbHlnb24oYSwgYikge1xuICAgIHZhciBwID0gYTtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLmkgIT09IGEuaSAmJiBwLm5leHQuaSAhPT0gYS5pICYmIHAuaSAhPT0gYi5pICYmIHAubmV4dC5pICE9PSBiLmkgJiZcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RzKHAsIHAubmV4dCwgYSwgYikpIHJldHVybiB0cnVlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IGEpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgbG9jYWxseSBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIGxvY2FsbHlJbnNpZGUoYSwgYikge1xuICAgIHJldHVybiBhcmVhKGEucHJldiwgYSwgYS5uZXh0KSA8IDAgP1xuICAgICAgICBhcmVhKGEsIGIsIGEubmV4dCkgPj0gMCAmJiBhcmVhKGEsIGEucHJldiwgYikgPj0gMCA6XG4gICAgICAgIGFyZWEoYSwgYiwgYS5wcmV2KSA8IDAgfHwgYXJlYShhLCBhLm5leHQsIGIpIDwgMDtcbn1cblxuLy8gY2hlY2sgaWYgdGhlIG1pZGRsZSBwb2ludCBvZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBtaWRkbGVJbnNpZGUoYSwgYikge1xuICAgIHZhciBwID0gYSxcbiAgICAgICAgaW5zaWRlID0gZmFsc2UsXG4gICAgICAgIHB4ID0gKGEueCArIGIueCkgLyAyLFxuICAgICAgICBweSA9IChhLnkgKyBiLnkpIC8gMjtcbiAgICBkbyB7XG4gICAgICAgIGlmICgoKHAueSA+IHB5KSAhPT0gKHAubmV4dC55ID4gcHkpKSAmJiBwLm5leHQueSAhPT0gcC55ICYmXG4gICAgICAgICAgICAgICAgKHB4IDwgKHAubmV4dC54IC0gcC54KSAqIChweSAtIHAueSkgLyAocC5uZXh0LnkgLSBwLnkpICsgcC54KSlcbiAgICAgICAgICAgIGluc2lkZSA9ICFpbnNpZGU7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gYSk7XG5cbiAgICByZXR1cm4gaW5zaWRlO1xufVxuXG4vLyBsaW5rIHR3byBwb2x5Z29uIHZlcnRpY2VzIHdpdGggYSBicmlkZ2U7IGlmIHRoZSB2ZXJ0aWNlcyBiZWxvbmcgdG8gdGhlIHNhbWUgcmluZywgaXQgc3BsaXRzIHBvbHlnb24gaW50byB0d287XG4vLyBpZiBvbmUgYmVsb25ncyB0byB0aGUgb3V0ZXIgcmluZyBhbmQgYW5vdGhlciB0byBhIGhvbGUsIGl0IG1lcmdlcyBpdCBpbnRvIGEgc2luZ2xlIHJpbmdcbmZ1bmN0aW9uIHNwbGl0UG9seWdvbihhLCBiKSB7XG4gICAgdmFyIGEyID0gbmV3IE5vZGUoYS5pLCBhLngsIGEueSksXG4gICAgICAgIGIyID0gbmV3IE5vZGUoYi5pLCBiLngsIGIueSksXG4gICAgICAgIGFuID0gYS5uZXh0LFxuICAgICAgICBicCA9IGIucHJldjtcblxuICAgIGEubmV4dCA9IGI7XG4gICAgYi5wcmV2ID0gYTtcblxuICAgIGEyLm5leHQgPSBhbjtcbiAgICBhbi5wcmV2ID0gYTI7XG5cbiAgICBiMi5uZXh0ID0gYTI7XG4gICAgYTIucHJldiA9IGIyO1xuXG4gICAgYnAubmV4dCA9IGIyO1xuICAgIGIyLnByZXYgPSBicDtcblxuICAgIHJldHVybiBiMjtcbn1cblxuLy8gY3JlYXRlIGEgbm9kZSBhbmQgb3B0aW9uYWxseSBsaW5rIGl0IHdpdGggcHJldmlvdXMgb25lIChpbiBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdClcbmZ1bmN0aW9uIGluc2VydE5vZGUoaSwgeCwgeSwgbGFzdCkge1xuICAgIHZhciBwID0gbmV3IE5vZGUoaSwgeCwgeSk7XG5cbiAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgcC5wcmV2ID0gcDtcbiAgICAgICAgcC5uZXh0ID0gcDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHAubmV4dCA9IGxhc3QubmV4dDtcbiAgICAgICAgcC5wcmV2ID0gbGFzdDtcbiAgICAgICAgbGFzdC5uZXh0LnByZXYgPSBwO1xuICAgICAgICBsYXN0Lm5leHQgPSBwO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTm9kZShwKSB7XG4gICAgcC5uZXh0LnByZXYgPSBwLnByZXY7XG4gICAgcC5wcmV2Lm5leHQgPSBwLm5leHQ7XG5cbiAgICBpZiAocC5wcmV2WikgcC5wcmV2Wi5uZXh0WiA9IHAubmV4dFo7XG4gICAgaWYgKHAubmV4dFopIHAubmV4dFoucHJldlogPSBwLnByZXZaO1xufVxuXG5mdW5jdGlvbiBOb2RlKGksIHgsIHkpIHtcbiAgICAvLyB2ZXJ0ZXggaW5kZXggaW4gY29vcmRpbmF0ZXMgYXJyYXlcbiAgICB0aGlzLmkgPSBpO1xuXG4gICAgLy8gdmVydGV4IGNvb3JkaW5hdGVzXG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuXG4gICAgLy8gcHJldmlvdXMgYW5kIG5leHQgdmVydGV4IG5vZGVzIGluIGEgcG9seWdvbiByaW5nXG4gICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuXG4gICAgLy8gei1vcmRlciBjdXJ2ZSB2YWx1ZVxuICAgIHRoaXMueiA9IDA7XG5cbiAgICAvLyBwcmV2aW91cyBhbmQgbmV4dCBub2RlcyBpbiB6LW9yZGVyXG4gICAgdGhpcy5wcmV2WiA9IG51bGw7XG4gICAgdGhpcy5uZXh0WiA9IG51bGw7XG5cbiAgICAvLyBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGEgc3RlaW5lciBwb2ludFxuICAgIHRoaXMuc3RlaW5lciA9IGZhbHNlO1xufVxuXG4vLyByZXR1cm4gYSBwZXJjZW50YWdlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgcG9seWdvbiBhcmVhIGFuZCBpdHMgdHJpYW5ndWxhdGlvbiBhcmVhO1xuLy8gdXNlZCB0byB2ZXJpZnkgY29ycmVjdG5lc3Mgb2YgdHJpYW5ndWxhdGlvblxuZWFyY3V0LmRldmlhdGlvbiA9IGZ1bmN0aW9uIChkYXRhLCBob2xlSW5kaWNlcywgZGltLCB0cmlhbmdsZXMpIHtcbiAgICB2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGg7XG4gICAgdmFyIG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuXG4gICAgdmFyIHBvbHlnb25BcmVhID0gTWF0aC5hYnMoc2lnbmVkQXJlYShkYXRhLCAwLCBvdXRlckxlbiwgZGltKSk7XG4gICAgaWYgKGhhc0hvbGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XG4gICAgICAgICAgICB2YXIgZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1tpICsgMV0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHBvbHlnb25BcmVhIC09IE1hdGguYWJzKHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdHJpYW5nbGVzQXJlYSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB2YXIgYSA9IHRyaWFuZ2xlc1tpXSAqIGRpbTtcbiAgICAgICAgdmFyIGIgPSB0cmlhbmdsZXNbaSArIDFdICogZGltO1xuICAgICAgICB2YXIgYyA9IHRyaWFuZ2xlc1tpICsgMl0gKiBkaW07XG4gICAgICAgIHRyaWFuZ2xlc0FyZWEgKz0gTWF0aC5hYnMoXG4gICAgICAgICAgICAoZGF0YVthXSAtIGRhdGFbY10pICogKGRhdGFbYiArIDFdIC0gZGF0YVthICsgMV0pIC1cbiAgICAgICAgICAgIChkYXRhW2FdIC0gZGF0YVtiXSkgKiAoZGF0YVtjICsgMV0gLSBkYXRhW2EgKyAxXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBwb2x5Z29uQXJlYSA9PT0gMCAmJiB0cmlhbmdsZXNBcmVhID09PSAwID8gMCA6XG4gICAgICAgIE1hdGguYWJzKCh0cmlhbmdsZXNBcmVhIC0gcG9seWdvbkFyZWEpIC8gcG9seWdvbkFyZWEpO1xufTtcblxuZnVuY3Rpb24gc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQsIGogPSBlbmQgLSBkaW07IGkgPCBlbmQ7IGkgKz0gZGltKSB7XG4gICAgICAgIHN1bSArPSAoZGF0YVtqXSAtIGRhdGFbaV0pICogKGRhdGFbaSArIDFdICsgZGF0YVtqICsgMV0pO1xuICAgICAgICBqID0gaTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cblxuLy8gdHVybiBhIHBvbHlnb24gaW4gYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSBmb3JtIChlLmcuIGFzIGluIEdlb0pTT04pIGludG8gYSBmb3JtIEVhcmN1dCBhY2NlcHRzXG5lYXJjdXQuZmxhdHRlbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGRpbSA9IGRhdGFbMF1bMF0ubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSB7dmVydGljZXM6IFtdLCBob2xlczogW10sIGRpbWVuc2lvbnM6IGRpbX0sXG4gICAgICAgIGhvbGVJbmRleCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkYXRhW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRpbTsgZCsrKSByZXN1bHQudmVydGljZXMucHVzaChkYXRhW2ldW2pdW2RdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGhvbGVJbmRleCArPSBkYXRhW2kgLSAxXS5sZW5ndGg7XG4gICAgICAgICAgICByZXN1bHQuaG9sZXMucHVzaChob2xlSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///720\n")},34:module=>{"use strict";eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQTZCO0FBQ2pDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qcz83MDJlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKCkge31cblxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vXG4gIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIC8vXG4gIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gZW1pdHRlcjtcbn1cblxuLyoqXG4gKiBDbGVhciBldmVudCBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG59XG5cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgbmFtZXMgPSBbXVxuICAgICwgZXZlbnRzXG4gICAgLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG4gIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKFxuICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICAgICkge1xuICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG4gICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcbiAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgICAvL1xuICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQ7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///34\n")},63:module=>{"use strict";eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (Array.isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZGVjb2RlLmpzPzk3MGUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///63\n")},957:module=>{"use strict";eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return Object.keys(obj).map(function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (Array.isArray(obj[k])) {\n        return obj[k].map(function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTU3LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2VuY29kZS5qcz82ZTQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gb2JqW2tdLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///957\n")},582:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nexports.decode = exports.parse = __webpack_require__(63);\nexports.encode = exports.stringify = __webpack_require__(957);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTgyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsR0FBRyx1Q0FBbUM7QUFDcEQsY0FBYyxHQUFHLDRDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9pbmRleC5qcz81MzFjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///582\n")},928:function(module,exports,__webpack_require__){eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports =  true && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule =  true && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * http://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttrue\n\t) {\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\t\treturn punycode;\n\t\t}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n\n}(this));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUVVO0FBQ1o7QUFDQSxFQUFFLG1DQUFtQjtBQUNyQjtBQUNBLEdBQUc7QUFBQSxrR0FBQztBQUNKLEdBQUcsS0FBSyxFQVVOOztBQUVGLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvdXJsL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcz9iZTU2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuMy4yIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjMuMicsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///928\n")},44:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("var __webpack_unused_export__;\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar punycode = __webpack_require__(928);\nvar util = __webpack_require__(944);\n\nexports.Qc = urlParse;\nexports.DB = urlResolve;\n__webpack_unused_export__ = urlResolveObject;\nexports.WU = urlFormat;\n\n__webpack_unused_export__ = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = __webpack_require__(582);\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvdXJsL3VybC5qcz81NzAwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///44\n")},944:module=>{"use strict";eval("\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQ0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanM/Yzk4OSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///944\n")},126:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  I: () => (/* reexport */ Color)\n});\n\n;// CONCATENATED MODULE: ./node_modules/colord/index.mjs\nvar r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return"string"==typeof r?r.length>0:"number"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?"0"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return{h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return{r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},c=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,p=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,v=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,m=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},"rgb"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u="deg"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},"hsl"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},"rgb"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},"hsl"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},"hsv"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return"string"==typeof r?N(r.trim(),y.string):"object"==typeof r&&null!==r?N(r,y.object):[null,void 0]},I=function(r){return x(r)[1]},M=function(r,t){var n=c(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):"","#"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?"rgba("+t+", "+n+", "+e+", "+u+")":"rgb("+t+", "+n+", "+e+")";var r,t,n,e,u},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?"hsla("+t+", "+n+"%, "+e+"%, "+u+")":"hsl("+t+", "+n+"%, "+e+"%)";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return"number"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=c(this.rgba);return"number"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r))})},E=function(){return new j({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};\n\n;// CONCATENATED MODULE: ./node_modules/colord/plugins/names.mjs\n/* harmony default export */ function names(e,f){var a={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var d,i,n=r[this.toHex()];if(n)return n;if(null==f?void 0:f.closest){var o=this.toRgb(),t=1/0,b="black";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=o,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d="transparent"===r?"#0000":a[r];return d?new e(d).toRgb():null},"name"])}\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/color/lib/Color.mjs\n\n\n\nk([names]);\nconst _Color = class {\n  constructor(value = 16777215) {\n    this._value = null;\n    this._components = new Float32Array(4);\n    this._components.fill(1);\n    this._int = 16777215;\n    this.value = value;\n  }\n  get red() {\n    return this._components[0];\n  }\n  get green() {\n    return this._components[1];\n  }\n  get blue() {\n    return this._components[2];\n  }\n  get alpha() {\n    return this._components[3];\n  }\n  setValue(value) {\n    this.value = value;\n    return this;\n  }\n  set value(value) {\n    if (value instanceof _Color) {\n      this._value = this.cloneSource(value._value);\n      this._int = value._int;\n      this._components.set(value._components);\n    } else if (value === null) {\n      throw new Error("Cannot set PIXI.Color#value to null");\n    } else if (this._value === null || !this.isSourceEqual(this._value, value)) {\n      this.normalize(value);\n      this._value = this.cloneSource(value);\n    }\n  }\n  get value() {\n    return this._value;\n  }\n  cloneSource(value) {\n    if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {\n      return value;\n    } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n      return value.slice(0);\n    } else if (typeof value === "object" && value !== null) {\n      return { ...value };\n    }\n    return value;\n  }\n  isSourceEqual(value1, value2) {\n    const type1 = typeof value1;\n    const type2 = typeof value2;\n    if (type1 !== type2) {\n      return false;\n    } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {\n      return value1 === value2;\n    } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {\n      if (value1.length !== value2.length) {\n        return false;\n      }\n      return value1.every((v, i) => v === value2[i]);\n    } else if (value1 !== null && value2 !== null) {\n      const keys1 = Object.keys(value1);\n      const keys2 = Object.keys(value2);\n      if (keys1.length !== keys2.length) {\n        return false;\n      }\n      return keys1.every((key) => value1[key] === value2[key]);\n    }\n    return value1 === value2;\n  }\n  toRgba() {\n    const [r, g, b, a] = this._components;\n    return { r, g, b, a };\n  }\n  toRgb() {\n    const [r, g, b] = this._components;\n    return { r, g, b };\n  }\n  toRgbaString() {\n    const [r, g, b] = this.toUint8RgbArray();\n    return `rgba(${r},${g},${b},${this.alpha})`;\n  }\n  toUint8RgbArray(out) {\n    const [r, g, b] = this._components;\n    out = out ?? [];\n    out[0] = Math.round(r * 255);\n    out[1] = Math.round(g * 255);\n    out[2] = Math.round(b * 255);\n    return out;\n  }\n  toRgbArray(out) {\n    out = out ?? [];\n    const [r, g, b] = this._components;\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    return out;\n  }\n  toNumber() {\n    return this._int;\n  }\n  toLittleEndianNumber() {\n    const value = this._int;\n    return (value >> 16) + (value & 65280) + ((value & 255) << 16);\n  }\n  multiply(value) {\n    const [r, g, b, a] = _Color.temp.setValue(value)._components;\n    this._components[0] *= r;\n    this._components[1] *= g;\n    this._components[2] *= b;\n    this._components[3] *= a;\n    this.refreshInt();\n    this._value = null;\n    return this;\n  }\n  premultiply(alpha, applyToRGB = true) {\n    if (applyToRGB) {\n      this._components[0] *= alpha;\n      this._components[1] *= alpha;\n      this._components[2] *= alpha;\n    }\n    this._components[3] = alpha;\n    this.refreshInt();\n    this._value = null;\n    return this;\n  }\n  toPremultiplied(alpha, applyToRGB = true) {\n    if (alpha === 1) {\n      return (255 << 24) + this._int;\n    }\n    if (alpha === 0) {\n      return applyToRGB ? 0 : this._int;\n    }\n    let r = this._int >> 16 & 255;\n    let g = this._int >> 8 & 255;\n    let b = this._int & 255;\n    if (applyToRGB) {\n      r = r * alpha + 0.5 | 0;\n      g = g * alpha + 0.5 | 0;\n      b = b * alpha + 0.5 | 0;\n    }\n    return (alpha * 255 << 24) + (r << 16) + (g << 8) + b;\n  }\n  toHex() {\n    const hexString = this._int.toString(16);\n    return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;\n  }\n  toHexa() {\n    const alphaValue = Math.round(this._components[3] * 255);\n    const alphaString = alphaValue.toString(16);\n    return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;\n  }\n  setAlpha(alpha) {\n    this._components[3] = this._clamp(alpha);\n    return this;\n  }\n  round(steps) {\n    const [r, g, b] = this._components;\n    this._components[0] = Math.round(r * steps) / steps;\n    this._components[1] = Math.round(g * steps) / steps;\n    this._components[2] = Math.round(b * steps) / steps;\n    this.refreshInt();\n    this._value = null;\n    return this;\n  }\n  toArray(out) {\n    out = out ?? [];\n    const [r, g, b, a] = this._components;\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    out[3] = a;\n    return out;\n  }\n  normalize(value) {\n    let r;\n    let g;\n    let b;\n    let a;\n    if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {\n      const int = value;\n      r = (int >> 16 & 255) / 255;\n      g = (int >> 8 & 255) / 255;\n      b = (int & 255) / 255;\n      a = 1;\n    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {\n      value = this._clamp(value);\n      [r, g, b, a = 1] = value;\n    } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {\n      value = this._clamp(value, 0, 255);\n      [r, g, b, a = 255] = value;\n      r /= 255;\n      g /= 255;\n      b /= 255;\n      a /= 255;\n    } else if (typeof value === "string" || typeof value === "object") {\n      if (typeof value === "string") {\n        const match = _Color.HEX_PATTERN.exec(value);\n        if (match) {\n          value = `#${match[2]}`;\n        }\n      }\n      const color = w(value);\n      if (color.isValid()) {\n        ({ r, g, b, a } = color.rgba);\n        r /= 255;\n        g /= 255;\n        b /= 255;\n      }\n    }\n    if (r !== void 0) {\n      this._components[0] = r;\n      this._components[1] = g;\n      this._components[2] = b;\n      this._components[3] = a;\n      this.refreshInt();\n    } else {\n      throw new Error(`Unable to convert color ${value}`);\n    }\n  }\n  refreshInt() {\n    this._clamp(this._components);\n    const [r, g, b] = this._components;\n    this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);\n  }\n  _clamp(value, min = 0, max = 1) {\n    if (typeof value === "number") {\n      return Math.min(Math.max(value, min), max);\n    }\n    value.forEach((v, i) => {\n      value[i] = Math.min(Math.max(v, min), max);\n    });\n    return value;\n  }\n};\nlet Color = _Color;\nColor.shared = new _Color();\nColor.temp = new _Color();\nColor.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\n\n\n//# sourceMappingURL=Color.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/color/lib/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEVBQUUsRUFBRSxJQUFJLFVBQVUsRUFBRTs7QUFFM0M7QUFDakI7OztBQ3RQb0M7QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvY29sb3JkL2luZGV4Lm1qcz80ZGIwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9jb2xvcmQvcGx1Z2lucy9uYW1lcy5tanM/NDM4YyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29sb3IvbGliL0NvbG9yLm1qcz82MGNlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb2xvci9saWIvaW5kZXgubWpzPzE2M2EiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHI9e2dyYWQ6LjksdHVybjozNjAscmFkOjM2MC8oMipNYXRoLlBJKX0sdD1mdW5jdGlvbihyKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2Ygcj9yLmxlbmd0aD4wOlwibnVtYmVyXCI9PXR5cGVvZiByfSxuPWZ1bmN0aW9uKHIsdCxuKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksdm9pZCAwPT09biYmKG49TWF0aC5wb3coMTAsdCkpLE1hdGgucm91bmQobipyKS9uKzB9LGU9ZnVuY3Rpb24ocix0LG4pe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSx2b2lkIDA9PT1uJiYobj0xKSxyPm4/bjpyPnQ/cjp0fSx1PWZ1bmN0aW9uKHIpe3JldHVybihyPWlzRmluaXRlKHIpP3IlMzYwOjApPjA/cjpyKzM2MH0sYT1mdW5jdGlvbihyKXtyZXR1cm57cjplKHIuciwwLDI1NSksZzplKHIuZywwLDI1NSksYjplKHIuYiwwLDI1NSksYTplKHIuYSl9fSxvPWZ1bmN0aW9uKHIpe3JldHVybntyOm4oci5yKSxnOm4oci5nKSxiOm4oci5iKSxhOm4oci5hLDMpfX0saT0vXiMoWzAtOWEtZl17Myw4fSkkL2kscz1mdW5jdGlvbihyKXt2YXIgdD1yLnRvU3RyaW5nKDE2KTtyZXR1cm4gdC5sZW5ndGg8Mj9cIjBcIit0OnR9LGg9ZnVuY3Rpb24ocil7dmFyIHQ9ci5yLG49ci5nLGU9ci5iLHU9ci5hLGE9TWF0aC5tYXgodCxuLGUpLG89YS1NYXRoLm1pbih0LG4sZSksaT1vP2E9PT10PyhuLWUpL286YT09PW4/MisoZS10KS9vOjQrKHQtbikvbzowO3JldHVybntoOjYwKihpPDA/aSs2OmkpLHM6YT9vL2EqMTAwOjAsdjphLzI1NSoxMDAsYTp1fX0sYj1mdW5jdGlvbihyKXt2YXIgdD1yLmgsbj1yLnMsZT1yLnYsdT1yLmE7dD10LzM2MCo2LG4vPTEwMCxlLz0xMDA7dmFyIGE9TWF0aC5mbG9vcih0KSxvPWUqKDEtbiksaT1lKigxLSh0LWEpKm4pLHM9ZSooMS0oMS10K2EpKm4pLGg9YSU2O3JldHVybntyOjI1NSpbZSxpLG8sbyxzLGVdW2hdLGc6MjU1KltzLGUsZSxpLG8sb11baF0sYjoyNTUqW28sbyxzLGUsZSxpXVtoXSxhOnV9fSxnPWZ1bmN0aW9uKHIpe3JldHVybntoOnUoci5oKSxzOmUoci5zLDAsMTAwKSxsOmUoci5sLDAsMTAwKSxhOmUoci5hKX19LGQ9ZnVuY3Rpb24ocil7cmV0dXJue2g6bihyLmgpLHM6bihyLnMpLGw6bihyLmwpLGE6bihyLmEsMyl9fSxmPWZ1bmN0aW9uKHIpe3JldHVybiBiKChuPSh0PXIpLnMse2g6dC5oLHM6KG4qPSgoZT10LmwpPDUwP2U6MTAwLWUpLzEwMCk+MD8yKm4vKGUrbikqMTAwOjAsdjplK24sYTp0LmF9KSk7dmFyIHQsbixlfSxjPWZ1bmN0aW9uKHIpe3JldHVybntoOih0PWgocikpLmgsczoodT0oMjAwLShuPXQucykpKihlPXQudikvMTAwKT4wJiZ1PDIwMD9uKmUvMTAwLyh1PD0xMDA/dToyMDAtdSkqMTAwOjAsbDp1LzIsYTp0LmF9O3ZhciB0LG4sZSx1fSxsPS9eaHNsYT9cXChcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKShkZWd8cmFkfGdyYWR8dHVybik/XFxzKixcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSVcXHMqLFxccyooWystXT9cXGQqXFwuP1xcZCspJVxccyooPzosXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKik/XFwpJC9pLHA9L15oc2xhP1xcKFxccyooWystXT9cXGQqXFwuP1xcZCspKGRlZ3xyYWR8Z3JhZHx0dXJuKT9cXHMrKFsrLV0/XFxkKlxcLj9cXGQrKSVcXHMrKFsrLV0/XFxkKlxcLj9cXGQrKSVcXHMqKD86XFwvXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKik/XFwpJC9pLHY9L15yZ2JhP1xcKFxccyooWystXT9cXGQqXFwuP1xcZCspKCUpP1xccyosXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKixcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMqKD86LFxccyooWystXT9cXGQqXFwuP1xcZCspKCUpP1xccyopP1xcKSQvaSxtPS9ecmdiYT9cXChcXHMqKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMrKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMrKFsrLV0/XFxkKlxcLj9cXGQrKSglKT9cXHMqKD86XFwvXFxzKihbKy1dP1xcZCpcXC4/XFxkKykoJSk/XFxzKik/XFwpJC9pLHk9e3N0cmluZzpbW2Z1bmN0aW9uKHIpe3ZhciB0PWkuZXhlYyhyKTtyZXR1cm4gdD8ocj10WzFdKS5sZW5ndGg8PTQ/e3I6cGFyc2VJbnQoclswXStyWzBdLDE2KSxnOnBhcnNlSW50KHJbMV0rclsxXSwxNiksYjpwYXJzZUludChyWzJdK3JbMl0sMTYpLGE6ND09PXIubGVuZ3RoP24ocGFyc2VJbnQoclszXStyWzNdLDE2KS8yNTUsMik6MX06Nj09PXIubGVuZ3RofHw4PT09ci5sZW5ndGg/e3I6cGFyc2VJbnQoci5zdWJzdHIoMCwyKSwxNiksZzpwYXJzZUludChyLnN1YnN0cigyLDIpLDE2KSxiOnBhcnNlSW50KHIuc3Vic3RyKDQsMiksMTYpLGE6OD09PXIubGVuZ3RoP24ocGFyc2VJbnQoci5zdWJzdHIoNiwyKSwxNikvMjU1LDIpOjF9Om51bGw6bnVsbH0sXCJoZXhcIl0sW2Z1bmN0aW9uKHIpe3ZhciB0PXYuZXhlYyhyKXx8bS5leGVjKHIpO3JldHVybiB0P3RbMl0hPT10WzRdfHx0WzRdIT09dFs2XT9udWxsOmEoe3I6TnVtYmVyKHRbMV0pLyh0WzJdPzEwMC8yNTU6MSksZzpOdW1iZXIodFszXSkvKHRbNF0/MTAwLzI1NToxKSxiOk51bWJlcih0WzVdKS8odFs2XT8xMDAvMjU1OjEpLGE6dm9pZCAwPT09dFs3XT8xOk51bWJlcih0WzddKS8odFs4XT8xMDA6MSl9KTpudWxsfSxcInJnYlwiXSxbZnVuY3Rpb24odCl7dmFyIG49bC5leGVjKHQpfHxwLmV4ZWModCk7aWYoIW4pcmV0dXJuIG51bGw7dmFyIGUsdSxhPWcoe2g6KGU9blsxXSx1PW5bMl0sdm9pZCAwPT09dSYmKHU9XCJkZWdcIiksTnVtYmVyKGUpKihyW3VdfHwxKSksczpOdW1iZXIoblszXSksbDpOdW1iZXIobls0XSksYTp2b2lkIDA9PT1uWzVdPzE6TnVtYmVyKG5bNV0pLyhuWzZdPzEwMDoxKX0pO3JldHVybiBmKGEpfSxcImhzbFwiXV0sb2JqZWN0OltbZnVuY3Rpb24ocil7dmFyIG49ci5yLGU9ci5nLHU9ci5iLG89ci5hLGk9dm9pZCAwPT09bz8xOm87cmV0dXJuIHQobikmJnQoZSkmJnQodSk/YSh7cjpOdW1iZXIobiksZzpOdW1iZXIoZSksYjpOdW1iZXIodSksYTpOdW1iZXIoaSl9KTpudWxsfSxcInJnYlwiXSxbZnVuY3Rpb24ocil7dmFyIG49ci5oLGU9ci5zLHU9ci5sLGE9ci5hLG89dm9pZCAwPT09YT8xOmE7aWYoIXQobil8fCF0KGUpfHwhdCh1KSlyZXR1cm4gbnVsbDt2YXIgaT1nKHtoOk51bWJlcihuKSxzOk51bWJlcihlKSxsOk51bWJlcih1KSxhOk51bWJlcihvKX0pO3JldHVybiBmKGkpfSxcImhzbFwiXSxbZnVuY3Rpb24ocil7dmFyIG49ci5oLGE9ci5zLG89ci52LGk9ci5hLHM9dm9pZCAwPT09aT8xOmk7aWYoIXQobil8fCF0KGEpfHwhdChvKSlyZXR1cm4gbnVsbDt2YXIgaD1mdW5jdGlvbihyKXtyZXR1cm57aDp1KHIuaCksczplKHIucywwLDEwMCksdjplKHIudiwwLDEwMCksYTplKHIuYSl9fSh7aDpOdW1iZXIobiksczpOdW1iZXIoYSksdjpOdW1iZXIobyksYTpOdW1iZXIocyl9KTtyZXR1cm4gYihoKX0sXCJoc3ZcIl1dfSxOPWZ1bmN0aW9uKHIsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBlPXRbbl1bMF0ocik7aWYoZSlyZXR1cm5bZSx0W25dWzFdXX1yZXR1cm5bbnVsbCx2b2lkIDBdfSx4PWZ1bmN0aW9uKHIpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiByP04oci50cmltKCkseS5zdHJpbmcpOlwib2JqZWN0XCI9PXR5cGVvZiByJiZudWxsIT09cj9OKHIseS5vYmplY3QpOltudWxsLHZvaWQgMF19LEk9ZnVuY3Rpb24ocil7cmV0dXJuIHgocilbMV19LE09ZnVuY3Rpb24ocix0KXt2YXIgbj1jKHIpO3JldHVybntoOm4uaCxzOmUobi5zKzEwMCp0LDAsMTAwKSxsOm4ubCxhOm4uYX19LEg9ZnVuY3Rpb24ocil7cmV0dXJuKDI5OSpyLnIrNTg3KnIuZysxMTQqci5iKS8xZTMvMjU1fSwkPWZ1bmN0aW9uKHIsdCl7dmFyIG49YyhyKTtyZXR1cm57aDpuLmgsczpuLnMsbDplKG4ubCsxMDAqdCwwLDEwMCksYTpuLmF9fSxqPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihyKXt0aGlzLnBhcnNlZD14KHIpWzBdLHRoaXMucmdiYT10aGlzLnBhcnNlZHx8e3I6MCxnOjAsYjowLGE6MX19cmV0dXJuIHIucHJvdG90eXBlLmlzVmFsaWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMucGFyc2VkfSxyLnByb3RvdHlwZS5icmlnaHRuZXNzPWZ1bmN0aW9uKCl7cmV0dXJuIG4oSCh0aGlzLnJnYmEpLDIpfSxyLnByb3RvdHlwZS5pc0Rhcms9ZnVuY3Rpb24oKXtyZXR1cm4gSCh0aGlzLnJnYmEpPC41fSxyLnByb3RvdHlwZS5pc0xpZ2h0PWZ1bmN0aW9uKCl7cmV0dXJuIEgodGhpcy5yZ2JhKT49LjV9LHIucHJvdG90eXBlLnRvSGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHI9byh0aGlzLnJnYmEpLHQ9ci5yLGU9ci5nLHU9ci5iLGk9KGE9ci5hKTwxP3MobigyNTUqYSkpOlwiXCIsXCIjXCIrcyh0KStzKGUpK3ModSkraTt2YXIgcix0LGUsdSxhLGl9LHIucHJvdG90eXBlLnRvUmdiPWZ1bmN0aW9uKCl7cmV0dXJuIG8odGhpcy5yZ2JhKX0sci5wcm90b3R5cGUudG9SZ2JTdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gcj1vKHRoaXMucmdiYSksdD1yLnIsbj1yLmcsZT1yLmIsKHU9ci5hKTwxP1wicmdiYShcIit0K1wiLCBcIituK1wiLCBcIitlK1wiLCBcIit1K1wiKVwiOlwicmdiKFwiK3QrXCIsIFwiK24rXCIsIFwiK2UrXCIpXCI7dmFyIHIsdCxuLGUsdX0sci5wcm90b3R5cGUudG9Ic2w9ZnVuY3Rpb24oKXtyZXR1cm4gZChjKHRoaXMucmdiYSkpfSxyLnByb3RvdHlwZS50b0hzbFN0cmluZz1mdW5jdGlvbigpe3JldHVybiByPWQoYyh0aGlzLnJnYmEpKSx0PXIuaCxuPXIucyxlPXIubCwodT1yLmEpPDE/XCJoc2xhKFwiK3QrXCIsIFwiK24rXCIlLCBcIitlK1wiJSwgXCIrdStcIilcIjpcImhzbChcIit0K1wiLCBcIituK1wiJSwgXCIrZStcIiUpXCI7dmFyIHIsdCxuLGUsdX0sci5wcm90b3R5cGUudG9Ic3Y9ZnVuY3Rpb24oKXtyZXR1cm4gcj1oKHRoaXMucmdiYSkse2g6bihyLmgpLHM6bihyLnMpLHY6bihyLnYpLGE6bihyLmEsMyl9O3ZhciByfSxyLnByb3RvdHlwZS5pbnZlcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdyh7cjoyNTUtKHI9dGhpcy5yZ2JhKS5yLGc6MjU1LXIuZyxiOjI1NS1yLmIsYTpyLmF9KTt2YXIgcn0sci5wcm90b3R5cGUuc2F0dXJhdGU9ZnVuY3Rpb24ocil7cmV0dXJuIHZvaWQgMD09PXImJihyPS4xKSx3KE0odGhpcy5yZ2JhLHIpKX0sci5wcm90b3R5cGUuZGVzYXR1cmF0ZT1mdW5jdGlvbihyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjEpLHcoTSh0aGlzLnJnYmEsLXIpKX0sci5wcm90b3R5cGUuZ3JheXNjYWxlPWZ1bmN0aW9uKCl7cmV0dXJuIHcoTSh0aGlzLnJnYmEsLTEpKX0sci5wcm90b3R5cGUubGlnaHRlbj1mdW5jdGlvbihyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjEpLHcoJCh0aGlzLnJnYmEscikpfSxyLnByb3RvdHlwZS5kYXJrZW49ZnVuY3Rpb24ocil7cmV0dXJuIHZvaWQgMD09PXImJihyPS4xKSx3KCQodGhpcy5yZ2JhLC1yKSl9LHIucHJvdG90eXBlLnJvdGF0ZT1mdW5jdGlvbihyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9MTUpLHRoaXMuaHVlKHRoaXMuaHVlKCkrcil9LHIucHJvdG90eXBlLmFscGhhPWZ1bmN0aW9uKHIpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiByP3coe3I6KHQ9dGhpcy5yZ2JhKS5yLGc6dC5nLGI6dC5iLGE6cn0pOm4odGhpcy5yZ2JhLmEsMyk7dmFyIHR9LHIucHJvdG90eXBlLmh1ZT1mdW5jdGlvbihyKXt2YXIgdD1jKHRoaXMucmdiYSk7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHI/dyh7aDpyLHM6dC5zLGw6dC5sLGE6dC5hfSk6bih0LmgpfSxyLnByb3RvdHlwZS5pc0VxdWFsPWZ1bmN0aW9uKHIpe3JldHVybiB0aGlzLnRvSGV4KCk9PT13KHIpLnRvSGV4KCl9LHJ9KCksdz1mdW5jdGlvbihyKXtyZXR1cm4gciBpbnN0YW5jZW9mIGo/cjpuZXcgaihyKX0sUz1bXSxrPWZ1bmN0aW9uKHIpe3IuZm9yRWFjaChmdW5jdGlvbihyKXtTLmluZGV4T2Yocik8MCYmKHIoaix5KSxTLnB1c2gocikpfSl9LEU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGooe3I6MjU1Kk1hdGgucmFuZG9tKCksZzoyNTUqTWF0aC5yYW5kb20oKSxiOjI1NSpNYXRoLnJhbmRvbSgpfSl9O2V4cG9ydHtqIGFzIENvbG9yZCx3IGFzIGNvbG9yZCxrIGFzIGV4dGVuZCxJIGFzIGdldEZvcm1hdCxFIGFzIHJhbmRvbX07XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihlLGYpe3ZhciBhPXt3aGl0ZTpcIiNmZmZmZmZcIixiaXNxdWU6XCIjZmZlNGM0XCIsYmx1ZTpcIiMwMDAwZmZcIixjYWRldGJsdWU6XCIjNWY5ZWEwXCIsY2hhcnRyZXVzZTpcIiM3ZmZmMDBcIixjaG9jb2xhdGU6XCIjZDI2OTFlXCIsY29yYWw6XCIjZmY3ZjUwXCIsYW50aXF1ZXdoaXRlOlwiI2ZhZWJkN1wiLGFxdWE6XCIjMDBmZmZmXCIsYXp1cmU6XCIjZjBmZmZmXCIsd2hpdGVzbW9rZTpcIiNmNWY1ZjVcIixwYXBheWF3aGlwOlwiI2ZmZWZkNVwiLHBsdW06XCIjZGRhMGRkXCIsYmxhbmNoZWRhbG1vbmQ6XCIjZmZlYmNkXCIsYmxhY2s6XCIjMDAwMDAwXCIsZ29sZDpcIiNmZmQ3MDBcIixnb2xkZW5yb2Q6XCIjZGFhNTIwXCIsZ2FpbnNib3JvOlwiI2RjZGNkY1wiLGNvcm5zaWxrOlwiI2ZmZjhkY1wiLGNvcm5mbG93ZXJibHVlOlwiIzY0OTVlZFwiLGJ1cmx5d29vZDpcIiNkZWI4ODdcIixhcXVhbWFyaW5lOlwiIzdmZmZkNFwiLGJlaWdlOlwiI2Y1ZjVkY1wiLGNyaW1zb246XCIjZGMxNDNjXCIsY3lhbjpcIiMwMGZmZmZcIixkYXJrYmx1ZTpcIiMwMDAwOGJcIixkYXJrY3lhbjpcIiMwMDhiOGJcIixkYXJrZ29sZGVucm9kOlwiI2I4ODYwYlwiLGRhcmtraGFraTpcIiNiZGI3NmJcIixkYXJrZ3JheTpcIiNhOWE5YTlcIixkYXJrZ3JlZW46XCIjMDA2NDAwXCIsZGFya2dyZXk6XCIjYTlhOWE5XCIscGVhY2hwdWZmOlwiI2ZmZGFiOVwiLGRhcmttYWdlbnRhOlwiIzhiMDA4YlwiLGRhcmtyZWQ6XCIjOGIwMDAwXCIsZGFya29yY2hpZDpcIiM5OTMyY2NcIixkYXJrb3JhbmdlOlwiI2ZmOGMwMFwiLGRhcmtzbGF0ZWJsdWU6XCIjNDgzZDhiXCIsZ3JheTpcIiM4MDgwODBcIixkYXJrc2xhdGVncmF5OlwiIzJmNGY0ZlwiLGRhcmtzbGF0ZWdyZXk6XCIjMmY0ZjRmXCIsZGVlcHBpbms6XCIjZmYxNDkzXCIsZGVlcHNreWJsdWU6XCIjMDBiZmZmXCIsd2hlYXQ6XCIjZjVkZWIzXCIsZmlyZWJyaWNrOlwiI2IyMjIyMlwiLGZsb3JhbHdoaXRlOlwiI2ZmZmFmMFwiLGdob3N0d2hpdGU6XCIjZjhmOGZmXCIsZGFya3Zpb2xldDpcIiM5NDAwZDNcIixtYWdlbnRhOlwiI2ZmMDBmZlwiLGdyZWVuOlwiIzAwODAwMFwiLGRvZGdlcmJsdWU6XCIjMWU5MGZmXCIsZ3JleTpcIiM4MDgwODBcIixob25leWRldzpcIiNmMGZmZjBcIixob3RwaW5rOlwiI2ZmNjliNFwiLGJsdWV2aW9sZXQ6XCIjOGEyYmUyXCIsZm9yZXN0Z3JlZW46XCIjMjI4YjIyXCIsbGF3bmdyZWVuOlwiIzdjZmMwMFwiLGluZGlhbnJlZDpcIiNjZDVjNWNcIixpbmRpZ286XCIjNGIwMDgyXCIsZnVjaHNpYTpcIiNmZjAwZmZcIixicm93bjpcIiNhNTJhMmFcIixtYXJvb246XCIjODAwMDAwXCIsbWVkaXVtYmx1ZTpcIiMwMDAwY2RcIixsaWdodGNvcmFsOlwiI2YwODA4MFwiLGRhcmt0dXJxdW9pc2U6XCIjMDBjZWQxXCIsbGlnaHRjeWFuOlwiI2UwZmZmZlwiLGl2b3J5OlwiI2ZmZmZmMFwiLGxpZ2h0eWVsbG93OlwiI2ZmZmZlMFwiLGxpZ2h0c2FsbW9uOlwiI2ZmYTA3YVwiLGxpZ2h0c2VhZ3JlZW46XCIjMjBiMmFhXCIsbGluZW46XCIjZmFmMGU2XCIsbWVkaXVtYXF1YW1hcmluZTpcIiM2NmNkYWFcIixsZW1vbmNoaWZmb246XCIjZmZmYWNkXCIsbGltZTpcIiMwMGZmMDBcIixraGFraTpcIiNmMGU2OGNcIixtZWRpdW1zZWFncmVlbjpcIiMzY2IzNzFcIixsaW1lZ3JlZW46XCIjMzJjZDMyXCIsbWVkaXVtc3ByaW5nZ3JlZW46XCIjMDBmYTlhXCIsbGlnaHRza3libHVlOlwiIzg3Y2VmYVwiLGxpZ2h0Ymx1ZTpcIiNhZGQ4ZTZcIixtaWRuaWdodGJsdWU6XCIjMTkxOTcwXCIsbGlnaHRwaW5rOlwiI2ZmYjZjMVwiLG1pc3R5cm9zZTpcIiNmZmU0ZTFcIixtb2NjYXNpbjpcIiNmZmU0YjVcIixtaW50Y3JlYW06XCIjZjVmZmZhXCIsbGlnaHRzbGF0ZWdyYXk6XCIjNzc4ODk5XCIsbGlnaHRzbGF0ZWdyZXk6XCIjNzc4ODk5XCIsbmF2YWpvd2hpdGU6XCIjZmZkZWFkXCIsbmF2eTpcIiMwMDAwODBcIixtZWRpdW12aW9sZXRyZWQ6XCIjYzcxNTg1XCIscG93ZGVyYmx1ZTpcIiNiMGUwZTZcIixwYWxlZ29sZGVucm9kOlwiI2VlZThhYVwiLG9sZGxhY2U6XCIjZmRmNWU2XCIscGFsZXR1cnF1b2lzZTpcIiNhZmVlZWVcIixtZWRpdW10dXJxdW9pc2U6XCIjNDhkMWNjXCIsbWVkaXVtb3JjaGlkOlwiI2JhNTVkM1wiLHJlYmVjY2FwdXJwbGU6XCIjNjYzMzk5XCIsbGlnaHRzdGVlbGJsdWU6XCIjYjBjNGRlXCIsbWVkaXVtc2xhdGVibHVlOlwiIzdiNjhlZVwiLHRoaXN0bGU6XCIjZDhiZmQ4XCIsdGFuOlwiI2QyYjQ4Y1wiLG9yY2hpZDpcIiNkYTcwZDZcIixtZWRpdW1wdXJwbGU6XCIjOTM3MGRiXCIscHVycGxlOlwiIzgwMDA4MFwiLHBpbms6XCIjZmZjMGNiXCIsc2t5Ymx1ZTpcIiM4N2NlZWJcIixzcHJpbmdncmVlbjpcIiMwMGZmN2ZcIixwYWxlZ3JlZW46XCIjOThmYjk4XCIscmVkOlwiI2ZmMDAwMFwiLHllbGxvdzpcIiNmZmZmMDBcIixzbGF0ZWJsdWU6XCIjNmE1YWNkXCIsbGF2ZW5kZXJibHVzaDpcIiNmZmYwZjVcIixwZXJ1OlwiI2NkODUzZlwiLHBhbGV2aW9sZXRyZWQ6XCIjZGI3MDkzXCIsdmlvbGV0OlwiI2VlODJlZVwiLHRlYWw6XCIjMDA4MDgwXCIsc2xhdGVncmF5OlwiIzcwODA5MFwiLHNsYXRlZ3JleTpcIiM3MDgwOTBcIixhbGljZWJsdWU6XCIjZjBmOGZmXCIsZGFya3NlYWdyZWVuOlwiIzhmYmM4ZlwiLGRhcmtvbGl2ZWdyZWVuOlwiIzU1NmIyZlwiLGdyZWVueWVsbG93OlwiI2FkZmYyZlwiLHNlYWdyZWVuOlwiIzJlOGI1N1wiLHNlYXNoZWxsOlwiI2ZmZjVlZVwiLHRvbWF0bzpcIiNmZjYzNDdcIixzaWx2ZXI6XCIjYzBjMGMwXCIsc2llbm5hOlwiI2EwNTIyZFwiLGxhdmVuZGVyOlwiI2U2ZTZmYVwiLGxpZ2h0Z3JlZW46XCIjOTBlZTkwXCIsb3JhbmdlOlwiI2ZmYTUwMFwiLG9yYW5nZXJlZDpcIiNmZjQ1MDBcIixzdGVlbGJsdWU6XCIjNDY4MmI0XCIscm95YWxibHVlOlwiIzQxNjllMVwiLHR1cnF1b2lzZTpcIiM0MGUwZDBcIix5ZWxsb3dncmVlbjpcIiM5YWNkMzJcIixzYWxtb246XCIjZmE4MDcyXCIsc2FkZGxlYnJvd246XCIjOGI0NTEzXCIsc2FuZHlicm93bjpcIiNmNGE0NjBcIixyb3N5YnJvd246XCIjYmM4ZjhmXCIsZGFya3NhbG1vbjpcIiNlOTk2N2FcIixsaWdodGdvbGRlbnJvZHllbGxvdzpcIiNmYWZhZDJcIixzbm93OlwiI2ZmZmFmYVwiLGxpZ2h0Z3JleTpcIiNkM2QzZDNcIixsaWdodGdyYXk6XCIjZDNkM2QzXCIsZGltZ3JheTpcIiM2OTY5NjlcIixkaW1ncmV5OlwiIzY5Njk2OVwiLG9saXZlZHJhYjpcIiM2YjhlMjNcIixvbGl2ZTpcIiM4MDgwMDBcIn0scj17fTtmb3IodmFyIGQgaW4gYSlyW2FbZF1dPWQ7dmFyIGw9e307ZS5wcm90b3R5cGUudG9OYW1lPWZ1bmN0aW9uKGYpe2lmKCEodGhpcy5yZ2JhLmF8fHRoaXMucmdiYS5yfHx0aGlzLnJnYmEuZ3x8dGhpcy5yZ2JhLmIpKXJldHVyblwidHJhbnNwYXJlbnRcIjt2YXIgZCxpLG49clt0aGlzLnRvSGV4KCldO2lmKG4pcmV0dXJuIG47aWYobnVsbD09Zj92b2lkIDA6Zi5jbG9zZXN0KXt2YXIgbz10aGlzLnRvUmdiKCksdD0xLzAsYj1cImJsYWNrXCI7aWYoIWwubGVuZ3RoKWZvcih2YXIgYyBpbiBhKWxbY109bmV3IGUoYVtjXSkudG9SZ2IoKTtmb3IodmFyIGcgaW4gYSl7dmFyIHU9KGQ9byxpPWxbZ10sTWF0aC5wb3coZC5yLWkuciwyKStNYXRoLnBvdyhkLmctaS5nLDIpK01hdGgucG93KGQuYi1pLmIsMikpO3U8dCYmKHQ9dSxiPWcpfXJldHVybiBifX07Zi5zdHJpbmcucHVzaChbZnVuY3Rpb24oZil7dmFyIHI9Zi50b0xvd2VyQ2FzZSgpLGQ9XCJ0cmFuc3BhcmVudFwiPT09cj9cIiMwMDAwXCI6YVtyXTtyZXR1cm4gZD9uZXcgZShkKS50b1JnYigpOm51bGx9LFwibmFtZVwiXSl9XG4iLCJpbXBvcnQgeyBleHRlbmQsIGNvbG9yZCB9IGZyb20gJ2NvbG9yZCc7XG5pbXBvcnQgbmFtZXNQbHVnaW4gZnJvbSAnY29sb3JkL3BsdWdpbnMvbmFtZXMnO1xuXG5leHRlbmQoW25hbWVzUGx1Z2luXSk7XG5jb25zdCBfQ29sb3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlID0gMTY3NzcyMTUpIHtcbiAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG4gICAgdGhpcy5fY29tcG9uZW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgdGhpcy5fY29tcG9uZW50cy5maWxsKDEpO1xuICAgIHRoaXMuX2ludCA9IDE2Nzc3MjE1O1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBnZXQgcmVkKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzWzBdO1xuICB9XG4gIGdldCBncmVlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c1sxXTtcbiAgfVxuICBnZXQgYmx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c1syXTtcbiAgfVxuICBnZXQgYWxwaGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNbM107XG4gIH1cbiAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgX0NvbG9yKSB7XG4gICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuY2xvbmVTb3VyY2UodmFsdWUuX3ZhbHVlKTtcbiAgICAgIHRoaXMuX2ludCA9IHZhbHVlLl9pbnQ7XG4gICAgICB0aGlzLl9jb21wb25lbnRzLnNldCh2YWx1ZS5fY29tcG9uZW50cyk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBQSVhJLkNvbG9yI3ZhbHVlIHRvIG51bGxcIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLl92YWx1ZSA9PT0gbnVsbCB8fCAhdGhpcy5pc1NvdXJjZUVxdWFsKHRoaXMuX3ZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgIHRoaXMubm9ybWFsaXplKHZhbHVlKTtcbiAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5jbG9uZVNvdXJjZSh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cbiAgY2xvbmVTb3VyY2UodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlciB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDApO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4geyAuLi52YWx1ZSB9O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaXNTb3VyY2VFcXVhbCh2YWx1ZTEsIHZhbHVlMikge1xuICAgIGNvbnN0IHR5cGUxID0gdHlwZW9mIHZhbHVlMTtcbiAgICBjb25zdCB0eXBlMiA9IHR5cGVvZiB2YWx1ZTI7XG4gICAgaWYgKHR5cGUxICE9PSB0eXBlMikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodHlwZTEgPT09IFwibnVtYmVyXCIgfHwgdHlwZTEgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUxIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUxID09PSB2YWx1ZTI7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlMSkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZTIpIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZTEpICYmIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZTIpKSB7XG4gICAgICBpZiAodmFsdWUxLmxlbmd0aCAhPT0gdmFsdWUyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUxLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSB2YWx1ZTJbaV0pO1xuICAgIH0gZWxzZSBpZiAodmFsdWUxICE9PSBudWxsICYmIHZhbHVlMiAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyh2YWx1ZTEpO1xuICAgICAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyh2YWx1ZTIpO1xuICAgICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlzMS5ldmVyeSgoa2V5KSA9PiB2YWx1ZTFba2V5XSA9PT0gdmFsdWUyW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUxID09PSB2YWx1ZTI7XG4gIH1cbiAgdG9SZ2JhKCkge1xuICAgIGNvbnN0IFtyLCBnLCBiLCBhXSA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgcmV0dXJuIHsgciwgZywgYiwgYSB9O1xuICB9XG4gIHRvUmdiKCkge1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgcmV0dXJuIHsgciwgZywgYiB9O1xuICB9XG4gIHRvUmdiYVN0cmluZygpIHtcbiAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLnRvVWludDhSZ2JBcnJheSgpO1xuICAgIHJldHVybiBgcmdiYSgke3J9LCR7Z30sJHtifSwke3RoaXMuYWxwaGF9KWA7XG4gIH1cbiAgdG9VaW50OFJnYkFycmF5KG91dCkge1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgb3V0ID0gb3V0ID8/IFtdO1xuICAgIG91dFswXSA9IE1hdGgucm91bmQociAqIDI1NSk7XG4gICAgb3V0WzFdID0gTWF0aC5yb3VuZChnICogMjU1KTtcbiAgICBvdXRbMl0gPSBNYXRoLnJvdW5kKGIgKiAyNTUpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgdG9SZ2JBcnJheShvdXQpIHtcbiAgICBvdXQgPSBvdXQgPz8gW107XG4gICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy5fY29tcG9uZW50cztcbiAgICBvdXRbMF0gPSByO1xuICAgIG91dFsxXSA9IGc7XG4gICAgb3V0WzJdID0gYjtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIHRvTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnQ7XG4gIH1cbiAgdG9MaXR0bGVFbmRpYW5OdW1iZXIoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLl9pbnQ7XG4gICAgcmV0dXJuICh2YWx1ZSA+PiAxNikgKyAodmFsdWUgJiA2NTI4MCkgKyAoKHZhbHVlICYgMjU1KSA8PCAxNik7XG4gIH1cbiAgbXVsdGlwbHkodmFsdWUpIHtcbiAgICBjb25zdCBbciwgZywgYiwgYV0gPSBfQ29sb3IudGVtcC5zZXRWYWx1ZSh2YWx1ZSkuX2NvbXBvbmVudHM7XG4gICAgdGhpcy5fY29tcG9uZW50c1swXSAqPSByO1xuICAgIHRoaXMuX2NvbXBvbmVudHNbMV0gKj0gZztcbiAgICB0aGlzLl9jb21wb25lbnRzWzJdICo9IGI7XG4gICAgdGhpcy5fY29tcG9uZW50c1szXSAqPSBhO1xuICAgIHRoaXMucmVmcmVzaEludCgpO1xuICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwcmVtdWx0aXBseShhbHBoYSwgYXBwbHlUb1JHQiA9IHRydWUpIHtcbiAgICBpZiAoYXBwbHlUb1JHQikge1xuICAgICAgdGhpcy5fY29tcG9uZW50c1swXSAqPSBhbHBoYTtcbiAgICAgIHRoaXMuX2NvbXBvbmVudHNbMV0gKj0gYWxwaGE7XG4gICAgICB0aGlzLl9jb21wb25lbnRzWzJdICo9IGFscGhhO1xuICAgIH1cbiAgICB0aGlzLl9jb21wb25lbnRzWzNdID0gYWxwaGE7XG4gICAgdGhpcy5yZWZyZXNoSW50KCk7XG4gICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRvUHJlbXVsdGlwbGllZChhbHBoYSwgYXBwbHlUb1JHQiA9IHRydWUpIHtcbiAgICBpZiAoYWxwaGEgPT09IDEpIHtcbiAgICAgIHJldHVybiAoMjU1IDw8IDI0KSArIHRoaXMuX2ludDtcbiAgICB9XG4gICAgaWYgKGFscGhhID09PSAwKSB7XG4gICAgICByZXR1cm4gYXBwbHlUb1JHQiA/IDAgOiB0aGlzLl9pbnQ7XG4gICAgfVxuICAgIGxldCByID0gdGhpcy5faW50ID4+IDE2ICYgMjU1O1xuICAgIGxldCBnID0gdGhpcy5faW50ID4+IDggJiAyNTU7XG4gICAgbGV0IGIgPSB0aGlzLl9pbnQgJiAyNTU7XG4gICAgaWYgKGFwcGx5VG9SR0IpIHtcbiAgICAgIHIgPSByICogYWxwaGEgKyAwLjUgfCAwO1xuICAgICAgZyA9IGcgKiBhbHBoYSArIDAuNSB8IDA7XG4gICAgICBiID0gYiAqIGFscGhhICsgMC41IHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIChhbHBoYSAqIDI1NSA8PCAyNCkgKyAociA8PCAxNikgKyAoZyA8PCA4KSArIGI7XG4gIH1cbiAgdG9IZXgoKSB7XG4gICAgY29uc3QgaGV4U3RyaW5nID0gdGhpcy5faW50LnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gYCMke1wiMDAwMDAwXCIuc3Vic3RyaW5nKDAsIDYgLSBoZXhTdHJpbmcubGVuZ3RoKSArIGhleFN0cmluZ31gO1xuICB9XG4gIHRvSGV4YSgpIHtcbiAgICBjb25zdCBhbHBoYVZhbHVlID0gTWF0aC5yb3VuZCh0aGlzLl9jb21wb25lbnRzWzNdICogMjU1KTtcbiAgICBjb25zdCBhbHBoYVN0cmluZyA9IGFscGhhVmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiB0aGlzLnRvSGV4KCkgKyBcIjAwXCIuc3Vic3RyaW5nKDAsIDIgLSBhbHBoYVN0cmluZy5sZW5ndGgpICsgYWxwaGFTdHJpbmc7XG4gIH1cbiAgc2V0QWxwaGEoYWxwaGEpIHtcbiAgICB0aGlzLl9jb21wb25lbnRzWzNdID0gdGhpcy5fY2xhbXAoYWxwaGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJvdW5kKHN0ZXBzKSB7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy5fY29tcG9uZW50cztcbiAgICB0aGlzLl9jb21wb25lbnRzWzBdID0gTWF0aC5yb3VuZChyICogc3RlcHMpIC8gc3RlcHM7XG4gICAgdGhpcy5fY29tcG9uZW50c1sxXSA9IE1hdGgucm91bmQoZyAqIHN0ZXBzKSAvIHN0ZXBzO1xuICAgIHRoaXMuX2NvbXBvbmVudHNbMl0gPSBNYXRoLnJvdW5kKGIgKiBzdGVwcykgLyBzdGVwcztcbiAgICB0aGlzLnJlZnJlc2hJbnQoKTtcbiAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdG9BcnJheShvdXQpIHtcbiAgICBvdXQgPSBvdXQgPz8gW107XG4gICAgY29uc3QgW3IsIGcsIGIsIGFdID0gdGhpcy5fY29tcG9uZW50cztcbiAgICBvdXRbMF0gPSByO1xuICAgIG91dFsxXSA9IGc7XG4gICAgb3V0WzJdID0gYjtcbiAgICBvdXRbM10gPSBhO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgbm9ybWFsaXplKHZhbHVlKSB7XG4gICAgbGV0IHI7XG4gICAgbGV0IGc7XG4gICAgbGV0IGI7XG4gICAgbGV0IGE7XG4gICAgaWYgKCh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpICYmIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gMTY3NzcyMTUpIHtcbiAgICAgIGNvbnN0IGludCA9IHZhbHVlO1xuICAgICAgciA9IChpbnQgPj4gMTYgJiAyNTUpIC8gMjU1O1xuICAgICAgZyA9IChpbnQgPj4gOCAmIDI1NSkgLyAyNTU7XG4gICAgICBiID0gKGludCAmIDI1NSkgLyAyNTU7XG4gICAgICBhID0gMTtcbiAgICB9IGVsc2UgaWYgKChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkgJiYgdmFsdWUubGVuZ3RoID49IDMgJiYgdmFsdWUubGVuZ3RoIDw9IDQpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5fY2xhbXAodmFsdWUpO1xuICAgICAgW3IsIGcsIGIsIGEgPSAxXSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSAmJiB2YWx1ZS5sZW5ndGggPj0gMyAmJiB2YWx1ZS5sZW5ndGggPD0gNCkge1xuICAgICAgdmFsdWUgPSB0aGlzLl9jbGFtcCh2YWx1ZSwgMCwgMjU1KTtcbiAgICAgIFtyLCBnLCBiLCBhID0gMjU1XSA9IHZhbHVlO1xuICAgICAgciAvPSAyNTU7XG4gICAgICBnIC89IDI1NTtcbiAgICAgIGIgLz0gMjU1O1xuICAgICAgYSAvPSAyNTU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gX0NvbG9yLkhFWF9QQVRURVJOLmV4ZWModmFsdWUpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICB2YWx1ZSA9IGAjJHttYXRjaFsyXX1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBjb2xvciA9IGNvbG9yZCh2YWx1ZSk7XG4gICAgICBpZiAoY29sb3IuaXNWYWxpZCgpKSB7XG4gICAgICAgICh7IHIsIGcsIGIsIGEgfSA9IGNvbG9yLnJnYmEpO1xuICAgICAgICByIC89IDI1NTtcbiAgICAgICAgZyAvPSAyNTU7XG4gICAgICAgIGIgLz0gMjU1O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAociAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLl9jb21wb25lbnRzWzBdID0gcjtcbiAgICAgIHRoaXMuX2NvbXBvbmVudHNbMV0gPSBnO1xuICAgICAgdGhpcy5fY29tcG9uZW50c1syXSA9IGI7XG4gICAgICB0aGlzLl9jb21wb25lbnRzWzNdID0gYTtcbiAgICAgIHRoaXMucmVmcmVzaEludCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBjb252ZXJ0IGNvbG9yICR7dmFsdWV9YCk7XG4gICAgfVxuICB9XG4gIHJlZnJlc2hJbnQoKSB7XG4gICAgdGhpcy5fY2xhbXAodGhpcy5fY29tcG9uZW50cyk7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy5fY29tcG9uZW50cztcbiAgICB0aGlzLl9pbnQgPSAociAqIDI1NSA8PCAxNikgKyAoZyAqIDI1NSA8PCA4KSArIChiICogMjU1IHwgMCk7XG4gIH1cbiAgX2NsYW1wKHZhbHVlLCBtaW4gPSAwLCBtYXggPSAxKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpO1xuICAgIH1cbiAgICB2YWx1ZS5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgICB2YWx1ZVtpXSA9IE1hdGgubWluKE1hdGgubWF4KHYsIG1pbiksIG1heCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xubGV0IENvbG9yID0gX0NvbG9yO1xuQ29sb3Iuc2hhcmVkID0gbmV3IF9Db2xvcigpO1xuQ29sb3IudGVtcCA9IG5ldyBfQ29sb3IoKTtcbkNvbG9yLkhFWF9QQVRURVJOID0gL14oI3wweCk/KChbYS1mMC05XXszfSl7MSwyfShbYS1mMC05XXsyfSk/KSQvaTtcblxuZXhwb3J0IHsgQ29sb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbG9yLm1qcy5tYXBcbiIsImV4cG9ydCB7IENvbG9yIH0gZnJvbSAnLi9Db2xvci5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///126\n')},361:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A7: () => (/* binding */ MASK_TYPES),\n/* harmony export */   G5: () => (/* binding */ MSAA_QUALITY),\n/* harmony export */   I2: () => (/* binding */ FORMATS),\n/* harmony export */   N3: () => (/* binding */ RENDERER_TYPE),\n/* harmony export */   Nt: () => (/* binding */ WRAP_MODES),\n/* harmony export */   T$: () => (/* binding */ BLEND_MODES),\n/* harmony export */   UN: () => (/* binding */ GC_MODES),\n/* harmony export */   V0: () => (/* binding */ BUFFER_BITS),\n/* harmony export */   Vi: () => (/* binding */ ENV),\n/* harmony export */   WB: () => (/* binding */ MIPMAP_MODES),\n/* harmony export */   aH: () => (/* binding */ SCALE_MODES),\n/* harmony export */   cB: () => (/* binding */ PRECISION),\n/* harmony export */   iw: () => (/* binding */ ALPHA_MODES),\n/* harmony export */   lg: () => (/* binding */ DRAW_MODES),\n/* harmony export */   mr: () => (/* binding */ BUFFER_TYPE),\n/* harmony export */   oT: () => (/* binding */ SAMPLER_TYPES),\n/* harmony export */   sp: () => (/* binding */ TARGETS),\n/* harmony export */   vK: () => (/* binding */ TYPES),\n/* harmony export */   yl: () => (/* binding */ CLEAR_MODES)\n/* harmony export */ });\n/* unused harmony export COLOR_MASK_BITS */\nvar ENV = /* @__PURE__ */ ((ENV2) => {\n  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";\n  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";\n  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";\n  return ENV2;\n})(ENV || {});\nvar RENDERER_TYPE = /* @__PURE__ */ ((RENDERER_TYPE2) => {\n  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";\n  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";\n  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";\n  return RENDERER_TYPE2;\n})(RENDERER_TYPE || {});\nvar BUFFER_BITS = /* @__PURE__ */ ((BUFFER_BITS2) => {\n  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";\n  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";\n  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";\n  return BUFFER_BITS2;\n})(BUFFER_BITS || {});\nvar BLEND_MODES = /* @__PURE__ */ ((BLEND_MODES2) => {\n  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";\n  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";\n  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";\n  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";\n  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";\n  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";\n  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";\n  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";\n  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";\n  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";\n  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";\n  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";\n  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";\n  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";\n  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";\n  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";\n  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";\n  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";\n  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";\n  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";\n  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";\n  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";\n  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";\n  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";\n  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";\n  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";\n  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";\n  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";\n  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";\n  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";\n  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";\n  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";\n  return BLEND_MODES2;\n})(BLEND_MODES || {});\nvar DRAW_MODES = /* @__PURE__ */ ((DRAW_MODES2) => {\n  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";\n  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";\n  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";\n  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";\n  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";\n  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";\n  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";\n  return DRAW_MODES2;\n})(DRAW_MODES || {});\nvar FORMATS = /* @__PURE__ */ ((FORMATS2) => {\n  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";\n  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";\n  FORMATS2[FORMATS2["RG"] = 33319] = "RG";\n  FORMATS2[FORMATS2["RED"] = 6403] = "RED";\n  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";\n  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";\n  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";\n  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";\n  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";\n  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";\n  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";\n  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";\n  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";\n  return FORMATS2;\n})(FORMATS || {});\nvar TARGETS = /* @__PURE__ */ ((TARGETS2) => {\n  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";\n  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";\n  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";\n  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";\n  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";\n  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";\n  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";\n  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";\n  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";\n  return TARGETS2;\n})(TARGETS || {});\nvar TYPES = /* @__PURE__ */ ((TYPES2) => {\n  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";\n  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";\n  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";\n  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";\n  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";\n  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";\n  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";\n  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";\n  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";\n  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";\n  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";\n  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";\n  TYPES2[TYPES2["INT"] = 5124] = "INT";\n  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";\n  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";\n  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";\n  return TYPES2;\n})(TYPES || {});\nvar SAMPLER_TYPES = /* @__PURE__ */ ((SAMPLER_TYPES2) => {\n  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";\n  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";\n  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";\n  return SAMPLER_TYPES2;\n})(SAMPLER_TYPES || {});\nvar SCALE_MODES = /* @__PURE__ */ ((SCALE_MODES2) => {\n  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";\n  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";\n  return SCALE_MODES2;\n})(SCALE_MODES || {});\nvar WRAP_MODES = /* @__PURE__ */ ((WRAP_MODES2) => {\n  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";\n  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";\n  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";\n  return WRAP_MODES2;\n})(WRAP_MODES || {});\nvar MIPMAP_MODES = /* @__PURE__ */ ((MIPMAP_MODES2) => {\n  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";\n  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";\n  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";\n  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";\n  return MIPMAP_MODES2;\n})(MIPMAP_MODES || {});\nvar ALPHA_MODES = /* @__PURE__ */ ((ALPHA_MODES2) => {\n  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";\n  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";\n  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";\n  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";\n  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";\n  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";\n  return ALPHA_MODES2;\n})(ALPHA_MODES || {});\nvar CLEAR_MODES = /* @__PURE__ */ ((CLEAR_MODES2) => {\n  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";\n  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";\n  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";\n  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";\n  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";\n  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";\n  return CLEAR_MODES2;\n})(CLEAR_MODES || {});\nvar GC_MODES = /* @__PURE__ */ ((GC_MODES2) => {\n  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";\n  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";\n  return GC_MODES2;\n})(GC_MODES || {});\nvar PRECISION = /* @__PURE__ */ ((PRECISION2) => {\n  PRECISION2["LOW"] = "lowp";\n  PRECISION2["MEDIUM"] = "mediump";\n  PRECISION2["HIGH"] = "highp";\n  return PRECISION2;\n})(PRECISION || {});\nvar MASK_TYPES = /* @__PURE__ */ ((MASK_TYPES2) => {\n  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";\n  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";\n  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";\n  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";\n  MASK_TYPES2[MASK_TYPES2["COLOR"] = 4] = "COLOR";\n  return MASK_TYPES2;\n})(MASK_TYPES || {});\nvar COLOR_MASK_BITS = /* @__PURE__ */ ((COLOR_MASK_BITS2) => {\n  COLOR_MASK_BITS2[COLOR_MASK_BITS2["RED"] = 1] = "RED";\n  COLOR_MASK_BITS2[COLOR_MASK_BITS2["GREEN"] = 2] = "GREEN";\n  COLOR_MASK_BITS2[COLOR_MASK_BITS2["BLUE"] = 4] = "BLUE";\n  COLOR_MASK_BITS2[COLOR_MASK_BITS2["ALPHA"] = 8] = "ALPHA";\n  return COLOR_MASK_BITS2;\n})(COLOR_MASK_BITS || {});\nvar MSAA_QUALITY = /* @__PURE__ */ ((MSAA_QUALITY2) => {\n  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";\n  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";\n  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";\n  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";\n  return MSAA_QUALITY2;\n})(MSAA_QUALITY || {});\nvar BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {\n  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";\n  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";\n  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";\n  return BUFFER_TYPE2;\n})(BUFFER_TYPE || {});\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxXQUFXO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG1CQUFtQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0JBQWtCO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZUFBZTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxlQUFlO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsYUFBYTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtCQUFrQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQkFBbUI7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQkFBZ0I7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsaUJBQWlCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQkFBa0I7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1QkFBdUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0I7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1COztBQUVzTztBQUMxUCIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb25zdGFudHMvbGliL2luZGV4Lm1qcz9hM2JiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBFTlYgPSAvKiBAX19QVVJFX18gKi8gKChFTlYyKSA9PiB7XG4gIEVOVjJbRU5WMltcIldFQkdMX0xFR0FDWVwiXSA9IDBdID0gXCJXRUJHTF9MRUdBQ1lcIjtcbiAgRU5WMltFTlYyW1wiV0VCR0xcIl0gPSAxXSA9IFwiV0VCR0xcIjtcbiAgRU5WMltFTlYyW1wiV0VCR0wyXCJdID0gMl0gPSBcIldFQkdMMlwiO1xuICByZXR1cm4gRU5WMjtcbn0pKEVOViB8fCB7fSk7XG52YXIgUkVOREVSRVJfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyAoKFJFTkRFUkVSX1RZUEUyKSA9PiB7XG4gIFJFTkRFUkVSX1RZUEUyW1JFTkRFUkVSX1RZUEUyW1wiVU5LTk9XTlwiXSA9IDBdID0gXCJVTktOT1dOXCI7XG4gIFJFTkRFUkVSX1RZUEUyW1JFTkRFUkVSX1RZUEUyW1wiV0VCR0xcIl0gPSAxXSA9IFwiV0VCR0xcIjtcbiAgUkVOREVSRVJfVFlQRTJbUkVOREVSRVJfVFlQRTJbXCJDQU5WQVNcIl0gPSAyXSA9IFwiQ0FOVkFTXCI7XG4gIHJldHVybiBSRU5ERVJFUl9UWVBFMjtcbn0pKFJFTkRFUkVSX1RZUEUgfHwge30pO1xudmFyIEJVRkZFUl9CSVRTID0gLyogQF9fUFVSRV9fICovICgoQlVGRkVSX0JJVFMyKSA9PiB7XG4gIEJVRkZFUl9CSVRTMltCVUZGRVJfQklUUzJbXCJDT0xPUlwiXSA9IDE2Mzg0XSA9IFwiQ09MT1JcIjtcbiAgQlVGRkVSX0JJVFMyW0JVRkZFUl9CSVRTMltcIkRFUFRIXCJdID0gMjU2XSA9IFwiREVQVEhcIjtcbiAgQlVGRkVSX0JJVFMyW0JVRkZFUl9CSVRTMltcIlNURU5DSUxcIl0gPSAxMDI0XSA9IFwiU1RFTkNJTFwiO1xuICByZXR1cm4gQlVGRkVSX0JJVFMyO1xufSkoQlVGRkVSX0JJVFMgfHwge30pO1xudmFyIEJMRU5EX01PREVTID0gLyogQF9fUFVSRV9fICovICgoQkxFTkRfTU9ERVMyKSA9PiB7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJOT1JNQUxcIl0gPSAwXSA9IFwiTk9STUFMXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJBRERcIl0gPSAxXSA9IFwiQUREXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJNVUxUSVBMWVwiXSA9IDJdID0gXCJNVUxUSVBMWVwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiU0NSRUVOXCJdID0gM10gPSBcIlNDUkVFTlwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiT1ZFUkxBWVwiXSA9IDRdID0gXCJPVkVSTEFZXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJEQVJLRU5cIl0gPSA1XSA9IFwiREFSS0VOXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJMSUdIVEVOXCJdID0gNl0gPSBcIkxJR0hURU5cIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIkNPTE9SX0RPREdFXCJdID0gN10gPSBcIkNPTE9SX0RPREdFXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJDT0xPUl9CVVJOXCJdID0gOF0gPSBcIkNPTE9SX0JVUk5cIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIkhBUkRfTElHSFRcIl0gPSA5XSA9IFwiSEFSRF9MSUdIVFwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiU09GVF9MSUdIVFwiXSA9IDEwXSA9IFwiU09GVF9MSUdIVFwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiRElGRkVSRU5DRVwiXSA9IDExXSA9IFwiRElGRkVSRU5DRVwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiRVhDTFVTSU9OXCJdID0gMTJdID0gXCJFWENMVVNJT05cIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIkhVRVwiXSA9IDEzXSA9IFwiSFVFXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJTQVRVUkFUSU9OXCJdID0gMTRdID0gXCJTQVRVUkFUSU9OXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJDT0xPUlwiXSA9IDE1XSA9IFwiQ09MT1JcIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIkxVTUlOT1NJVFlcIl0gPSAxNl0gPSBcIkxVTUlOT1NJVFlcIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIk5PUk1BTF9OUE1cIl0gPSAxN10gPSBcIk5PUk1BTF9OUE1cIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIkFERF9OUE1cIl0gPSAxOF0gPSBcIkFERF9OUE1cIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIlNDUkVFTl9OUE1cIl0gPSAxOV0gPSBcIlNDUkVFTl9OUE1cIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIk5PTkVcIl0gPSAyMF0gPSBcIk5PTkVcIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIlNSQ19PVkVSXCJdID0gMF0gPSBcIlNSQ19PVkVSXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJTUkNfSU5cIl0gPSAyMV0gPSBcIlNSQ19JTlwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiU1JDX09VVFwiXSA9IDIyXSA9IFwiU1JDX09VVFwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiU1JDX0FUT1BcIl0gPSAyM10gPSBcIlNSQ19BVE9QXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJEU1RfT1ZFUlwiXSA9IDI0XSA9IFwiRFNUX09WRVJcIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIkRTVF9JTlwiXSA9IDI1XSA9IFwiRFNUX0lOXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJEU1RfT1VUXCJdID0gMjZdID0gXCJEU1RfT1VUXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJEU1RfQVRPUFwiXSA9IDI3XSA9IFwiRFNUX0FUT1BcIjtcbiAgQkxFTkRfTU9ERVMyW0JMRU5EX01PREVTMltcIkVSQVNFXCJdID0gMjZdID0gXCJFUkFTRVwiO1xuICBCTEVORF9NT0RFUzJbQkxFTkRfTU9ERVMyW1wiU1VCVFJBQ1RcIl0gPSAyOF0gPSBcIlNVQlRSQUNUXCI7XG4gIEJMRU5EX01PREVTMltCTEVORF9NT0RFUzJbXCJYT1JcIl0gPSAyOV0gPSBcIlhPUlwiO1xuICByZXR1cm4gQkxFTkRfTU9ERVMyO1xufSkoQkxFTkRfTU9ERVMgfHwge30pO1xudmFyIERSQVdfTU9ERVMgPSAvKiBAX19QVVJFX18gKi8gKChEUkFXX01PREVTMikgPT4ge1xuICBEUkFXX01PREVTMltEUkFXX01PREVTMltcIlBPSU5UU1wiXSA9IDBdID0gXCJQT0lOVFNcIjtcbiAgRFJBV19NT0RFUzJbRFJBV19NT0RFUzJbXCJMSU5FU1wiXSA9IDFdID0gXCJMSU5FU1wiO1xuICBEUkFXX01PREVTMltEUkFXX01PREVTMltcIkxJTkVfTE9PUFwiXSA9IDJdID0gXCJMSU5FX0xPT1BcIjtcbiAgRFJBV19NT0RFUzJbRFJBV19NT0RFUzJbXCJMSU5FX1NUUklQXCJdID0gM10gPSBcIkxJTkVfU1RSSVBcIjtcbiAgRFJBV19NT0RFUzJbRFJBV19NT0RFUzJbXCJUUklBTkdMRVNcIl0gPSA0XSA9IFwiVFJJQU5HTEVTXCI7XG4gIERSQVdfTU9ERVMyW0RSQVdfTU9ERVMyW1wiVFJJQU5HTEVfU1RSSVBcIl0gPSA1XSA9IFwiVFJJQU5HTEVfU1RSSVBcIjtcbiAgRFJBV19NT0RFUzJbRFJBV19NT0RFUzJbXCJUUklBTkdMRV9GQU5cIl0gPSA2XSA9IFwiVFJJQU5HTEVfRkFOXCI7XG4gIHJldHVybiBEUkFXX01PREVTMjtcbn0pKERSQVdfTU9ERVMgfHwge30pO1xudmFyIEZPUk1BVFMgPSAvKiBAX19QVVJFX18gKi8gKChGT1JNQVRTMikgPT4ge1xuICBGT1JNQVRTMltGT1JNQVRTMltcIlJHQkFcIl0gPSA2NDA4XSA9IFwiUkdCQVwiO1xuICBGT1JNQVRTMltGT1JNQVRTMltcIlJHQlwiXSA9IDY0MDddID0gXCJSR0JcIjtcbiAgRk9STUFUUzJbRk9STUFUUzJbXCJSR1wiXSA9IDMzMzE5XSA9IFwiUkdcIjtcbiAgRk9STUFUUzJbRk9STUFUUzJbXCJSRURcIl0gPSA2NDAzXSA9IFwiUkVEXCI7XG4gIEZPUk1BVFMyW0ZPUk1BVFMyW1wiUkdCQV9JTlRFR0VSXCJdID0gMzYyNDldID0gXCJSR0JBX0lOVEVHRVJcIjtcbiAgRk9STUFUUzJbRk9STUFUUzJbXCJSR0JfSU5URUdFUlwiXSA9IDM2MjQ4XSA9IFwiUkdCX0lOVEVHRVJcIjtcbiAgRk9STUFUUzJbRk9STUFUUzJbXCJSR19JTlRFR0VSXCJdID0gMzMzMjBdID0gXCJSR19JTlRFR0VSXCI7XG4gIEZPUk1BVFMyW0ZPUk1BVFMyW1wiUkVEX0lOVEVHRVJcIl0gPSAzNjI0NF0gPSBcIlJFRF9JTlRFR0VSXCI7XG4gIEZPUk1BVFMyW0ZPUk1BVFMyW1wiQUxQSEFcIl0gPSA2NDA2XSA9IFwiQUxQSEFcIjtcbiAgRk9STUFUUzJbRk9STUFUUzJbXCJMVU1JTkFOQ0VcIl0gPSA2NDA5XSA9IFwiTFVNSU5BTkNFXCI7XG4gIEZPUk1BVFMyW0ZPUk1BVFMyW1wiTFVNSU5BTkNFX0FMUEhBXCJdID0gNjQxMF0gPSBcIkxVTUlOQU5DRV9BTFBIQVwiO1xuICBGT1JNQVRTMltGT1JNQVRTMltcIkRFUFRIX0NPTVBPTkVOVFwiXSA9IDY0MDJdID0gXCJERVBUSF9DT01QT05FTlRcIjtcbiAgRk9STUFUUzJbRk9STUFUUzJbXCJERVBUSF9TVEVOQ0lMXCJdID0gMzQwNDFdID0gXCJERVBUSF9TVEVOQ0lMXCI7XG4gIHJldHVybiBGT1JNQVRTMjtcbn0pKEZPUk1BVFMgfHwge30pO1xudmFyIFRBUkdFVFMgPSAvKiBAX19QVVJFX18gKi8gKChUQVJHRVRTMikgPT4ge1xuICBUQVJHRVRTMltUQVJHRVRTMltcIlRFWFRVUkVfMkRcIl0gPSAzNTUzXSA9IFwiVEVYVFVSRV8yRFwiO1xuICBUQVJHRVRTMltUQVJHRVRTMltcIlRFWFRVUkVfQ1VCRV9NQVBcIl0gPSAzNDA2N10gPSBcIlRFWFRVUkVfQ1VCRV9NQVBcIjtcbiAgVEFSR0VUUzJbVEFSR0VUUzJbXCJURVhUVVJFXzJEX0FSUkFZXCJdID0gMzU4NjZdID0gXCJURVhUVVJFXzJEX0FSUkFZXCI7XG4gIFRBUkdFVFMyW1RBUkdFVFMyW1wiVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YXCJdID0gMzQwNjldID0gXCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1hcIjtcbiAgVEFSR0VUUzJbVEFSR0VUUzJbXCJURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1hcIl0gPSAzNDA3MF0gPSBcIlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWFwiO1xuICBUQVJHRVRTMltUQVJHRVRTMltcIlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWVwiXSA9IDM0MDcxXSA9IFwiVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9ZXCI7XG4gIFRBUkdFVFMyW1RBUkdFVFMyW1wiVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZXCJdID0gMzQwNzJdID0gXCJURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1lcIjtcbiAgVEFSR0VUUzJbVEFSR0VUUzJbXCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1pcIl0gPSAzNDA3M10gPSBcIlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWlwiO1xuICBUQVJHRVRTMltUQVJHRVRTMltcIlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWlwiXSA9IDM0MDc0XSA9IFwiVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9aXCI7XG4gIHJldHVybiBUQVJHRVRTMjtcbn0pKFRBUkdFVFMgfHwge30pO1xudmFyIFRZUEVTID0gLyogQF9fUFVSRV9fICovICgoVFlQRVMyKSA9PiB7XG4gIFRZUEVTMltUWVBFUzJbXCJVTlNJR05FRF9CWVRFXCJdID0gNTEyMV0gPSBcIlVOU0lHTkVEX0JZVEVcIjtcbiAgVFlQRVMyW1RZUEVTMltcIlVOU0lHTkVEX1NIT1JUXCJdID0gNTEyM10gPSBcIlVOU0lHTkVEX1NIT1JUXCI7XG4gIFRZUEVTMltUWVBFUzJbXCJVTlNJR05FRF9TSE9SVF81XzZfNVwiXSA9IDMzNjM1XSA9IFwiVU5TSUdORURfU0hPUlRfNV82XzVcIjtcbiAgVFlQRVMyW1RZUEVTMltcIlVOU0lHTkVEX1NIT1JUXzRfNF80XzRcIl0gPSAzMjgxOV0gPSBcIlVOU0lHTkVEX1NIT1JUXzRfNF80XzRcIjtcbiAgVFlQRVMyW1RZUEVTMltcIlVOU0lHTkVEX1NIT1JUXzVfNV81XzFcIl0gPSAzMjgyMF0gPSBcIlVOU0lHTkVEX1NIT1JUXzVfNV81XzFcIjtcbiAgVFlQRVMyW1RZUEVTMltcIlVOU0lHTkVEX0lOVFwiXSA9IDUxMjVdID0gXCJVTlNJR05FRF9JTlRcIjtcbiAgVFlQRVMyW1RZUEVTMltcIlVOU0lHTkVEX0lOVF8xMEZfMTFGXzExRl9SRVZcIl0gPSAzNTg5OV0gPSBcIlVOU0lHTkVEX0lOVF8xMEZfMTFGXzExRl9SRVZcIjtcbiAgVFlQRVMyW1RZUEVTMltcIlVOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFVlwiXSA9IDMzNjQwXSA9IFwiVU5TSUdORURfSU5UXzJfMTBfMTBfMTBfUkVWXCI7XG4gIFRZUEVTMltUWVBFUzJbXCJVTlNJR05FRF9JTlRfMjRfOFwiXSA9IDM0MDQyXSA9IFwiVU5TSUdORURfSU5UXzI0XzhcIjtcbiAgVFlQRVMyW1RZUEVTMltcIlVOU0lHTkVEX0lOVF81XzlfOV85X1JFVlwiXSA9IDM1OTAyXSA9IFwiVU5TSUdORURfSU5UXzVfOV85XzlfUkVWXCI7XG4gIFRZUEVTMltUWVBFUzJbXCJCWVRFXCJdID0gNTEyMF0gPSBcIkJZVEVcIjtcbiAgVFlQRVMyW1RZUEVTMltcIlNIT1JUXCJdID0gNTEyMl0gPSBcIlNIT1JUXCI7XG4gIFRZUEVTMltUWVBFUzJbXCJJTlRcIl0gPSA1MTI0XSA9IFwiSU5UXCI7XG4gIFRZUEVTMltUWVBFUzJbXCJGTE9BVFwiXSA9IDUxMjZdID0gXCJGTE9BVFwiO1xuICBUWVBFUzJbVFlQRVMyW1wiRkxPQVRfMzJfVU5TSUdORURfSU5UXzI0XzhfUkVWXCJdID0gMzYyNjldID0gXCJGTE9BVF8zMl9VTlNJR05FRF9JTlRfMjRfOF9SRVZcIjtcbiAgVFlQRVMyW1RZUEVTMltcIkhBTEZfRkxPQVRcIl0gPSAzNjE5M10gPSBcIkhBTEZfRkxPQVRcIjtcbiAgcmV0dXJuIFRZUEVTMjtcbn0pKFRZUEVTIHx8IHt9KTtcbnZhciBTQU1QTEVSX1RZUEVTID0gLyogQF9fUFVSRV9fICovICgoU0FNUExFUl9UWVBFUzIpID0+IHtcbiAgU0FNUExFUl9UWVBFUzJbU0FNUExFUl9UWVBFUzJbXCJGTE9BVFwiXSA9IDBdID0gXCJGTE9BVFwiO1xuICBTQU1QTEVSX1RZUEVTMltTQU1QTEVSX1RZUEVTMltcIklOVFwiXSA9IDFdID0gXCJJTlRcIjtcbiAgU0FNUExFUl9UWVBFUzJbU0FNUExFUl9UWVBFUzJbXCJVSU5UXCJdID0gMl0gPSBcIlVJTlRcIjtcbiAgcmV0dXJuIFNBTVBMRVJfVFlQRVMyO1xufSkoU0FNUExFUl9UWVBFUyB8fCB7fSk7XG52YXIgU0NBTEVfTU9ERVMgPSAvKiBAX19QVVJFX18gKi8gKChTQ0FMRV9NT0RFUzIpID0+IHtcbiAgU0NBTEVfTU9ERVMyW1NDQUxFX01PREVTMltcIk5FQVJFU1RcIl0gPSAwXSA9IFwiTkVBUkVTVFwiO1xuICBTQ0FMRV9NT0RFUzJbU0NBTEVfTU9ERVMyW1wiTElORUFSXCJdID0gMV0gPSBcIkxJTkVBUlwiO1xuICByZXR1cm4gU0NBTEVfTU9ERVMyO1xufSkoU0NBTEVfTU9ERVMgfHwge30pO1xudmFyIFdSQVBfTU9ERVMgPSAvKiBAX19QVVJFX18gKi8gKChXUkFQX01PREVTMikgPT4ge1xuICBXUkFQX01PREVTMltXUkFQX01PREVTMltcIkNMQU1QXCJdID0gMzMwNzFdID0gXCJDTEFNUFwiO1xuICBXUkFQX01PREVTMltXUkFQX01PREVTMltcIlJFUEVBVFwiXSA9IDEwNDk3XSA9IFwiUkVQRUFUXCI7XG4gIFdSQVBfTU9ERVMyW1dSQVBfTU9ERVMyW1wiTUlSUk9SRURfUkVQRUFUXCJdID0gMzM2NDhdID0gXCJNSVJST1JFRF9SRVBFQVRcIjtcbiAgcmV0dXJuIFdSQVBfTU9ERVMyO1xufSkoV1JBUF9NT0RFUyB8fCB7fSk7XG52YXIgTUlQTUFQX01PREVTID0gLyogQF9fUFVSRV9fICovICgoTUlQTUFQX01PREVTMikgPT4ge1xuICBNSVBNQVBfTU9ERVMyW01JUE1BUF9NT0RFUzJbXCJPRkZcIl0gPSAwXSA9IFwiT0ZGXCI7XG4gIE1JUE1BUF9NT0RFUzJbTUlQTUFQX01PREVTMltcIlBPVzJcIl0gPSAxXSA9IFwiUE9XMlwiO1xuICBNSVBNQVBfTU9ERVMyW01JUE1BUF9NT0RFUzJbXCJPTlwiXSA9IDJdID0gXCJPTlwiO1xuICBNSVBNQVBfTU9ERVMyW01JUE1BUF9NT0RFUzJbXCJPTl9NQU5VQUxcIl0gPSAzXSA9IFwiT05fTUFOVUFMXCI7XG4gIHJldHVybiBNSVBNQVBfTU9ERVMyO1xufSkoTUlQTUFQX01PREVTIHx8IHt9KTtcbnZhciBBTFBIQV9NT0RFUyA9IC8qIEBfX1BVUkVfXyAqLyAoKEFMUEhBX01PREVTMikgPT4ge1xuICBBTFBIQV9NT0RFUzJbQUxQSEFfTU9ERVMyW1wiTlBNXCJdID0gMF0gPSBcIk5QTVwiO1xuICBBTFBIQV9NT0RFUzJbQUxQSEFfTU9ERVMyW1wiVU5QQUNLXCJdID0gMV0gPSBcIlVOUEFDS1wiO1xuICBBTFBIQV9NT0RFUzJbQUxQSEFfTU9ERVMyW1wiUE1BXCJdID0gMl0gPSBcIlBNQVwiO1xuICBBTFBIQV9NT0RFUzJbQUxQSEFfTU9ERVMyW1wiTk9fUFJFTVVMVElQTElFRF9BTFBIQVwiXSA9IDBdID0gXCJOT19QUkVNVUxUSVBMSUVEX0FMUEhBXCI7XG4gIEFMUEhBX01PREVTMltBTFBIQV9NT0RFUzJbXCJQUkVNVUxUSVBMWV9PTl9VUExPQURcIl0gPSAxXSA9IFwiUFJFTVVMVElQTFlfT05fVVBMT0FEXCI7XG4gIEFMUEhBX01PREVTMltBTFBIQV9NT0RFUzJbXCJQUkVNVUxUSVBMSUVEX0FMUEhBXCJdID0gMl0gPSBcIlBSRU1VTFRJUExJRURfQUxQSEFcIjtcbiAgcmV0dXJuIEFMUEhBX01PREVTMjtcbn0pKEFMUEhBX01PREVTIHx8IHt9KTtcbnZhciBDTEVBUl9NT0RFUyA9IC8qIEBfX1BVUkVfXyAqLyAoKENMRUFSX01PREVTMikgPT4ge1xuICBDTEVBUl9NT0RFUzJbQ0xFQVJfTU9ERVMyW1wiTk9cIl0gPSAwXSA9IFwiTk9cIjtcbiAgQ0xFQVJfTU9ERVMyW0NMRUFSX01PREVTMltcIllFU1wiXSA9IDFdID0gXCJZRVNcIjtcbiAgQ0xFQVJfTU9ERVMyW0NMRUFSX01PREVTMltcIkFVVE9cIl0gPSAyXSA9IFwiQVVUT1wiO1xuICBDTEVBUl9NT0RFUzJbQ0xFQVJfTU9ERVMyW1wiQkxFTkRcIl0gPSAwXSA9IFwiQkxFTkRcIjtcbiAgQ0xFQVJfTU9ERVMyW0NMRUFSX01PREVTMltcIkNMRUFSXCJdID0gMV0gPSBcIkNMRUFSXCI7XG4gIENMRUFSX01PREVTMltDTEVBUl9NT0RFUzJbXCJCTElUXCJdID0gMl0gPSBcIkJMSVRcIjtcbiAgcmV0dXJuIENMRUFSX01PREVTMjtcbn0pKENMRUFSX01PREVTIHx8IHt9KTtcbnZhciBHQ19NT0RFUyA9IC8qIEBfX1BVUkVfXyAqLyAoKEdDX01PREVTMikgPT4ge1xuICBHQ19NT0RFUzJbR0NfTU9ERVMyW1wiQVVUT1wiXSA9IDBdID0gXCJBVVRPXCI7XG4gIEdDX01PREVTMltHQ19NT0RFUzJbXCJNQU5VQUxcIl0gPSAxXSA9IFwiTUFOVUFMXCI7XG4gIHJldHVybiBHQ19NT0RFUzI7XG59KShHQ19NT0RFUyB8fCB7fSk7XG52YXIgUFJFQ0lTSU9OID0gLyogQF9fUFVSRV9fICovICgoUFJFQ0lTSU9OMikgPT4ge1xuICBQUkVDSVNJT04yW1wiTE9XXCJdID0gXCJsb3dwXCI7XG4gIFBSRUNJU0lPTjJbXCJNRURJVU1cIl0gPSBcIm1lZGl1bXBcIjtcbiAgUFJFQ0lTSU9OMltcIkhJR0hcIl0gPSBcImhpZ2hwXCI7XG4gIHJldHVybiBQUkVDSVNJT04yO1xufSkoUFJFQ0lTSU9OIHx8IHt9KTtcbnZhciBNQVNLX1RZUEVTID0gLyogQF9fUFVSRV9fICovICgoTUFTS19UWVBFUzIpID0+IHtcbiAgTUFTS19UWVBFUzJbTUFTS19UWVBFUzJbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgTUFTS19UWVBFUzJbTUFTS19UWVBFUzJbXCJTQ0lTU09SXCJdID0gMV0gPSBcIlNDSVNTT1JcIjtcbiAgTUFTS19UWVBFUzJbTUFTS19UWVBFUzJbXCJTVEVOQ0lMXCJdID0gMl0gPSBcIlNURU5DSUxcIjtcbiAgTUFTS19UWVBFUzJbTUFTS19UWVBFUzJbXCJTUFJJVEVcIl0gPSAzXSA9IFwiU1BSSVRFXCI7XG4gIE1BU0tfVFlQRVMyW01BU0tfVFlQRVMyW1wiQ09MT1JcIl0gPSA0XSA9IFwiQ09MT1JcIjtcbiAgcmV0dXJuIE1BU0tfVFlQRVMyO1xufSkoTUFTS19UWVBFUyB8fCB7fSk7XG52YXIgQ09MT1JfTUFTS19CSVRTID0gLyogQF9fUFVSRV9fICovICgoQ09MT1JfTUFTS19CSVRTMikgPT4ge1xuICBDT0xPUl9NQVNLX0JJVFMyW0NPTE9SX01BU0tfQklUUzJbXCJSRURcIl0gPSAxXSA9IFwiUkVEXCI7XG4gIENPTE9SX01BU0tfQklUUzJbQ09MT1JfTUFTS19CSVRTMltcIkdSRUVOXCJdID0gMl0gPSBcIkdSRUVOXCI7XG4gIENPTE9SX01BU0tfQklUUzJbQ09MT1JfTUFTS19CSVRTMltcIkJMVUVcIl0gPSA0XSA9IFwiQkxVRVwiO1xuICBDT0xPUl9NQVNLX0JJVFMyW0NPTE9SX01BU0tfQklUUzJbXCJBTFBIQVwiXSA9IDhdID0gXCJBTFBIQVwiO1xuICByZXR1cm4gQ09MT1JfTUFTS19CSVRTMjtcbn0pKENPTE9SX01BU0tfQklUUyB8fCB7fSk7XG52YXIgTVNBQV9RVUFMSVRZID0gLyogQF9fUFVSRV9fICovICgoTVNBQV9RVUFMSVRZMikgPT4ge1xuICBNU0FBX1FVQUxJVFkyW01TQUFfUVVBTElUWTJbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgTVNBQV9RVUFMSVRZMltNU0FBX1FVQUxJVFkyW1wiTE9XXCJdID0gMl0gPSBcIkxPV1wiO1xuICBNU0FBX1FVQUxJVFkyW01TQUFfUVVBTElUWTJbXCJNRURJVU1cIl0gPSA0XSA9IFwiTUVESVVNXCI7XG4gIE1TQUFfUVVBTElUWTJbTVNBQV9RVUFMSVRZMltcIkhJR0hcIl0gPSA4XSA9IFwiSElHSFwiO1xuICByZXR1cm4gTVNBQV9RVUFMSVRZMjtcbn0pKE1TQUFfUVVBTElUWSB8fCB7fSk7XG52YXIgQlVGRkVSX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gKChCVUZGRVJfVFlQRTIpID0+IHtcbiAgQlVGRkVSX1RZUEUyW0JVRkZFUl9UWVBFMltcIkVMRU1FTlRfQVJSQVlfQlVGRkVSXCJdID0gMzQ5NjNdID0gXCJFTEVNRU5UX0FSUkFZX0JVRkZFUlwiO1xuICBCVUZGRVJfVFlQRTJbQlVGRkVSX1RZUEUyW1wiQVJSQVlfQlVGRkVSXCJdID0gMzQ5NjJdID0gXCJBUlJBWV9CVUZGRVJcIjtcbiAgQlVGRkVSX1RZUEUyW0JVRkZFUl9UWVBFMltcIlVOSUZPUk1fQlVGRkVSXCJdID0gMzUzNDVdID0gXCJVTklGT1JNX0JVRkZFUlwiO1xuICByZXR1cm4gQlVGRkVSX1RZUEUyO1xufSkoQlVGRkVSX1RZUEUgfHwge30pO1xuXG5leHBvcnQgeyBBTFBIQV9NT0RFUywgQkxFTkRfTU9ERVMsIEJVRkZFUl9CSVRTLCBCVUZGRVJfVFlQRSwgQ0xFQVJfTU9ERVMsIENPTE9SX01BU0tfQklUUywgRFJBV19NT0RFUywgRU5WLCBGT1JNQVRTLCBHQ19NT0RFUywgTUFTS19UWVBFUywgTUlQTUFQX01PREVTLCBNU0FBX1FVQUxJVFksIFBSRUNJU0lPTiwgUkVOREVSRVJfVFlQRSwgU0FNUExFUl9UWVBFUywgU0NBTEVfTU9ERVMsIFRBUkdFVFMsIFRZUEVTLCBXUkFQX01PREVTIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///361\n')},116:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  tq: () => (/* reexport */ isMobile_isMobile),\n  Xd: () => (/* reexport */ settings)\n});\n\n// UNUSED EXPORTS: BrowserAdapter\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/settings/lib/adapter.mjs\nconst BrowserAdapter = {\n  createCanvas: (width, height) => {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  },\n  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,\n  getWebGLRenderingContext: () => WebGLRenderingContext,\n  getNavigator: () => navigator,\n  getBaseUrl: () => document.baseURI ?? window.location.href,\n  getFontFaceSet: () => document.fonts,\n  fetch: (url, options) => fetch(url, options),\n  parseXML: (xml) => {\n    const parser = new DOMParser();\n    return parser.parseFromString(xml, \"text/xml\");\n  }\n};\n\n\n//# sourceMappingURL=adapter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/settings/lib/settings.mjs\n\n\nconst settings = {\n  ADAPTER: BrowserAdapter,\n  RESOLUTION: 1,\n  CREATE_IMAGE_BITMAP: false,\n  ROUND_PIXELS: false\n};\n\n\n//# sourceMappingURL=settings.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/ismobilejs/esm/isMobile.js\nvar appleIphone = /iPhone/i;\nvar appleIpod = /iPod/i;\nvar appleTablet = /iPad/i;\nvar appleUniversal = /\\biOS-universal(?:.+)Mac\\b/i;\nvar androidPhone = /\\bAndroid(?:.+)Mobile\\b/i;\nvar androidTablet = /Android/i;\nvar amazonPhone = /(?:SD4930UR|\\bSilk(?:.+)Mobile\\b)/i;\nvar amazonTablet = /Silk/i;\nvar windowsPhone = /Windows Phone/i;\nvar windowsTablet = /\\bWindows(?:.+)ARM\\b/i;\nvar otherBlackBerry = /BlackBerry/i;\nvar otherBlackBerry10 = /BB10/i;\nvar otherOpera = /Opera Mini/i;\nvar otherChrome = /\\b(CriOS|Chrome)(?:.+)Mobile/i;\nvar otherFirefox = /Mobile(?:.+)Firefox\\b/i;\nvar isAppleTabletOnIos13 = function (navigator) {\n    return (typeof navigator !== 'undefined' &&\n        navigator.platform === 'MacIntel' &&\n        typeof navigator.maxTouchPoints === 'number' &&\n        navigator.maxTouchPoints > 1 &&\n        typeof MSStream === 'undefined');\n};\nfunction createMatch(userAgent) {\n    return function (regex) { return regex.test(userAgent); };\n}\nfunction isMobile(param) {\n    var nav = {\n        userAgent: '',\n        platform: '',\n        maxTouchPoints: 0\n    };\n    if (!param && typeof navigator !== 'undefined') {\n        nav = {\n            userAgent: navigator.userAgent,\n            platform: navigator.platform,\n            maxTouchPoints: navigator.maxTouchPoints || 0\n        };\n    }\n    else if (typeof param === 'string') {\n        nav.userAgent = param;\n    }\n    else if (param && param.userAgent) {\n        nav = {\n            userAgent: param.userAgent,\n            platform: param.platform,\n            maxTouchPoints: param.maxTouchPoints || 0\n        };\n    }\n    var userAgent = nav.userAgent;\n    var tmp = userAgent.split('[FBAN');\n    if (typeof tmp[1] !== 'undefined') {\n        userAgent = tmp[0];\n    }\n    tmp = userAgent.split('Twitter');\n    if (typeof tmp[1] !== 'undefined') {\n        userAgent = tmp[0];\n    }\n    var match = createMatch(userAgent);\n    var result = {\n        apple: {\n            phone: match(appleIphone) && !match(windowsPhone),\n            ipod: match(appleIpod),\n            tablet: !match(appleIphone) &&\n                (match(appleTablet) || isAppleTabletOnIos13(nav)) &&\n                !match(windowsPhone),\n            universal: match(appleUniversal),\n            device: (match(appleIphone) ||\n                match(appleIpod) ||\n                match(appleTablet) ||\n                match(appleUniversal) ||\n                isAppleTabletOnIos13(nav)) &&\n                !match(windowsPhone)\n        },\n        amazon: {\n            phone: match(amazonPhone),\n            tablet: !match(amazonPhone) && match(amazonTablet),\n            device: match(amazonPhone) || match(amazonTablet)\n        },\n        android: {\n            phone: (!match(windowsPhone) && match(amazonPhone)) ||\n                (!match(windowsPhone) && match(androidPhone)),\n            tablet: !match(windowsPhone) &&\n                !match(amazonPhone) &&\n                !match(androidPhone) &&\n                (match(amazonTablet) || match(androidTablet)),\n            device: (!match(windowsPhone) &&\n                (match(amazonPhone) ||\n                    match(amazonTablet) ||\n                    match(androidPhone) ||\n                    match(androidTablet))) ||\n                match(/\\bokhttp\\b/i)\n        },\n        windows: {\n            phone: match(windowsPhone),\n            tablet: match(windowsTablet),\n            device: match(windowsPhone) || match(windowsTablet)\n        },\n        other: {\n            blackberry: match(otherBlackBerry),\n            blackberry10: match(otherBlackBerry10),\n            opera: match(otherOpera),\n            firefox: match(otherFirefox),\n            chrome: match(otherChrome),\n            device: match(otherBlackBerry) ||\n                match(otherBlackBerry10) ||\n                match(otherOpera) ||\n                match(otherFirefox) ||\n                match(otherChrome)\n        },\n        any: false,\n        phone: false,\n        tablet: false\n    };\n    result.any =\n        result.apple.device ||\n            result.android.device ||\n            result.windows.device ||\n            result.other.device;\n    result.phone =\n        result.apple.phone || result.android.phone || result.windows.phone;\n    result.tablet =\n        result.apple.tablet || result.android.tablet || result.windows.tablet;\n    return result;\n}\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/settings/lib/utils/isMobile.mjs\n\n\nconst isMobileCall = isMobile[\"default\"] ?? isMobile;\nconst isMobile_isMobile = isMobileCall(globalThis.navigator);\n\n\n//# sourceMappingURL=isMobile.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/settings/lib/index.mjs\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixDQUFDO2dCQUN4QixLQUFLLENBQUMsVUFBVSxDQUFDO2dCQUNqQixLQUFLLENBQUMsWUFBWSxDQUFDO2dCQUNuQixLQUFLLENBQUMsV0FBVyxDQUFDO1NBQ3JCO1FBQ0QsR0FBRyxFQUFFLEtBQUs7UUFDVixLQUFLLEVBQUUsS0FBSztRQUNaLE1BQU0sRUFBRSxLQUFLO0tBQ2QsQ0FBQztJQUVGLE1BQU0sQ0FBQyxHQUFHO1FBQ1IsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNO1lBQ25CLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTTtZQUNyQixNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU07WUFDckIsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7SUFFdEIsTUFBTSxDQUFDLEtBQUs7UUFDVixNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQztJQUNyRSxNQUFNLENBQUMsTUFBTTtRQUNYLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDO0lBRXhFLE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUM7OztBQy9MbUM7O0FBRXBDLHFCQUFxQixtQkFBa0IsSUFBSSxRQUFVO0FBQ3JELE1BQU0saUJBQVE7O0FBRU07QUFDcEI7OztBQ04rQztBQUN4QjtBQUNrQjtBQUNDO0FBQ007QUFDaEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvc2V0dGluZ3MvbGliL2FkYXB0ZXIubWpzPzBmNzciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3NldHRpbmdzL2xpYi9zZXR0aW5ncy5tanM/N2Y3OCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvaXNtb2JpbGVqcy9zcmMvaXNNb2JpbGUudHM/YWE5OCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvc2V0dGluZ3MvbGliL3V0aWxzL2lzTW9iaWxlLm1qcz8xYzc1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9zZXR0aW5ncy9saWIvaW5kZXgubWpzPzcwOTUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQnJvd3NlckFkYXB0ZXIgPSB7XG4gIGNyZWF0ZUNhbnZhczogKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfSxcbiAgZ2V0Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEOiAoKSA9PiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGdldFdlYkdMUmVuZGVyaW5nQ29udGV4dDogKCkgPT4gV2ViR0xSZW5kZXJpbmdDb250ZXh0LFxuICBnZXROYXZpZ2F0b3I6ICgpID0+IG5hdmlnYXRvcixcbiAgZ2V0QmFzZVVybDogKCkgPT4gZG9jdW1lbnQuYmFzZVVSSSA/PyB3aW5kb3cubG9jYXRpb24uaHJlZixcbiAgZ2V0Rm9udEZhY2VTZXQ6ICgpID0+IGRvY3VtZW50LmZvbnRzLFxuICBmZXRjaDogKHVybCwgb3B0aW9ucykgPT4gZmV0Y2godXJsLCBvcHRpb25zKSxcbiAgcGFyc2VYTUw6ICh4bWwpID0+IHtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgcmV0dXJuIHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sLCBcInRleHQveG1sXCIpO1xuICB9XG59O1xuXG5leHBvcnQgeyBCcm93c2VyQWRhcHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRhcHRlci5tanMubWFwXG4iLCJpbXBvcnQgeyBCcm93c2VyQWRhcHRlciB9IGZyb20gJy4vYWRhcHRlci5tanMnO1xuXG5jb25zdCBzZXR0aW5ncyA9IHtcbiAgQURBUFRFUjogQnJvd3NlckFkYXB0ZXIsXG4gIFJFU09MVVRJT046IDEsXG4gIENSRUFURV9JTUFHRV9CSVRNQVA6IGZhbHNlLFxuICBST1VORF9QSVhFTFM6IGZhbHNlXG59O1xuXG5leHBvcnQgeyBzZXR0aW5ncyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0dGluZ3MubWpzLm1hcFxuIiwiY29uc3QgYXBwbGVJcGhvbmUgPSAvaVBob25lL2k7XG5jb25zdCBhcHBsZUlwb2QgPSAvaVBvZC9pO1xuY29uc3QgYXBwbGVUYWJsZXQgPSAvaVBhZC9pO1xuY29uc3QgYXBwbGVVbml2ZXJzYWwgPSAvXFxiaU9TLXVuaXZlcnNhbCg/Oi4rKU1hY1xcYi9pO1xuY29uc3QgYW5kcm9pZFBob25lID0gL1xcYkFuZHJvaWQoPzouKylNb2JpbGVcXGIvaTsgLy8gTWF0Y2ggJ0FuZHJvaWQnIEFORCAnTW9iaWxlJ1xuY29uc3QgYW5kcm9pZFRhYmxldCA9IC9BbmRyb2lkL2k7XG5jb25zdCBhbWF6b25QaG9uZSA9IC8oPzpTRDQ5MzBVUnxcXGJTaWxrKD86LispTW9iaWxlXFxiKS9pOyAvLyBNYXRjaCAnU2lsaycgQU5EICdNb2JpbGUnXG5jb25zdCBhbWF6b25UYWJsZXQgPSAvU2lsay9pO1xuY29uc3Qgd2luZG93c1Bob25lID0gL1dpbmRvd3MgUGhvbmUvaTtcbmNvbnN0IHdpbmRvd3NUYWJsZXQgPSAvXFxiV2luZG93cyg/Oi4rKUFSTVxcYi9pOyAvLyBNYXRjaCAnV2luZG93cycgQU5EICdBUk0nXG5jb25zdCBvdGhlckJsYWNrQmVycnkgPSAvQmxhY2tCZXJyeS9pO1xuY29uc3Qgb3RoZXJCbGFja0JlcnJ5MTAgPSAvQkIxMC9pO1xuY29uc3Qgb3RoZXJPcGVyYSA9IC9PcGVyYSBNaW5pL2k7XG5jb25zdCBvdGhlckNocm9tZSA9IC9cXGIoQ3JpT1N8Q2hyb21lKSg/Oi4rKU1vYmlsZS9pO1xuY29uc3Qgb3RoZXJGaXJlZm94ID0gL01vYmlsZSg/Oi4rKUZpcmVmb3hcXGIvaTsgLy8gTWF0Y2ggJ01vYmlsZScgQU5EICdGaXJlZm94J1xuXG5leHBvcnQgdHlwZSBVc2VyQWdlbnQgPSBzdHJpbmc7XG5leHBvcnQgdHlwZSBOYXZpZ2F0b3IgPSB7XG4gIHVzZXJBZ2VudDogc3RyaW5nO1xuICBwbGF0Zm9ybTogc3RyaW5nO1xuICBtYXhUb3VjaFBvaW50cz86IG51bWJlcjtcbn07XG5cbmNvbnN0IGlzQXBwbGVUYWJsZXRPbklvczEzID0gKG5hdmlnYXRvcj86IE5hdmlnYXRvcik6IGJvb2xlYW4gPT4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgbmF2aWdhdG9yLnBsYXRmb3JtID09PSAnTWFjSW50ZWwnICYmXG4gICAgdHlwZW9mIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA9PT0gJ251bWJlcicgJiZcbiAgICBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxICYmXG4gICAgdHlwZW9mIE1TU3RyZWFtID09PSAndW5kZWZpbmVkJ1xuICApO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlTWF0Y2godXNlckFnZW50OiBVc2VyQWdlbnQpOiAocmVnZXg6IFJlZ0V4cCkgPT4gYm9vbGVhbiB7XG4gIHJldHVybiAocmVnZXg6IFJlZ0V4cCk6IGJvb2xlYW4gPT4gcmVnZXgudGVzdCh1c2VyQWdlbnQpO1xufVxuXG5leHBvcnQgdHlwZSBpc01vYmlsZVJlc3VsdCA9IHtcbiAgYXBwbGU6IHtcbiAgICBwaG9uZTogYm9vbGVhbjtcbiAgICBpcG9kOiBib29sZWFuO1xuICAgIHRhYmxldDogYm9vbGVhbjtcbiAgICB1bml2ZXJzYWw6IGJvb2xlYW47XG4gICAgZGV2aWNlOiBib29sZWFuO1xuICB9O1xuICBhbWF6b246IHtcbiAgICBwaG9uZTogYm9vbGVhbjtcbiAgICB0YWJsZXQ6IGJvb2xlYW47XG4gICAgZGV2aWNlOiBib29sZWFuO1xuICB9O1xuICBhbmRyb2lkOiB7XG4gICAgcGhvbmU6IGJvb2xlYW47XG4gICAgdGFibGV0OiBib29sZWFuO1xuICAgIGRldmljZTogYm9vbGVhbjtcbiAgfTtcbiAgd2luZG93czoge1xuICAgIHBob25lOiBib29sZWFuO1xuICAgIHRhYmxldDogYm9vbGVhbjtcbiAgICBkZXZpY2U6IGJvb2xlYW47XG4gIH07XG4gIG90aGVyOiB7XG4gICAgYmxhY2tiZXJyeTogYm9vbGVhbjtcbiAgICBibGFja2JlcnJ5MTA6IGJvb2xlYW47XG4gICAgb3BlcmE6IGJvb2xlYW47XG4gICAgZmlyZWZveDogYm9vbGVhbjtcbiAgICBjaHJvbWU6IGJvb2xlYW47XG4gICAgZGV2aWNlOiBib29sZWFuO1xuICB9O1xuICBwaG9uZTogYm9vbGVhbjtcbiAgdGFibGV0OiBib29sZWFuO1xuICBhbnk6IGJvb2xlYW47XG59O1xuXG5leHBvcnQgdHlwZSBJc01vYmlsZVBhcmFtZXRlciA9IFVzZXJBZ2VudCB8IE5hdmlnYXRvcjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNNb2JpbGUocGFyYW0/OiBJc01vYmlsZVBhcmFtZXRlcik6IGlzTW9iaWxlUmVzdWx0IHtcbiAgbGV0IG5hdjogTmF2aWdhdG9yID0ge1xuICAgIHVzZXJBZ2VudDogJycsXG4gICAgcGxhdGZvcm06ICcnLFxuICAgIG1heFRvdWNoUG9pbnRzOiAwLFxuICB9O1xuXG4gIGlmICghcGFyYW0gJiYgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBuYXYgPSB7XG4gICAgICB1c2VyQWdlbnQ6IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICBwbGF0Zm9ybTogbmF2aWdhdG9yLnBsYXRmb3JtLFxuICAgICAgbWF4VG91Y2hQb2ludHM6IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyB8fCAwLFxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJykge1xuICAgIG5hdi51c2VyQWdlbnQgPSBwYXJhbTtcbiAgfSBlbHNlIGlmIChwYXJhbSAmJiBwYXJhbS51c2VyQWdlbnQpIHtcbiAgICBuYXYgPSB7XG4gICAgICB1c2VyQWdlbnQ6IHBhcmFtLnVzZXJBZ2VudCxcbiAgICAgIHBsYXRmb3JtOiBwYXJhbS5wbGF0Zm9ybSxcbiAgICAgIG1heFRvdWNoUG9pbnRzOiBwYXJhbS5tYXhUb3VjaFBvaW50cyB8fCAwLFxuICAgIH07XG4gIH1cblxuICBsZXQgdXNlckFnZW50ID0gbmF2LnVzZXJBZ2VudDtcblxuICAvLyBGYWNlYm9vayBtb2JpbGUgYXBwJ3MgaW50ZWdyYXRlZCBicm93c2VyIGFkZHMgYSBidW5jaCBvZiBzdHJpbmdzIHRoYXRcbiAgLy8gbWF0Y2ggZXZlcnl0aGluZy4gU3RyaXAgaXQgb3V0IGlmIGl0IGV4aXN0cy5cbiAgbGV0IHRtcCA9IHVzZXJBZ2VudC5zcGxpdCgnW0ZCQU4nKTtcbiAgaWYgKHR5cGVvZiB0bXBbMV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdXNlckFnZW50ID0gdG1wWzBdO1xuICB9XG5cbiAgLy8gVHdpdHRlciBtb2JpbGUgYXBwJ3MgaW50ZWdyYXRlZCBicm93c2VyIG9uIGlQYWQgYWRkcyBhIFwiVHdpdHRlciBmb3JcbiAgLy8gaVBob25lXCIgc3RyaW5nLiBTYW1lIHByb2JhYmx5IGhhcHBlbnMgb24gb3RoZXIgdGFibGV0IHBsYXRmb3Jtcy5cbiAgLy8gVGhpcyB3aWxsIGNvbmZ1c2UgZGV0ZWN0aW9uIHNvIHN0cmlwIGl0IG91dCBpZiBpdCBleGlzdHMuXG4gIHRtcCA9IHVzZXJBZ2VudC5zcGxpdCgnVHdpdHRlcicpO1xuICBpZiAodHlwZW9mIHRtcFsxXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB1c2VyQWdlbnQgPSB0bXBbMF07XG4gIH1cblxuICBjb25zdCBtYXRjaCA9IGNyZWF0ZU1hdGNoKHVzZXJBZ2VudCk7XG5cbiAgY29uc3QgcmVzdWx0OiBpc01vYmlsZVJlc3VsdCA9IHtcbiAgICBhcHBsZToge1xuICAgICAgcGhvbmU6IG1hdGNoKGFwcGxlSXBob25lKSAmJiAhbWF0Y2god2luZG93c1Bob25lKSxcbiAgICAgIGlwb2Q6IG1hdGNoKGFwcGxlSXBvZCksXG4gICAgICB0YWJsZXQ6XG4gICAgICAgICFtYXRjaChhcHBsZUlwaG9uZSkgJiZcbiAgICAgICAgKG1hdGNoKGFwcGxlVGFibGV0KSB8fCBpc0FwcGxlVGFibGV0T25Jb3MxMyhuYXYpKSAmJlxuICAgICAgICAhbWF0Y2god2luZG93c1Bob25lKSxcbiAgICAgIHVuaXZlcnNhbDogbWF0Y2goYXBwbGVVbml2ZXJzYWwpLFxuICAgICAgZGV2aWNlOlxuICAgICAgICAobWF0Y2goYXBwbGVJcGhvbmUpIHx8XG4gICAgICAgICAgbWF0Y2goYXBwbGVJcG9kKSB8fFxuICAgICAgICAgIG1hdGNoKGFwcGxlVGFibGV0KSB8fFxuICAgICAgICAgIG1hdGNoKGFwcGxlVW5pdmVyc2FsKSB8fFxuICAgICAgICAgIGlzQXBwbGVUYWJsZXRPbklvczEzKG5hdikpICYmXG4gICAgICAgICFtYXRjaCh3aW5kb3dzUGhvbmUpLFxuICAgIH0sXG4gICAgYW1hem9uOiB7XG4gICAgICBwaG9uZTogbWF0Y2goYW1hem9uUGhvbmUpLFxuICAgICAgdGFibGV0OiAhbWF0Y2goYW1hem9uUGhvbmUpICYmIG1hdGNoKGFtYXpvblRhYmxldCksXG4gICAgICBkZXZpY2U6IG1hdGNoKGFtYXpvblBob25lKSB8fCBtYXRjaChhbWF6b25UYWJsZXQpLFxuICAgIH0sXG4gICAgYW5kcm9pZDoge1xuICAgICAgcGhvbmU6XG4gICAgICAgICghbWF0Y2god2luZG93c1Bob25lKSAmJiBtYXRjaChhbWF6b25QaG9uZSkpIHx8XG4gICAgICAgICghbWF0Y2god2luZG93c1Bob25lKSAmJiBtYXRjaChhbmRyb2lkUGhvbmUpKSxcbiAgICAgIHRhYmxldDpcbiAgICAgICAgIW1hdGNoKHdpbmRvd3NQaG9uZSkgJiZcbiAgICAgICAgIW1hdGNoKGFtYXpvblBob25lKSAmJlxuICAgICAgICAhbWF0Y2goYW5kcm9pZFBob25lKSAmJlxuICAgICAgICAobWF0Y2goYW1hem9uVGFibGV0KSB8fCBtYXRjaChhbmRyb2lkVGFibGV0KSksXG4gICAgICBkZXZpY2U6XG4gICAgICAgICghbWF0Y2god2luZG93c1Bob25lKSAmJlxuICAgICAgICAgIChtYXRjaChhbWF6b25QaG9uZSkgfHxcbiAgICAgICAgICAgIG1hdGNoKGFtYXpvblRhYmxldCkgfHxcbiAgICAgICAgICAgIG1hdGNoKGFuZHJvaWRQaG9uZSkgfHxcbiAgICAgICAgICAgIG1hdGNoKGFuZHJvaWRUYWJsZXQpKSkgfHxcbiAgICAgICAgbWF0Y2goL1xcYm9raHR0cFxcYi9pKSxcbiAgICB9LFxuICAgIHdpbmRvd3M6IHtcbiAgICAgIHBob25lOiBtYXRjaCh3aW5kb3dzUGhvbmUpLFxuICAgICAgdGFibGV0OiBtYXRjaCh3aW5kb3dzVGFibGV0KSxcbiAgICAgIGRldmljZTogbWF0Y2god2luZG93c1Bob25lKSB8fCBtYXRjaCh3aW5kb3dzVGFibGV0KSxcbiAgICB9LFxuICAgIG90aGVyOiB7XG4gICAgICBibGFja2JlcnJ5OiBtYXRjaChvdGhlckJsYWNrQmVycnkpLFxuICAgICAgYmxhY2tiZXJyeTEwOiBtYXRjaChvdGhlckJsYWNrQmVycnkxMCksXG4gICAgICBvcGVyYTogbWF0Y2gob3RoZXJPcGVyYSksXG4gICAgICBmaXJlZm94OiBtYXRjaChvdGhlckZpcmVmb3gpLFxuICAgICAgY2hyb21lOiBtYXRjaChvdGhlckNocm9tZSksXG4gICAgICBkZXZpY2U6XG4gICAgICAgIG1hdGNoKG90aGVyQmxhY2tCZXJyeSkgfHxcbiAgICAgICAgbWF0Y2gob3RoZXJCbGFja0JlcnJ5MTApIHx8XG4gICAgICAgIG1hdGNoKG90aGVyT3BlcmEpIHx8XG4gICAgICAgIG1hdGNoKG90aGVyRmlyZWZveCkgfHxcbiAgICAgICAgbWF0Y2gob3RoZXJDaHJvbWUpLFxuICAgIH0sXG4gICAgYW55OiBmYWxzZSxcbiAgICBwaG9uZTogZmFsc2UsXG4gICAgdGFibGV0OiBmYWxzZSxcbiAgfTtcblxuICByZXN1bHQuYW55ID1cbiAgICByZXN1bHQuYXBwbGUuZGV2aWNlIHx8XG4gICAgcmVzdWx0LmFuZHJvaWQuZGV2aWNlIHx8XG4gICAgcmVzdWx0LndpbmRvd3MuZGV2aWNlIHx8XG4gICAgcmVzdWx0Lm90aGVyLmRldmljZTtcbiAgLy8gZXhjbHVkZXMgJ290aGVyJyBkZXZpY2VzIGFuZCBpcG9kcywgdGFyZ2V0aW5nIHRvdWNoc2NyZWVuIHBob25lc1xuICByZXN1bHQucGhvbmUgPVxuICAgIHJlc3VsdC5hcHBsZS5waG9uZSB8fCByZXN1bHQuYW5kcm9pZC5waG9uZSB8fCByZXN1bHQud2luZG93cy5waG9uZTtcbiAgcmVzdWx0LnRhYmxldCA9XG4gICAgcmVzdWx0LmFwcGxlLnRhYmxldCB8fCByZXN1bHQuYW5kcm9pZC50YWJsZXQgfHwgcmVzdWx0LndpbmRvd3MudGFibGV0O1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJpbXBvcnQgaXNNb2JpbGVKcyBmcm9tICdpc21vYmlsZWpzJztcblxuY29uc3QgaXNNb2JpbGVDYWxsID0gaXNNb2JpbGVKcy5kZWZhdWx0ID8/IGlzTW9iaWxlSnM7XG5jb25zdCBpc01vYmlsZSA9IGlzTW9iaWxlQ2FsbChnbG9iYWxUaGlzLm5hdmlnYXRvcik7XG5cbmV4cG9ydCB7IGlzTW9iaWxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc01vYmlsZS5tanMubWFwXG4iLCJleHBvcnQgeyBCcm93c2VyQWRhcHRlciB9IGZyb20gJy4vYWRhcHRlci5tanMnO1xuaW1wb3J0ICcuL0lDYW52YXMubWpzJztcbmltcG9ydCAnLi9JQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELm1qcyc7XG5leHBvcnQgeyBzZXR0aW5ncyB9IGZyb20gJy4vc2V0dGluZ3MubWpzJztcbmV4cG9ydCB7IGlzTW9iaWxlIH0gZnJvbSAnLi91dGlscy9pc01vYmlsZS5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///116\n")},441:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  BaseTextureCache: () => (/* reexport */ BaseTextureCache),\n  BoundingBox: () => (/* reexport */ BoundingBox),\n  CanvasRenderTarget: () => (/* reexport */ CanvasRenderTarget),\n  DATA_URI: () => (/* reexport */ DATA_URI),\n  EventEmitter: () => (/* reexport */ eventemitter3),\n  ProgramCache: () => (/* reexport */ ProgramCache),\n  TextureCache: () => (/* reexport */ TextureCache),\n  clearTextureCache: () => (/* reexport */ clearTextureCache),\n  correctBlendMode: () => (/* reexport */ correctBlendMode),\n  createIndicesForQuads: () => (/* reexport */ createIndicesForQuads),\n  decomposeDataUri: () => (/* reexport */ decomposeDataUri),\n  deprecation: () => (/* reexport */ deprecation),\n  destroyTextureCache: () => (/* reexport */ destroyTextureCache),\n  determineCrossOrigin: () => (/* reexport */ determineCrossOrigin),\n  earcut: () => (/* reexport */ earcut),\n  getBufferType: () => (/* reexport */ getBufferType),\n  getCanvasBoundingBox: () => (/* reexport */ getCanvasBoundingBox),\n  getResolutionOfUrl: () => (/* reexport */ getResolutionOfUrl),\n  hex2rgb: () => (/* reexport */ hex2rgb),\n  hex2string: () => (/* reexport */ hex2string),\n  interleaveTypedArrays: () => (/* reexport */ interleaveTypedArrays),\n  isMobile: () => (/* reexport */ lib/* isMobile */.tq),\n  isPow2: () => (/* reexport */ isPow2),\n  isWebGLSupported: () => (/* reexport */ isWebGLSupported),\n  log2: () => (/* reexport */ log2),\n  nextPow2: () => (/* reexport */ nextPow2),\n  path: () => (/* reexport */ path),\n  premultiplyBlendMode: () => (/* reexport */ premultiplyBlendMode),\n  premultiplyRgba: () => (/* reexport */ premultiplyRgba),\n  premultiplyTint: () => (/* reexport */ premultiplyTint),\n  premultiplyTintToRgba: () => (/* reexport */ premultiplyTintToRgba),\n  removeItems: () => (/* reexport */ removeItems),\n  rgb2hex: () => (/* reexport */ rgb2hex),\n  sayHello: () => (/* reexport */ sayHello),\n  sign: () => (/* reexport */ sign),\n  skipHello: () => (/* reexport */ skipHello),\n  string2hex: () => (/* reexport */ string2hex),\n  trimCanvas: () => (/* reexport */ trimCanvas),\n  uid: () => (/* reexport */ uid),\n  url: () => (/* reexport */ url_url)\n});\n\n// EXTERNAL MODULE: ./node_modules/@pixi/settings/lib/index.mjs + 4 modules\nvar lib = __webpack_require__(116);\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/settings.mjs\n\n\n\nlib/* settings */.Xd.RETINA_PREFIX = /@([0-9\\.]+)x/;\nlib/* settings */.Xd.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;\n//# sourceMappingURL=settings.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/eventemitter3/index.js\nvar eventemitter3 = __webpack_require__(34);\n// EXTERNAL MODULE: ./node_modules/earcut/src/earcut.js\nvar earcut = __webpack_require__(720);\n// EXTERNAL MODULE: ./node_modules/url/url.js\nvar url = __webpack_require__(44);\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/url.mjs\n\n\nconst url_url = {\n  parse: url/* parse */.Qc,\n  format: url/* format */.WU,\n  resolve: url/* resolve */.DB\n};\n\n\n//# sourceMappingURL=url.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/path.mjs\n\n\nfunction assertPath(path2) {\n  if (typeof path2 !== "string") {\n    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);\n  }\n}\nfunction removeUrlParams(url) {\n  const re = url.split("?")[0];\n  return re.split("#")[0];\n}\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&");\n}\nfunction replaceAll(str, find, replace) {\n  return str.replace(new RegExp(escapeRegExp(find), "g"), replace);\n}\nfunction normalizeStringPosix(path2, allowAboveRoot) {\n  let res = "";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = -1;\n  for (let i = 0; i <= path2.length; ++i) {\n    if (i < path2.length) {\n      code = path2.charCodeAt(i);\n    } else if (code === 47) {\n      break;\n    } else {\n      code = 47;\n    }\n    if (code === 47) {\n      if (lastSlash === i - 1 || dots === 1) {\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf("/");\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = "";\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = "";\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) {\n            res += "/..";\n          } else {\n            res = "..";\n          }\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `/${path2.slice(lastSlash + 1, i)}`;\n        } else {\n          res = path2.slice(lastSlash + 1, i);\n        }\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nconst path = {\n  toPosix(path2) {\n    return replaceAll(path2, "\\\\", "/");\n  },\n  isUrl(path2) {\n    return /^https?:/.test(this.toPosix(path2));\n  },\n  isDataUrl(path2) {\n    return /^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&\',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i.test(path2);\n  },\n  hasProtocol(path2) {\n    return /^[^/:]+:\\//.test(this.toPosix(path2));\n  },\n  getProtocol(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    let protocol = "";\n    const isFile = /^file:\\/\\/\\//.exec(path2);\n    const isHttp = /^[^/:]+:\\/\\//.exec(path2);\n    const isWindows = /^[^/:]+:\\//.exec(path2);\n    if (isFile || isHttp || isWindows) {\n      const arr = isFile?.[0] || isHttp?.[0] || isWindows?.[0];\n      protocol = arr;\n      path2 = path2.slice(arr.length);\n    }\n    return protocol;\n  },\n  toAbsolute(url, customBaseUrl, customRootUrl) {\n    if (this.isDataUrl(url))\n      return url;\n    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? lib/* settings */.Xd.ADAPTER.getBaseUrl()));\n    const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n    assertPath(url);\n    url = this.toPosix(url);\n    if (url.startsWith("/")) {\n      return path.join(rootUrl, url.slice(1));\n    }\n    const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n    return absolutePath;\n  },\n  normalize(path2) {\n    path2 = this.toPosix(path2);\n    assertPath(path2);\n    if (path2.length === 0)\n      return ".";\n    let protocol = "";\n    const isAbsolute = path2.startsWith("/");\n    if (this.hasProtocol(path2)) {\n      protocol = this.rootname(path2);\n      path2 = path2.slice(protocol.length);\n    }\n    const trailingSeparator = path2.endsWith("/");\n    path2 = normalizeStringPosix(path2, false);\n    if (path2.length > 0 && trailingSeparator)\n      path2 += "/";\n    if (isAbsolute)\n      return `/${path2}`;\n    return protocol + path2;\n  },\n  isAbsolute(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    if (this.hasProtocol(path2))\n      return true;\n    return path2.startsWith("/");\n  },\n  join(...segments) {\n    if (segments.length === 0) {\n      return ".";\n    }\n    let joined;\n    for (let i = 0; i < segments.length; ++i) {\n      const arg = segments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === void 0)\n          joined = arg;\n        else {\n          const prevArg = segments[i - 1] ?? "";\n          if (this.extname(prevArg)) {\n            joined += `/../${arg}`;\n          } else {\n            joined += `/${arg}`;\n          }\n        }\n      }\n    }\n    if (joined === void 0) {\n      return ".";\n    }\n    return this.normalize(joined);\n  },\n  dirname(path2) {\n    assertPath(path2);\n    if (path2.length === 0)\n      return ".";\n    path2 = this.toPosix(path2);\n    let code = path2.charCodeAt(0);\n    const hasRoot = code === 47;\n    let end = -1;\n    let matchedSlash = true;\n    const proto = this.getProtocol(path2);\n    const origpath = path2;\n    path2 = path2.slice(proto.length);\n    for (let i = path2.length - 1; i >= 1; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        matchedSlash = false;\n      }\n    }\n    if (end === -1)\n      return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;\n    if (hasRoot && end === 1)\n      return "//";\n    return proto + path2.slice(0, end);\n  },\n  rootname(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    let root = "";\n    if (path2.startsWith("/"))\n      root = "/";\n    else {\n      root = this.getProtocol(path2);\n    }\n    if (this.isUrl(path2)) {\n      const index = path2.indexOf("/", root.length);\n      if (index !== -1) {\n        root = path2.slice(0, index);\n      } else\n        root = path2;\n      if (!root.endsWith("/"))\n        root += "/";\n    }\n    return root;\n  },\n  basename(path2, ext) {\n    assertPath(path2);\n    if (ext)\n      assertPath(ext);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {\n      if (ext.length === path2.length && ext === path2)\n        return "";\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path2.length - 1; i >= 0; --i) {\n        const code = path2.charCodeAt(i);\n        if (code === 47) {\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                end = i;\n              }\n            } else {\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path2.length;\n      return path2.slice(start, end);\n    }\n    for (i = path2.length - 1; i >= 0; --i) {\n      if (path2.charCodeAt(i) === 47) {\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n    if (end === -1)\n      return "";\n    return path2.slice(start, end);\n  },\n  extname(path2) {\n    assertPath(path2);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let preDotState = 0;\n    for (let i = path2.length - 1; i >= 0; --i) {\n      const code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return "";\n    }\n    return path2.slice(startDot, end);\n  },\n  parse(path2) {\n    assertPath(path2);\n    const ret = { root: "", dir: "", base: "", ext: "", name: "" };\n    if (path2.length === 0)\n      return ret;\n    path2 = removeUrlParams(this.toPosix(path2));\n    let code = path2.charCodeAt(0);\n    const isAbsolute = this.isAbsolute(path2);\n    let start;\n    const protocol = "";\n    ret.root = this.rootname(path2);\n    if (isAbsolute || this.hasProtocol(path2)) {\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path2.length - 1;\n    let preDotState = 0;\n    for (; i >= start; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute)\n          ret.base = ret.name = path2.slice(1, end);\n        else\n          ret.base = ret.name = path2.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path2.slice(1, startDot);\n        ret.base = path2.slice(1, end);\n      } else {\n        ret.name = path2.slice(startPart, startDot);\n        ret.base = path2.slice(startPart, end);\n      }\n      ret.ext = path2.slice(startDot, end);\n    }\n    ret.dir = this.dirname(path2);\n    if (protocol)\n      ret.dir = protocol + ret.dir;\n    return ret;\n  },\n  sep: "/",\n  delimiter: ":"\n};\n\n\n//# sourceMappingURL=path.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/logging/deprecation.mjs\nconst warnings = {};\nfunction deprecation(version, message, ignoreDepth = 3) {\n  if (warnings[message]) {\n    return;\n  }\n  let stack = new Error().stack;\n  if (typeof stack === "undefined") {\n    console.warn("PixiJS Deprecation Warning: ", `${message}\nDeprecated since v${version}`);\n  } else {\n    stack = stack.split("\\n").splice(ignoreDepth).join("\\n");\n    if (console.groupCollapsed) {\n      console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${message}\nDeprecated since v${version}`);\n      console.warn(stack);\n      console.groupEnd();\n    } else {\n      console.warn("PixiJS Deprecation Warning: ", `${message}\nDeprecated since v${version}`);\n      console.warn(stack);\n    }\n  }\n  warnings[message] = true;\n}\n\n\n//# sourceMappingURL=deprecation.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/browser/hello.mjs\n\n\nfunction skipHello() {\n  deprecation("7.0.0", "skipHello is deprecated, please use settings.RENDER_OPTIONS.hello");\n}\nfunction sayHello() {\n  deprecation("7.0.0", `sayHello is deprecated, please use Renderer\'s "hello" option`);\n}\n\n\n//# sourceMappingURL=hello.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/browser/isWebGLSupported.mjs\n\n\n\nlet supported;\nfunction isWebGLSupported() {\n  if (typeof supported === "undefined") {\n    supported = function supported2() {\n      const contextOptions = {\n        stencil: true,\n        failIfMajorPerformanceCaveat: lib/* settings */.Xd.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT\n      };\n      try {\n        if (!lib/* settings */.Xd.ADAPTER.getWebGLRenderingContext()) {\n          return false;\n        }\n        const canvas = lib/* settings */.Xd.ADAPTER.createCanvas();\n        let gl = canvas.getContext("webgl", contextOptions) || canvas.getContext("experimental-webgl", contextOptions);\n        const success = !!gl?.getContextAttributes()?.stencil;\n        if (gl) {\n          const loseContext = gl.getExtension("WEBGL_lose_context");\n          if (loseContext) {\n            loseContext.loseContext();\n          }\n        }\n        gl = null;\n        return success;\n      } catch (e) {\n        return false;\n      }\n    }();\n  }\n  return supported;\n}\n\n\n//# sourceMappingURL=isWebGLSupported.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/@pixi/color/lib/index.mjs + 3 modules\nvar color_lib = __webpack_require__(126);\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/color/hex.mjs\n\n\n\nfunction hex2rgb(hex, out = []) {\n  deprecation("7.2.0", "utils.hex2rgb is deprecated, use Color#toRgbArray instead");\n  return color_lib/* Color */.I.shared.setValue(hex).toRgbArray(out);\n}\nfunction hex2string(hex) {\n  deprecation("7.2.0", "utils.hex2string is deprecated, use Color#toHex instead");\n  return color_lib/* Color */.I.shared.setValue(hex).toHex();\n}\nfunction string2hex(string) {\n  deprecation("7.2.0", "utils.string2hex is deprecated, use Color#toNumber instead");\n  return color_lib/* Color */.I.shared.setValue(string).toNumber();\n}\nfunction rgb2hex(rgb) {\n  deprecation("7.2.0", "utils.rgb2hex is deprecated, use Color#toNumber instead");\n  return color_lib/* Color */.I.shared.setValue(rgb).toNumber();\n}\n\n\n//# sourceMappingURL=hex.mjs.map\n\n// EXTERNAL MODULE: ./node_modules/@pixi/constants/lib/index.mjs\nvar constants_lib = __webpack_require__(361);\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/color/premultiply.mjs\n\n\n\n\nfunction mapPremultipliedBlendModes() {\n  const pm = [];\n  const npm = [];\n  for (let i = 0; i < 32; i++) {\n    pm[i] = i;\n    npm[i] = i;\n  }\n  pm[constants_lib/* BLEND_MODES */.T$.NORMAL_NPM] = constants_lib/* BLEND_MODES */.T$.NORMAL;\n  pm[constants_lib/* BLEND_MODES */.T$.ADD_NPM] = constants_lib/* BLEND_MODES */.T$.ADD;\n  pm[constants_lib/* BLEND_MODES */.T$.SCREEN_NPM] = constants_lib/* BLEND_MODES */.T$.SCREEN;\n  npm[constants_lib/* BLEND_MODES */.T$.NORMAL] = constants_lib/* BLEND_MODES */.T$.NORMAL_NPM;\n  npm[constants_lib/* BLEND_MODES */.T$.ADD] = constants_lib/* BLEND_MODES */.T$.ADD_NPM;\n  npm[constants_lib/* BLEND_MODES */.T$.SCREEN] = constants_lib/* BLEND_MODES */.T$.SCREEN_NPM;\n  const array = [];\n  array.push(npm);\n  array.push(pm);\n  return array;\n}\nconst premultiplyBlendMode = mapPremultipliedBlendModes();\nfunction correctBlendMode(blendMode, premultiplied) {\n  return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];\n}\nfunction premultiplyRgba(rgb, alpha, out, premultiply = true) {\n  deprecation("7.2.0", `utils.premultiplyRgba has moved to Color.premultiply`);\n  return color_lib/* Color */.I.shared.setValue(rgb).premultiply(alpha, premultiply).toArray(out ?? new Float32Array(4));\n}\nfunction premultiplyTint(tint, alpha) {\n  deprecation("7.2.0", `utils.premultiplyTint has moved to Color.toPremultiplied`);\n  return color_lib/* Color */.I.shared.setValue(tint).toPremultiplied(alpha);\n}\nfunction premultiplyTintToRgba(tint, alpha, out, premultiply = true) {\n  deprecation("7.2.0", `utils.premultiplyTintToRgba has moved to Color.premultiply`);\n  return color_lib/* Color */.I.shared.setValue(tint).premultiply(alpha, premultiply).toArray(out ?? new Float32Array(4));\n}\n\n\n//# sourceMappingURL=premultiply.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/const.mjs\nconst DATA_URI = /^\\s*data:(?:([\\w-]+)\\/([\\w+.-]+))?(?:;charset=([\\w-]+))?(?:;(base64))?,(.*)/i;\n\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/createIndicesForQuads.mjs\nfunction createIndicesForQuads(size, outBuffer = null) {\n  const totalIndices = size * 6;\n  outBuffer = outBuffer || new Uint16Array(totalIndices);\n  if (outBuffer.length !== totalIndices) {\n    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n  }\n  for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4) {\n    outBuffer[i + 0] = j + 0;\n    outBuffer[i + 1] = j + 1;\n    outBuffer[i + 2] = j + 2;\n    outBuffer[i + 3] = j + 0;\n    outBuffer[i + 4] = j + 2;\n    outBuffer[i + 5] = j + 3;\n  }\n  return outBuffer;\n}\n\n\n//# sourceMappingURL=createIndicesForQuads.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/getBufferType.mjs\nfunction getBufferType(array) {\n  if (array.BYTES_PER_ELEMENT === 4) {\n    if (array instanceof Float32Array) {\n      return "Float32Array";\n    } else if (array instanceof Uint32Array) {\n      return "Uint32Array";\n    }\n    return "Int32Array";\n  } else if (array.BYTES_PER_ELEMENT === 2) {\n    if (array instanceof Uint16Array) {\n      return "Uint16Array";\n    }\n  } else if (array.BYTES_PER_ELEMENT === 1) {\n    if (array instanceof Uint8Array) {\n      return "Uint8Array";\n    }\n  }\n  return null;\n}\n\n\n//# sourceMappingURL=getBufferType.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/interleaveTypedArrays.mjs\n\n\nconst map = { Float32Array, Uint32Array, Int32Array, Uint8Array };\nfunction interleaveTypedArrays(arrays, sizes) {\n  let outSize = 0;\n  let stride = 0;\n  const views = {};\n  for (let i = 0; i < arrays.length; i++) {\n    stride += sizes[i];\n    outSize += arrays[i].length;\n  }\n  const buffer = new ArrayBuffer(outSize * 4);\n  let out = null;\n  let littleOffset = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const size = sizes[i];\n    const array = arrays[i];\n    const type = getBufferType(array);\n    if (!views[type]) {\n      views[type] = new map[type](buffer);\n    }\n    out = views[type];\n    for (let j = 0; j < array.length; j++) {\n      const indexStart = (j / size | 0) * stride + littleOffset;\n      const index = j % size;\n      out[indexStart + index] = array[j];\n    }\n    littleOffset += size;\n  }\n  return new Float32Array(buffer);\n}\n\n\n//# sourceMappingURL=interleaveTypedArrays.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/pow2.mjs\nfunction nextPow2(v) {\n  v += v === 0 ? 1 : 0;\n  --v;\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v + 1;\n}\nfunction isPow2(v) {\n  return !(v & v - 1) && !!v;\n}\nfunction log2(v) {\n  let r = (v > 65535 ? 1 : 0) << 4;\n  v >>>= r;\n  let shift = (v > 255 ? 1 : 0) << 3;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 15 ? 1 : 0) << 2;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 3 ? 1 : 0) << 1;\n  v >>>= shift;\n  r |= shift;\n  return r | v >> 1;\n}\n\n\n//# sourceMappingURL=pow2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/removeItems.mjs\nfunction removeItems(arr, startIdx, removeCount) {\n  const length = arr.length;\n  let i;\n  if (startIdx >= length || removeCount === 0) {\n    return;\n  }\n  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;\n  const len = length - removeCount;\n  for (i = startIdx; i < len; ++i) {\n    arr[i] = arr[i + removeCount];\n  }\n  arr.length = len;\n}\n\n\n//# sourceMappingURL=removeItems.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/sign.mjs\nfunction sign(n) {\n  if (n === 0)\n    return 0;\n  return n < 0 ? -1 : 1;\n}\n\n\n//# sourceMappingURL=sign.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/data/uid.mjs\nlet nextUid = 0;\nfunction uid() {\n  return ++nextUid;\n}\n\n\n//# sourceMappingURL=uid.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/media/BoundingBox.mjs\nconst _BoundingBox = class {\n  constructor(left, top, right, bottom) {\n    this.left = left;\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n  }\n  get width() {\n    return this.right - this.left;\n  }\n  get height() {\n    return this.bottom - this.top;\n  }\n  isEmpty() {\n    return this.left === this.right || this.top === this.bottom;\n  }\n};\nlet BoundingBox = _BoundingBox;\nBoundingBox.EMPTY = new _BoundingBox(0, 0, 0, 0);\n\n\n//# sourceMappingURL=BoundingBox.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/media/caches.mjs\nconst ProgramCache = {};\nconst TextureCache = /* @__PURE__ */ Object.create(null);\nconst BaseTextureCache = /* @__PURE__ */ Object.create(null);\nfunction destroyTextureCache() {\n  let key;\n  for (key in TextureCache) {\n    TextureCache[key].destroy();\n  }\n  for (key in BaseTextureCache) {\n    BaseTextureCache[key].destroy();\n  }\n}\nfunction clearTextureCache() {\n  let key;\n  for (key in TextureCache) {\n    delete TextureCache[key];\n  }\n  for (key in BaseTextureCache) {\n    delete BaseTextureCache[key];\n  }\n}\n\n\n//# sourceMappingURL=caches.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/media/CanvasRenderTarget.mjs\n\n\nclass CanvasRenderTarget {\n  constructor(width, height, resolution) {\n    this._canvas = lib/* settings */.Xd.ADAPTER.createCanvas();\n    this._context = this._canvas.getContext("2d");\n    this.resolution = resolution || lib/* settings */.Xd.RESOLUTION;\n    this.resize(width, height);\n  }\n  clear() {\n    this._checkDestroyed();\n    this._context.setTransform(1, 0, 0, 1, 0, 0);\n    this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);\n  }\n  resize(desiredWidth, desiredHeight) {\n    this._checkDestroyed();\n    this._canvas.width = Math.round(desiredWidth * this.resolution);\n    this._canvas.height = Math.round(desiredHeight * this.resolution);\n  }\n  destroy() {\n    this._context = null;\n    this._canvas = null;\n  }\n  get width() {\n    this._checkDestroyed();\n    return this._canvas.width;\n  }\n  set width(val) {\n    this._checkDestroyed();\n    this._canvas.width = Math.round(val);\n  }\n  get height() {\n    this._checkDestroyed();\n    return this._canvas.height;\n  }\n  set height(val) {\n    this._checkDestroyed();\n    this._canvas.height = Math.round(val);\n  }\n  get canvas() {\n    this._checkDestroyed();\n    return this._canvas;\n  }\n  get context() {\n    this._checkDestroyed();\n    return this._context;\n  }\n  _checkDestroyed() {\n    if (this._canvas === null) {\n      throw new TypeError("The CanvasRenderTarget has already been destroyed");\n    }\n  }\n}\n\n\n//# sourceMappingURL=CanvasRenderTarget.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/media/getCanvasBoundingBox.mjs\n\n\nfunction checkRow(data, width, y) {\n  for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4) {\n    if (data[index + 3] !== 0)\n      return false;\n  }\n  return true;\n}\nfunction checkColumn(data, width, x, top, bottom) {\n  const stride = 4 * width;\n  for (let y = top, index = top * stride + 4 * x; y <= bottom; ++y, index += stride) {\n    if (data[index + 3] !== 0)\n      return false;\n  }\n  return true;\n}\nfunction getCanvasBoundingBox(canvas) {\n  const { width, height } = canvas;\n  const context = canvas.getContext("2d", {\n    willReadFrequently: true\n  });\n  if (context === null) {\n    throw new TypeError("Failed to get canvas 2D context");\n  }\n  const imageData = context.getImageData(0, 0, width, height);\n  const data = imageData.data;\n  let left = 0;\n  let top = 0;\n  let right = width - 1;\n  let bottom = height - 1;\n  while (top < height && checkRow(data, width, top))\n    ++top;\n  if (top === height)\n    return BoundingBox.EMPTY;\n  while (checkRow(data, width, bottom))\n    --bottom;\n  while (checkColumn(data, width, left, top, bottom))\n    ++left;\n  while (checkColumn(data, width, right, top, bottom))\n    --right;\n  ++right;\n  ++bottom;\n  return new BoundingBox(left, top, right, bottom);\n}\n\n\n//# sourceMappingURL=getCanvasBoundingBox.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/media/trimCanvas.mjs\n\n\nfunction trimCanvas(canvas) {\n  const boundingBox = getCanvasBoundingBox(canvas);\n  const { width, height } = boundingBox;\n  let data = null;\n  if (!boundingBox.isEmpty()) {\n    const context = canvas.getContext("2d");\n    if (context === null) {\n      throw new TypeError("Failed to get canvas 2D context");\n    }\n    data = context.getImageData(boundingBox.left, boundingBox.top, width, height);\n  }\n  return { width, height, data };\n}\n\n\n//# sourceMappingURL=trimCanvas.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/network/decomposeDataUri.mjs\n\n\nfunction decomposeDataUri(dataUri) {\n  const dataUriMatch = DATA_URI.exec(dataUri);\n  if (dataUriMatch) {\n    return {\n      mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : void 0,\n      subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : void 0,\n      charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : void 0,\n      encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : void 0,\n      data: dataUriMatch[5]\n    };\n  }\n  return void 0;\n}\n\n\n//# sourceMappingURL=decomposeDataUri.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/network/determineCrossOrigin.mjs\n\n\nlet tempAnchor;\nfunction determineCrossOrigin(url$1, loc = globalThis.location) {\n  if (url$1.startsWith("data:")) {\n    return "";\n  }\n  loc = loc || globalThis.location;\n  if (!tempAnchor) {\n    tempAnchor = document.createElement("a");\n  }\n  tempAnchor.href = url$1;\n  const parsedUrl = url_url.parse(tempAnchor.href);\n  const samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;\n  if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {\n    return "anonymous";\n  }\n  return "";\n}\n\n\n//# sourceMappingURL=determineCrossOrigin.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/network/getResolutionOfUrl.mjs\n\n\n\nfunction getResolutionOfUrl(url, defaultValue = 1) {\n  const resolution = lib/* settings */.Xd.RETINA_PREFIX?.exec(url);\n  if (resolution) {\n    return parseFloat(resolution[1]);\n  }\n  return defaultValue;\n}\n\n\n//# sourceMappingURL=getResolutionOfUrl.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/utils/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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eEI7O0FBRWdDO0FBQ2hDOzs7QUMvQ2tFOztBQUVsRTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUMsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFc0I7QUFDdEI7OztBQ2pCd0M7O0FBRXhDO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEI7QUFDNUI7OztBQ2pCaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQUc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnQztBQUNoQzs7O0FDckJ5QjtBQUNpQjs7QUFFMUM7QUFDQSxxQkFBcUIsb0JBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFOEI7QUFDOUI7OztBQ1p3QjtBQUNrQjtBQUNjO0FBQ2I7QUFDWDtBQUNFO0FBQ3dCO0FBQ1E7QUFDUztBQUMrRDtBQUNuRztBQUNrQztBQUNoQjtBQUNnQjtBQUNoQjtBQUNKO0FBQ2Q7QUFDRjtBQUNtQjtBQUNGO0FBQ29FO0FBQ3REO0FBQ0k7QUFDcEI7QUFDYztBQUNRO0FBQ0o7QUFDM0M7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL3NldHRpbmdzLm1qcz9lYmRmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvdXJsLm1qcz9hMWMzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvcGF0aC5tanM/ZWU4MiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzPzNjMGIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9icm93c2VyL2hlbGxvLm1qcz80NGZjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvYnJvd3Nlci9pc1dlYkdMU3VwcG9ydGVkLm1qcz85YzU5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvY29sb3IvaGV4Lm1qcz9lYTY2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvY29sb3IvcHJlbXVsdGlwbHkubWpzPzZlYTYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9jb25zdC5tanM/ZWJkMCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2RhdGEvY3JlYXRlSW5kaWNlc0ZvclF1YWRzLm1qcz9hMWIzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvZGF0YS9nZXRCdWZmZXJUeXBlLm1qcz9mZmQ5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvZGF0YS9pbnRlcmxlYXZlVHlwZWRBcnJheXMubWpzPzFmMTIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9kYXRhL3BvdzIubWpzPzgyY2UiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9kYXRhL3JlbW92ZUl0ZW1zLm1qcz9iZmE1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvZGF0YS9zaWduLm1qcz9jYjU3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvZGF0YS91aWQubWpzPzVhMzMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9tZWRpYS9Cb3VuZGluZ0JveC5tanM/ODdjZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL21lZGlhL2NhY2hlcy5tanM/Njk1OCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL21lZGlhL0NhbnZhc1JlbmRlclRhcmdldC5tanM/NzliZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL21lZGlhL2dldENhbnZhc0JvdW5kaW5nQm94Lm1qcz9hMTFlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS91dGlscy9saWIvbWVkaWEvdHJpbUNhbnZhcy5tanM/ZmFhNyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL25ldHdvcmsvZGVjb21wb3NlRGF0YVVyaS5tanM/NzlkNyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL25ldHdvcmsvZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4ubWpzPzE0ZjIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3V0aWxzL2xpYi9uZXR3b3JrL2dldFJlc29sdXRpb25PZlVybC5tanM/MmMwZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvdXRpbHMvbGliL2luZGV4Lm1qcz9iNTBjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSAnQHBpeGkvc2V0dGluZ3MnO1xuZXhwb3J0IHsgc2V0dGluZ3MgfSBmcm9tICdAcGl4aS9zZXR0aW5ncyc7XG5cbnNldHRpbmdzLlJFVElOQV9QUkVGSVggPSAvQChbMC05XFwuXSspeC87XG5zZXR0aW5ncy5GQUlMX0lGX01BSk9SX1BFUkZPUk1BTkNFX0NBVkVBVCA9IGZhbHNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0dGluZ3MubWpzLm1hcFxuIiwiaW1wb3J0IHsgcGFyc2UsIGZvcm1hdCwgcmVzb2x2ZSB9IGZyb20gJ3VybCc7XG5cbmNvbnN0IHVybCA9IHtcbiAgcGFyc2U6IHBhcnNlLFxuICBmb3JtYXQ6IGZvcm1hdCxcbiAgcmVzb2x2ZTogcmVzb2x2ZVxufTtcblxuZXhwb3J0IHsgdXJsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmwubWpzLm1hcFxuIiwiaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tICdAcGl4aS9zZXR0aW5ncyc7XG5cbmZ1bmN0aW9uIGFzc2VydFBhdGgocGF0aDIpIHtcbiAgaWYgKHR5cGVvZiBwYXRoMiAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhdGggbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeShwYXRoMil9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZVVybFBhcmFtcyh1cmwpIHtcbiAgY29uc3QgcmUgPSB1cmwuc3BsaXQoXCI/XCIpWzBdO1xuICByZXR1cm4gcmUuc3BsaXQoXCIjXCIpWzBdO1xufVxuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VBbGwoc3RyLCBmaW5kLCByZXBsYWNlKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cChmaW5kKSwgXCJnXCIpLCByZXBsYWNlKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KHBhdGgyLCBhbGxvd0Fib3ZlUm9vdCkge1xuICBsZXQgcmVzID0gXCJcIjtcbiAgbGV0IGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcbiAgbGV0IGxhc3RTbGFzaCA9IC0xO1xuICBsZXQgZG90cyA9IDA7XG4gIGxldCBjb2RlID0gLTE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IHBhdGgyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGkgPCBwYXRoMi5sZW5ndGgpIHtcbiAgICAgIGNvZGUgPSBwYXRoMi5jaGFyQ29kZUF0KGkpO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gNDcpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlID0gNDc7XG4gICAgfVxuICAgIGlmIChjb2RlID09PSA0Nykge1xuICAgICAgaWYgKGxhc3RTbGFzaCA9PT0gaSAtIDEgfHwgZG90cyA9PT0gMSkge1xuICAgICAgfSBlbHNlIGlmIChsYXN0U2xhc2ggIT09IGkgLSAxICYmIGRvdHMgPT09IDIpIHtcbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPCAyIHx8IGxhc3RTZWdtZW50TGVuZ3RoICE9PSAyIHx8IHJlcy5jaGFyQ29kZUF0KHJlcy5sZW5ndGggLSAxKSAhPT0gNDYgfHwgcmVzLmNoYXJDb2RlQXQocmVzLmxlbmd0aCAtIDIpICE9PSA0Nikge1xuICAgICAgICAgIGlmIChyZXMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgY29uc3QgbGFzdFNsYXNoSW5kZXggPSByZXMubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgICAgICAgICAgaWYgKGxhc3RTbGFzaEluZGV4ICE9PSByZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBpZiAobGFzdFNsYXNoSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gXCJcIjtcbiAgICAgICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IDA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVzLnNsaWNlKDAsIGxhc3RTbGFzaEluZGV4KTtcbiAgICAgICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IHJlcy5sZW5ndGggLSAxIC0gcmVzLmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsYXN0U2xhc2ggPSBpO1xuICAgICAgICAgICAgICBkb3RzID0gMDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXMubGVuZ3RoID09PSAyIHx8IHJlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJlcyA9IFwiXCI7XG4gICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IDA7XG4gICAgICAgICAgICBsYXN0U2xhc2ggPSBpO1xuICAgICAgICAgICAgZG90cyA9IDA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXMgKz0gXCIvLi5cIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gXCIuLlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IDI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlcyArPSBgLyR7cGF0aDIuc2xpY2UobGFzdFNsYXNoICsgMSwgaSl9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXMgPSBwYXRoMi5zbGljZShsYXN0U2xhc2ggKyAxLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IGkgLSBsYXN0U2xhc2ggLSAxO1xuICAgICAgfVxuICAgICAgbGFzdFNsYXNoID0gaTtcbiAgICAgIGRvdHMgPSAwO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gNDYgJiYgZG90cyAhPT0gLTEpIHtcbiAgICAgICsrZG90cztcbiAgICB9IGVsc2Uge1xuICAgICAgZG90cyA9IC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuY29uc3QgcGF0aCA9IHtcbiAgdG9Qb3NpeChwYXRoMikge1xuICAgIHJldHVybiByZXBsYWNlQWxsKHBhdGgyLCBcIlxcXFxcIiwgXCIvXCIpO1xuICB9LFxuICBpc1VybChwYXRoMikge1xuICAgIHJldHVybiAvXmh0dHBzPzovLnRlc3QodGhpcy50b1Bvc2l4KHBhdGgyKSk7XG4gIH0sXG4gIGlzRGF0YVVybChwYXRoMikge1xuICAgIHJldHVybiAvXmRhdGE6KFthLXpdK1xcL1thLXowLTktKy5dKyg7W2EtejAtOS0uISMkJSorLnt9fH5gXSs9W2EtejAtOS0uISMkJSorLnt9KClffH5gXSspKik/KDtiYXNlNjQpPywoW2EtejAtOSEkJicsKCkqKzs9XFwtLl9+OkBcXC8/JVxcczw+XSo/KSQvaS50ZXN0KHBhdGgyKTtcbiAgfSxcbiAgaGFzUHJvdG9jb2wocGF0aDIpIHtcbiAgICByZXR1cm4gL15bXi86XSs6XFwvLy50ZXN0KHRoaXMudG9Qb3NpeChwYXRoMikpO1xuICB9LFxuICBnZXRQcm90b2NvbChwYXRoMikge1xuICAgIGFzc2VydFBhdGgocGF0aDIpO1xuICAgIHBhdGgyID0gdGhpcy50b1Bvc2l4KHBhdGgyKTtcbiAgICBsZXQgcHJvdG9jb2wgPSBcIlwiO1xuICAgIGNvbnN0IGlzRmlsZSA9IC9eZmlsZTpcXC9cXC9cXC8vLmV4ZWMocGF0aDIpO1xuICAgIGNvbnN0IGlzSHR0cCA9IC9eW14vOl0rOlxcL1xcLy8uZXhlYyhwYXRoMik7XG4gICAgY29uc3QgaXNXaW5kb3dzID0gL15bXi86XSs6XFwvLy5leGVjKHBhdGgyKTtcbiAgICBpZiAoaXNGaWxlIHx8IGlzSHR0cCB8fCBpc1dpbmRvd3MpIHtcbiAgICAgIGNvbnN0IGFyciA9IGlzRmlsZT8uWzBdIHx8IGlzSHR0cD8uWzBdIHx8IGlzV2luZG93cz8uWzBdO1xuICAgICAgcHJvdG9jb2wgPSBhcnI7XG4gICAgICBwYXRoMiA9IHBhdGgyLnNsaWNlKGFyci5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvdG9jb2w7XG4gIH0sXG4gIHRvQWJzb2x1dGUodXJsLCBjdXN0b21CYXNlVXJsLCBjdXN0b21Sb290VXJsKSB7XG4gICAgaWYgKHRoaXMuaXNEYXRhVXJsKHVybCkpXG4gICAgICByZXR1cm4gdXJsO1xuICAgIGNvbnN0IGJhc2VVcmwgPSByZW1vdmVVcmxQYXJhbXModGhpcy50b1Bvc2l4KGN1c3RvbUJhc2VVcmwgPz8gc2V0dGluZ3MuQURBUFRFUi5nZXRCYXNlVXJsKCkpKTtcbiAgICBjb25zdCByb290VXJsID0gcmVtb3ZlVXJsUGFyYW1zKHRoaXMudG9Qb3NpeChjdXN0b21Sb290VXJsID8/IHRoaXMucm9vdG5hbWUoYmFzZVVybCkpKTtcbiAgICBhc3NlcnRQYXRoKHVybCk7XG4gICAgdXJsID0gdGhpcy50b1Bvc2l4KHVybCk7XG4gICAgaWYgKHVybC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgcmV0dXJuIHBhdGguam9pbihyb290VXJsLCB1cmwuc2xpY2UoMSkpO1xuICAgIH1cbiAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSB0aGlzLmlzQWJzb2x1dGUodXJsKSA/IHVybCA6IHRoaXMuam9pbihiYXNlVXJsLCB1cmwpO1xuICAgIHJldHVybiBhYnNvbHV0ZVBhdGg7XG4gIH0sXG4gIG5vcm1hbGl6ZShwYXRoMikge1xuICAgIHBhdGgyID0gdGhpcy50b1Bvc2l4KHBhdGgyKTtcbiAgICBhc3NlcnRQYXRoKHBhdGgyKTtcbiAgICBpZiAocGF0aDIubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIFwiLlwiO1xuICAgIGxldCBwcm90b2NvbCA9IFwiXCI7XG4gICAgY29uc3QgaXNBYnNvbHV0ZSA9IHBhdGgyLnN0YXJ0c1dpdGgoXCIvXCIpO1xuICAgIGlmICh0aGlzLmhhc1Byb3RvY29sKHBhdGgyKSkge1xuICAgICAgcHJvdG9jb2wgPSB0aGlzLnJvb3RuYW1lKHBhdGgyKTtcbiAgICAgIHBhdGgyID0gcGF0aDIuc2xpY2UocHJvdG9jb2wubGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgdHJhaWxpbmdTZXBhcmF0b3IgPSBwYXRoMi5lbmRzV2l0aChcIi9cIik7XG4gICAgcGF0aDIgPSBub3JtYWxpemVTdHJpbmdQb3NpeChwYXRoMiwgZmFsc2UpO1xuICAgIGlmIChwYXRoMi5sZW5ndGggPiAwICYmIHRyYWlsaW5nU2VwYXJhdG9yKVxuICAgICAgcGF0aDIgKz0gXCIvXCI7XG4gICAgaWYgKGlzQWJzb2x1dGUpXG4gICAgICByZXR1cm4gYC8ke3BhdGgyfWA7XG4gICAgcmV0dXJuIHByb3RvY29sICsgcGF0aDI7XG4gIH0sXG4gIGlzQWJzb2x1dGUocGF0aDIpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgyKTtcbiAgICBwYXRoMiA9IHRoaXMudG9Qb3NpeChwYXRoMik7XG4gICAgaWYgKHRoaXMuaGFzUHJvdG9jb2wocGF0aDIpKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHBhdGgyLnN0YXJ0c1dpdGgoXCIvXCIpO1xuICB9LFxuICBqb2luKC4uLnNlZ21lbnRzKSB7XG4gICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFwiLlwiO1xuICAgIH1cbiAgICBsZXQgam9pbmVkO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGFyZyA9IHNlZ21lbnRzW2ldO1xuICAgICAgYXNzZXJ0UGF0aChhcmcpO1xuICAgICAgaWYgKGFyZy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChqb2luZWQgPT09IHZvaWQgMClcbiAgICAgICAgICBqb2luZWQgPSBhcmc7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHByZXZBcmcgPSBzZWdtZW50c1tpIC0gMV0gPz8gXCJcIjtcbiAgICAgICAgICBpZiAodGhpcy5leHRuYW1lKHByZXZBcmcpKSB7XG4gICAgICAgICAgICBqb2luZWQgKz0gYC8uLi8ke2FyZ31gO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBqb2luZWQgKz0gYC8ke2FyZ31gO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoam9pbmVkID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBcIi5cIjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubm9ybWFsaXplKGpvaW5lZCk7XG4gIH0sXG4gIGRpcm5hbWUocGF0aDIpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgyKTtcbiAgICBpZiAocGF0aDIubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIFwiLlwiO1xuICAgIHBhdGgyID0gdGhpcy50b1Bvc2l4KHBhdGgyKTtcbiAgICBsZXQgY29kZSA9IHBhdGgyLmNoYXJDb2RlQXQoMCk7XG4gICAgY29uc3QgaGFzUm9vdCA9IGNvZGUgPT09IDQ3O1xuICAgIGxldCBlbmQgPSAtMTtcbiAgICBsZXQgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICBjb25zdCBwcm90byA9IHRoaXMuZ2V0UHJvdG9jb2wocGF0aDIpO1xuICAgIGNvbnN0IG9yaWdwYXRoID0gcGF0aDI7XG4gICAgcGF0aDIgPSBwYXRoMi5zbGljZShwcm90by5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSBwYXRoMi5sZW5ndGggLSAxOyBpID49IDE7IC0taSkge1xuICAgICAgY29kZSA9IHBhdGgyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoY29kZSA9PT0gNDcpIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZCA9PT0gLTEpXG4gICAgICByZXR1cm4gaGFzUm9vdCA/IFwiL1wiIDogdGhpcy5pc1VybChvcmlncGF0aCkgPyBwcm90byArIHBhdGgyIDogcHJvdG87XG4gICAgaWYgKGhhc1Jvb3QgJiYgZW5kID09PSAxKVxuICAgICAgcmV0dXJuIFwiLy9cIjtcbiAgICByZXR1cm4gcHJvdG8gKyBwYXRoMi5zbGljZSgwLCBlbmQpO1xuICB9LFxuICByb290bmFtZShwYXRoMikge1xuICAgIGFzc2VydFBhdGgocGF0aDIpO1xuICAgIHBhdGgyID0gdGhpcy50b1Bvc2l4KHBhdGgyKTtcbiAgICBsZXQgcm9vdCA9IFwiXCI7XG4gICAgaWYgKHBhdGgyLnN0YXJ0c1dpdGgoXCIvXCIpKVxuICAgICAgcm9vdCA9IFwiL1wiO1xuICAgIGVsc2Uge1xuICAgICAgcm9vdCA9IHRoaXMuZ2V0UHJvdG9jb2wocGF0aDIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1VybChwYXRoMikpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gcGF0aDIuaW5kZXhPZihcIi9cIiwgcm9vdC5sZW5ndGgpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICByb290ID0gcGF0aDIuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJvb3QgPSBwYXRoMjtcbiAgICAgIGlmICghcm9vdC5lbmRzV2l0aChcIi9cIikpXG4gICAgICAgIHJvb3QgKz0gXCIvXCI7XG4gICAgfVxuICAgIHJldHVybiByb290O1xuICB9LFxuICBiYXNlbmFtZShwYXRoMiwgZXh0KSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoMik7XG4gICAgaWYgKGV4dClcbiAgICAgIGFzc2VydFBhdGgoZXh0KTtcbiAgICBwYXRoMiA9IHJlbW92ZVVybFBhcmFtcyh0aGlzLnRvUG9zaXgocGF0aDIpKTtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSAtMTtcbiAgICBsZXQgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICBsZXQgaTtcbiAgICBpZiAoZXh0ICE9PSB2b2lkIDAgJiYgZXh0Lmxlbmd0aCA+IDAgJiYgZXh0Lmxlbmd0aCA8PSBwYXRoMi5sZW5ndGgpIHtcbiAgICAgIGlmIChleHQubGVuZ3RoID09PSBwYXRoMi5sZW5ndGggJiYgZXh0ID09PSBwYXRoMilcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICBsZXQgZXh0SWR4ID0gZXh0Lmxlbmd0aCAtIDE7XG4gICAgICBsZXQgZmlyc3ROb25TbGFzaEVuZCA9IC0xO1xuICAgICAgZm9yIChpID0gcGF0aDIubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHBhdGgyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlID09PSA0Nykge1xuICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmaXJzdE5vblNsYXNoRW5kID09PSAtMSkge1xuICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICBmaXJzdE5vblNsYXNoRW5kID0gaSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleHRJZHggPj0gMCkge1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IGV4dC5jaGFyQ29kZUF0KGV4dElkeCkpIHtcbiAgICAgICAgICAgICAgaWYgKC0tZXh0SWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGV4dElkeCA9IC0xO1xuICAgICAgICAgICAgICBlbmQgPSBmaXJzdE5vblNsYXNoRW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpXG4gICAgICAgIGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQ7XG4gICAgICBlbHNlIGlmIChlbmQgPT09IC0xKVxuICAgICAgICBlbmQgPSBwYXRoMi5sZW5ndGg7XG4gICAgICByZXR1cm4gcGF0aDIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIGZvciAoaSA9IHBhdGgyLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBpZiAocGF0aDIuY2hhckNvZGVBdChpKSA9PT0gNDcpIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgIGVuZCA9IGkgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5kID09PSAtMSlcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIHJldHVybiBwYXRoMi5zbGljZShzdGFydCwgZW5kKTtcbiAgfSxcbiAgZXh0bmFtZShwYXRoMikge1xuICAgIGFzc2VydFBhdGgocGF0aDIpO1xuICAgIHBhdGgyID0gcmVtb3ZlVXJsUGFyYW1zKHRoaXMudG9Qb3NpeChwYXRoMikpO1xuICAgIGxldCBzdGFydERvdCA9IC0xO1xuICAgIGxldCBzdGFydFBhcnQgPSAwO1xuICAgIGxldCBlbmQgPSAtMTtcbiAgICBsZXQgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICBsZXQgcHJlRG90U3RhdGUgPSAwO1xuICAgIGZvciAobGV0IGkgPSBwYXRoMi5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3QgY29kZSA9IHBhdGgyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoY29kZSA9PT0gNDcpIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSA0Nikge1xuICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKVxuICAgICAgICAgIHN0YXJ0RG90ID0gaTtcbiAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpXG4gICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fCBlbmQgPT09IC0xIHx8IHByZURvdFN0YXRlID09PSAwIHx8IHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGgyLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xuICB9LFxuICBwYXJzZShwYXRoMikge1xuICAgIGFzc2VydFBhdGgocGF0aDIpO1xuICAgIGNvbnN0IHJldCA9IHsgcm9vdDogXCJcIiwgZGlyOiBcIlwiLCBiYXNlOiBcIlwiLCBleHQ6IFwiXCIsIG5hbWU6IFwiXCIgfTtcbiAgICBpZiAocGF0aDIubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHJldDtcbiAgICBwYXRoMiA9IHJlbW92ZVVybFBhcmFtcyh0aGlzLnRvUG9zaXgocGF0aDIpKTtcbiAgICBsZXQgY29kZSA9IHBhdGgyLmNoYXJDb2RlQXQoMCk7XG4gICAgY29uc3QgaXNBYnNvbHV0ZSA9IHRoaXMuaXNBYnNvbHV0ZShwYXRoMik7XG4gICAgbGV0IHN0YXJ0O1xuICAgIGNvbnN0IHByb3RvY29sID0gXCJcIjtcbiAgICByZXQucm9vdCA9IHRoaXMucm9vdG5hbWUocGF0aDIpO1xuICAgIGlmIChpc0Fic29sdXRlIHx8IHRoaXMuaGFzUHJvdG9jb2wocGF0aDIpKSB7XG4gICAgICBzdGFydCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgbGV0IHN0YXJ0RG90ID0gLTE7XG4gICAgbGV0IHN0YXJ0UGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IC0xO1xuICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIGxldCBpID0gcGF0aDIubGVuZ3RoIC0gMTtcbiAgICBsZXQgcHJlRG90U3RhdGUgPSAwO1xuICAgIGZvciAoOyBpID49IHN0YXJ0OyAtLWkpIHtcbiAgICAgIGNvZGUgPSBwYXRoMi5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgPT09IDQ3KSB7XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICB9XG4gICAgICBpZiAoY29kZSA9PT0gNDYpIHtcbiAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSlcbiAgICAgICAgICBzdGFydERvdCA9IGk7XG4gICAgICAgIGVsc2UgaWYgKHByZURvdFN0YXRlICE9PSAxKVxuICAgICAgICAgIHByZURvdFN0YXRlID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGFydERvdCA9PT0gLTEgfHwgZW5kID09PSAtMSB8fCBwcmVEb3RTdGF0ZSA9PT0gMCB8fCBwcmVEb3RTdGF0ZSA9PT0gMSAmJiBzdGFydERvdCA9PT0gZW5kIC0gMSAmJiBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkge1xuICAgICAgaWYgKGVuZCAhPT0gLTEpIHtcbiAgICAgICAgaWYgKHN0YXJ0UGFydCA9PT0gMCAmJiBpc0Fic29sdXRlKVxuICAgICAgICAgIHJldC5iYXNlID0gcmV0Lm5hbWUgPSBwYXRoMi5zbGljZSgxLCBlbmQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0LmJhc2UgPSByZXQubmFtZSA9IHBhdGgyLnNsaWNlKHN0YXJ0UGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXJ0UGFydCA9PT0gMCAmJiBpc0Fic29sdXRlKSB7XG4gICAgICAgIHJldC5uYW1lID0gcGF0aDIuc2xpY2UoMSwgc3RhcnREb3QpO1xuICAgICAgICByZXQuYmFzZSA9IHBhdGgyLnNsaWNlKDEsIGVuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQubmFtZSA9IHBhdGgyLnNsaWNlKHN0YXJ0UGFydCwgc3RhcnREb3QpO1xuICAgICAgICByZXQuYmFzZSA9IHBhdGgyLnNsaWNlKHN0YXJ0UGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICAgIHJldC5leHQgPSBwYXRoMi5zbGljZShzdGFydERvdCwgZW5kKTtcbiAgICB9XG4gICAgcmV0LmRpciA9IHRoaXMuZGlybmFtZShwYXRoMik7XG4gICAgaWYgKHByb3RvY29sKVxuICAgICAgcmV0LmRpciA9IHByb3RvY29sICsgcmV0LmRpcjtcbiAgICByZXR1cm4gcmV0O1xuICB9LFxuICBzZXA6IFwiL1wiLFxuICBkZWxpbWl0ZXI6IFwiOlwiXG59O1xuXG5leHBvcnQgeyBwYXRoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRoLm1qcy5tYXBcbiIsImNvbnN0IHdhcm5pbmdzID0ge307XG5mdW5jdGlvbiBkZXByZWNhdGlvbih2ZXJzaW9uLCBtZXNzYWdlLCBpZ25vcmVEZXB0aCA9IDMpIHtcbiAgaWYgKHdhcm5pbmdzW21lc3NhZ2VdKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICBpZiAodHlwZW9mIHN0YWNrID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc29sZS53YXJuKFwiUGl4aUpTIERlcHJlY2F0aW9uIFdhcm5pbmc6IFwiLCBgJHttZXNzYWdlfVxuRGVwcmVjYXRlZCBzaW5jZSB2JHt2ZXJzaW9ufWApO1xuICB9IGVsc2Uge1xuICAgIHN0YWNrID0gc3RhY2suc3BsaXQoXCJcXG5cIikuc3BsaWNlKGlnbm9yZURlcHRoKS5qb2luKFwiXFxuXCIpO1xuICAgIGlmIChjb25zb2xlLmdyb3VwQ29sbGFwc2VkKSB7XG4gICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKFwiJWNQaXhpSlMgRGVwcmVjYXRpb24gV2FybmluZzogJWMlc1wiLCBcImNvbG9yOiM2MTQxMDg7YmFja2dyb3VuZDojZmZmYmU2XCIsIFwiZm9udC13ZWlnaHQ6bm9ybWFsO2NvbG9yOiM2MTQxMDg7YmFja2dyb3VuZDojZmZmYmU2XCIsIGAke21lc3NhZ2V9XG5EZXByZWNhdGVkIHNpbmNlIHYke3ZlcnNpb259YCk7XG4gICAgICBjb25zb2xlLndhcm4oc3RhY2spO1xuICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJQaXhpSlMgRGVwcmVjYXRpb24gV2FybmluZzogXCIsIGAke21lc3NhZ2V9XG5EZXByZWNhdGVkIHNpbmNlIHYke3ZlcnNpb259YCk7XG4gICAgICBjb25zb2xlLndhcm4oc3RhY2spO1xuICAgIH1cbiAgfVxuICB3YXJuaW5nc1ttZXNzYWdlXSA9IHRydWU7XG59XG5cbmV4cG9ydCB7IGRlcHJlY2F0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXByZWNhdGlvbi5tanMubWFwXG4iLCJpbXBvcnQgeyBkZXByZWNhdGlvbiB9IGZyb20gJy4uL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcblxuZnVuY3Rpb24gc2tpcEhlbGxvKCkge1xuICBkZXByZWNhdGlvbihcIjcuMC4wXCIsIFwic2tpcEhlbGxvIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2Ugc2V0dGluZ3MuUkVOREVSX09QVElPTlMuaGVsbG9cIik7XG59XG5mdW5jdGlvbiBzYXlIZWxsbygpIHtcbiAgZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBgc2F5SGVsbG8gaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBSZW5kZXJlcidzIFwiaGVsbG9cIiBvcHRpb25gKTtcbn1cblxuZXhwb3J0IHsgc2F5SGVsbG8sIHNraXBIZWxsbyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVsbG8ubWpzLm1hcFxuIiwiaW1wb3J0ICcuLi9zZXR0aW5ncy5tanMnO1xuaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tICdAcGl4aS9zZXR0aW5ncyc7XG5cbmxldCBzdXBwb3J0ZWQ7XG5mdW5jdGlvbiBpc1dlYkdMU3VwcG9ydGVkKCkge1xuICBpZiAodHlwZW9mIHN1cHBvcnRlZCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHN1cHBvcnRlZCA9IGZ1bmN0aW9uIHN1cHBvcnRlZDIoKSB7XG4gICAgICBjb25zdCBjb250ZXh0T3B0aW9ucyA9IHtcbiAgICAgICAgc3RlbmNpbDogdHJ1ZSxcbiAgICAgICAgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogc2V0dGluZ3MuRkFJTF9JRl9NQUpPUl9QRVJGT1JNQU5DRV9DQVZFQVRcbiAgICAgIH07XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXNldHRpbmdzLkFEQVBURVIuZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0KCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FudmFzID0gc2V0dGluZ3MuQURBUFRFUi5jcmVhdGVDYW52YXMoKTtcbiAgICAgICAgbGV0IGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiLCBjb250ZXh0T3B0aW9ucykgfHwgY2FudmFzLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIiwgY29udGV4dE9wdGlvbnMpO1xuICAgICAgICBjb25zdCBzdWNjZXNzID0gISFnbD8uZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKT8uc3RlbmNpbDtcbiAgICAgICAgaWYgKGdsKSB7XG4gICAgICAgICAgY29uc3QgbG9zZUNvbnRleHQgPSBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9sb3NlX2NvbnRleHRcIik7XG4gICAgICAgICAgaWYgKGxvc2VDb250ZXh0KSB7XG4gICAgICAgICAgICBsb3NlQ29udGV4dC5sb3NlQ29udGV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnbCA9IG51bGw7XG4gICAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSgpO1xuICB9XG4gIHJldHVybiBzdXBwb3J0ZWQ7XG59XG5cbmV4cG9ydCB7IGlzV2ViR0xTdXBwb3J0ZWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzV2ViR0xTdXBwb3J0ZWQubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICdAcGl4aS9jb2xvcic7XG5pbXBvcnQgeyBkZXByZWNhdGlvbiB9IGZyb20gJy4uL2xvZ2dpbmcvZGVwcmVjYXRpb24ubWpzJztcblxuZnVuY3Rpb24gaGV4MnJnYihoZXgsIG91dCA9IFtdKSB7XG4gIGRlcHJlY2F0aW9uKFwiNy4yLjBcIiwgXCJ1dGlscy5oZXgycmdiIGlzIGRlcHJlY2F0ZWQsIHVzZSBDb2xvciN0b1JnYkFycmF5IGluc3RlYWRcIik7XG4gIHJldHVybiBDb2xvci5zaGFyZWQuc2V0VmFsdWUoaGV4KS50b1JnYkFycmF5KG91dCk7XG59XG5mdW5jdGlvbiBoZXgyc3RyaW5nKGhleCkge1xuICBkZXByZWNhdGlvbihcIjcuMi4wXCIsIFwidXRpbHMuaGV4MnN0cmluZyBpcyBkZXByZWNhdGVkLCB1c2UgQ29sb3IjdG9IZXggaW5zdGVhZFwiKTtcbiAgcmV0dXJuIENvbG9yLnNoYXJlZC5zZXRWYWx1ZShoZXgpLnRvSGV4KCk7XG59XG5mdW5jdGlvbiBzdHJpbmcyaGV4KHN0cmluZykge1xuICBkZXByZWNhdGlvbihcIjcuMi4wXCIsIFwidXRpbHMuc3RyaW5nMmhleCBpcyBkZXByZWNhdGVkLCB1c2UgQ29sb3IjdG9OdW1iZXIgaW5zdGVhZFwiKTtcbiAgcmV0dXJuIENvbG9yLnNoYXJlZC5zZXRWYWx1ZShzdHJpbmcpLnRvTnVtYmVyKCk7XG59XG5mdW5jdGlvbiByZ2IyaGV4KHJnYikge1xuICBkZXByZWNhdGlvbihcIjcuMi4wXCIsIFwidXRpbHMucmdiMmhleCBpcyBkZXByZWNhdGVkLCB1c2UgQ29sb3IjdG9OdW1iZXIgaW5zdGVhZFwiKTtcbiAgcmV0dXJuIENvbG9yLnNoYXJlZC5zZXRWYWx1ZShyZ2IpLnRvTnVtYmVyKCk7XG59XG5cbmV4cG9ydCB7IGhleDJyZ2IsIGhleDJzdHJpbmcsIHJnYjJoZXgsIHN0cmluZzJoZXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhleC5tanMubWFwXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJ0BwaXhpL2NvbG9yJztcbmltcG9ydCB7IEJMRU5EX01PREVTIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcbmltcG9ydCB7IGRlcHJlY2F0aW9uIH0gZnJvbSAnLi4vbG9nZ2luZy9kZXByZWNhdGlvbi5tanMnO1xuXG5mdW5jdGlvbiBtYXBQcmVtdWx0aXBsaWVkQmxlbmRNb2RlcygpIHtcbiAgY29uc3QgcG0gPSBbXTtcbiAgY29uc3QgbnBtID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIHBtW2ldID0gaTtcbiAgICBucG1baV0gPSBpO1xuICB9XG4gIHBtW0JMRU5EX01PREVTLk5PUk1BTF9OUE1dID0gQkxFTkRfTU9ERVMuTk9STUFMO1xuICBwbVtCTEVORF9NT0RFUy5BRERfTlBNXSA9IEJMRU5EX01PREVTLkFERDtcbiAgcG1bQkxFTkRfTU9ERVMuU0NSRUVOX05QTV0gPSBCTEVORF9NT0RFUy5TQ1JFRU47XG4gIG5wbVtCTEVORF9NT0RFUy5OT1JNQUxdID0gQkxFTkRfTU9ERVMuTk9STUFMX05QTTtcbiAgbnBtW0JMRU5EX01PREVTLkFERF0gPSBCTEVORF9NT0RFUy5BRERfTlBNO1xuICBucG1bQkxFTkRfTU9ERVMuU0NSRUVOXSA9IEJMRU5EX01PREVTLlNDUkVFTl9OUE07XG4gIGNvbnN0IGFycmF5ID0gW107XG4gIGFycmF5LnB1c2gobnBtKTtcbiAgYXJyYXkucHVzaChwbSk7XG4gIHJldHVybiBhcnJheTtcbn1cbmNvbnN0IHByZW11bHRpcGx5QmxlbmRNb2RlID0gbWFwUHJlbXVsdGlwbGllZEJsZW5kTW9kZXMoKTtcbmZ1bmN0aW9uIGNvcnJlY3RCbGVuZE1vZGUoYmxlbmRNb2RlLCBwcmVtdWx0aXBsaWVkKSB7XG4gIHJldHVybiBwcmVtdWx0aXBseUJsZW5kTW9kZVtwcmVtdWx0aXBsaWVkID8gMSA6IDBdW2JsZW5kTW9kZV07XG59XG5mdW5jdGlvbiBwcmVtdWx0aXBseVJnYmEocmdiLCBhbHBoYSwgb3V0LCBwcmVtdWx0aXBseSA9IHRydWUpIHtcbiAgZGVwcmVjYXRpb24oXCI3LjIuMFwiLCBgdXRpbHMucHJlbXVsdGlwbHlSZ2JhIGhhcyBtb3ZlZCB0byBDb2xvci5wcmVtdWx0aXBseWApO1xuICByZXR1cm4gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHJnYikucHJlbXVsdGlwbHkoYWxwaGEsIHByZW11bHRpcGx5KS50b0FycmF5KG91dCA/PyBuZXcgRmxvYXQzMkFycmF5KDQpKTtcbn1cbmZ1bmN0aW9uIHByZW11bHRpcGx5VGludCh0aW50LCBhbHBoYSkge1xuICBkZXByZWNhdGlvbihcIjcuMi4wXCIsIGB1dGlscy5wcmVtdWx0aXBseVRpbnQgaGFzIG1vdmVkIHRvIENvbG9yLnRvUHJlbXVsdGlwbGllZGApO1xuICByZXR1cm4gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHRpbnQpLnRvUHJlbXVsdGlwbGllZChhbHBoYSk7XG59XG5mdW5jdGlvbiBwcmVtdWx0aXBseVRpbnRUb1JnYmEodGludCwgYWxwaGEsIG91dCwgcHJlbXVsdGlwbHkgPSB0cnVlKSB7XG4gIGRlcHJlY2F0aW9uKFwiNy4yLjBcIiwgYHV0aWxzLnByZW11bHRpcGx5VGludFRvUmdiYSBoYXMgbW92ZWQgdG8gQ29sb3IucHJlbXVsdGlwbHlgKTtcbiAgcmV0dXJuIENvbG9yLnNoYXJlZC5zZXRWYWx1ZSh0aW50KS5wcmVtdWx0aXBseShhbHBoYSwgcHJlbXVsdGlwbHkpLnRvQXJyYXkob3V0ID8/IG5ldyBGbG9hdDMyQXJyYXkoNCkpO1xufVxuXG5leHBvcnQgeyBjb3JyZWN0QmxlbmRNb2RlLCBwcmVtdWx0aXBseUJsZW5kTW9kZSwgcHJlbXVsdGlwbHlSZ2JhLCBwcmVtdWx0aXBseVRpbnQsIHByZW11bHRpcGx5VGludFRvUmdiYSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlbXVsdGlwbHkubWpzLm1hcFxuIiwiY29uc3QgREFUQV9VUkkgPSAvXlxccypkYXRhOig/OihbXFx3LV0rKVxcLyhbXFx3Ky4tXSspKT8oPzo7Y2hhcnNldD0oW1xcdy1dKykpPyg/OjsoYmFzZTY0KSk/LCguKikvaTtcblxuZXhwb3J0IHsgREFUQV9VUkkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0Lm1qcy5tYXBcbiIsImZ1bmN0aW9uIGNyZWF0ZUluZGljZXNGb3JRdWFkcyhzaXplLCBvdXRCdWZmZXIgPSBudWxsKSB7XG4gIGNvbnN0IHRvdGFsSW5kaWNlcyA9IHNpemUgKiA2O1xuICBvdXRCdWZmZXIgPSBvdXRCdWZmZXIgfHwgbmV3IFVpbnQxNkFycmF5KHRvdGFsSW5kaWNlcyk7XG4gIGlmIChvdXRCdWZmZXIubGVuZ3RoICE9PSB0b3RhbEluZGljZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE91dCBidWZmZXIgbGVuZ3RoIGlzIGluY29ycmVjdCwgZ290ICR7b3V0QnVmZmVyLmxlbmd0aH0gYW5kIGV4cGVjdGVkICR7dG90YWxJbmRpY2VzfWApO1xuICB9XG4gIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHRvdGFsSW5kaWNlczsgaSArPSA2LCBqICs9IDQpIHtcbiAgICBvdXRCdWZmZXJbaSArIDBdID0gaiArIDA7XG4gICAgb3V0QnVmZmVyW2kgKyAxXSA9IGogKyAxO1xuICAgIG91dEJ1ZmZlcltpICsgMl0gPSBqICsgMjtcbiAgICBvdXRCdWZmZXJbaSArIDNdID0gaiArIDA7XG4gICAgb3V0QnVmZmVyW2kgKyA0XSA9IGogKyAyO1xuICAgIG91dEJ1ZmZlcltpICsgNV0gPSBqICsgMztcbiAgfVxuICByZXR1cm4gb3V0QnVmZmVyO1xufVxuXG5leHBvcnQgeyBjcmVhdGVJbmRpY2VzRm9yUXVhZHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZUluZGljZXNGb3JRdWFkcy5tanMubWFwXG4iLCJmdW5jdGlvbiBnZXRCdWZmZXJUeXBlKGFycmF5KSB7XG4gIGlmIChhcnJheS5CWVRFU19QRVJfRUxFTUVOVCA9PT0gNCkge1xuICAgIGlmIChhcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xuICAgICAgcmV0dXJuIFwiRmxvYXQzMkFycmF5XCI7XG4gICAgfSBlbHNlIGlmIChhcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSB7XG4gICAgICByZXR1cm4gXCJVaW50MzJBcnJheVwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJJbnQzMkFycmF5XCI7XG4gIH0gZWxzZSBpZiAoYXJyYXkuQllURVNfUEVSX0VMRU1FTlQgPT09IDIpIHtcbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkge1xuICAgICAgcmV0dXJuIFwiVWludDE2QXJyYXlcIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJyYXkuQllURVNfUEVSX0VMRU1FTlQgPT09IDEpIHtcbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICByZXR1cm4gXCJVaW50OEFycmF5XCI7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgeyBnZXRCdWZmZXJUeXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRCdWZmZXJUeXBlLm1qcy5tYXBcbiIsImltcG9ydCB7IGdldEJ1ZmZlclR5cGUgfSBmcm9tICcuL2dldEJ1ZmZlclR5cGUubWpzJztcblxuY29uc3QgbWFwID0geyBGbG9hdDMyQXJyYXksIFVpbnQzMkFycmF5LCBJbnQzMkFycmF5LCBVaW50OEFycmF5IH07XG5mdW5jdGlvbiBpbnRlcmxlYXZlVHlwZWRBcnJheXMoYXJyYXlzLCBzaXplcykge1xuICBsZXQgb3V0U2l6ZSA9IDA7XG4gIGxldCBzdHJpZGUgPSAwO1xuICBjb25zdCB2aWV3cyA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgIHN0cmlkZSArPSBzaXplc1tpXTtcbiAgICBvdXRTaXplICs9IGFycmF5c1tpXS5sZW5ndGg7XG4gIH1cbiAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKG91dFNpemUgKiA0KTtcbiAgbGV0IG91dCA9IG51bGw7XG4gIGxldCBsaXR0bGVPZmZzZXQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNpemUgPSBzaXplc1tpXTtcbiAgICBjb25zdCBhcnJheSA9IGFycmF5c1tpXTtcbiAgICBjb25zdCB0eXBlID0gZ2V0QnVmZmVyVHlwZShhcnJheSk7XG4gICAgaWYgKCF2aWV3c1t0eXBlXSkge1xuICAgICAgdmlld3NbdHlwZV0gPSBuZXcgbWFwW3R5cGVdKGJ1ZmZlcik7XG4gICAgfVxuICAgIG91dCA9IHZpZXdzW3R5cGVdO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgYXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IGluZGV4U3RhcnQgPSAoaiAvIHNpemUgfCAwKSAqIHN0cmlkZSArIGxpdHRsZU9mZnNldDtcbiAgICAgIGNvbnN0IGluZGV4ID0gaiAlIHNpemU7XG4gICAgICBvdXRbaW5kZXhTdGFydCArIGluZGV4XSA9IGFycmF5W2pdO1xuICAgIH1cbiAgICBsaXR0bGVPZmZzZXQgKz0gc2l6ZTtcbiAgfVxuICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xufVxuXG5leHBvcnQgeyBpbnRlcmxlYXZlVHlwZWRBcnJheXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVybGVhdmVUeXBlZEFycmF5cy5tanMubWFwXG4iLCJmdW5jdGlvbiBuZXh0UG93Mih2KSB7XG4gIHYgKz0gdiA9PT0gMCA/IDEgOiAwO1xuICAtLXY7XG4gIHYgfD0gdiA+Pj4gMTtcbiAgdiB8PSB2ID4+PiAyO1xuICB2IHw9IHYgPj4+IDQ7XG4gIHYgfD0gdiA+Pj4gODtcbiAgdiB8PSB2ID4+PiAxNjtcbiAgcmV0dXJuIHYgKyAxO1xufVxuZnVuY3Rpb24gaXNQb3cyKHYpIHtcbiAgcmV0dXJuICEodiAmIHYgLSAxKSAmJiAhIXY7XG59XG5mdW5jdGlvbiBsb2cyKHYpIHtcbiAgbGV0IHIgPSAodiA+IDY1NTM1ID8gMSA6IDApIDw8IDQ7XG4gIHYgPj4+PSByO1xuICBsZXQgc2hpZnQgPSAodiA+IDI1NSA/IDEgOiAwKSA8PCAzO1xuICB2ID4+Pj0gc2hpZnQ7XG4gIHIgfD0gc2hpZnQ7XG4gIHNoaWZ0ID0gKHYgPiAxNSA/IDEgOiAwKSA8PCAyO1xuICB2ID4+Pj0gc2hpZnQ7XG4gIHIgfD0gc2hpZnQ7XG4gIHNoaWZ0ID0gKHYgPiAzID8gMSA6IDApIDw8IDE7XG4gIHYgPj4+PSBzaGlmdDtcbiAgciB8PSBzaGlmdDtcbiAgcmV0dXJuIHIgfCB2ID4+IDE7XG59XG5cbmV4cG9ydCB7IGlzUG93MiwgbG9nMiwgbmV4dFBvdzIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvdzIubWpzLm1hcFxuIiwiZnVuY3Rpb24gcmVtb3ZlSXRlbXMoYXJyLCBzdGFydElkeCwgcmVtb3ZlQ291bnQpIHtcbiAgY29uc3QgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgbGV0IGk7XG4gIGlmIChzdGFydElkeCA+PSBsZW5ndGggfHwgcmVtb3ZlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVtb3ZlQ291bnQgPSBzdGFydElkeCArIHJlbW92ZUNvdW50ID4gbGVuZ3RoID8gbGVuZ3RoIC0gc3RhcnRJZHggOiByZW1vdmVDb3VudDtcbiAgY29uc3QgbGVuID0gbGVuZ3RoIC0gcmVtb3ZlQ291bnQ7XG4gIGZvciAoaSA9IHN0YXJ0SWR4OyBpIDwgbGVuOyArK2kpIHtcbiAgICBhcnJbaV0gPSBhcnJbaSArIHJlbW92ZUNvdW50XTtcbiAgfVxuICBhcnIubGVuZ3RoID0gbGVuO1xufVxuXG5leHBvcnQgeyByZW1vdmVJdGVtcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3ZlSXRlbXMubWpzLm1hcFxuIiwiZnVuY3Rpb24gc2lnbihuKSB7XG4gIGlmIChuID09PSAwKVxuICAgIHJldHVybiAwO1xuICByZXR1cm4gbiA8IDAgPyAtMSA6IDE7XG59XG5cbmV4cG9ydCB7IHNpZ24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ24ubWpzLm1hcFxuIiwibGV0IG5leHRVaWQgPSAwO1xuZnVuY3Rpb24gdWlkKCkge1xuICByZXR1cm4gKytuZXh0VWlkO1xufVxuXG5leHBvcnQgeyB1aWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVpZC5tanMubWFwXG4iLCJjb25zdCBfQm91bmRpbmdCb3ggPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSkge1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgdGhpcy50b3AgPSB0b3A7XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIHRoaXMuYm90dG9tID0gYm90dG9tO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5yaWdodCAtIHRoaXMubGVmdDtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmJvdHRvbSAtIHRoaXMudG9wO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVmdCA9PT0gdGhpcy5yaWdodCB8fCB0aGlzLnRvcCA9PT0gdGhpcy5ib3R0b207XG4gIH1cbn07XG5sZXQgQm91bmRpbmdCb3ggPSBfQm91bmRpbmdCb3g7XG5Cb3VuZGluZ0JveC5FTVBUWSA9IG5ldyBfQm91bmRpbmdCb3goMCwgMCwgMCwgMCk7XG5cbmV4cG9ydCB7IEJvdW5kaW5nQm94IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Cb3VuZGluZ0JveC5tanMubWFwXG4iLCJjb25zdCBQcm9ncmFtQ2FjaGUgPSB7fTtcbmNvbnN0IFRleHR1cmVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3QgQmFzZVRleHR1cmVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gZGVzdHJveVRleHR1cmVDYWNoZSgpIHtcbiAgbGV0IGtleTtcbiAgZm9yIChrZXkgaW4gVGV4dHVyZUNhY2hlKSB7XG4gICAgVGV4dHVyZUNhY2hlW2tleV0uZGVzdHJveSgpO1xuICB9XG4gIGZvciAoa2V5IGluIEJhc2VUZXh0dXJlQ2FjaGUpIHtcbiAgICBCYXNlVGV4dHVyZUNhY2hlW2tleV0uZGVzdHJveSgpO1xuICB9XG59XG5mdW5jdGlvbiBjbGVhclRleHR1cmVDYWNoZSgpIHtcbiAgbGV0IGtleTtcbiAgZm9yIChrZXkgaW4gVGV4dHVyZUNhY2hlKSB7XG4gICAgZGVsZXRlIFRleHR1cmVDYWNoZVtrZXldO1xuICB9XG4gIGZvciAoa2V5IGluIEJhc2VUZXh0dXJlQ2FjaGUpIHtcbiAgICBkZWxldGUgQmFzZVRleHR1cmVDYWNoZVtrZXldO1xuICB9XG59XG5cbmV4cG9ydCB7IEJhc2VUZXh0dXJlQ2FjaGUsIFByb2dyYW1DYWNoZSwgVGV4dHVyZUNhY2hlLCBjbGVhclRleHR1cmVDYWNoZSwgZGVzdHJveVRleHR1cmVDYWNoZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FjaGVzLm1qcy5tYXBcbiIsImltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSAnQHBpeGkvc2V0dGluZ3MnO1xuXG5jbGFzcyBDYW52YXNSZW5kZXJUYXJnZXQge1xuICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uKSB7XG4gICAgdGhpcy5fY2FudmFzID0gc2V0dGluZ3MuQURBUFRFUi5jcmVhdGVDYW52YXMoKTtcbiAgICB0aGlzLl9jb250ZXh0ID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uIHx8IHNldHRpbmdzLlJFU09MVVRJT047XG4gICAgdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fY2hlY2tEZXN0cm95ZWQoKTtcbiAgICB0aGlzLl9jb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICB0aGlzLl9jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQpO1xuICB9XG4gIHJlc2l6ZShkZXNpcmVkV2lkdGgsIGRlc2lyZWRIZWlnaHQpIHtcbiAgICB0aGlzLl9jaGVja0Rlc3Ryb3llZCgpO1xuICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IE1hdGgucm91bmQoZGVzaXJlZFdpZHRoICogdGhpcy5yZXNvbHV0aW9uKTtcbiAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gTWF0aC5yb3VuZChkZXNpcmVkSGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuX2NhbnZhcyA9IG51bGw7XG4gIH1cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHRoaXMuX2NoZWNrRGVzdHJveWVkKCk7XG4gICAgcmV0dXJuIHRoaXMuX2NhbnZhcy53aWR0aDtcbiAgfVxuICBzZXQgd2lkdGgodmFsKSB7XG4gICAgdGhpcy5fY2hlY2tEZXN0cm95ZWQoKTtcbiAgICB0aGlzLl9jYW52YXMud2lkdGggPSBNYXRoLnJvdW5kKHZhbCk7XG4gIH1cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICB0aGlzLl9jaGVja0Rlc3Ryb3llZCgpO1xuICAgIHJldHVybiB0aGlzLl9jYW52YXMuaGVpZ2h0O1xuICB9XG4gIHNldCBoZWlnaHQodmFsKSB7XG4gICAgdGhpcy5fY2hlY2tEZXN0cm95ZWQoKTtcbiAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gTWF0aC5yb3VuZCh2YWwpO1xuICB9XG4gIGdldCBjYW52YXMoKSB7XG4gICAgdGhpcy5fY2hlY2tEZXN0cm95ZWQoKTtcbiAgICByZXR1cm4gdGhpcy5fY2FudmFzO1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHRoaXMuX2NoZWNrRGVzdHJveWVkKCk7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHQ7XG4gIH1cbiAgX2NoZWNrRGVzdHJveWVkKCkge1xuICAgIGlmICh0aGlzLl9jYW52YXMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgQ2FudmFzUmVuZGVyVGFyZ2V0IGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkXCIpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBDYW52YXNSZW5kZXJUYXJnZXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbnZhc1JlbmRlclRhcmdldC5tanMubWFwXG4iLCJpbXBvcnQgeyBCb3VuZGluZ0JveCB9IGZyb20gJy4vQm91bmRpbmdCb3gubWpzJztcblxuZnVuY3Rpb24gY2hlY2tSb3coZGF0YSwgd2lkdGgsIHkpIHtcbiAgZm9yIChsZXQgeCA9IDAsIGluZGV4ID0gNCAqIHkgKiB3aWR0aDsgeCA8IHdpZHRoOyArK3gsIGluZGV4ICs9IDQpIHtcbiAgICBpZiAoZGF0YVtpbmRleCArIDNdICE9PSAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY2hlY2tDb2x1bW4oZGF0YSwgd2lkdGgsIHgsIHRvcCwgYm90dG9tKSB7XG4gIGNvbnN0IHN0cmlkZSA9IDQgKiB3aWR0aDtcbiAgZm9yIChsZXQgeSA9IHRvcCwgaW5kZXggPSB0b3AgKiBzdHJpZGUgKyA0ICogeDsgeSA8PSBib3R0b207ICsreSwgaW5kZXggKz0gc3RyaWRlKSB7XG4gICAgaWYgKGRhdGFbaW5kZXggKyAzXSAhPT0gMClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldENhbnZhc0JvdW5kaW5nQm94KGNhbnZhcykge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGNhbnZhcztcbiAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICB9KTtcbiAgaWYgKGNvbnRleHQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGdldCBjYW52YXMgMkQgY29udGV4dFwiKTtcbiAgfVxuICBjb25zdCBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgY29uc3QgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuICBsZXQgbGVmdCA9IDA7XG4gIGxldCB0b3AgPSAwO1xuICBsZXQgcmlnaHQgPSB3aWR0aCAtIDE7XG4gIGxldCBib3R0b20gPSBoZWlnaHQgLSAxO1xuICB3aGlsZSAodG9wIDwgaGVpZ2h0ICYmIGNoZWNrUm93KGRhdGEsIHdpZHRoLCB0b3ApKVxuICAgICsrdG9wO1xuICBpZiAodG9wID09PSBoZWlnaHQpXG4gICAgcmV0dXJuIEJvdW5kaW5nQm94LkVNUFRZO1xuICB3aGlsZSAoY2hlY2tSb3coZGF0YSwgd2lkdGgsIGJvdHRvbSkpXG4gICAgLS1ib3R0b207XG4gIHdoaWxlIChjaGVja0NvbHVtbihkYXRhLCB3aWR0aCwgbGVmdCwgdG9wLCBib3R0b20pKVxuICAgICsrbGVmdDtcbiAgd2hpbGUgKGNoZWNrQ29sdW1uKGRhdGEsIHdpZHRoLCByaWdodCwgdG9wLCBib3R0b20pKVxuICAgIC0tcmlnaHQ7XG4gICsrcmlnaHQ7XG4gICsrYm90dG9tO1xuICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSk7XG59XG5cbmV4cG9ydCB7IGdldENhbnZhc0JvdW5kaW5nQm94IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRDYW52YXNCb3VuZGluZ0JveC5tanMubWFwXG4iLCJpbXBvcnQgeyBnZXRDYW52YXNCb3VuZGluZ0JveCB9IGZyb20gJy4vZ2V0Q2FudmFzQm91bmRpbmdCb3gubWpzJztcblxuZnVuY3Rpb24gdHJpbUNhbnZhcyhjYW52YXMpIHtcbiAgY29uc3QgYm91bmRpbmdCb3ggPSBnZXRDYW52YXNCb3VuZGluZ0JveChjYW52YXMpO1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGJvdW5kaW5nQm94O1xuICBsZXQgZGF0YSA9IG51bGw7XG4gIGlmICghYm91bmRpbmdCb3guaXNFbXB0eSgpKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgaWYgKGNvbnRleHQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gZ2V0IGNhbnZhcyAyRCBjb250ZXh0XCIpO1xuICAgIH1cbiAgICBkYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoYm91bmRpbmdCb3gubGVmdCwgYm91bmRpbmdCb3gudG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0LCBkYXRhIH07XG59XG5cbmV4cG9ydCB7IHRyaW1DYW52YXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyaW1DYW52YXMubWpzLm1hcFxuIiwiaW1wb3J0IHsgREFUQV9VUkkgfSBmcm9tICcuLi9jb25zdC5tanMnO1xuXG5mdW5jdGlvbiBkZWNvbXBvc2VEYXRhVXJpKGRhdGFVcmkpIHtcbiAgY29uc3QgZGF0YVVyaU1hdGNoID0gREFUQV9VUkkuZXhlYyhkYXRhVXJpKTtcbiAgaWYgKGRhdGFVcmlNYXRjaCkge1xuICAgIHJldHVybiB7XG4gICAgICBtZWRpYVR5cGU6IGRhdGFVcmlNYXRjaFsxXSA/IGRhdGFVcmlNYXRjaFsxXS50b0xvd2VyQ2FzZSgpIDogdm9pZCAwLFxuICAgICAgc3ViVHlwZTogZGF0YVVyaU1hdGNoWzJdID8gZGF0YVVyaU1hdGNoWzJdLnRvTG93ZXJDYXNlKCkgOiB2b2lkIDAsXG4gICAgICBjaGFyc2V0OiBkYXRhVXJpTWF0Y2hbM10gPyBkYXRhVXJpTWF0Y2hbM10udG9Mb3dlckNhc2UoKSA6IHZvaWQgMCxcbiAgICAgIGVuY29kaW5nOiBkYXRhVXJpTWF0Y2hbNF0gPyBkYXRhVXJpTWF0Y2hbNF0udG9Mb3dlckNhc2UoKSA6IHZvaWQgMCxcbiAgICAgIGRhdGE6IGRhdGFVcmlNYXRjaFs1XVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cblxuZXhwb3J0IHsgZGVjb21wb3NlRGF0YVVyaSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjb21wb3NlRGF0YVVyaS5tanMubWFwXG4iLCJpbXBvcnQgeyB1cmwgfSBmcm9tICcuLi91cmwubWpzJztcblxubGV0IHRlbXBBbmNob3I7XG5mdW5jdGlvbiBkZXRlcm1pbmVDcm9zc09yaWdpbih1cmwkMSwgbG9jID0gZ2xvYmFsVGhpcy5sb2NhdGlvbikge1xuICBpZiAodXJsJDEuc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgbG9jID0gbG9jIHx8IGdsb2JhbFRoaXMubG9jYXRpb247XG4gIGlmICghdGVtcEFuY2hvcikge1xuICAgIHRlbXBBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgfVxuICB0ZW1wQW5jaG9yLmhyZWYgPSB1cmwkMTtcbiAgY29uc3QgcGFyc2VkVXJsID0gdXJsLnBhcnNlKHRlbXBBbmNob3IuaHJlZik7XG4gIGNvbnN0IHNhbWVQb3J0ID0gIXBhcnNlZFVybC5wb3J0ICYmIGxvYy5wb3J0ID09PSBcIlwiIHx8IHBhcnNlZFVybC5wb3J0ID09PSBsb2MucG9ydDtcbiAgaWYgKHBhcnNlZFVybC5ob3N0bmFtZSAhPT0gbG9jLmhvc3RuYW1lIHx8ICFzYW1lUG9ydCB8fCBwYXJzZWRVcmwucHJvdG9jb2wgIT09IGxvYy5wcm90b2NvbCkge1xuICAgIHJldHVybiBcImFub255bW91c1wiO1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxuXG5leHBvcnQgeyBkZXRlcm1pbmVDcm9zc09yaWdpbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4ubWpzLm1hcFxuIiwiaW1wb3J0ICcuLi9zZXR0aW5ncy5tanMnO1xuaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tICdAcGl4aS9zZXR0aW5ncyc7XG5cbmZ1bmN0aW9uIGdldFJlc29sdXRpb25PZlVybCh1cmwsIGRlZmF1bHRWYWx1ZSA9IDEpIHtcbiAgY29uc3QgcmVzb2x1dGlvbiA9IHNldHRpbmdzLlJFVElOQV9QUkVGSVg/LmV4ZWModXJsKTtcbiAgaWYgKHJlc29sdXRpb24pIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChyZXNvbHV0aW9uWzFdKTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFZhbHVlO1xufVxuXG5leHBvcnQgeyBnZXRSZXNvbHV0aW9uT2ZVcmwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFJlc29sdXRpb25PZlVybC5tanMubWFwXG4iLCJpbXBvcnQgJy4vc2V0dGluZ3MubWpzJztcbmV4cG9ydCB7IGlzTW9iaWxlIH0gZnJvbSAnQHBpeGkvc2V0dGluZ3MnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudGVtaXR0ZXIzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZWFyY3V0IH0gZnJvbSAnZWFyY3V0JztcbmV4cG9ydCB7IHVybCB9IGZyb20gJy4vdXJsLm1qcyc7XG5leHBvcnQgeyBwYXRoIH0gZnJvbSAnLi9wYXRoLm1qcyc7XG5leHBvcnQgeyBzYXlIZWxsbywgc2tpcEhlbGxvIH0gZnJvbSAnLi9icm93c2VyL2hlbGxvLm1qcyc7XG5leHBvcnQgeyBpc1dlYkdMU3VwcG9ydGVkIH0gZnJvbSAnLi9icm93c2VyL2lzV2ViR0xTdXBwb3J0ZWQubWpzJztcbmV4cG9ydCB7IGhleDJyZ2IsIGhleDJzdHJpbmcsIHJnYjJoZXgsIHN0cmluZzJoZXggfSBmcm9tICcuL2NvbG9yL2hleC5tanMnO1xuZXhwb3J0IHsgY29ycmVjdEJsZW5kTW9kZSwgcHJlbXVsdGlwbHlCbGVuZE1vZGUsIHByZW11bHRpcGx5UmdiYSwgcHJlbXVsdGlwbHlUaW50LCBwcmVtdWx0aXBseVRpbnRUb1JnYmEgfSBmcm9tICcuL2NvbG9yL3ByZW11bHRpcGx5Lm1qcyc7XG5leHBvcnQgeyBEQVRBX1VSSSB9IGZyb20gJy4vY29uc3QubWpzJztcbmV4cG9ydCB7IGNyZWF0ZUluZGljZXNGb3JRdWFkcyB9IGZyb20gJy4vZGF0YS9jcmVhdGVJbmRpY2VzRm9yUXVhZHMubWpzJztcbmV4cG9ydCB7IGdldEJ1ZmZlclR5cGUgfSBmcm9tICcuL2RhdGEvZ2V0QnVmZmVyVHlwZS5tanMnO1xuZXhwb3J0IHsgaW50ZXJsZWF2ZVR5cGVkQXJyYXlzIH0gZnJvbSAnLi9kYXRhL2ludGVybGVhdmVUeXBlZEFycmF5cy5tanMnO1xuZXhwb3J0IHsgaXNQb3cyLCBsb2cyLCBuZXh0UG93MiB9IGZyb20gJy4vZGF0YS9wb3cyLm1qcyc7XG5leHBvcnQgeyByZW1vdmVJdGVtcyB9IGZyb20gJy4vZGF0YS9yZW1vdmVJdGVtcy5tanMnO1xuZXhwb3J0IHsgc2lnbiB9IGZyb20gJy4vZGF0YS9zaWduLm1qcyc7XG5leHBvcnQgeyB1aWQgfSBmcm9tICcuL2RhdGEvdWlkLm1qcyc7XG5leHBvcnQgeyBkZXByZWNhdGlvbiB9IGZyb20gJy4vbG9nZ2luZy9kZXByZWNhdGlvbi5tanMnO1xuZXhwb3J0IHsgQm91bmRpbmdCb3ggfSBmcm9tICcuL21lZGlhL0JvdW5kaW5nQm94Lm1qcyc7XG5leHBvcnQgeyBCYXNlVGV4dHVyZUNhY2hlLCBQcm9ncmFtQ2FjaGUsIFRleHR1cmVDYWNoZSwgY2xlYXJUZXh0dXJlQ2FjaGUsIGRlc3Ryb3lUZXh0dXJlQ2FjaGUgfSBmcm9tICcuL21lZGlhL2NhY2hlcy5tanMnO1xuZXhwb3J0IHsgQ2FudmFzUmVuZGVyVGFyZ2V0IH0gZnJvbSAnLi9tZWRpYS9DYW52YXNSZW5kZXJUYXJnZXQubWpzJztcbmV4cG9ydCB7IGdldENhbnZhc0JvdW5kaW5nQm94IH0gZnJvbSAnLi9tZWRpYS9nZXRDYW52YXNCb3VuZGluZ0JveC5tanMnO1xuZXhwb3J0IHsgdHJpbUNhbnZhcyB9IGZyb20gJy4vbWVkaWEvdHJpbUNhbnZhcy5tanMnO1xuZXhwb3J0IHsgZGVjb21wb3NlRGF0YVVyaSB9IGZyb20gJy4vbmV0d29yay9kZWNvbXBvc2VEYXRhVXJpLm1qcyc7XG5leHBvcnQgeyBkZXRlcm1pbmVDcm9zc09yaWdpbiB9IGZyb20gJy4vbmV0d29yay9kZXRlcm1pbmVDcm9zc09yaWdpbi5tanMnO1xuZXhwb3J0IHsgZ2V0UmVzb2x1dGlvbk9mVXJsIH0gZnJvbSAnLi9uZXR3b3JrL2dldFJlc29sdXRpb25PZlVybC5tanMnO1xuaW1wb3J0ICcuL3R5cGVzL2luZGV4Lm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///441\n')},998:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  MxU: () => (/* reexport */ Application),\n  W20: () => (/* reexport */ Container_Container),\n  TCu: () => (/* reexport */ Graphics),\n  xvT: () => (/* reexport */ Text)\n});\n\n// UNUSED EXPORTS: ALPHA_MODES, AbstractMultiResource, AccessibilityManager, AlphaFilter, AnimatedSprite, ArrayResource, Assets, AssetsClass, Attribute, BLEND_MODES, BUFFER_BITS, BUFFER_TYPE, BackgroundSystem, BaseImageResource, BasePrepare, BaseRenderTexture, BaseTexture, BatchDrawCall, BatchGeometry, BatchRenderer, BatchShaderGenerator, BatchSystem, BatchTextureArray, BitmapFont, BitmapFontData, BitmapText, BlobResource, BlurFilter, BlurFilterPass, Bounds, BrowserAdapter, Buffer, BufferResource, BufferSystem, CLEAR_MODES, COLOR_MASK_BITS, Cache, CanvasResource, Circle, Color, ColorMatrixFilter, CompressedTextureResource, ContextSystem, CountLimiter, CubeResource, DEG_TO_RAD, DRAW_MODES, DisplacementFilter, DisplayObject, ENV, Ellipse, EventBoundary, EventSystem, ExtensionType, Extract, FORMATS, FORMATS_TO_COMPONENTS, FXAAFilter, FederatedDisplayObject, FederatedEvent, FederatedMouseEvent, FederatedPointerEvent, FederatedWheelEvent, FillStyle, Filter, FilterState, FilterSystem, Framebuffer, FramebufferSystem, GC_MODES, GLFramebuffer, GLProgram, GLTexture, GRAPHICS_CURVES, GenerateTextureSystem, Geometry, GeometrySystem, GraphicsData, GraphicsGeometry, HTMLText, HTMLTextStyle, IGLUniformData, INSTALLED, INTERNAL_FORMATS, INTERNAL_FORMAT_TO_BYTES_PER_PIXEL, ImageBitmapResource, ImageResource, LINE_CAP, LINE_JOIN, LineStyle, LoaderParserPriority, MASK_TYPES, MIPMAP_MODES, MSAA_QUALITY, MaskData, MaskSystem, Matrix, Mesh, MeshBatchUvs, MeshGeometry, MeshMaterial, MultisampleSystem, NineSlicePlane, NoiseFilter, ObjectRenderer, ObjectRendererSystem, ObservablePoint, PI_2, PRECISION, ParticleContainer, ParticleRenderer, PlaneGeometry, PluginSystem, Point, Polygon, Prepare, Program, ProjectionSystem, Quad, QuadUv, RAD_TO_DEG, RENDERER_TYPE, Rectangle, RenderTexture, RenderTexturePool, RenderTextureSystem, Renderer, ResizePlugin, Resource, RopeGeometry, RoundedRectangle, Runner, SAMPLER_TYPES, SCALE_MODES, SHAPES, SVGResource, ScissorSystem, Shader, ShaderSystem, SimpleMesh, SimplePlane, SimpleRope, Sprite, SpriteMaskFilter, Spritesheet, StartupSystem, State, StateSystem, StencilSystem, SystemManager, TARGETS, TEXT_GRADIENT, TYPES, TYPES_TO_BYTES_PER_COMPONENT, TYPES_TO_BYTES_PER_PIXEL, TemporaryDisplayObject, TextFormat, TextMetrics, TextStyle, Texture, TextureGCSystem, TextureMatrix, TextureSystem, TextureUvs, Ticker, TickerPlugin, TilingSprite, TilingSpriteRenderer, TimeLimiter, Transform, TransformFeedback, TransformFeedbackSystem, UPDATE_PRIORITY, UniformGroup, VERSION, VideoResource, ViewSystem, ViewableBuffer, WRAP_MODES, XMLFormat, XMLStringFormat, accessibleTarget, autoDetectFormat, autoDetectRenderer, autoDetectResource, cacheTextureArray, checkDataUrl, checkExtension, checkMaxIfStatementsInShader, convertToList, copySearchParams, createStringVariations, createTexture, createUBOElements, curves, defaultFilterVertex, defaultVertex, detectAvif, detectCompressedTextures, detectDefaults, detectWebp, extensions, filters, generateProgram, generateUniformBufferSync, getFontFamilyName, getTestContext, getUBOData, graphicsUtils, groupD8, isMobile, isSingleItem, loadBitmapFont, loadDDS, loadImageBitmap, loadJson, loadKTX, loadSVG, loadTextures, loadTxt, loadWebFont, parseDDS, parseKTX, resolveCompressedTextureUrl, resolveTextureUrl, settings, spritesheetAsset, uniformParsers, unsafeEvalSupported, utils\n\n// EXTERNAL MODULE: ./node_modules/@pixi/constants/lib/index.mjs\nvar lib = __webpack_require__(361);\n// EXTERNAL MODULE: ./node_modules/@pixi/settings/lib/index.mjs + 4 modules\nvar settings_lib = __webpack_require__(116);\n// EXTERNAL MODULE: ./node_modules/@pixi/utils/lib/index.mjs + 24 modules\nvar utils_lib = __webpack_require__(441);\n// EXTERNAL MODULE: ./node_modules/@pixi/color/lib/index.mjs + 3 modules\nvar color_lib = __webpack_require__(126);\n;// CONCATENATED MODULE: ./node_modules/@pixi/extensions/lib/index.mjs\nvar ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {\n  ExtensionType2["Renderer"] = "renderer";\n  ExtensionType2["Application"] = "application";\n  ExtensionType2["RendererSystem"] = "renderer-webgl-system";\n  ExtensionType2["RendererPlugin"] = "renderer-webgl-plugin";\n  ExtensionType2["CanvasRendererSystem"] = "renderer-canvas-system";\n  ExtensionType2["CanvasRendererPlugin"] = "renderer-canvas-plugin";\n  ExtensionType2["Asset"] = "asset";\n  ExtensionType2["LoadParser"] = "load-parser";\n  ExtensionType2["ResolveParser"] = "resolve-parser";\n  ExtensionType2["CacheParser"] = "cache-parser";\n  ExtensionType2["DetectionParser"] = "detection-parser";\n  return ExtensionType2;\n})(ExtensionType || {});\nconst normalizeExtension = (ext) => {\n  if (typeof ext === "function" || typeof ext === "object" && ext.extension) {\n    if (!ext.extension) {\n      throw new Error("Extension class must have an extension object");\n    }\n    const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;\n    ext = { ...metadata, ref: ext };\n  }\n  if (typeof ext === "object") {\n    ext = { ...ext };\n  } else {\n    throw new Error("Invalid extension type");\n  }\n  if (typeof ext.type === "string") {\n    ext.type = [ext.type];\n  }\n  return ext;\n};\nconst normalizePriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;\nconst extensions = {\n  _addHandlers: {},\n  _removeHandlers: {},\n  _queue: {},\n  remove(...extensions2) {\n    extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => this._removeHandlers[type]?.(ext));\n    });\n    return this;\n  },\n  add(...extensions2) {\n    extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => {\n        const handlers = this._addHandlers;\n        const queue = this._queue;\n        if (!handlers[type]) {\n          queue[type] = queue[type] || [];\n          queue[type].push(ext);\n        } else {\n          handlers[type](ext);\n        }\n      });\n    });\n    return this;\n  },\n  handle(type, onAdd, onRemove) {\n    const addHandlers = this._addHandlers;\n    const removeHandlers = this._removeHandlers;\n    if (addHandlers[type] || removeHandlers[type]) {\n      throw new Error(`Extension type ${type} already has a handler`);\n    }\n    addHandlers[type] = onAdd;\n    removeHandlers[type] = onRemove;\n    const queue = this._queue;\n    if (queue[type]) {\n      queue[type].forEach((ext) => onAdd(ext));\n      delete queue[type];\n    }\n    return this;\n  },\n  handleByMap(type, map) {\n    return this.handle(type, (extension) => {\n      map[extension.name] = extension.ref;\n    }, (extension) => {\n      delete map[extension.name];\n    });\n  },\n  handleByList(type, list, defaultPriority = -1) {\n    return this.handle(type, (extension) => {\n      if (list.includes(extension.ref)) {\n        return;\n      }\n      list.push(extension.ref);\n      list.sort((a, b) => normalizePriority(b, defaultPriority) - normalizePriority(a, defaultPriority));\n    }, (extension) => {\n      const index = list.indexOf(extension.ref);\n      if (index !== -1) {\n        list.splice(index, 1);\n      }\n    });\n  }\n};\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/ViewableBuffer.mjs\nclass ViewableBuffer {\n  constructor(sizeOrBuffer) {\n    if (typeof sizeOrBuffer === "number") {\n      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n    } else if (sizeOrBuffer instanceof Uint8Array) {\n      this.rawBinaryData = sizeOrBuffer.buffer;\n    } else {\n      this.rawBinaryData = sizeOrBuffer;\n    }\n    this.uint32View = new Uint32Array(this.rawBinaryData);\n    this.float32View = new Float32Array(this.rawBinaryData);\n  }\n  get int8View() {\n    if (!this._int8View) {\n      this._int8View = new Int8Array(this.rawBinaryData);\n    }\n    return this._int8View;\n  }\n  get uint8View() {\n    if (!this._uint8View) {\n      this._uint8View = new Uint8Array(this.rawBinaryData);\n    }\n    return this._uint8View;\n  }\n  get int16View() {\n    if (!this._int16View) {\n      this._int16View = new Int16Array(this.rawBinaryData);\n    }\n    return this._int16View;\n  }\n  get uint16View() {\n    if (!this._uint16View) {\n      this._uint16View = new Uint16Array(this.rawBinaryData);\n    }\n    return this._uint16View;\n  }\n  get int32View() {\n    if (!this._int32View) {\n      this._int32View = new Int32Array(this.rawBinaryData);\n    }\n    return this._int32View;\n  }\n  view(type) {\n    return this[`${type}View`];\n  }\n  destroy() {\n    this.rawBinaryData = null;\n    this._int8View = null;\n    this._uint8View = null;\n    this._int16View = null;\n    this._uint16View = null;\n    this._int32View = null;\n    this.uint32View = null;\n    this.float32View = null;\n  }\n  static sizeOf(type) {\n    switch (type) {\n      case "int8":\n      case "uint8":\n        return 1;\n      case "int16":\n      case "uint16":\n        return 2;\n      case "int32":\n      case "uint32":\n      case "float32":\n        return 4;\n      default:\n        throw new Error(`${type} isn\'t a valid view type`);\n    }\n  }\n}\n\n\n//# sourceMappingURL=ViewableBuffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/checkMaxIfStatementsInShader.mjs\nconst fragTemplate = [\n  "precision mediump float;",\n  "void main(void){",\n  "float test = 0.1;",\n  "%forloop%",\n  "gl_FragColor = vec4(0.0);",\n  "}"\n].join("\\n");\nfunction generateIfTestSrc(maxIfs) {\n  let src = "";\n  for (let i = 0; i < maxIfs; ++i) {\n    if (i > 0) {\n      src += "\\nelse ";\n    }\n    if (i < maxIfs - 1) {\n      src += `if(test == ${i}.0){}`;\n    }\n  }\n  return src;\n}\nfunction checkMaxIfStatementsInShader(maxIfs, gl) {\n  if (maxIfs === 0) {\n    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");\n  }\n  const shader = gl.createShader(gl.FRAGMENT_SHADER);\n  while (true) {\n    const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));\n    gl.shaderSource(shader, fragmentSrc);\n    gl.compileShader(shader);\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      maxIfs = maxIfs / 2 | 0;\n    } else {\n      break;\n    }\n  }\n  return maxIfs;\n}\n\n\n//# sourceMappingURL=checkMaxIfStatementsInShader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/state/State.mjs\n\n\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\nclass State {\n  constructor() {\n    this.data = 0;\n    this.blendMode = lib/* BLEND_MODES */.T$.NORMAL;\n    this.polygonOffset = 0;\n    this.blend = true;\n    this.depthMask = true;\n  }\n  get blend() {\n    return !!(this.data & 1 << BLEND);\n  }\n  set blend(value) {\n    if (!!(this.data & 1 << BLEND) !== value) {\n      this.data ^= 1 << BLEND;\n    }\n  }\n  get offsets() {\n    return !!(this.data & 1 << OFFSET);\n  }\n  set offsets(value) {\n    if (!!(this.data & 1 << OFFSET) !== value) {\n      this.data ^= 1 << OFFSET;\n    }\n  }\n  get culling() {\n    return !!(this.data & 1 << CULLING);\n  }\n  set culling(value) {\n    if (!!(this.data & 1 << CULLING) !== value) {\n      this.data ^= 1 << CULLING;\n    }\n  }\n  get depthTest() {\n    return !!(this.data & 1 << DEPTH_TEST);\n  }\n  set depthTest(value) {\n    if (!!(this.data & 1 << DEPTH_TEST) !== value) {\n      this.data ^= 1 << DEPTH_TEST;\n    }\n  }\n  get depthMask() {\n    return !!(this.data & 1 << DEPTH_MASK);\n  }\n  set depthMask(value) {\n    if (!!(this.data & 1 << DEPTH_MASK) !== value) {\n      this.data ^= 1 << DEPTH_MASK;\n    }\n  }\n  get clockwiseFrontFace() {\n    return !!(this.data & 1 << WINDING);\n  }\n  set clockwiseFrontFace(value) {\n    if (!!(this.data & 1 << WINDING) !== value) {\n      this.data ^= 1 << WINDING;\n    }\n  }\n  get blendMode() {\n    return this._blendMode;\n  }\n  set blendMode(value) {\n    this.blend = value !== lib/* BLEND_MODES */.T$.NONE;\n    this._blendMode = value;\n  }\n  get polygonOffset() {\n    return this._polygonOffset;\n  }\n  set polygonOffset(value) {\n    this.offsets = !!value;\n    this._polygonOffset = value;\n  }\n  toString() {\n    return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n  }\n  static for2d() {\n    const state = new State();\n    state.depthTest = false;\n    state.blend = true;\n    return state;\n  }\n}\n\n\n//# sourceMappingURL=State.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/autoDetectResource.mjs\nconst INSTALLED = [];\nfunction autoDetectResource(source, options) {\n  if (!source) {\n    return null;\n  }\n  let extension = "";\n  if (typeof source === "string") {\n    const result = /\\.(\\w{3,4})(?:$|\\?|#)/i.exec(source);\n    if (result) {\n      extension = result[1].toLowerCase();\n    }\n  }\n  for (let i = INSTALLED.length - 1; i >= 0; --i) {\n    const ResourcePlugin = INSTALLED[i];\n    if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {\n      return new ResourcePlugin(source, options);\n    }\n  }\n  throw new Error("Unrecognized source type to auto-detect Resource");\n}\n\n\n//# sourceMappingURL=autoDetectResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/runner/lib/Runner.mjs\nclass Runner_Runner {\n  constructor(name) {\n    this.items = [];\n    this._name = name;\n    this._aliasCount = 0;\n  }\n  emit(a0, a1, a2, a3, a4, a5, a6, a7) {\n    if (arguments.length > 8) {\n      throw new Error("max arguments reached");\n    }\n    const { name, items } = this;\n    this._aliasCount++;\n    for (let i = 0, len = items.length; i < len; i++) {\n      items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n    }\n    if (items === this.items) {\n      this._aliasCount--;\n    }\n    return this;\n  }\n  ensureNonAliasedItems() {\n    if (this._aliasCount > 0 && this.items.length > 1) {\n      this._aliasCount = 0;\n      this.items = this.items.slice(0);\n    }\n  }\n  add(item) {\n    if (item[this._name]) {\n      this.ensureNonAliasedItems();\n      this.remove(item);\n      this.items.push(item);\n    }\n    return this;\n  }\n  remove(item) {\n    const index = this.items.indexOf(item);\n    if (index !== -1) {\n      this.ensureNonAliasedItems();\n      this.items.splice(index, 1);\n    }\n    return this;\n  }\n  contains(item) {\n    return this.items.includes(item);\n  }\n  removeAll() {\n    this.ensureNonAliasedItems();\n    this.items.length = 0;\n    return this;\n  }\n  destroy() {\n    this.removeAll();\n    this.items = null;\n    this._name = null;\n  }\n  get empty() {\n    return this.items.length === 0;\n  }\n  get name() {\n    return this._name;\n  }\n}\nObject.defineProperties(Runner_Runner.prototype, {\n  dispatch: { value: Runner_Runner.prototype.emit },\n  run: { value: Runner_Runner.prototype.emit }\n});\n\n\n//# sourceMappingURL=Runner.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/runner/lib/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/Resource.mjs\n\n\nclass Resource {\n  constructor(width = 0, height = 0) {\n    this._width = width;\n    this._height = height;\n    this.destroyed = false;\n    this.internal = false;\n    this.onResize = new Runner_Runner("setRealSize");\n    this.onUpdate = new Runner_Runner("update");\n    this.onError = new Runner_Runner("onError");\n  }\n  bind(baseTexture) {\n    this.onResize.add(baseTexture);\n    this.onUpdate.add(baseTexture);\n    this.onError.add(baseTexture);\n    if (this._width || this._height) {\n      this.onResize.emit(this._width, this._height);\n    }\n  }\n  unbind(baseTexture) {\n    this.onResize.remove(baseTexture);\n    this.onUpdate.remove(baseTexture);\n    this.onError.remove(baseTexture);\n  }\n  resize(width, height) {\n    if (width !== this._width || height !== this._height) {\n      this._width = width;\n      this._height = height;\n      this.onResize.emit(width, height);\n    }\n  }\n  get valid() {\n    return !!this._width && !!this._height;\n  }\n  update() {\n    if (!this.destroyed) {\n      this.onUpdate.emit();\n    }\n  }\n  load() {\n    return Promise.resolve(this);\n  }\n  get width() {\n    return this._width;\n  }\n  get height() {\n    return this._height;\n  }\n  style(_renderer, _baseTexture, _glTexture) {\n    return false;\n  }\n  dispose() {\n  }\n  destroy() {\n    if (!this.destroyed) {\n      this.destroyed = true;\n      this.dispose();\n      this.onError.removeAll();\n      this.onError = null;\n      this.onResize.removeAll();\n      this.onResize = null;\n      this.onUpdate.removeAll();\n      this.onUpdate = null;\n    }\n  }\n  static test(_source, _extension) {\n    return false;\n  }\n}\n\n\n//# sourceMappingURL=Resource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/BufferResource.mjs\n\n\n\nclass BufferResource extends Resource {\n  constructor(source, options) {\n    const { width, height } = options || {};\n    if (!width || !height) {\n      throw new Error("BufferResource width or height invalid");\n    }\n    super(width, height);\n    this.data = source;\n  }\n  upload(renderer, baseTexture, glTexture) {\n    const gl = renderer.gl;\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === lib/* ALPHA_MODES */.iw.UNPACK);\n    const width = baseTexture.realWidth;\n    const height = baseTexture.realHeight;\n    if (glTexture.width === width && glTexture.height === height) {\n      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);\n    } else {\n      glTexture.width = width;\n      glTexture.height = height;\n      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);\n    }\n    return true;\n  }\n  dispose() {\n    this.data = null;\n  }\n  static test(source) {\n    return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;\n  }\n}\n\n\n//# sourceMappingURL=BufferResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/BaseTexture.mjs\n\n\n\n\n\n\n\nconst defaultBufferOptions = {\n  scaleMode: lib/* SCALE_MODES */.aH.NEAREST,\n  format: lib/* FORMATS */.I2.RGBA,\n  alphaMode: lib/* ALPHA_MODES */.iw.NPM\n};\nconst _BaseTexture = class extends utils_lib.EventEmitter {\n  constructor(resource = null, options = null) {\n    super();\n    options = Object.assign({}, _BaseTexture.defaultOptions, options);\n    const {\n      alphaMode,\n      mipmap,\n      anisotropicLevel,\n      scaleMode,\n      width,\n      height,\n      wrapMode,\n      format,\n      type,\n      target,\n      resolution,\n      resourceOptions\n    } = options;\n    if (resource && !(resource instanceof Resource)) {\n      resource = autoDetectResource(resource, resourceOptions);\n      resource.internal = true;\n    }\n    this.resolution = resolution || settings_lib/* settings */.Xd.RESOLUTION;\n    this.width = Math.round((width || 0) * this.resolution) / this.resolution;\n    this.height = Math.round((height || 0) * this.resolution) / this.resolution;\n    this._mipmap = mipmap;\n    this.anisotropicLevel = anisotropicLevel;\n    this._wrapMode = wrapMode;\n    this._scaleMode = scaleMode;\n    this.format = format;\n    this.type = type;\n    this.target = target;\n    this.alphaMode = alphaMode;\n    this.uid = (0,utils_lib.uid)();\n    this.touched = 0;\n    this.isPowerOfTwo = false;\n    this._refreshPOT();\n    this._glTextures = {};\n    this.dirtyId = 0;\n    this.dirtyStyleId = 0;\n    this.cacheId = null;\n    this.valid = width > 0 && height > 0;\n    this.textureCacheIds = [];\n    this.destroyed = false;\n    this.resource = null;\n    this._batchEnabled = 0;\n    this._batchLocation = 0;\n    this.parentTextureArray = null;\n    this.setResource(resource);\n  }\n  get realWidth() {\n    return Math.round(this.width * this.resolution);\n  }\n  get realHeight() {\n    return Math.round(this.height * this.resolution);\n  }\n  get mipmap() {\n    return this._mipmap;\n  }\n  set mipmap(value) {\n    if (this._mipmap !== value) {\n      this._mipmap = value;\n      this.dirtyStyleId++;\n    }\n  }\n  get scaleMode() {\n    return this._scaleMode;\n  }\n  set scaleMode(value) {\n    if (this._scaleMode !== value) {\n      this._scaleMode = value;\n      this.dirtyStyleId++;\n    }\n  }\n  get wrapMode() {\n    return this._wrapMode;\n  }\n  set wrapMode(value) {\n    if (this._wrapMode !== value) {\n      this._wrapMode = value;\n      this.dirtyStyleId++;\n    }\n  }\n  setStyle(scaleMode, mipmap) {\n    let dirty;\n    if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {\n      this.scaleMode = scaleMode;\n      dirty = true;\n    }\n    if (mipmap !== void 0 && mipmap !== this.mipmap) {\n      this.mipmap = mipmap;\n      dirty = true;\n    }\n    if (dirty) {\n      this.dirtyStyleId++;\n    }\n    return this;\n  }\n  setSize(desiredWidth, desiredHeight, resolution) {\n    resolution = resolution || this.resolution;\n    return this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);\n  }\n  setRealSize(realWidth, realHeight, resolution) {\n    this.resolution = resolution || this.resolution;\n    this.width = Math.round(realWidth) / this.resolution;\n    this.height = Math.round(realHeight) / this.resolution;\n    this._refreshPOT();\n    this.update();\n    return this;\n  }\n  _refreshPOT() {\n    this.isPowerOfTwo = (0,utils_lib.isPow2)(this.realWidth) && (0,utils_lib.isPow2)(this.realHeight);\n  }\n  setResolution(resolution) {\n    const oldResolution = this.resolution;\n    if (oldResolution === resolution) {\n      return this;\n    }\n    this.resolution = resolution;\n    if (this.valid) {\n      this.width = Math.round(this.width * oldResolution) / resolution;\n      this.height = Math.round(this.height * oldResolution) / resolution;\n      this.emit("update", this);\n    }\n    this._refreshPOT();\n    return this;\n  }\n  setResource(resource) {\n    if (this.resource === resource) {\n      return this;\n    }\n    if (this.resource) {\n      throw new Error("Resource can be set only once");\n    }\n    resource.bind(this);\n    this.resource = resource;\n    return this;\n  }\n  update() {\n    if (!this.valid) {\n      if (this.width > 0 && this.height > 0) {\n        this.valid = true;\n        this.emit("loaded", this);\n        this.emit("update", this);\n      }\n    } else {\n      this.dirtyId++;\n      this.dirtyStyleId++;\n      this.emit("update", this);\n    }\n  }\n  onError(event) {\n    this.emit("error", this, event);\n  }\n  destroy() {\n    if (this.resource) {\n      this.resource.unbind(this);\n      if (this.resource.internal) {\n        this.resource.destroy();\n      }\n      this.resource = null;\n    }\n    if (this.cacheId) {\n      delete utils_lib.BaseTextureCache[this.cacheId];\n      delete utils_lib.TextureCache[this.cacheId];\n      this.cacheId = null;\n    }\n    this.dispose();\n    _BaseTexture.removeFromCache(this);\n    this.textureCacheIds = null;\n    this.destroyed = true;\n  }\n  dispose() {\n    this.emit("dispose", this);\n  }\n  castToBaseTexture() {\n    return this;\n  }\n  static from(source, options, strict = settings_lib/* settings */.Xd.STRICT_TEXTURE_CACHE) {\n    const isFrame = typeof source === "string";\n    let cacheId = null;\n    if (isFrame) {\n      cacheId = source;\n    } else {\n      if (!source._pixiId) {\n        const prefix = options?.pixiIdPrefix || "pixiid";\n        source._pixiId = `${prefix}_${(0,utils_lib.uid)()}`;\n      }\n      cacheId = source._pixiId;\n    }\n    let baseTexture = utils_lib.BaseTextureCache[cacheId];\n    if (isFrame && strict && !baseTexture) {\n      throw new Error(`The cacheId "${cacheId}" does not exist in BaseTextureCache.`);\n    }\n    if (!baseTexture) {\n      baseTexture = new _BaseTexture(source, options);\n      baseTexture.cacheId = cacheId;\n      _BaseTexture.addToCache(baseTexture, cacheId);\n    }\n    return baseTexture;\n  }\n  static fromBuffer(buffer, width, height, options) {\n    buffer = buffer || new Float32Array(width * height * 4);\n    const resource = new BufferResource(buffer, { width, height });\n    const type = buffer instanceof Float32Array ? lib/* TYPES */.vK.FLOAT : lib/* TYPES */.vK.UNSIGNED_BYTE;\n    return new _BaseTexture(resource, Object.assign({}, defaultBufferOptions, { type }, options));\n  }\n  static addToCache(baseTexture, id) {\n    if (id) {\n      if (!baseTexture.textureCacheIds.includes(id)) {\n        baseTexture.textureCacheIds.push(id);\n      }\n      if (utils_lib.BaseTextureCache[id] && utils_lib.BaseTextureCache[id] !== baseTexture) {\n        console.warn(`BaseTexture added to the cache with an id [${id}] that already had an entry`);\n      }\n      utils_lib.BaseTextureCache[id] = baseTexture;\n    }\n  }\n  static removeFromCache(baseTexture) {\n    if (typeof baseTexture === "string") {\n      const baseTextureFromCache = utils_lib.BaseTextureCache[baseTexture];\n      if (baseTextureFromCache) {\n        const index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);\n        if (index > -1) {\n          baseTextureFromCache.textureCacheIds.splice(index, 1);\n        }\n        delete utils_lib.BaseTextureCache[baseTexture];\n        return baseTextureFromCache;\n      }\n    } else if (baseTexture?.textureCacheIds) {\n      for (let i = 0; i < baseTexture.textureCacheIds.length; ++i) {\n        delete utils_lib.BaseTextureCache[baseTexture.textureCacheIds[i]];\n      }\n      baseTexture.textureCacheIds.length = 0;\n      return baseTexture;\n    }\n    return null;\n  }\n};\nlet BaseTexture = _BaseTexture;\nBaseTexture.defaultOptions = {\n  mipmap: lib/* MIPMAP_MODES */.WB.POW2,\n  anisotropicLevel: 0,\n  scaleMode: lib/* SCALE_MODES */.aH.LINEAR,\n  wrapMode: lib/* WRAP_MODES */.Nt.CLAMP,\n  alphaMode: lib/* ALPHA_MODES */.iw.UNPACK,\n  target: lib/* TARGETS */.sp.TEXTURE_2D,\n  format: lib/* FORMATS */.I2.RGBA,\n  type: lib/* TYPES */.vK.UNSIGNED_BYTE\n};\nBaseTexture._globalBatch = 0;\n\n\n//# sourceMappingURL=BaseTexture.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/BatchDrawCall.mjs\n\n\nclass BatchDrawCall {\n  constructor() {\n    this.texArray = null;\n    this.blend = 0;\n    this.type = lib/* DRAW_MODES */.lg.TRIANGLES;\n    this.start = 0;\n    this.size = 0;\n    this.data = null;\n  }\n}\n\n\n//# sourceMappingURL=BatchDrawCall.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/Buffer.mjs\n\n\n\nlet UID = 0;\nclass Buffer {\n  constructor(data, _static = true, index = false) {\n    this.data = data || new Float32Array(1);\n    this._glBuffers = {};\n    this._updateID = 0;\n    this.index = index;\n    this.static = _static;\n    this.id = UID++;\n    this.disposeRunner = new Runner_Runner("disposeBuffer");\n  }\n  update(data) {\n    if (data instanceof Array) {\n      data = new Float32Array(data);\n    }\n    this.data = data || this.data;\n    this._updateID++;\n  }\n  dispose() {\n    this.disposeRunner.emit(this, false);\n  }\n  destroy() {\n    this.dispose();\n    this.data = null;\n  }\n  set index(value) {\n    this.type = value ? lib/* BUFFER_TYPE */.mr.ELEMENT_ARRAY_BUFFER : lib/* BUFFER_TYPE */.mr.ARRAY_BUFFER;\n  }\n  get index() {\n    return this.type === lib/* BUFFER_TYPE */.mr.ELEMENT_ARRAY_BUFFER;\n  }\n  static from(data) {\n    if (data instanceof Array) {\n      data = new Float32Array(data);\n    }\n    return new Buffer(data);\n  }\n}\n\n\n//# sourceMappingURL=Buffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/Attribute.mjs\n\n\nclass Attribute {\n  constructor(buffer, size = 0, normalized = false, type = lib/* TYPES */.vK.FLOAT, stride, start, instance, divisor = 1) {\n    this.buffer = buffer;\n    this.size = size;\n    this.normalized = normalized;\n    this.type = type;\n    this.stride = stride;\n    this.start = start;\n    this.instance = instance;\n    this.divisor = divisor;\n  }\n  destroy() {\n    this.buffer = null;\n  }\n  static from(buffer, size, normalized, type, stride) {\n    return new Attribute(buffer, size, normalized, type, stride);\n  }\n}\n\n\n//# sourceMappingURL=Attribute.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/utils/interleaveTypedArrays.mjs\n\n\nconst map = {\n  Float32Array,\n  Uint32Array,\n  Int32Array,\n  Uint8Array\n};\nfunction interleaveTypedArrays(arrays, sizes) {\n  let outSize = 0;\n  let stride = 0;\n  const views = {};\n  for (let i = 0; i < arrays.length; i++) {\n    stride += sizes[i];\n    outSize += arrays[i].length;\n  }\n  const buffer = new ArrayBuffer(outSize * 4);\n  let out = null;\n  let littleOffset = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const size = sizes[i];\n    const array = arrays[i];\n    const type = (0,utils_lib.getBufferType)(array);\n    if (!views[type]) {\n      views[type] = new map[type](buffer);\n    }\n    out = views[type];\n    for (let j = 0; j < array.length; j++) {\n      const indexStart = (j / size | 0) * stride + littleOffset;\n      const index = j % size;\n      out[indexStart + index] = array[j];\n    }\n    littleOffset += size;\n  }\n  return new Float32Array(buffer);\n}\n\n\n//# sourceMappingURL=interleaveTypedArrays.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/Geometry.mjs\n\n\n\n\n\n\n\nconst byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };\nlet Geometry_UID = 0;\nconst Geometry_map = {\n  Float32Array,\n  Uint32Array,\n  Int32Array,\n  Uint8Array,\n  Uint16Array\n};\nclass Geometry {\n  constructor(buffers = [], attributes = {}) {\n    this.buffers = buffers;\n    this.indexBuffer = null;\n    this.attributes = attributes;\n    this.glVertexArrayObjects = {};\n    this.id = Geometry_UID++;\n    this.instanced = false;\n    this.instanceCount = 1;\n    this.disposeRunner = new Runner_Runner("disposeGeometry");\n    this.refCount = 0;\n  }\n  addAttribute(id, buffer, size = 0, normalized = false, type, stride, start, instance = false) {\n    if (!buffer) {\n      throw new Error("You must pass a buffer when creating an attribute");\n    }\n    if (!(buffer instanceof Buffer)) {\n      if (buffer instanceof Array) {\n        buffer = new Float32Array(buffer);\n      }\n      buffer = new Buffer(buffer);\n    }\n    const ids = id.split("|");\n    if (ids.length > 1) {\n      for (let i = 0; i < ids.length; i++) {\n        this.addAttribute(ids[i], buffer, size, normalized, type);\n      }\n      return this;\n    }\n    let bufferIndex = this.buffers.indexOf(buffer);\n    if (bufferIndex === -1) {\n      this.buffers.push(buffer);\n      bufferIndex = this.buffers.length - 1;\n    }\n    this.attributes[id] = new Attribute(bufferIndex, size, normalized, type, stride, start, instance);\n    this.instanced = this.instanced || instance;\n    return this;\n  }\n  getAttribute(id) {\n    return this.attributes[id];\n  }\n  getBuffer(id) {\n    return this.buffers[this.getAttribute(id).buffer];\n  }\n  addIndex(buffer) {\n    if (!(buffer instanceof Buffer)) {\n      if (buffer instanceof Array) {\n        buffer = new Uint16Array(buffer);\n      }\n      buffer = new Buffer(buffer);\n    }\n    buffer.type = lib/* BUFFER_TYPE */.mr.ELEMENT_ARRAY_BUFFER;\n    this.indexBuffer = buffer;\n    if (!this.buffers.includes(buffer)) {\n      this.buffers.push(buffer);\n    }\n    return this;\n  }\n  getIndex() {\n    return this.indexBuffer;\n  }\n  interleave() {\n    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)\n      return this;\n    const arrays = [];\n    const sizes = [];\n    const interleavedBuffer = new Buffer();\n    let i;\n    for (i in this.attributes) {\n      const attribute = this.attributes[i];\n      const buffer = this.buffers[attribute.buffer];\n      arrays.push(buffer.data);\n      sizes.push(attribute.size * byteSizeMap[attribute.type] / 4);\n      attribute.buffer = 0;\n    }\n    interleavedBuffer.data = interleaveTypedArrays(arrays, sizes);\n    for (i = 0; i < this.buffers.length; i++) {\n      if (this.buffers[i] !== this.indexBuffer) {\n        this.buffers[i].destroy();\n      }\n    }\n    this.buffers = [interleavedBuffer];\n    if (this.indexBuffer) {\n      this.buffers.push(this.indexBuffer);\n    }\n    return this;\n  }\n  getSize() {\n    for (const i in this.attributes) {\n      const attribute = this.attributes[i];\n      const buffer = this.buffers[attribute.buffer];\n      return buffer.data.length / (attribute.stride / 4 || attribute.size);\n    }\n    return 0;\n  }\n  dispose() {\n    this.disposeRunner.emit(this, false);\n  }\n  destroy() {\n    this.dispose();\n    this.buffers = null;\n    this.indexBuffer = null;\n    this.attributes = null;\n  }\n  clone() {\n    const geometry = new Geometry();\n    for (let i = 0; i < this.buffers.length; i++) {\n      geometry.buffers[i] = new Buffer(this.buffers[i].data.slice(0));\n    }\n    for (const i in this.attributes) {\n      const attrib = this.attributes[i];\n      geometry.attributes[i] = new Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);\n    }\n    if (this.indexBuffer) {\n      geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];\n      geometry.indexBuffer.type = lib/* BUFFER_TYPE */.mr.ELEMENT_ARRAY_BUFFER;\n    }\n    return geometry;\n  }\n  static merge(geometries) {\n    const geometryOut = new Geometry();\n    const arrays = [];\n    const sizes = [];\n    const offsets = [];\n    let geometry;\n    for (let i = 0; i < geometries.length; i++) {\n      geometry = geometries[i];\n      for (let j = 0; j < geometry.buffers.length; j++) {\n        sizes[j] = sizes[j] || 0;\n        sizes[j] += geometry.buffers[j].data.length;\n        offsets[j] = 0;\n      }\n    }\n    for (let i = 0; i < geometry.buffers.length; i++) {\n      arrays[i] = new Geometry_map[(0,utils_lib.getBufferType)(geometry.buffers[i].data)](sizes[i]);\n      geometryOut.buffers[i] = new Buffer(arrays[i]);\n    }\n    for (let i = 0; i < geometries.length; i++) {\n      geometry = geometries[i];\n      for (let j = 0; j < geometry.buffers.length; j++) {\n        arrays[j].set(geometry.buffers[j].data, offsets[j]);\n        offsets[j] += geometry.buffers[j].data.length;\n      }\n    }\n    geometryOut.attributes = geometry.attributes;\n    if (geometry.indexBuffer) {\n      geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];\n      geometryOut.indexBuffer.type = lib/* BUFFER_TYPE */.mr.ELEMENT_ARRAY_BUFFER;\n      let offset = 0;\n      let stride = 0;\n      let offset2 = 0;\n      let bufferIndexToCount = 0;\n      for (let i = 0; i < geometry.buffers.length; i++) {\n        if (geometry.buffers[i] !== geometry.indexBuffer) {\n          bufferIndexToCount = i;\n          break;\n        }\n      }\n      for (const i in geometry.attributes) {\n        const attribute = geometry.attributes[i];\n        if ((attribute.buffer | 0) === bufferIndexToCount) {\n          stride += attribute.size * byteSizeMap[attribute.type] / 4;\n        }\n      }\n      for (let i = 0; i < geometries.length; i++) {\n        const indexBufferData = geometries[i].indexBuffer.data;\n        for (let j = 0; j < indexBufferData.length; j++) {\n          geometryOut.indexBuffer.data[j + offset2] += offset;\n        }\n        offset += geometries[i].buffers[bufferIndexToCount].data.length / stride;\n        offset2 += indexBufferData.length;\n      }\n    }\n    return geometryOut;\n  }\n}\n\n\n//# sourceMappingURL=Geometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/BatchGeometry.mjs\n\n\n\n\nclass BatchGeometry extends Geometry {\n  constructor(_static = false) {\n    super();\n    this._buffer = new Buffer(null, _static, false);\n    this._indexBuffer = new Buffer(null, _static, true);\n    this.addAttribute("aVertexPosition", this._buffer, 2, false, lib/* TYPES */.vK.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, false, lib/* TYPES */.vK.FLOAT).addAttribute("aColor", this._buffer, 4, true, lib/* TYPES */.vK.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, true, lib/* TYPES */.vK.FLOAT).addIndex(this._indexBuffer);\n  }\n}\n\n\n//# sourceMappingURL=BatchGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/const.mjs\nconst PI_2 = Math.PI * 2;\nconst RAD_TO_DEG = 180 / Math.PI;\nconst DEG_TO_RAD = Math.PI / 180;\nvar SHAPES = /* @__PURE__ */ ((SHAPES2) => {\n  SHAPES2[SHAPES2["POLY"] = 0] = "POLY";\n  SHAPES2[SHAPES2["RECT"] = 1] = "RECT";\n  SHAPES2[SHAPES2["CIRC"] = 2] = "CIRC";\n  SHAPES2[SHAPES2["ELIP"] = 3] = "ELIP";\n  SHAPES2[SHAPES2["RREC"] = 4] = "RREC";\n  return SHAPES2;\n})(SHAPES || {});\n\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/Point.mjs\nclass Point {\n  constructor(x = 0, y = 0) {\n    this.x = 0;\n    this.y = 0;\n    this.x = x;\n    this.y = y;\n  }\n  clone() {\n    return new Point(this.x, this.y);\n  }\n  copyFrom(p) {\n    this.set(p.x, p.y);\n    return this;\n  }\n  copyTo(p) {\n    p.set(this.x, this.y);\n    return p;\n  }\n  equals(p) {\n    return p.x === this.x && p.y === this.y;\n  }\n  set(x = 0, y = x) {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  toString() {\n    return `[@pixi/math:Point x=${this.x} y=${this.y}]`;\n  }\n}\n\n\n//# sourceMappingURL=Point.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/shapes/Rectangle.mjs\n\n\n\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\nclass Rectangle_Rectangle {\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    this.x = Number(x);\n    this.y = Number(y);\n    this.width = Number(width);\n    this.height = Number(height);\n    this.type = SHAPES.RECT;\n  }\n  get left() {\n    return this.x;\n  }\n  get right() {\n    return this.x + this.width;\n  }\n  get top() {\n    return this.y;\n  }\n  get bottom() {\n    return this.y + this.height;\n  }\n  static get EMPTY() {\n    return new Rectangle_Rectangle(0, 0, 0, 0);\n  }\n  clone() {\n    return new Rectangle_Rectangle(this.x, this.y, this.width, this.height);\n  }\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  copyTo(rectangle) {\n    rectangle.x = this.x;\n    rectangle.y = this.y;\n    rectangle.width = this.width;\n    rectangle.height = this.height;\n    return rectangle;\n  }\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x < this.x + this.width) {\n      if (y >= this.y && y < this.y + this.height) {\n        return true;\n      }\n    }\n    return false;\n  }\n  intersects(other, transform) {\n    if (!transform) {\n      const x02 = this.x < other.x ? other.x : this.x;\n      const x12 = this.right > other.right ? other.right : this.right;\n      if (x12 <= x02) {\n        return false;\n      }\n      const y02 = this.y < other.y ? other.y : this.y;\n      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;\n      return y12 > y02;\n    }\n    const x0 = this.left;\n    const x1 = this.right;\n    const y0 = this.top;\n    const y1 = this.bottom;\n    if (x1 <= x0 || y1 <= y0) {\n      return false;\n    }\n    const lt = tempPoints[0].set(other.left, other.top);\n    const lb = tempPoints[1].set(other.left, other.bottom);\n    const rt = tempPoints[2].set(other.right, other.top);\n    const rb = tempPoints[3].set(other.right, other.bottom);\n    if (rt.x <= lt.x || lb.y <= lt.y) {\n      return false;\n    }\n    const s = Math.sign(transform.a * transform.d - transform.b * transform.c);\n    if (s === 0) {\n      return false;\n    }\n    transform.apply(lt, lt);\n    transform.apply(lb, lb);\n    transform.apply(rt, rt);\n    transform.apply(rb, rb);\n    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {\n      return false;\n    }\n    const nx = s * (lb.y - lt.y);\n    const ny = s * (lt.x - lb.x);\n    const n00 = nx * x0 + ny * y0;\n    const n10 = nx * x1 + ny * y0;\n    const n01 = nx * x0 + ny * y1;\n    const n11 = nx * x1 + ny * y1;\n    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {\n      return false;\n    }\n    const mx = s * (lt.y - rt.y);\n    const my = s * (rt.x - lt.x);\n    const m00 = mx * x0 + my * y0;\n    const m10 = mx * x1 + my * y0;\n    const m01 = mx * x0 + my * y1;\n    const m11 = mx * x1 + my * y1;\n    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {\n      return false;\n    }\n    return true;\n  }\n  pad(paddingX = 0, paddingY = paddingX) {\n    this.x -= paddingX;\n    this.y -= paddingY;\n    this.width += paddingX * 2;\n    this.height += paddingY * 2;\n    return this;\n  }\n  fit(rectangle) {\n    const x1 = Math.max(this.x, rectangle.x);\n    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.max(this.y, rectangle.y);\n    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = Math.max(x2 - x1, 0);\n    this.y = y1;\n    this.height = Math.max(y2 - y1, 0);\n    return this;\n  }\n  ceil(resolution = 1, eps = 1e-3) {\n    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n    const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n    this.x = Math.floor((this.x + eps) * resolution) / resolution;\n    this.y = Math.floor((this.y + eps) * resolution) / resolution;\n    this.width = x2 - this.x;\n    this.height = y2 - this.y;\n    return this;\n  }\n  enlarge(rectangle) {\n    const x1 = Math.min(this.x, rectangle.x);\n    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.min(this.y, rectangle.y);\n    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = x2 - x1;\n    this.y = y1;\n    this.height = y2 - y1;\n    return this;\n  }\n  toString() {\n    return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n  }\n}\n\n\n//# sourceMappingURL=Rectangle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/shapes/Circle.mjs\n\n\n\nclass Circle {\n  constructor(x = 0, y = 0, radius = 0) {\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n    this.type = SHAPES.CIRC;\n  }\n  clone() {\n    return new Circle(this.x, this.y, this.radius);\n  }\n  contains(x, y) {\n    if (this.radius <= 0) {\n      return false;\n    }\n    const r2 = this.radius * this.radius;\n    let dx = this.x - x;\n    let dy = this.y - y;\n    dx *= dx;\n    dy *= dy;\n    return dx + dy <= r2;\n  }\n  getBounds() {\n    return new Rectangle_Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);\n  }\n  toString() {\n    return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n  }\n}\n\n\n//# sourceMappingURL=Circle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/shapes/Ellipse.mjs\n\n\n\nclass Ellipse {\n  constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {\n    this.x = x;\n    this.y = y;\n    this.width = halfWidth;\n    this.height = halfHeight;\n    this.type = SHAPES.ELIP;\n  }\n  clone() {\n    return new Ellipse(this.x, this.y, this.width, this.height);\n  }\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    let normx = (x - this.x) / this.width;\n    let normy = (y - this.y) / this.height;\n    normx *= normx;\n    normy *= normy;\n    return normx + normy <= 1;\n  }\n  getBounds() {\n    return new Rectangle_Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);\n  }\n  toString() {\n    return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n  }\n}\n\n\n//# sourceMappingURL=Ellipse.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/shapes/Polygon.mjs\n\n\nclass Polygon {\n  constructor(...points) {\n    let flat = Array.isArray(points[0]) ? points[0] : points;\n    if (typeof flat[0] !== "number") {\n      const p = [];\n      for (let i = 0, il = flat.length; i < il; i++) {\n        p.push(flat[i].x, flat[i].y);\n      }\n      flat = p;\n    }\n    this.points = flat;\n    this.type = SHAPES.POLY;\n    this.closeStroke = true;\n  }\n  clone() {\n    const points = this.points.slice();\n    const polygon = new Polygon(points);\n    polygon.closeStroke = this.closeStroke;\n    return polygon;\n  }\n  contains(x, y) {\n    let inside = false;\n    const length = this.points.length / 2;\n    for (let i = 0, j = length - 1; i < length; j = i++) {\n      const xi = this.points[i * 2];\n      const yi = this.points[i * 2 + 1];\n      const xj = this.points[j * 2];\n      const yj = this.points[j * 2 + 1];\n      const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n    return inside;\n  }\n  toString() {\n    return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;\n  }\n}\n\n\n//# sourceMappingURL=Polygon.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/shapes/RoundedRectangle.mjs\n\n\nclass RoundedRectangle {\n  constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.radius = radius;\n    this.type = SHAPES.RREC;\n  }\n  clone() {\n    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n  }\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x <= this.x + this.width) {\n      if (y >= this.y && y <= this.y + this.height) {\n        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n        if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {\n          return true;\n        }\n        let dx = x - (this.x + radius);\n        let dy = y - (this.y + radius);\n        const radius2 = radius * radius;\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + this.width - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dy = y - (this.y + this.height - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  toString() {\n    return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;\n  }\n}\n\n\n//# sourceMappingURL=RoundedRectangle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/Matrix.mjs\n\n\n\nclass Matrix {\n  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n    this.array = null;\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n  }\n  fromArray(array) {\n    this.a = array[0];\n    this.b = array[1];\n    this.c = array[3];\n    this.d = array[4];\n    this.tx = array[2];\n    this.ty = array[5];\n  }\n  set(a, b, c, d, tx, ty) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n    return this;\n  }\n  toArray(transpose, out) {\n    if (!this.array) {\n      this.array = new Float32Array(9);\n    }\n    const array = out || this.array;\n    if (transpose) {\n      array[0] = this.a;\n      array[1] = this.b;\n      array[2] = 0;\n      array[3] = this.c;\n      array[4] = this.d;\n      array[5] = 0;\n      array[6] = this.tx;\n      array[7] = this.ty;\n      array[8] = 1;\n    } else {\n      array[0] = this.a;\n      array[1] = this.c;\n      array[2] = this.tx;\n      array[3] = this.b;\n      array[4] = this.d;\n      array[5] = this.ty;\n      array[6] = 0;\n      array[7] = 0;\n      array[8] = 1;\n    }\n    return array;\n  }\n  apply(pos, newPos) {\n    newPos = newPos || new Point();\n    const x = pos.x;\n    const y = pos.y;\n    newPos.x = this.a * x + this.c * y + this.tx;\n    newPos.y = this.b * x + this.d * y + this.ty;\n    return newPos;\n  }\n  applyInverse(pos, newPos) {\n    newPos = newPos || new Point();\n    const id = 1 / (this.a * this.d + this.c * -this.b);\n    const x = pos.x;\n    const y = pos.y;\n    newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;\n    newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;\n    return newPos;\n  }\n  translate(x, y) {\n    this.tx += x;\n    this.ty += y;\n    return this;\n  }\n  scale(x, y) {\n    this.a *= x;\n    this.d *= y;\n    this.c *= x;\n    this.b *= y;\n    this.tx *= x;\n    this.ty *= y;\n    return this;\n  }\n  rotate(angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const a1 = this.a;\n    const c1 = this.c;\n    const tx1 = this.tx;\n    this.a = a1 * cos - this.b * sin;\n    this.b = a1 * sin + this.b * cos;\n    this.c = c1 * cos - this.d * sin;\n    this.d = c1 * sin + this.d * cos;\n    this.tx = tx1 * cos - this.ty * sin;\n    this.ty = tx1 * sin + this.ty * cos;\n    return this;\n  }\n  append(matrix) {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    this.a = matrix.a * a1 + matrix.b * c1;\n    this.b = matrix.a * b1 + matrix.b * d1;\n    this.c = matrix.c * a1 + matrix.d * c1;\n    this.d = matrix.c * b1 + matrix.d * d1;\n    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;\n    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;\n    return this;\n  }\n  setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {\n    this.a = Math.cos(rotation + skewY) * scaleX;\n    this.b = Math.sin(rotation + skewY) * scaleX;\n    this.c = -Math.sin(rotation - skewX) * scaleY;\n    this.d = Math.cos(rotation - skewX) * scaleY;\n    this.tx = x - (pivotX * this.a + pivotY * this.c);\n    this.ty = y - (pivotX * this.b + pivotY * this.d);\n    return this;\n  }\n  prepend(matrix) {\n    const tx1 = this.tx;\n    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n      const a1 = this.a;\n      const c1 = this.c;\n      this.a = a1 * matrix.a + this.b * matrix.c;\n      this.b = a1 * matrix.b + this.b * matrix.d;\n      this.c = c1 * matrix.a + this.d * matrix.c;\n      this.d = c1 * matrix.b + this.d * matrix.d;\n    }\n    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;\n    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;\n    return this;\n  }\n  decompose(transform) {\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const pivot = transform.pivot;\n    const skewX = -Math.atan2(-c, d);\n    const skewY = Math.atan2(b, a);\n    const delta = Math.abs(skewX + skewY);\n    if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {\n      transform.rotation = skewY;\n      transform.skew.x = transform.skew.y = 0;\n    } else {\n      transform.rotation = 0;\n      transform.skew.x = skewX;\n      transform.skew.y = skewY;\n    }\n    transform.scale.x = Math.sqrt(a * a + b * b);\n    transform.scale.y = Math.sqrt(c * c + d * d);\n    transform.position.x = this.tx + (pivot.x * a + pivot.y * c);\n    transform.position.y = this.ty + (pivot.x * b + pivot.y * d);\n    return transform;\n  }\n  invert() {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    const tx1 = this.tx;\n    const n = a1 * d1 - b1 * c1;\n    this.a = d1 / n;\n    this.b = -b1 / n;\n    this.c = -c1 / n;\n    this.d = a1 / n;\n    this.tx = (c1 * this.ty - d1 * tx1) / n;\n    this.ty = -(a1 * this.ty - b1 * tx1) / n;\n    return this;\n  }\n  identity() {\n    this.a = 1;\n    this.b = 0;\n    this.c = 0;\n    this.d = 1;\n    this.tx = 0;\n    this.ty = 0;\n    return this;\n  }\n  clone() {\n    const matrix = new Matrix();\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  }\n  copyTo(matrix) {\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  }\n  copyFrom(matrix) {\n    this.a = matrix.a;\n    this.b = matrix.b;\n    this.c = matrix.c;\n    this.d = matrix.d;\n    this.tx = matrix.tx;\n    this.ty = matrix.ty;\n    return this;\n  }\n  toString() {\n    return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n  }\n  static get IDENTITY() {\n    return new Matrix();\n  }\n  static get TEMP_MATRIX() {\n    return new Matrix();\n  }\n}\n\n\n//# sourceMappingURL=Matrix.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/groupD8.mjs\n\n\nconst ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nconst uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\nconst rotationCayley = [];\nconst rotationMatrices = [];\nconst signum = Math.sign;\nfunction init() {\n  for (let i = 0; i < 16; i++) {\n    const row = [];\n    rotationCayley.push(row);\n    for (let j = 0; j < 16; j++) {\n      const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);\n      const _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);\n      const _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);\n      const _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);\n      for (let k = 0; k < 16; k++) {\n        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {\n          row.push(k);\n          break;\n        }\n      }\n    }\n  }\n  for (let i = 0; i < 16; i++) {\n    const mat = new Matrix();\n    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);\n    rotationMatrices.push(mat);\n  }\n}\ninit();\nconst groupD8 = {\n  E: 0,\n  SE: 1,\n  S: 2,\n  SW: 3,\n  W: 4,\n  NW: 5,\n  N: 6,\n  NE: 7,\n  MIRROR_VERTICAL: 8,\n  MAIN_DIAGONAL: 10,\n  MIRROR_HORIZONTAL: 12,\n  REVERSE_DIAGONAL: 14,\n  uX: (ind) => ux[ind],\n  uY: (ind) => uy[ind],\n  vX: (ind) => vx[ind],\n  vY: (ind) => vy[ind],\n  inv: (rotation) => {\n    if (rotation & 8) {\n      return rotation & 15;\n    }\n    return -rotation & 7;\n  },\n  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],\n  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],\n  rotate180: (rotation) => rotation ^ 4,\n  isVertical: (rotation) => (rotation & 3) === 2,\n  byDirection: (dx, dy) => {\n    if (Math.abs(dx) * 2 <= Math.abs(dy)) {\n      if (dy >= 0) {\n        return groupD8.S;\n      }\n      return groupD8.N;\n    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {\n      if (dx > 0) {\n        return groupD8.E;\n      }\n      return groupD8.W;\n    } else if (dy > 0) {\n      if (dx > 0) {\n        return groupD8.SE;\n      }\n      return groupD8.SW;\n    } else if (dx > 0) {\n      return groupD8.NE;\n    }\n    return groupD8.NW;\n  },\n  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {\n    const mat = rotationMatrices[groupD8.inv(rotation)];\n    mat.tx = tx;\n    mat.ty = ty;\n    matrix.append(mat);\n  }\n};\n\n\n//# sourceMappingURL=groupD8.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/ObservablePoint.mjs\nclass ObservablePoint {\n  constructor(cb, scope, x = 0, y = 0) {\n    this._x = x;\n    this._y = y;\n    this.cb = cb;\n    this.scope = scope;\n  }\n  clone(cb = this.cb, scope = this.scope) {\n    return new ObservablePoint(cb, scope, this._x, this._y);\n  }\n  set(x = 0, y = x) {\n    if (this._x !== x || this._y !== y) {\n      this._x = x;\n      this._y = y;\n      this.cb.call(this.scope);\n    }\n    return this;\n  }\n  copyFrom(p) {\n    if (this._x !== p.x || this._y !== p.y) {\n      this._x = p.x;\n      this._y = p.y;\n      this.cb.call(this.scope);\n    }\n    return this;\n  }\n  copyTo(p) {\n    p.set(this._x, this._y);\n    return p;\n  }\n  equals(p) {\n    return p.x === this._x && p.y === this._y;\n  }\n  toString() {\n    return `[@pixi/math:ObservablePoint x=${0} y=${0} scope=${this.scope}]`;\n  }\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    if (this._x !== value) {\n      this._x = value;\n      this.cb.call(this.scope);\n    }\n  }\n  get y() {\n    return this._y;\n  }\n  set y(value) {\n    if (this._y !== value) {\n      this._y = value;\n      this.cb.call(this.scope);\n    }\n  }\n}\n\n\n//# sourceMappingURL=ObservablePoint.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/Transform.mjs\n\n\n\nconst _Transform = class {\n  constructor() {\n    this.worldTransform = new Matrix();\n    this.localTransform = new Matrix();\n    this.position = new ObservablePoint(this.onChange, this, 0, 0);\n    this.scale = new ObservablePoint(this.onChange, this, 1, 1);\n    this.pivot = new ObservablePoint(this.onChange, this, 0, 0);\n    this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);\n    this._rotation = 0;\n    this._cx = 1;\n    this._sx = 0;\n    this._cy = 0;\n    this._sy = 1;\n    this._localID = 0;\n    this._currentLocalID = 0;\n    this._worldID = 0;\n    this._parentID = 0;\n  }\n  onChange() {\n    this._localID++;\n  }\n  updateSkew() {\n    this._cx = Math.cos(this._rotation + this.skew.y);\n    this._sx = Math.sin(this._rotation + this.skew.y);\n    this._cy = -Math.sin(this._rotation - this.skew.x);\n    this._sy = Math.cos(this._rotation - this.skew.x);\n    this._localID++;\n  }\n  toString() {\n    return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;\n  }\n  updateLocalTransform() {\n    const lt = this.localTransform;\n    if (this._localID !== this._currentLocalID) {\n      lt.a = this._cx * this.scale.x;\n      lt.b = this._sx * this.scale.x;\n      lt.c = this._cy * this.scale.y;\n      lt.d = this._sy * this.scale.y;\n      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);\n      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);\n      this._currentLocalID = this._localID;\n      this._parentID = -1;\n    }\n  }\n  updateTransform(parentTransform) {\n    const lt = this.localTransform;\n    if (this._localID !== this._currentLocalID) {\n      lt.a = this._cx * this.scale.x;\n      lt.b = this._sx * this.scale.x;\n      lt.c = this._cy * this.scale.y;\n      lt.d = this._sy * this.scale.y;\n      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);\n      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);\n      this._currentLocalID = this._localID;\n      this._parentID = -1;\n    }\n    if (this._parentID !== parentTransform._worldID) {\n      const pt = parentTransform.worldTransform;\n      const wt = this.worldTransform;\n      wt.a = lt.a * pt.a + lt.b * pt.c;\n      wt.b = lt.a * pt.b + lt.b * pt.d;\n      wt.c = lt.c * pt.a + lt.d * pt.c;\n      wt.d = lt.c * pt.b + lt.d * pt.d;\n      wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\n      wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\n      this._parentID = parentTransform._worldID;\n      this._worldID++;\n    }\n  }\n  setFromMatrix(matrix) {\n    matrix.decompose(this);\n    this._localID++;\n  }\n  get rotation() {\n    return this._rotation;\n  }\n  set rotation(value) {\n    if (this._rotation !== value) {\n      this._rotation = value;\n      this.updateSkew();\n    }\n  }\n};\nlet Transform_Transform = _Transform;\nTransform_Transform.IDENTITY = new _Transform();\n\n\n//# sourceMappingURL=Transform.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/math/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/defaultProgram.mjs\nvar defaultFragment = "varying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\n\\nvoid main(void){\\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\\n}";\n\n\n//# sourceMappingURL=defaultProgram.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/defaultProgram2.mjs\nvar defaultVertex = "attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void){\\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n   vTextureCoord = aTextureCoord;\\n}\\n";\n\n\n//# sourceMappingURL=defaultProgram2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/uniformParsers.mjs\nconst uniformParsers = [\n  {\n    test: (data) => data.type === "float" && data.size === 1 && !data.isArray,\n    code: (name) => `\n            if(uv["${name}"] !== ud["${name}"].value)\n            {\n                ud["${name}"].value = uv["${name}"]\n                gl.uniform1f(ud["${name}"].location, uv["${name}"])\n            }\n            `\n  },\n  {\n    test: (data, uniform) => (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray && (uniform == null || uniform.castToBaseTexture !== void 0),\n    code: (name) => `t = syncData.textureCount++;\n\n            renderer.texture.bind(uv["${name}"], t);\n\n            if(ud["${name}"].value !== t)\n            {\n                ud["${name}"].value = t;\n                gl.uniform1i(ud["${name}"].location, t);\n; // eslint-disable-line max-len\n            }`\n  },\n  {\n    test: (data, uniform) => data.type === "mat3" && data.size === 1 && !data.isArray && uniform.a !== void 0,\n    code: (name) => `\n            gl.uniformMatrix3fv(ud["${name}"].location, false, uv["${name}"].toArray(true));\n            `,\n    codeUbo: (name) => `\n                var ${name}_matrix = uv.${name}.toArray(true);\n\n                data[offset] = ${name}_matrix[0];\n                data[offset+1] = ${name}_matrix[1];\n                data[offset+2] = ${name}_matrix[2];\n        \n                data[offset + 4] = ${name}_matrix[3];\n                data[offset + 5] = ${name}_matrix[4];\n                data[offset + 6] = ${name}_matrix[5];\n        \n                data[offset + 8] = ${name}_matrix[6];\n                data[offset + 9] = ${name}_matrix[7];\n                data[offset + 10] = ${name}_matrix[8];\n            `\n  },\n  {\n    test: (data, uniform) => data.type === "vec2" && data.size === 1 && !data.isArray && uniform.x !== void 0,\n    code: (name) => `\n                cv = ud["${name}"].value;\n                v = uv["${name}"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["${name}"].location, v.x, v.y);\n                }`,\n    codeUbo: (name) => `\n                v = uv.${name};\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            `\n  },\n  {\n    test: (data) => data.type === "vec2" && data.size === 1 && !data.isArray,\n    code: (name) => `\n                cv = ud["${name}"].value;\n                v = uv["${name}"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["${name}"].location, v[0], v[1]);\n                }\n            `\n  },\n  {\n    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.width !== void 0,\n    code: (name) => `\n                cv = ud["${name}"].value;\n                v = uv["${name}"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["${name}"].location, v.x, v.y, v.width, v.height)\n                }`,\n    codeUbo: (name) => `\n                    v = uv.${name};\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                `\n  },\n  {\n    test: (data, uniform) => data.type === "vec4" && data.size === 1 && !data.isArray && uniform.red !== void 0,\n    code: (name) => `\n                cv = ud["${name}"].value;\n                v = uv["${name}"];\n\n                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)\n                {\n                    cv[0] = v.red;\n                    cv[1] = v.green;\n                    cv[2] = v.blue;\n                    cv[3] = v.alpha;\n                    gl.uniform4f(ud["${name}"].location, v.red, v.green, v.blue, v.alpha)\n                }`,\n    codeUbo: (name) => `\n                    v = uv.${name};\n\n                    data[offset] = v.red;\n                    data[offset+1] = v.green;\n                    data[offset+2] = v.blue;\n                    data[offset+3] = v.alpha;\n                `\n  },\n  {\n    test: (data, uniform) => data.type === "vec3" && data.size === 1 && !data.isArray && uniform.red !== void 0,\n    code: (name) => `\n                cv = ud["${name}"].value;\n                v = uv["${name}"];\n\n                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)\n                {\n                    cv[0] = v.red;\n                    cv[1] = v.green;\n                    cv[2] = v.blue;\n    \n                    gl.uniform3f(ud["${name}"].location, v.red, v.green, v.blue)\n                }`,\n    codeUbo: (name) => `\n                    v = uv.${name};\n\n                    data[offset] = v.red;\n                    data[offset+1] = v.green;\n                    data[offset+2] = v.blue;\n                `\n  },\n  {\n    test: (data) => data.type === "vec4" && data.size === 1 && !data.isArray,\n    code: (name) => `\n                cv = ud["${name}"].value;\n                v = uv["${name}"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["${name}"].location, v[0], v[1], v[2], v[3])\n                }`\n  }\n];\n\n\n//# sourceMappingURL=uniformParsers.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/generateUniformsSync.mjs\n\n\nconst GLSL_TO_SINGLE_SETTERS_CACHED = {\n  float: `\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }`,\n  vec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }`,\n  vec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }`,\n  vec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }`,\n  int: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  ivec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }`,\n  ivec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }`,\n  ivec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }`,\n  uint: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }`,\n  uvec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }`,\n  uvec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }`,\n  uvec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }`,\n  bool: `\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }`,\n  bvec2: `\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }`,\n  bvec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }`,\n  bvec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }`,\n  mat2: "gl.uniformMatrix2fv(location, false, v)",\n  mat3: "gl.uniformMatrix3fv(location, false, v)",\n  mat4: "gl.uniformMatrix4fv(location, false, v)",\n  sampler2D: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  samplerCube: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  sampler2DArray: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`\n};\nconst GLSL_TO_ARRAY_SETTERS = {\n  float: `gl.uniform1fv(location, v)`,\n  vec2: `gl.uniform2fv(location, v)`,\n  vec3: `gl.uniform3fv(location, v)`,\n  vec4: "gl.uniform4fv(location, v)",\n  mat4: "gl.uniformMatrix4fv(location, false, v)",\n  mat3: "gl.uniformMatrix3fv(location, false, v)",\n  mat2: "gl.uniformMatrix2fv(location, false, v)",\n  int: "gl.uniform1iv(location, v)",\n  ivec2: "gl.uniform2iv(location, v)",\n  ivec3: "gl.uniform3iv(location, v)",\n  ivec4: "gl.uniform4iv(location, v)",\n  uint: "gl.uniform1uiv(location, v)",\n  uvec2: "gl.uniform2uiv(location, v)",\n  uvec3: "gl.uniform3uiv(location, v)",\n  uvec4: "gl.uniform4uiv(location, v)",\n  bool: "gl.uniform1iv(location, v)",\n  bvec2: "gl.uniform2iv(location, v)",\n  bvec3: "gl.uniform3iv(location, v)",\n  bvec4: "gl.uniform4iv(location, v)",\n  sampler2D: "gl.uniform1iv(location, v)",\n  samplerCube: "gl.uniform1iv(location, v)",\n  sampler2DArray: "gl.uniform1iv(location, v)"\n};\nfunction generateUniformsSync(group, uniformData) {\n  const funcFragments = [`\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    `];\n  for (const i in group.uniforms) {\n    const data = uniformData[i];\n    if (!data) {\n      if (group.uniforms[i]?.group) {\n        if (group.uniforms[i].ubo) {\n          funcFragments.push(`\n                        renderer.shader.syncUniformBufferGroup(uv.${i}, \'${i}\');\n                    `);\n        } else {\n          funcFragments.push(`\n                        renderer.shader.syncUniformGroup(uv.${i}, syncData);\n                    `);\n        }\n      }\n      continue;\n    }\n    const uniform = group.uniforms[i];\n    let parsed = false;\n    for (let j = 0; j < uniformParsers.length; j++) {\n      if (uniformParsers[j].test(data, uniform)) {\n        funcFragments.push(uniformParsers[j].code(i, uniform));\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      const templateType = data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;\n      const template = templateType[data.type].replace("location", `ud["${i}"].location`);\n      funcFragments.push(`\n            cu = ud["${i}"];\n            cv = cu.value;\n            v = uv["${i}"];\n            ${template};`);\n    }\n  }\n  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\\n"));\n}\n\n\n//# sourceMappingURL=generateUniformsSync.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/getTestContext.mjs\n\n\n\nconst unknownContext = {};\nlet context = unknownContext;\nfunction getTestContext() {\n  if (context === unknownContext || context?.isContextLost()) {\n    const canvas = settings_lib/* settings */.Xd.ADAPTER.createCanvas();\n    let gl;\n    if (settings_lib/* settings */.Xd.PREFER_ENV >= lib/* ENV */.Vi.WEBGL2) {\n      gl = canvas.getContext("webgl2", {});\n    }\n    if (!gl) {\n      gl = canvas.getContext("webgl", {}) || canvas.getContext("experimental-webgl", {});\n      if (!gl) {\n        gl = null;\n      } else {\n        gl.getExtension("WEBGL_draw_buffers");\n      }\n    }\n    context = gl;\n  }\n  return context;\n}\n\n\n//# sourceMappingURL=getTestContext.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/getMaxFragmentPrecision.mjs\n\n\n\nlet maxFragmentPrecision;\nfunction getMaxFragmentPrecision() {\n  if (!maxFragmentPrecision) {\n    maxFragmentPrecision = lib/* PRECISION */.cB.MEDIUM;\n    const gl = getTestContext();\n    if (gl) {\n      if (gl.getShaderPrecisionFormat) {\n        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n        maxFragmentPrecision = shaderFragment.precision ? lib/* PRECISION */.cB.HIGH : lib/* PRECISION */.cB.MEDIUM;\n      }\n    }\n  }\n  return maxFragmentPrecision;\n}\n\n\n//# sourceMappingURL=getMaxFragmentPrecision.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/mapSize.mjs\nconst GLSL_TO_SIZE = {\n  float: 1,\n  vec2: 2,\n  vec3: 3,\n  vec4: 4,\n  int: 1,\n  ivec2: 2,\n  ivec3: 3,\n  ivec4: 4,\n  uint: 1,\n  uvec2: 2,\n  uvec3: 3,\n  uvec4: 4,\n  bool: 1,\n  bvec2: 2,\n  bvec3: 3,\n  bvec4: 4,\n  mat2: 4,\n  mat3: 9,\n  mat4: 16,\n  sampler2D: 1\n};\nfunction mapSize(type) {\n  return GLSL_TO_SIZE[type];\n}\n\n\n//# sourceMappingURL=mapSize.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/mapType.mjs\nlet GL_TABLE = null;\nconst GL_TO_GLSL_TYPES = {\n  FLOAT: "float",\n  FLOAT_VEC2: "vec2",\n  FLOAT_VEC3: "vec3",\n  FLOAT_VEC4: "vec4",\n  INT: "int",\n  INT_VEC2: "ivec2",\n  INT_VEC3: "ivec3",\n  INT_VEC4: "ivec4",\n  UNSIGNED_INT: "uint",\n  UNSIGNED_INT_VEC2: "uvec2",\n  UNSIGNED_INT_VEC3: "uvec3",\n  UNSIGNED_INT_VEC4: "uvec4",\n  BOOL: "bool",\n  BOOL_VEC2: "bvec2",\n  BOOL_VEC3: "bvec3",\n  BOOL_VEC4: "bvec4",\n  FLOAT_MAT2: "mat2",\n  FLOAT_MAT3: "mat3",\n  FLOAT_MAT4: "mat4",\n  SAMPLER_2D: "sampler2D",\n  INT_SAMPLER_2D: "sampler2D",\n  UNSIGNED_INT_SAMPLER_2D: "sampler2D",\n  SAMPLER_CUBE: "samplerCube",\n  INT_SAMPLER_CUBE: "samplerCube",\n  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",\n  SAMPLER_2D_ARRAY: "sampler2DArray",\n  INT_SAMPLER_2D_ARRAY: "sampler2DArray",\n  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"\n};\nfunction mapType(gl, type) {\n  if (!GL_TABLE) {\n    const typeNames = Object.keys(GL_TO_GLSL_TYPES);\n    GL_TABLE = {};\n    for (let i = 0; i < typeNames.length; ++i) {\n      const tn = typeNames[i];\n      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];\n    }\n  }\n  return GL_TABLE[type];\n}\n\n\n//# sourceMappingURL=mapType.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/setPrecision.mjs\n\n\nfunction setPrecision(src, requestedPrecision, maxSupportedPrecision) {\n  if (src.substring(0, 9) !== "precision") {\n    let precision = requestedPrecision;\n    if (requestedPrecision === lib/* PRECISION */.cB.HIGH && maxSupportedPrecision !== lib/* PRECISION */.cB.HIGH) {\n      precision = lib/* PRECISION */.cB.MEDIUM;\n    }\n    return `precision ${precision} float;\n${src}`;\n  } else if (maxSupportedPrecision !== lib/* PRECISION */.cB.HIGH && src.substring(0, 15) === "precision highp") {\n    return src.replace("precision highp", "precision mediump");\n  }\n  return src;\n}\n\n\n//# sourceMappingURL=setPrecision.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/Program.mjs\n\n\n\n\n\n\n\n\nlet Program_UID = 0;\nconst nameCache = {};\nconst _Program = class {\n  constructor(vertexSrc, fragmentSrc, name = "pixi-shader", extra = {}) {\n    this.extra = {};\n    this.id = Program_UID++;\n    this.vertexSrc = vertexSrc || _Program.defaultVertexSrc;\n    this.fragmentSrc = fragmentSrc || _Program.defaultFragmentSrc;\n    this.vertexSrc = this.vertexSrc.trim();\n    this.fragmentSrc = this.fragmentSrc.trim();\n    this.extra = extra;\n    if (this.vertexSrc.substring(0, 8) !== "#version") {\n      name = name.replace(/\\s+/g, "-");\n      if (nameCache[name]) {\n        nameCache[name]++;\n        name += `-${nameCache[name]}`;\n      } else {\n        nameCache[name] = 1;\n      }\n      this.vertexSrc = `#define SHADER_NAME ${name}\n${this.vertexSrc}`;\n      this.fragmentSrc = `#define SHADER_NAME ${name}\n${this.fragmentSrc}`;\n      this.vertexSrc = setPrecision(this.vertexSrc, _Program.defaultVertexPrecision, lib/* PRECISION */.cB.HIGH);\n      this.fragmentSrc = setPrecision(this.fragmentSrc, _Program.defaultFragmentPrecision, getMaxFragmentPrecision());\n    }\n    this.glPrograms = {};\n    this.syncUniforms = null;\n  }\n  static get defaultVertexSrc() {\n    return defaultVertex;\n  }\n  static get defaultFragmentSrc() {\n    return defaultFragment;\n  }\n  static from(vertexSrc, fragmentSrc, name) {\n    const key = vertexSrc + fragmentSrc;\n    let program = utils_lib.ProgramCache[key];\n    if (!program) {\n      utils_lib.ProgramCache[key] = program = new _Program(vertexSrc, fragmentSrc, name);\n    }\n    return program;\n  }\n};\nlet Program = _Program;\nProgram.defaultVertexPrecision = lib/* PRECISION */.cB.HIGH;\nProgram.defaultFragmentPrecision = utils_lib.isMobile.apple.device ? lib/* PRECISION */.cB.HIGH : lib/* PRECISION */.cB.MEDIUM;\n\n\n//# sourceMappingURL=Program.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/UniformGroup.mjs\n\n\n\nlet UniformGroup_UID = 0;\nclass UniformGroup {\n  constructor(uniforms, isStatic, isUbo) {\n    this.group = true;\n    this.syncUniforms = {};\n    this.dirtyId = 0;\n    this.id = UniformGroup_UID++;\n    this.static = !!isStatic;\n    this.ubo = !!isUbo;\n    if (uniforms instanceof Buffer) {\n      this.buffer = uniforms;\n      this.buffer.type = lib/* BUFFER_TYPE */.mr.UNIFORM_BUFFER;\n      this.autoManage = false;\n      this.ubo = true;\n    } else {\n      this.uniforms = uniforms;\n      if (this.ubo) {\n        this.buffer = new Buffer(new Float32Array(1));\n        this.buffer.type = lib/* BUFFER_TYPE */.mr.UNIFORM_BUFFER;\n        this.autoManage = true;\n      }\n    }\n  }\n  update() {\n    this.dirtyId++;\n    if (!this.autoManage && this.buffer) {\n      this.buffer.update();\n    }\n  }\n  add(name, uniforms, _static) {\n    if (!this.ubo) {\n      this.uniforms[name] = new UniformGroup(uniforms, _static);\n    } else {\n      throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");\n    }\n  }\n  static from(uniforms, _static, _ubo) {\n    return new UniformGroup(uniforms, _static, _ubo);\n  }\n  static uboFrom(uniforms, _static) {\n    return new UniformGroup(uniforms, _static ?? true, true);\n  }\n}\n\n\n//# sourceMappingURL=UniformGroup.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/Shader.mjs\n\n\n\n\nclass Shader {\n  constructor(program, uniforms) {\n    this.uniformBindCount = 0;\n    this.program = program;\n    if (uniforms) {\n      if (uniforms instanceof UniformGroup) {\n        this.uniformGroup = uniforms;\n      } else {\n        this.uniformGroup = new UniformGroup(uniforms);\n      }\n    } else {\n      this.uniformGroup = new UniformGroup({});\n    }\n    this.disposeRunner = new Runner_Runner("disposeShader");\n  }\n  checkUniformExists(name, group) {\n    if (group.uniforms[name]) {\n      return true;\n    }\n    for (const i in group.uniforms) {\n      const uniform = group.uniforms[i];\n      if (uniform.group) {\n        if (this.checkUniformExists(name, uniform)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  destroy() {\n    this.uniformGroup = null;\n    this.disposeRunner.emit(this);\n    this.disposeRunner.destroy();\n  }\n  get uniforms() {\n    return this.uniformGroup.uniforms;\n  }\n  static from(vertexSrc, fragmentSrc, uniforms) {\n    const program = Program.from(vertexSrc, fragmentSrc);\n    return new Shader(program, uniforms);\n  }\n}\n\n\n//# sourceMappingURL=Shader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/BatchShaderGenerator.mjs\n\n\n\n\n\nclass BatchShaderGenerator {\n  constructor(vertexSrc, fragTemplate) {\n    this.vertexSrc = vertexSrc;\n    this.fragTemplate = fragTemplate;\n    this.programCache = {};\n    this.defaultGroupCache = {};\n    if (!fragTemplate.includes("%count%")) {\n      throw new Error(\'Fragment template must contain "%count%".\');\n    }\n    if (!fragTemplate.includes("%forloop%")) {\n      throw new Error(\'Fragment template must contain "%forloop%".\');\n    }\n  }\n  generateShader(maxTextures) {\n    if (!this.programCache[maxTextures]) {\n      const sampleValues = new Int32Array(maxTextures);\n      for (let i = 0; i < maxTextures; i++) {\n        sampleValues[i] = i;\n      }\n      this.defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, true);\n      let fragmentSrc = this.fragTemplate;\n      fragmentSrc = fragmentSrc.replace(/%count%/gi, `${maxTextures}`);\n      fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));\n      this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);\n    }\n    const uniforms = {\n      tint: new Float32Array([1, 1, 1, 1]),\n      translationMatrix: new Matrix(),\n      default: this.defaultGroupCache[maxTextures]\n    };\n    return new Shader(this.programCache[maxTextures], uniforms);\n  }\n  generateSampleSrc(maxTextures) {\n    let src = "";\n    src += "\\n";\n    src += "\\n";\n    for (let i = 0; i < maxTextures; i++) {\n      if (i > 0) {\n        src += "\\nelse ";\n      }\n      if (i < maxTextures - 1) {\n        src += `if(vTextureId < ${i}.5)`;\n      }\n      src += "\\n{";\n      src += `\n\tcolor = texture2D(uSamplers[${i}], vTextureCoord);`;\n      src += "\\n}";\n    }\n    src += "\\n";\n    src += "\\n";\n    return src;\n  }\n}\n\n\n//# sourceMappingURL=BatchShaderGenerator.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/BatchTextureArray.mjs\nclass BatchTextureArray {\n  constructor() {\n    this.elements = [];\n    this.ids = [];\n    this.count = 0;\n  }\n  clear() {\n    for (let i = 0; i < this.count; i++) {\n      this.elements[i] = null;\n    }\n    this.count = 0;\n  }\n}\n\n\n//# sourceMappingURL=BatchTextureArray.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/canUploadSameBuffer.mjs\n\n\nfunction canUploadSameBuffer() {\n  return !settings_lib/* isMobile */.tq.apple.device;\n}\n\n\n//# sourceMappingURL=canUploadSameBuffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/maxRecommendedTextures.mjs\n\n\nfunction maxRecommendedTextures(max) {\n  let allowMax = true;\n  const navigator = settings_lib/* settings */.Xd.ADAPTER.getNavigator();\n  if (settings_lib/* isMobile */.tq.tablet || settings_lib/* isMobile */.tq.phone) {\n    if (settings_lib/* isMobile */.tq.apple.device) {\n      const match = navigator.userAgent.match(/OS (\\d+)_(\\d+)?/);\n      if (match) {\n        const majorVersion = parseInt(match[1], 10);\n        if (majorVersion < 11) {\n          allowMax = false;\n        }\n      }\n    }\n    if (settings_lib/* isMobile */.tq.android.device) {\n      const match = navigator.userAgent.match(/Android\\s([0-9.]*)/);\n      if (match) {\n        const majorVersion = parseInt(match[1], 10);\n        if (majorVersion < 7) {\n          allowMax = false;\n        }\n      }\n    }\n  }\n  return allowMax ? max : 4;\n}\n\n\n//# sourceMappingURL=maxRecommendedTextures.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/ObjectRenderer.mjs\nclass ObjectRenderer {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  flush() {\n  }\n  destroy() {\n    this.renderer = null;\n  }\n  start() {\n  }\n  stop() {\n    this.flush();\n  }\n  render(_object) {\n  }\n}\n\n\n//# sourceMappingURL=ObjectRenderer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/texture.mjs\nvar texture_defaultFragment = "varying vec2 vTextureCoord;\\nvarying vec4 vColor;\\nvarying float vTextureId;\\nuniform sampler2D uSamplers[%count%];\\n\\nvoid main(void){\\n    vec4 color;\\n    %forloop%\\n    gl_FragColor = color * vColor;\\n}\\n";\n\n\n//# sourceMappingURL=texture.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/texture2.mjs\nvar texture2_defaultVertex = "precision highp float;\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\nattribute float aTextureId;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform vec4 tint;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\nvarying float vTextureId;\\n\\nvoid main(void){\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = aTextureCoord;\\n    vTextureId = aTextureId;\\n    vColor = aColor * tint;\\n}\\n";\n\n\n//# sourceMappingURL=texture2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/BatchRenderer.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst _BatchRenderer = class extends ObjectRenderer {\n  constructor(renderer) {\n    super(renderer);\n    this.setShaderGenerator();\n    this.geometryClass = BatchGeometry;\n    this.vertexSize = 6;\n    this.state = State.for2d();\n    this.size = _BatchRenderer.defaultBatchSize * 4;\n    this._vertexCount = 0;\n    this._indexCount = 0;\n    this._bufferedElements = [];\n    this._bufferedTextures = [];\n    this._bufferSize = 0;\n    this._shader = null;\n    this._packedGeometries = [];\n    this._packedGeometryPoolSize = 2;\n    this._flushId = 0;\n    this._aBuffers = {};\n    this._iBuffers = {};\n    this.maxTextures = 1;\n    this.renderer.on("prerender", this.onPrerender, this);\n    renderer.runners.contextChange.add(this);\n    this._dcIndex = 0;\n    this._aIndex = 0;\n    this._iIndex = 0;\n    this._attributeBuffer = null;\n    this._indexBuffer = null;\n    this._tempBoundTextures = [];\n  }\n  static get defaultMaxTextures() {\n    this._defaultMaxTextures = this._defaultMaxTextures ?? maxRecommendedTextures(32);\n    return this._defaultMaxTextures;\n  }\n  static set defaultMaxTextures(value) {\n    this._defaultMaxTextures = value;\n  }\n  static get canUploadSameBuffer() {\n    this._canUploadSameBuffer = this._canUploadSameBuffer ?? canUploadSameBuffer();\n    return this._canUploadSameBuffer;\n  }\n  static set canUploadSameBuffer(value) {\n    this._canUploadSameBuffer = value;\n  }\n  get MAX_TEXTURES() {\n    (0,utils_lib.deprecation)("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures");\n    return this.maxTextures;\n  }\n  static get defaultVertexSrc() {\n    return texture2_defaultVertex;\n  }\n  static get defaultFragmentTemplate() {\n    return texture_defaultFragment;\n  }\n  setShaderGenerator({\n    vertex = _BatchRenderer.defaultVertexSrc,\n    fragment = _BatchRenderer.defaultFragmentTemplate\n  } = {}) {\n    this.shaderGenerator = new BatchShaderGenerator(vertex, fragment);\n  }\n  contextChange() {\n    const gl = this.renderer.gl;\n    if (settings_lib/* settings */.Xd.PREFER_ENV === lib/* ENV */.Vi.WEBGL_LEGACY) {\n      this.maxTextures = 1;\n    } else {\n      this.maxTextures = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), _BatchRenderer.defaultMaxTextures);\n      this.maxTextures = checkMaxIfStatementsInShader(this.maxTextures, gl);\n    }\n    this._shader = this.shaderGenerator.generateShader(this.maxTextures);\n    for (let i = 0; i < this._packedGeometryPoolSize; i++) {\n      this._packedGeometries[i] = new this.geometryClass();\n    }\n    this.initFlushBuffers();\n  }\n  initFlushBuffers() {\n    const {\n      _drawCallPool,\n      _textureArrayPool\n    } = _BatchRenderer;\n    const MAX_SPRITES = this.size / 4;\n    const MAX_TA = Math.floor(MAX_SPRITES / this.maxTextures) + 1;\n    while (_drawCallPool.length < MAX_SPRITES) {\n      _drawCallPool.push(new BatchDrawCall());\n    }\n    while (_textureArrayPool.length < MAX_TA) {\n      _textureArrayPool.push(new BatchTextureArray());\n    }\n    for (let i = 0; i < this.maxTextures; i++) {\n      this._tempBoundTextures[i] = null;\n    }\n  }\n  onPrerender() {\n    this._flushId = 0;\n  }\n  render(element) {\n    if (!element._texture.valid) {\n      return;\n    }\n    if (this._vertexCount + element.vertexData.length / 2 > this.size) {\n      this.flush();\n    }\n    this._vertexCount += element.vertexData.length / 2;\n    this._indexCount += element.indices.length;\n    this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;\n    this._bufferedElements[this._bufferSize++] = element;\n  }\n  buildTexturesAndDrawCalls() {\n    const {\n      _bufferedTextures: textures,\n      maxTextures\n    } = this;\n    const textureArrays = _BatchRenderer._textureArrayPool;\n    const batch = this.renderer.batch;\n    const boundTextures = this._tempBoundTextures;\n    const touch = this.renderer.textureGC.count;\n    let TICK = ++BaseTexture._globalBatch;\n    let countTexArrays = 0;\n    let texArray = textureArrays[0];\n    let start = 0;\n    batch.copyBoundTextures(boundTextures, maxTextures);\n    for (let i = 0; i < this._bufferSize; ++i) {\n      const tex = textures[i];\n      textures[i] = null;\n      if (tex._batchEnabled === TICK) {\n        continue;\n      }\n      if (texArray.count >= maxTextures) {\n        batch.boundArray(texArray, boundTextures, TICK, maxTextures);\n        this.buildDrawCalls(texArray, start, i);\n        start = i;\n        texArray = textureArrays[++countTexArrays];\n        ++TICK;\n      }\n      tex._batchEnabled = TICK;\n      tex.touched = touch;\n      texArray.elements[texArray.count++] = tex;\n    }\n    if (texArray.count > 0) {\n      batch.boundArray(texArray, boundTextures, TICK, maxTextures);\n      this.buildDrawCalls(texArray, start, this._bufferSize);\n      ++countTexArrays;\n      ++TICK;\n    }\n    for (let i = 0; i < boundTextures.length; i++) {\n      boundTextures[i] = null;\n    }\n    BaseTexture._globalBatch = TICK;\n  }\n  buildDrawCalls(texArray, start, finish) {\n    const {\n      _bufferedElements: elements,\n      _attributeBuffer,\n      _indexBuffer,\n      vertexSize\n    } = this;\n    const drawCalls = _BatchRenderer._drawCallPool;\n    let dcIndex = this._dcIndex;\n    let aIndex = this._aIndex;\n    let iIndex = this._iIndex;\n    let drawCall = drawCalls[dcIndex];\n    drawCall.start = this._iIndex;\n    drawCall.texArray = texArray;\n    for (let i = start; i < finish; ++i) {\n      const sprite = elements[i];\n      const tex = sprite._texture.baseTexture;\n      const spriteBlendMode = utils_lib.premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];\n      elements[i] = null;\n      if (start < i && drawCall.blend !== spriteBlendMode) {\n        drawCall.size = iIndex - drawCall.start;\n        start = i;\n        drawCall = drawCalls[++dcIndex];\n        drawCall.texArray = texArray;\n        drawCall.start = iIndex;\n      }\n      this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);\n      aIndex += sprite.vertexData.length / 2 * vertexSize;\n      iIndex += sprite.indices.length;\n      drawCall.blend = spriteBlendMode;\n    }\n    if (start < finish) {\n      drawCall.size = iIndex - drawCall.start;\n      ++dcIndex;\n    }\n    this._dcIndex = dcIndex;\n    this._aIndex = aIndex;\n    this._iIndex = iIndex;\n  }\n  bindAndClearTexArray(texArray) {\n    const textureSystem = this.renderer.texture;\n    for (let j = 0; j < texArray.count; j++) {\n      textureSystem.bind(texArray.elements[j], texArray.ids[j]);\n      texArray.elements[j] = null;\n    }\n    texArray.count = 0;\n  }\n  updateGeometry() {\n    const {\n      _packedGeometries: packedGeometries,\n      _attributeBuffer: attributeBuffer,\n      _indexBuffer: indexBuffer\n    } = this;\n    if (!_BatchRenderer.canUploadSameBuffer) {\n      if (this._packedGeometryPoolSize <= this._flushId) {\n        this._packedGeometryPoolSize++;\n        packedGeometries[this._flushId] = new this.geometryClass();\n      }\n      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);\n      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);\n      this.renderer.geometry.bind(packedGeometries[this._flushId]);\n      this.renderer.geometry.updateBuffers();\n      this._flushId++;\n    } else {\n      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);\n      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);\n      this.renderer.geometry.updateBuffers();\n    }\n  }\n  drawBatches() {\n    const dcCount = this._dcIndex;\n    const { gl, state: stateSystem } = this.renderer;\n    const drawCalls = _BatchRenderer._drawCallPool;\n    let curTexArray = null;\n    for (let i = 0; i < dcCount; i++) {\n      const { texArray, type, size, start, blend } = drawCalls[i];\n      if (curTexArray !== texArray) {\n        curTexArray = texArray;\n        this.bindAndClearTexArray(texArray);\n      }\n      this.state.blendMode = blend;\n      stateSystem.set(this.state);\n      gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);\n    }\n  }\n  flush() {\n    if (this._vertexCount === 0) {\n      return;\n    }\n    this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);\n    this._indexBuffer = this.getIndexBuffer(this._indexCount);\n    this._aIndex = 0;\n    this._iIndex = 0;\n    this._dcIndex = 0;\n    this.buildTexturesAndDrawCalls();\n    this.updateGeometry();\n    this.drawBatches();\n    this._bufferSize = 0;\n    this._vertexCount = 0;\n    this._indexCount = 0;\n  }\n  start() {\n    this.renderer.state.set(this.state);\n    this.renderer.texture.ensureSamplerType(this.maxTextures);\n    this.renderer.shader.bind(this._shader);\n    if (_BatchRenderer.canUploadSameBuffer) {\n      this.renderer.geometry.bind(this._packedGeometries[this._flushId]);\n    }\n  }\n  stop() {\n    this.flush();\n  }\n  destroy() {\n    for (let i = 0; i < this._packedGeometryPoolSize; i++) {\n      if (this._packedGeometries[i]) {\n        this._packedGeometries[i].destroy();\n      }\n    }\n    this.renderer.off("prerender", this.onPrerender, this);\n    this._aBuffers = null;\n    this._iBuffers = null;\n    this._packedGeometries = null;\n    this._attributeBuffer = null;\n    this._indexBuffer = null;\n    if (this._shader) {\n      this._shader.destroy();\n      this._shader = null;\n    }\n    super.destroy();\n  }\n  getAttributeBuffer(size) {\n    const roundedP2 = (0,utils_lib.nextPow2)(Math.ceil(size / 8));\n    const roundedSizeIndex = (0,utils_lib.log2)(roundedP2);\n    const roundedSize = roundedP2 * 8;\n    if (this._aBuffers.length <= roundedSizeIndex) {\n      this._iBuffers.length = roundedSizeIndex + 1;\n    }\n    let buffer = this._aBuffers[roundedSize];\n    if (!buffer) {\n      this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);\n    }\n    return buffer;\n  }\n  getIndexBuffer(size) {\n    const roundedP2 = (0,utils_lib.nextPow2)(Math.ceil(size / 12));\n    const roundedSizeIndex = (0,utils_lib.log2)(roundedP2);\n    const roundedSize = roundedP2 * 12;\n    if (this._iBuffers.length <= roundedSizeIndex) {\n      this._iBuffers.length = roundedSizeIndex + 1;\n    }\n    let buffer = this._iBuffers[roundedSizeIndex];\n    if (!buffer) {\n      this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);\n    }\n    return buffer;\n  }\n  packInterleavedGeometry(element, attributeBuffer, indexBuffer, aIndex, iIndex) {\n    const {\n      uint32View,\n      float32View\n    } = attributeBuffer;\n    const packedVertices = aIndex / this.vertexSize;\n    const uvs = element.uvs;\n    const indicies = element.indices;\n    const vertexData = element.vertexData;\n    const textureId = element._texture.baseTexture._batchLocation;\n    const alpha = Math.min(element.worldAlpha, 1);\n    const argb = color_lib/* Color */.I.shared.setValue(element._tintRGB).toPremultiplied(alpha, element._texture.baseTexture.alphaMode > 0);\n    for (let i = 0; i < vertexData.length; i += 2) {\n      float32View[aIndex++] = vertexData[i];\n      float32View[aIndex++] = vertexData[i + 1];\n      float32View[aIndex++] = uvs[i];\n      float32View[aIndex++] = uvs[i + 1];\n      uint32View[aIndex++] = argb;\n      float32View[aIndex++] = textureId;\n    }\n    for (let i = 0; i < indicies.length; i++) {\n      indexBuffer[iIndex++] = packedVertices + indicies[i];\n    }\n  }\n};\nlet BatchRenderer = _BatchRenderer;\nBatchRenderer.defaultBatchSize = 4096;\nBatchRenderer.extension = {\n  name: "batch",\n  type: ExtensionType.RendererPlugin\n};\nBatchRenderer._drawCallPool = [];\nBatchRenderer._textureArrayPool = [];\nextensions.add(BatchRenderer);\n\n\n//# sourceMappingURL=BatchRenderer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/defaultFilter.mjs\nvar defaultFilter_defaultFragment = "varying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\n\\nvoid main(void){\\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\\n}\\n";\n\n\n//# sourceMappingURL=defaultFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/defaultFilter2.mjs\nvar defaultFilter2_defaultVertex = "attribute vec2 aVertexPosition;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform vec4 inputSize;\\nuniform vec4 outputFrame;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\\n\\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n}\\n";\n\n\n//# sourceMappingURL=defaultFilter2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/Filter.mjs\n\n\n\n\n\n\n\nconst _Filter = class extends Shader {\n  constructor(vertexSrc, fragmentSrc, uniforms) {\n    const program = Program.from(vertexSrc || _Filter.defaultVertexSrc, fragmentSrc || _Filter.defaultFragmentSrc);\n    super(program, uniforms);\n    this.padding = 0;\n    this.resolution = _Filter.defaultResolution;\n    this.multisample = _Filter.defaultMultisample;\n    this.enabled = true;\n    this.autoFit = true;\n    this.state = new State();\n  }\n  apply(filterManager, input, output, clearMode, _currentState) {\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  get blendMode() {\n    return this.state.blendMode;\n  }\n  set blendMode(value) {\n    this.state.blendMode = value;\n  }\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(value) {\n    this._resolution = value;\n  }\n  static get defaultVertexSrc() {\n    return defaultFilter2_defaultVertex;\n  }\n  static get defaultFragmentSrc() {\n    return defaultFilter_defaultFragment;\n  }\n};\nlet Filter = _Filter;\nFilter.defaultResolution = 1;\nFilter.defaultMultisample = lib/* MSAA_QUALITY */.G5.NONE;\n\n\n//# sourceMappingURL=Filter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/background/BackgroundSystem.mjs\n\n\n\nclass BackgroundSystem {\n  constructor() {\n    this.clearBeforeRender = true;\n    this._backgroundColor = new color_lib/* Color */.I(0);\n    this.alpha = 1;\n  }\n  init(options) {\n    this.clearBeforeRender = options.clearBeforeRender;\n    const { backgroundColor, background, backgroundAlpha } = options;\n    const color = background ?? backgroundColor;\n    if (color !== void 0) {\n      this.color = color;\n    }\n    this.alpha = backgroundAlpha;\n  }\n  get color() {\n    return this._backgroundColor.value;\n  }\n  set color(value) {\n    this._backgroundColor.setValue(value);\n  }\n  get alpha() {\n    return this._backgroundColor.alpha;\n  }\n  set alpha(value) {\n    this._backgroundColor.setAlpha(value);\n  }\n  get backgroundColor() {\n    return this._backgroundColor;\n  }\n  destroy() {\n  }\n}\nBackgroundSystem.defaultOptions = {\n  backgroundAlpha: 1,\n  backgroundColor: 0,\n  clearBeforeRender: true\n};\nBackgroundSystem.extension = {\n  type: [\n    ExtensionType.RendererSystem,\n    ExtensionType.CanvasRendererSystem\n  ],\n  name: "background"\n};\nextensions.add(BackgroundSystem);\n\n\n//# sourceMappingURL=BackgroundSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/batch/BatchSystem.mjs\n\n\n\nclass BatchSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.emptyRenderer = new ObjectRenderer(renderer);\n    this.currentRenderer = this.emptyRenderer;\n  }\n  setObjectRenderer(objectRenderer) {\n    if (this.currentRenderer === objectRenderer) {\n      return;\n    }\n    this.currentRenderer.stop();\n    this.currentRenderer = objectRenderer;\n    this.currentRenderer.start();\n  }\n  flush() {\n    this.setObjectRenderer(this.emptyRenderer);\n  }\n  reset() {\n    this.setObjectRenderer(this.emptyRenderer);\n  }\n  copyBoundTextures(arr, maxTextures) {\n    const { boundTextures } = this.renderer.texture;\n    for (let i = maxTextures - 1; i >= 0; --i) {\n      arr[i] = boundTextures[i] || null;\n      if (arr[i]) {\n        arr[i]._batchLocation = i;\n      }\n    }\n  }\n  boundArray(texArray, boundTextures, batchId, maxTextures) {\n    const { elements, ids, count } = texArray;\n    let j = 0;\n    for (let i = 0; i < count; i++) {\n      const tex = elements[i];\n      const loc = tex._batchLocation;\n      if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {\n        ids[i] = loc;\n        continue;\n      }\n      while (j < maxTextures) {\n        const bound = boundTextures[j];\n        if (bound && bound._batchEnabled === batchId && bound._batchLocation === j) {\n          j++;\n          continue;\n        }\n        ids[i] = j;\n        tex._batchLocation = j;\n        boundTextures[j] = tex;\n        break;\n      }\n    }\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nBatchSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "batch"\n};\nextensions.add(BatchSystem);\n\n\n//# sourceMappingURL=BatchSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/context/ContextSystem.mjs\n\n\n\n\nlet CONTEXT_UID_COUNTER = 0;\nclass ContextSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.webGLVersion = 1;\n    this.extensions = {};\n    this.supports = {\n      uint32Indices: false\n    };\n    this.handleContextLost = this.handleContextLost.bind(this);\n    this.handleContextRestored = this.handleContextRestored.bind(this);\n  }\n  get isLost() {\n    return !this.gl || this.gl.isContextLost();\n  }\n  contextChange(gl) {\n    this.gl = gl;\n    this.renderer.gl = gl;\n    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;\n  }\n  init(options) {\n    if (options.context) {\n      this.initFromContext(options.context);\n    } else {\n      const alpha = this.renderer.background.alpha < 1;\n      const premultipliedAlpha = options.premultipliedAlpha;\n      this.preserveDrawingBuffer = options.preserveDrawingBuffer;\n      this.useContextAlpha = options.useContextAlpha;\n      this.powerPreference = options.powerPreference;\n      this.initFromOptions({\n        alpha,\n        premultipliedAlpha,\n        antialias: options.antialias,\n        stencil: true,\n        preserveDrawingBuffer: options.preserveDrawingBuffer,\n        powerPreference: options.powerPreference\n      });\n    }\n  }\n  initFromContext(gl) {\n    this.gl = gl;\n    this.validateContext(gl);\n    this.renderer.gl = gl;\n    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;\n    this.renderer.runners.contextChange.emit(gl);\n    const view = this.renderer.view;\n    if (view.addEventListener !== void 0) {\n      view.addEventListener("webglcontextlost", this.handleContextLost, false);\n      view.addEventListener("webglcontextrestored", this.handleContextRestored, false);\n    }\n  }\n  initFromOptions(options) {\n    const gl = this.createContext(this.renderer.view, options);\n    this.initFromContext(gl);\n  }\n  createContext(canvas, options) {\n    let gl;\n    if (settings_lib/* settings */.Xd.PREFER_ENV >= lib/* ENV */.Vi.WEBGL2) {\n      gl = canvas.getContext("webgl2", options);\n    }\n    if (gl) {\n      this.webGLVersion = 2;\n    } else {\n      this.webGLVersion = 1;\n      gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);\n      if (!gl) {\n        throw new Error("This browser does not support WebGL. Try using the canvas renderer");\n      }\n    }\n    this.gl = gl;\n    this.getExtensions();\n    return this.gl;\n  }\n  getExtensions() {\n    const { gl } = this;\n    const common = {\n      loseContext: gl.getExtension("WEBGL_lose_context"),\n      anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),\n      floatTextureLinear: gl.getExtension("OES_texture_float_linear"),\n      s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),\n      s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),\n      etc: gl.getExtension("WEBGL_compressed_texture_etc"),\n      etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),\n      pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),\n      atc: gl.getExtension("WEBGL_compressed_texture_atc"),\n      astc: gl.getExtension("WEBGL_compressed_texture_astc")\n    };\n    if (this.webGLVersion === 1) {\n      Object.assign(this.extensions, common, {\n        drawBuffers: gl.getExtension("WEBGL_draw_buffers"),\n        depthTexture: gl.getExtension("WEBGL_depth_texture"),\n        vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),\n        uint32ElementIndex: gl.getExtension("OES_element_index_uint"),\n        floatTexture: gl.getExtension("OES_texture_float"),\n        floatTextureLinear: gl.getExtension("OES_texture_float_linear"),\n        textureHalfFloat: gl.getExtension("OES_texture_half_float"),\n        textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")\n      });\n    } else if (this.webGLVersion === 2) {\n      Object.assign(this.extensions, common, {\n        colorBufferFloat: gl.getExtension("EXT_color_buffer_float")\n      });\n    }\n  }\n  handleContextLost(event) {\n    event.preventDefault();\n    setTimeout(() => {\n      if (this.gl.isContextLost() && this.extensions.loseContext) {\n        this.extensions.loseContext.restoreContext();\n      }\n    }, 0);\n  }\n  handleContextRestored() {\n    this.renderer.runners.contextChange.emit(this.gl);\n  }\n  destroy() {\n    const view = this.renderer.view;\n    this.renderer = null;\n    if (view.removeEventListener !== void 0) {\n      view.removeEventListener("webglcontextlost", this.handleContextLost);\n      view.removeEventListener("webglcontextrestored", this.handleContextRestored);\n    }\n    this.gl.useProgram(null);\n    if (this.extensions.loseContext) {\n      this.extensions.loseContext.loseContext();\n    }\n  }\n  postrender() {\n    if (this.renderer.objectRenderer.renderingToScreen) {\n      this.gl.flush();\n    }\n  }\n  validateContext(gl) {\n    const attributes = gl.getContextAttributes();\n    const isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;\n    if (isWebGl2) {\n      this.webGLVersion = 2;\n    }\n    if (attributes && !attributes.stencil) {\n      console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");\n    }\n    const hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");\n    this.supports.uint32Indices = hasuint32;\n    if (!hasuint32) {\n      console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");\n    }\n  }\n}\nContextSystem.defaultOptions = {\n  context: null,\n  antialias: false,\n  premultipliedAlpha: true,\n  preserveDrawingBuffer: false,\n  powerPreference: "default"\n};\nContextSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "context"\n};\nextensions.add(ContextSystem);\n\n\n//# sourceMappingURL=ContextSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/DepthResource.mjs\n\n\n\nclass DepthResource extends BufferResource {\n  upload(renderer, baseTexture, glTexture) {\n    const gl = renderer.gl;\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === lib/* ALPHA_MODES */.iw.UNPACK);\n    const width = baseTexture.realWidth;\n    const height = baseTexture.realHeight;\n    if (glTexture.width === width && glTexture.height === height) {\n      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);\n    } else {\n      glTexture.width = width;\n      glTexture.height = height;\n      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);\n    }\n    return true;\n  }\n}\n\n\n//# sourceMappingURL=DepthResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/framebuffer/Framebuffer.mjs\n\n\n\n\n\nclass Framebuffer {\n  constructor(width, height) {\n    this.width = Math.round(width || 100);\n    this.height = Math.round(height || 100);\n    this.stencil = false;\n    this.depth = false;\n    this.dirtyId = 0;\n    this.dirtyFormat = 0;\n    this.dirtySize = 0;\n    this.depthTexture = null;\n    this.colorTextures = [];\n    this.glFramebuffers = {};\n    this.disposeRunner = new Runner_Runner("disposeFramebuffer");\n    this.multisample = lib/* MSAA_QUALITY */.G5.NONE;\n  }\n  get colorTexture() {\n    return this.colorTextures[0];\n  }\n  addColorTexture(index = 0, texture) {\n    this.colorTextures[index] = texture || new BaseTexture(null, {\n      scaleMode: lib/* SCALE_MODES */.aH.NEAREST,\n      resolution: 1,\n      mipmap: lib/* MIPMAP_MODES */.WB.OFF,\n      width: this.width,\n      height: this.height\n    });\n    this.dirtyId++;\n    this.dirtyFormat++;\n    return this;\n  }\n  addDepthTexture(texture) {\n    this.depthTexture = texture || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {\n      scaleMode: lib/* SCALE_MODES */.aH.NEAREST,\n      resolution: 1,\n      width: this.width,\n      height: this.height,\n      mipmap: lib/* MIPMAP_MODES */.WB.OFF,\n      format: lib/* FORMATS */.I2.DEPTH_COMPONENT,\n      type: lib/* TYPES */.vK.UNSIGNED_SHORT\n    });\n    this.dirtyId++;\n    this.dirtyFormat++;\n    return this;\n  }\n  enableDepth() {\n    this.depth = true;\n    this.dirtyId++;\n    this.dirtyFormat++;\n    return this;\n  }\n  enableStencil() {\n    this.stencil = true;\n    this.dirtyId++;\n    this.dirtyFormat++;\n    return this;\n  }\n  resize(width, height) {\n    width = Math.round(width);\n    height = Math.round(height);\n    if (width === this.width && height === this.height)\n      return;\n    this.width = width;\n    this.height = height;\n    this.dirtyId++;\n    this.dirtySize++;\n    for (let i = 0; i < this.colorTextures.length; i++) {\n      const texture = this.colorTextures[i];\n      const resolution = texture.resolution;\n      texture.setSize(width / resolution, height / resolution);\n    }\n    if (this.depthTexture) {\n      const resolution = this.depthTexture.resolution;\n      this.depthTexture.setSize(width / resolution, height / resolution);\n    }\n  }\n  dispose() {\n    this.disposeRunner.emit(this, false);\n  }\n  destroyDepthTexture() {\n    if (this.depthTexture) {\n      this.depthTexture.destroy();\n      this.depthTexture = null;\n      ++this.dirtyId;\n      ++this.dirtyFormat;\n    }\n  }\n}\n\n\n//# sourceMappingURL=Framebuffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/renderTexture/BaseRenderTexture.mjs\n\n\n\n\n\nclass BaseRenderTexture extends BaseTexture {\n  constructor(options = {}) {\n    if (typeof options === "number") {\n      const width = arguments[0];\n      const height = arguments[1];\n      const scaleMode = arguments[2];\n      const resolution = arguments[3];\n      options = { width, height, scaleMode, resolution };\n    }\n    options.width = options.width || 100;\n    options.height = options.height || 100;\n    options.multisample ?? (options.multisample = lib/* MSAA_QUALITY */.G5.NONE);\n    super(null, options);\n    this.mipmap = lib/* MIPMAP_MODES */.WB.OFF;\n    this.valid = true;\n    this._clear = new color_lib/* Color */.I([0, 0, 0, 0]);\n    this.framebuffer = new Framebuffer(this.realWidth, this.realHeight).addColorTexture(0, this);\n    this.framebuffer.multisample = options.multisample;\n    this.maskStack = [];\n    this.filterStack = [{}];\n  }\n  set clearColor(value) {\n    this._clear.setValue(value);\n  }\n  get clearColor() {\n    return this._clear.value;\n  }\n  get clear() {\n    return this._clear;\n  }\n  resize(desiredWidth, desiredHeight) {\n    this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution);\n    this.setRealSize(this.framebuffer.width, this.framebuffer.height);\n  }\n  dispose() {\n    this.framebuffer.dispose();\n    super.dispose();\n  }\n  destroy() {\n    super.destroy();\n    this.framebuffer.destroyDepthTexture();\n    this.framebuffer = null;\n  }\n}\n\n\n//# sourceMappingURL=BaseRenderTexture.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/BaseImageResource.mjs\n\n\n\n\nclass BaseImageResource extends Resource {\n  constructor(source) {\n    const sourceAny = source;\n    const width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;\n    const height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;\n    super(width, height);\n    this.source = source;\n    this.noSubImage = false;\n  }\n  static crossOrigin(element, url, crossorigin) {\n    if (crossorigin === void 0 && !url.startsWith("data:")) {\n      element.crossOrigin = (0,utils_lib.determineCrossOrigin)(url);\n    } else if (crossorigin !== false) {\n      element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";\n    }\n  }\n  upload(renderer, baseTexture, glTexture, source) {\n    const gl = renderer.gl;\n    const width = baseTexture.realWidth;\n    const height = baseTexture.realHeight;\n    source = source || this.source;\n    if (typeof HTMLImageElement !== "undefined" && source instanceof HTMLImageElement) {\n      if (!source.complete || source.naturalWidth === 0) {\n        return false;\n      }\n    } else if (typeof HTMLVideoElement !== "undefined" && source instanceof HTMLVideoElement) {\n      if (source.readyState <= 1 && source.buffered.length === 0) {\n        return false;\n      }\n    }\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === lib/* ALPHA_MODES */.iw.UNPACK);\n    if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {\n      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source);\n    } else {\n      glTexture.width = width;\n      glTexture.height = height;\n      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source);\n    }\n    return true;\n  }\n  update() {\n    if (this.destroyed) {\n      return;\n    }\n    const source = this.source;\n    const width = source.naturalWidth || source.videoWidth || source.width;\n    const height = source.naturalHeight || source.videoHeight || source.height;\n    this.resize(width, height);\n    super.update();\n  }\n  dispose() {\n    this.source = null;\n  }\n}\n\n\n//# sourceMappingURL=BaseImageResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/ImageResource.mjs\n\n\n\n\nclass ImageResource extends BaseImageResource {\n  constructor(source, options) {\n    options = options || {};\n    if (typeof source === "string") {\n      const imageElement = new Image();\n      BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);\n      imageElement.src = source;\n      source = imageElement;\n    }\n    super(source);\n    if (!source.complete && !!this._width && !!this._height) {\n      this._width = 0;\n      this._height = 0;\n    }\n    this.url = source.src;\n    this._process = null;\n    this.preserveBitmap = false;\n    this.createBitmap = (options.createBitmap ?? settings_lib/* settings */.Xd.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;\n    this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;\n    this.bitmap = null;\n    this._load = null;\n    if (options.autoLoad !== false) {\n      this.load();\n    }\n  }\n  load(createBitmap) {\n    if (this._load) {\n      return this._load;\n    }\n    if (createBitmap !== void 0) {\n      this.createBitmap = createBitmap;\n    }\n    this._load = new Promise((resolve, reject) => {\n      const source = this.source;\n      this.url = source.src;\n      const completed = () => {\n        if (this.destroyed) {\n          return;\n        }\n        source.onload = null;\n        source.onerror = null;\n        this.resize(source.width, source.height);\n        this._load = null;\n        if (this.createBitmap) {\n          resolve(this.process());\n        } else {\n          resolve(this);\n        }\n      };\n      if (source.complete && source.src) {\n        completed();\n      } else {\n        source.onload = completed;\n        source.onerror = (event) => {\n          reject(event);\n          this.onError.emit(event);\n        };\n      }\n    });\n    return this._load;\n  }\n  process() {\n    const source = this.source;\n    if (this._process !== null) {\n      return this._process;\n    }\n    if (this.bitmap !== null || !globalThis.createImageBitmap) {\n      return Promise.resolve(this);\n    }\n    const createImageBitmap = globalThis.createImageBitmap;\n    const cors = !source.crossOrigin || source.crossOrigin === "anonymous";\n    this._process = fetch(source.src, {\n      mode: cors ? "cors" : "no-cors"\n    }).then((r) => r.blob()).then((blob) => createImageBitmap(blob, 0, 0, source.width, source.height, {\n      premultiplyAlpha: this.alphaMode === null || this.alphaMode === lib/* ALPHA_MODES */.iw.UNPACK ? "premultiply" : "none"\n    })).then((bitmap) => {\n      if (this.destroyed) {\n        return Promise.reject();\n      }\n      this.bitmap = bitmap;\n      this.update();\n      this._process = null;\n      return Promise.resolve(this);\n    });\n    return this._process;\n  }\n  upload(renderer, baseTexture, glTexture) {\n    if (typeof this.alphaMode === "number") {\n      baseTexture.alphaMode = this.alphaMode;\n    }\n    if (!this.createBitmap) {\n      return super.upload(renderer, baseTexture, glTexture);\n    }\n    if (!this.bitmap) {\n      this.process();\n      if (!this.bitmap) {\n        return false;\n      }\n    }\n    super.upload(renderer, baseTexture, glTexture, this.bitmap);\n    if (!this.preserveBitmap) {\n      let flag = true;\n      const glTextures = baseTexture._glTextures;\n      for (const key in glTextures) {\n        const otherTex = glTextures[key];\n        if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {\n          flag = false;\n          break;\n        }\n      }\n      if (flag) {\n        if (this.bitmap.close) {\n          this.bitmap.close();\n        }\n        this.bitmap = null;\n      }\n    }\n    return true;\n  }\n  dispose() {\n    this.source.onload = null;\n    this.source.onerror = null;\n    super.dispose();\n    if (this.bitmap) {\n      this.bitmap.close();\n      this.bitmap = null;\n    }\n    this._process = null;\n    this._load = null;\n  }\n  static test(source) {\n    return typeof HTMLImageElement !== "undefined" && (typeof source === "string" || source instanceof HTMLImageElement);\n  }\n}\n\n\n//# sourceMappingURL=ImageResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/TextureUvs.mjs\n\n\nclass TextureUvs {\n  constructor() {\n    this.x0 = 0;\n    this.y0 = 0;\n    this.x1 = 1;\n    this.y1 = 0;\n    this.x2 = 1;\n    this.y2 = 1;\n    this.x3 = 0;\n    this.y3 = 1;\n    this.uvsFloat32 = new Float32Array(8);\n  }\n  set(frame, baseFrame, rotate) {\n    const tw = baseFrame.width;\n    const th = baseFrame.height;\n    if (rotate) {\n      const w2 = frame.width / 2 / tw;\n      const h2 = frame.height / 2 / th;\n      const cX = frame.x / tw + w2;\n      const cY = frame.y / th + h2;\n      rotate = groupD8.add(rotate, groupD8.NW);\n      this.x0 = cX + w2 * groupD8.uX(rotate);\n      this.y0 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      this.x1 = cX + w2 * groupD8.uX(rotate);\n      this.y1 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      this.x2 = cX + w2 * groupD8.uX(rotate);\n      this.y2 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      this.x3 = cX + w2 * groupD8.uX(rotate);\n      this.y3 = cY + h2 * groupD8.uY(rotate);\n    } else {\n      this.x0 = frame.x / tw;\n      this.y0 = frame.y / th;\n      this.x1 = (frame.x + frame.width) / tw;\n      this.y1 = frame.y / th;\n      this.x2 = (frame.x + frame.width) / tw;\n      this.y2 = (frame.y + frame.height) / th;\n      this.x3 = frame.x / tw;\n      this.y3 = (frame.y + frame.height) / th;\n    }\n    this.uvsFloat32[0] = this.x0;\n    this.uvsFloat32[1] = this.y0;\n    this.uvsFloat32[2] = this.x1;\n    this.uvsFloat32[3] = this.y1;\n    this.uvsFloat32[4] = this.x2;\n    this.uvsFloat32[5] = this.y2;\n    this.uvsFloat32[6] = this.x3;\n    this.uvsFloat32[7] = this.y3;\n  }\n  toString() {\n    return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;\n  }\n}\n\n\n//# sourceMappingURL=TextureUvs.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/Texture.mjs\n\n\n\n\n\n\n\nconst DEFAULT_UVS = new TextureUvs();\nfunction removeAllHandlers(tex) {\n  tex.destroy = function _emptyDestroy() {\n  };\n  tex.on = function _emptyOn() {\n  };\n  tex.once = function _emptyOnce() {\n  };\n  tex.emit = function _emptyEmit() {\n  };\n}\nclass Texture_Texture extends utils_lib.EventEmitter {\n  constructor(baseTexture, frame, orig, trim, rotate, anchor, borders) {\n    super();\n    this.noFrame = false;\n    if (!frame) {\n      this.noFrame = true;\n      frame = new Rectangle_Rectangle(0, 0, 1, 1);\n    }\n    if (baseTexture instanceof Texture_Texture) {\n      baseTexture = baseTexture.baseTexture;\n    }\n    this.baseTexture = baseTexture;\n    this._frame = frame;\n    this.trim = trim;\n    this.valid = false;\n    this._uvs = DEFAULT_UVS;\n    this.uvMatrix = null;\n    this.orig = orig || frame;\n    this._rotate = Number(rotate || 0);\n    if (rotate === true) {\n      this._rotate = 2;\n    } else if (this._rotate % 2 !== 0) {\n      throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");\n    }\n    this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0);\n    this.defaultBorders = borders;\n    this._updateID = 0;\n    this.textureCacheIds = [];\n    if (!baseTexture.valid) {\n      baseTexture.once("loaded", this.onBaseTextureUpdated, this);\n    } else if (this.noFrame) {\n      if (baseTexture.valid) {\n        this.onBaseTextureUpdated(baseTexture);\n      }\n    } else {\n      this.frame = frame;\n    }\n    if (this.noFrame) {\n      baseTexture.on("update", this.onBaseTextureUpdated, this);\n    }\n  }\n  update() {\n    if (this.baseTexture.resource) {\n      this.baseTexture.resource.update();\n    }\n  }\n  onBaseTextureUpdated(baseTexture) {\n    if (this.noFrame) {\n      if (!this.baseTexture.valid) {\n        return;\n      }\n      this._frame.width = baseTexture.width;\n      this._frame.height = baseTexture.height;\n      this.valid = true;\n      this.updateUvs();\n    } else {\n      this.frame = this._frame;\n    }\n    this.emit("update", this);\n  }\n  destroy(destroyBase) {\n    if (this.baseTexture) {\n      if (destroyBase) {\n        const { resource } = this.baseTexture;\n        if (resource?.url && utils_lib.TextureCache[resource.url]) {\n          Texture_Texture.removeFromCache(resource.url);\n        }\n        this.baseTexture.destroy();\n      }\n      this.baseTexture.off("loaded", this.onBaseTextureUpdated, this);\n      this.baseTexture.off("update", this.onBaseTextureUpdated, this);\n      this.baseTexture = null;\n    }\n    this._frame = null;\n    this._uvs = null;\n    this.trim = null;\n    this.orig = null;\n    this.valid = false;\n    Texture_Texture.removeFromCache(this);\n    this.textureCacheIds = null;\n  }\n  clone() {\n    const clonedFrame = this._frame.clone();\n    const clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone();\n    const clonedTexture = new Texture_Texture(this.baseTexture, !this.noFrame && clonedFrame, clonedOrig, this.trim?.clone(), this.rotate, this.defaultAnchor, this.defaultBorders);\n    if (this.noFrame) {\n      clonedTexture._frame = clonedFrame;\n    }\n    return clonedTexture;\n  }\n  updateUvs() {\n    if (this._uvs === DEFAULT_UVS) {\n      this._uvs = new TextureUvs();\n    }\n    this._uvs.set(this._frame, this.baseTexture, this.rotate);\n    this._updateID++;\n  }\n  static from(source, options = {}, strict = settings_lib/* settings */.Xd.STRICT_TEXTURE_CACHE) {\n    const isFrame = typeof source === "string";\n    let cacheId = null;\n    if (isFrame) {\n      cacheId = source;\n    } else if (source instanceof BaseTexture) {\n      if (!source.cacheId) {\n        const prefix = options?.pixiIdPrefix || "pixiid";\n        source.cacheId = `${prefix}-${(0,utils_lib.uid)()}`;\n        BaseTexture.addToCache(source, source.cacheId);\n      }\n      cacheId = source.cacheId;\n    } else {\n      if (!source._pixiId) {\n        const prefix = options?.pixiIdPrefix || "pixiid";\n        source._pixiId = `${prefix}_${(0,utils_lib.uid)()}`;\n      }\n      cacheId = source._pixiId;\n    }\n    let texture = utils_lib.TextureCache[cacheId];\n    if (isFrame && strict && !texture) {\n      throw new Error(`The cacheId "${cacheId}" does not exist in TextureCache.`);\n    }\n    if (!texture && !(source instanceof BaseTexture)) {\n      if (!options.resolution) {\n        options.resolution = (0,utils_lib.getResolutionOfUrl)(source);\n      }\n      texture = new Texture_Texture(new BaseTexture(source, options));\n      texture.baseTexture.cacheId = cacheId;\n      BaseTexture.addToCache(texture.baseTexture, cacheId);\n      Texture_Texture.addToCache(texture, cacheId);\n    } else if (!texture && source instanceof BaseTexture) {\n      texture = new Texture_Texture(source);\n      Texture_Texture.addToCache(texture, cacheId);\n    }\n    return texture;\n  }\n  static fromURL(url, options) {\n    const resourceOptions = Object.assign({ autoLoad: false }, options?.resourceOptions);\n    const texture = Texture_Texture.from(url, Object.assign({ resourceOptions }, options), false);\n    const resource = texture.baseTexture.resource;\n    if (texture.baseTexture.valid) {\n      return Promise.resolve(texture);\n    }\n    return resource.load().then(() => Promise.resolve(texture));\n  }\n  static fromBuffer(buffer, width, height, options) {\n    return new Texture_Texture(BaseTexture.fromBuffer(buffer, width, height, options));\n  }\n  static fromLoader(source, imageUrl, name, options) {\n    const baseTexture = new BaseTexture(source, Object.assign({\n      scaleMode: BaseTexture.defaultOptions.scaleMode,\n      resolution: (0,utils_lib.getResolutionOfUrl)(imageUrl)\n    }, options));\n    const { resource } = baseTexture;\n    if (resource instanceof ImageResource) {\n      resource.url = imageUrl;\n    }\n    const texture = new Texture_Texture(baseTexture);\n    if (!name) {\n      name = imageUrl;\n    }\n    BaseTexture.addToCache(texture.baseTexture, name);\n    Texture_Texture.addToCache(texture, name);\n    if (name !== imageUrl) {\n      BaseTexture.addToCache(texture.baseTexture, imageUrl);\n      Texture_Texture.addToCache(texture, imageUrl);\n    }\n    if (texture.baseTexture.valid) {\n      return Promise.resolve(texture);\n    }\n    return new Promise((resolve) => {\n      texture.baseTexture.once("loaded", () => resolve(texture));\n    });\n  }\n  static addToCache(texture, id) {\n    if (id) {\n      if (!texture.textureCacheIds.includes(id)) {\n        texture.textureCacheIds.push(id);\n      }\n      if (utils_lib.TextureCache[id] && utils_lib.TextureCache[id] !== texture) {\n        console.warn(`Texture added to the cache with an id [${id}] that already had an entry`);\n      }\n      utils_lib.TextureCache[id] = texture;\n    }\n  }\n  static removeFromCache(texture) {\n    if (typeof texture === "string") {\n      const textureFromCache = utils_lib.TextureCache[texture];\n      if (textureFromCache) {\n        const index = textureFromCache.textureCacheIds.indexOf(texture);\n        if (index > -1) {\n          textureFromCache.textureCacheIds.splice(index, 1);\n        }\n        delete utils_lib.TextureCache[texture];\n        return textureFromCache;\n      }\n    } else if (texture?.textureCacheIds) {\n      for (let i = 0; i < texture.textureCacheIds.length; ++i) {\n        if (utils_lib.TextureCache[texture.textureCacheIds[i]] === texture) {\n          delete utils_lib.TextureCache[texture.textureCacheIds[i]];\n        }\n      }\n      texture.textureCacheIds.length = 0;\n      return texture;\n    }\n    return null;\n  }\n  get resolution() {\n    return this.baseTexture.resolution;\n  }\n  get frame() {\n    return this._frame;\n  }\n  set frame(frame) {\n    this._frame = frame;\n    this.noFrame = false;\n    const { x, y, width, height } = frame;\n    const xNotFit = x + width > this.baseTexture.width;\n    const yNotFit = y + height > this.baseTexture.height;\n    if (xNotFit || yNotFit) {\n      const relationship = xNotFit && yNotFit ? "and" : "or";\n      const errorX = `X: ${x} + ${width} = ${x + width} > ${this.baseTexture.width}`;\n      const errorY = `Y: ${y} + ${height} = ${y + height} > ${this.baseTexture.height}`;\n      throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${errorX} ${relationship} ${errorY}`);\n    }\n    this.valid = width && height && this.baseTexture.valid;\n    if (!this.trim && !this.rotate) {\n      this.orig = frame;\n    }\n    if (this.valid) {\n      this.updateUvs();\n    }\n  }\n  get rotate() {\n    return this._rotate;\n  }\n  set rotate(rotate) {\n    this._rotate = rotate;\n    if (this.valid) {\n      this.updateUvs();\n    }\n  }\n  get width() {\n    return this.orig.width;\n  }\n  get height() {\n    return this.orig.height;\n  }\n  castToBaseTexture() {\n    return this.baseTexture;\n  }\n  static get EMPTY() {\n    if (!Texture_Texture._EMPTY) {\n      Texture_Texture._EMPTY = new Texture_Texture(new BaseTexture());\n      removeAllHandlers(Texture_Texture._EMPTY);\n      removeAllHandlers(Texture_Texture._EMPTY.baseTexture);\n    }\n    return Texture_Texture._EMPTY;\n  }\n  static get WHITE() {\n    if (!Texture_Texture._WHITE) {\n      const canvas = settings_lib/* settings */.Xd.ADAPTER.createCanvas(16, 16);\n      const context = canvas.getContext("2d");\n      canvas.width = 16;\n      canvas.height = 16;\n      context.fillStyle = "white";\n      context.fillRect(0, 0, 16, 16);\n      Texture_Texture._WHITE = new Texture_Texture(BaseTexture.from(canvas));\n      removeAllHandlers(Texture_Texture._WHITE);\n      removeAllHandlers(Texture_Texture._WHITE.baseTexture);\n    }\n    return Texture_Texture._WHITE;\n  }\n}\n\n\n//# sourceMappingURL=Texture.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/renderTexture/RenderTexture.mjs\n\n\n\nclass RenderTexture extends Texture_Texture {\n  constructor(baseRenderTexture, frame) {\n    super(baseRenderTexture, frame);\n    this.valid = true;\n    this.filterFrame = null;\n    this.filterPoolKey = null;\n    this.updateUvs();\n  }\n  get framebuffer() {\n    return this.baseTexture.framebuffer;\n  }\n  get multisample() {\n    return this.framebuffer.multisample;\n  }\n  set multisample(value) {\n    this.framebuffer.multisample = value;\n  }\n  resize(desiredWidth, desiredHeight, resizeBaseTexture = true) {\n    const resolution = this.baseTexture.resolution;\n    const width = Math.round(desiredWidth * resolution) / resolution;\n    const height = Math.round(desiredHeight * resolution) / resolution;\n    this.valid = width > 0 && height > 0;\n    this._frame.width = this.orig.width = width;\n    this._frame.height = this.orig.height = height;\n    if (resizeBaseTexture) {\n      this.baseTexture.resize(width, height);\n    }\n    this.updateUvs();\n  }\n  setResolution(resolution) {\n    const { baseTexture } = this;\n    if (baseTexture.resolution === resolution) {\n      return;\n    }\n    baseTexture.setResolution(resolution);\n    this.resize(baseTexture.width, baseTexture.height, false);\n  }\n  static create(options) {\n    return new RenderTexture(new BaseRenderTexture(options));\n  }\n}\n\n\n//# sourceMappingURL=RenderTexture.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/renderTexture/RenderTexturePool.mjs\n\n\n\n\n\nclass RenderTexturePool {\n  constructor(textureOptions) {\n    this.texturePool = {};\n    this.textureOptions = textureOptions || {};\n    this.enableFullScreen = false;\n    this._pixelsWidth = 0;\n    this._pixelsHeight = 0;\n  }\n  createTexture(realWidth, realHeight, multisample = lib/* MSAA_QUALITY */.G5.NONE) {\n    const baseRenderTexture = new BaseRenderTexture(Object.assign({\n      width: realWidth,\n      height: realHeight,\n      resolution: 1,\n      multisample\n    }, this.textureOptions));\n    return new RenderTexture(baseRenderTexture);\n  }\n  getOptimalTexture(minWidth, minHeight, resolution = 1, multisample = lib/* MSAA_QUALITY */.G5.NONE) {\n    let key;\n    minWidth = Math.ceil(minWidth * resolution - 1e-6);\n    minHeight = Math.ceil(minHeight * resolution - 1e-6);\n    if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {\n      minWidth = (0,utils_lib.nextPow2)(minWidth);\n      minHeight = (0,utils_lib.nextPow2)(minHeight);\n      key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0;\n      if (multisample > 1) {\n        key += multisample * 4294967296;\n      }\n    } else {\n      key = multisample > 1 ? -multisample : -1;\n    }\n    if (!this.texturePool[key]) {\n      this.texturePool[key] = [];\n    }\n    let renderTexture = this.texturePool[key].pop();\n    if (!renderTexture) {\n      renderTexture = this.createTexture(minWidth, minHeight, multisample);\n    }\n    renderTexture.filterPoolKey = key;\n    renderTexture.setResolution(resolution);\n    return renderTexture;\n  }\n  getFilterTexture(input, resolution, multisample) {\n    const filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || lib/* MSAA_QUALITY */.G5.NONE);\n    filterTexture.filterFrame = input.filterFrame;\n    return filterTexture;\n  }\n  returnTexture(renderTexture) {\n    const key = renderTexture.filterPoolKey;\n    renderTexture.filterFrame = null;\n    this.texturePool[key].push(renderTexture);\n  }\n  returnFilterTexture(renderTexture) {\n    this.returnTexture(renderTexture);\n  }\n  clear(destroyTextures) {\n    destroyTextures = destroyTextures !== false;\n    if (destroyTextures) {\n      for (const i in this.texturePool) {\n        const textures = this.texturePool[i];\n        if (textures) {\n          for (let j = 0; j < textures.length; j++) {\n            textures[j].destroy(true);\n          }\n        }\n      }\n    }\n    this.texturePool = {};\n  }\n  setScreenSize(size) {\n    if (size.width === this._pixelsWidth && size.height === this._pixelsHeight) {\n      return;\n    }\n    this.enableFullScreen = size.width > 0 && size.height > 0;\n    for (const i in this.texturePool) {\n      if (!(Number(i) < 0)) {\n        continue;\n      }\n      const textures = this.texturePool[i];\n      if (textures) {\n        for (let j = 0; j < textures.length; j++) {\n          textures[j].destroy(true);\n        }\n      }\n      this.texturePool[i] = [];\n    }\n    this._pixelsWidth = size.width;\n    this._pixelsHeight = size.height;\n  }\n}\nRenderTexturePool.SCREEN_KEY = -1;\n\n\n//# sourceMappingURL=RenderTexturePool.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/utils/Quad.mjs\n\n\nclass Quad extends Geometry {\n  constructor() {\n    super();\n    this.addAttribute("aVertexPosition", new Float32Array([\n      0,\n      0,\n      1,\n      0,\n      1,\n      1,\n      0,\n      1\n    ])).addIndex([0, 1, 3, 2]);\n  }\n}\n\n\n//# sourceMappingURL=Quad.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/utils/QuadUv.mjs\n\n\n\nclass QuadUv extends Geometry {\n  constructor() {\n    super();\n    this.vertices = new Float32Array([\n      -1,\n      -1,\n      1,\n      -1,\n      1,\n      1,\n      -1,\n      1\n    ]);\n    this.uvs = new Float32Array([\n      0,\n      0,\n      1,\n      0,\n      1,\n      1,\n      0,\n      1\n    ]);\n    this.vertexBuffer = new Buffer(this.vertices);\n    this.uvBuffer = new Buffer(this.uvs);\n    this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);\n  }\n  map(targetTextureFrame, destinationFrame) {\n    let x = 0;\n    let y = 0;\n    this.uvs[0] = x;\n    this.uvs[1] = y;\n    this.uvs[2] = x + destinationFrame.width / targetTextureFrame.width;\n    this.uvs[3] = y;\n    this.uvs[4] = x + destinationFrame.width / targetTextureFrame.width;\n    this.uvs[5] = y + destinationFrame.height / targetTextureFrame.height;\n    this.uvs[6] = x;\n    this.uvs[7] = y + destinationFrame.height / targetTextureFrame.height;\n    x = destinationFrame.x;\n    y = destinationFrame.y;\n    this.vertices[0] = x;\n    this.vertices[1] = y;\n    this.vertices[2] = x + destinationFrame.width;\n    this.vertices[3] = y;\n    this.vertices[4] = x + destinationFrame.width;\n    this.vertices[5] = y + destinationFrame.height;\n    this.vertices[6] = x;\n    this.vertices[7] = y + destinationFrame.height;\n    this.invalidate();\n    return this;\n  }\n  invalidate() {\n    this.vertexBuffer._updateID++;\n    this.uvBuffer._updateID++;\n    return this;\n  }\n}\n\n\n//# sourceMappingURL=QuadUv.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/FilterState.mjs\n\n\n\nclass FilterState {\n  constructor() {\n    this.renderTexture = null;\n    this.target = null;\n    this.legacy = false;\n    this.resolution = 1;\n    this.multisample = lib/* MSAA_QUALITY */.G5.NONE;\n    this.sourceFrame = new Rectangle_Rectangle();\n    this.destinationFrame = new Rectangle_Rectangle();\n    this.bindingSourceFrame = new Rectangle_Rectangle();\n    this.bindingDestinationFrame = new Rectangle_Rectangle();\n    this.filters = [];\n    this.transform = null;\n  }\n  clear() {\n    this.target = null;\n    this.filters = null;\n    this.renderTexture = null;\n  }\n}\n\n\n//# sourceMappingURL=FilterState.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/FilterSystem.mjs\n\n\n\n\n\n\n\n\n\nconst FilterSystem_tempPoints = [new Point(), new Point(), new Point(), new Point()];\nconst tempMatrix = new Matrix();\nclass FilterSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.defaultFilterStack = [{}];\n    this.texturePool = new RenderTexturePool();\n    this.statePool = [];\n    this.quad = new Quad();\n    this.quadUv = new QuadUv();\n    this.tempRect = new Rectangle_Rectangle();\n    this.activeState = {};\n    this.globalUniforms = new UniformGroup({\n      outputFrame: new Rectangle_Rectangle(),\n      inputSize: new Float32Array(4),\n      inputPixel: new Float32Array(4),\n      inputClamp: new Float32Array(4),\n      resolution: 1,\n      filterArea: new Float32Array(4),\n      filterClamp: new Float32Array(4)\n    }, true);\n    this.forceClear = false;\n    this.useMaxPadding = false;\n  }\n  init() {\n    this.texturePool.setScreenSize(this.renderer.view);\n  }\n  push(target, filters) {\n    const renderer = this.renderer;\n    const filterStack = this.defaultFilterStack;\n    const state = this.statePool.pop() || new FilterState();\n    const renderTextureSystem = this.renderer.renderTexture;\n    let resolution = filters[0].resolution;\n    let multisample = filters[0].multisample;\n    let padding = filters[0].padding;\n    let autoFit = filters[0].autoFit;\n    let legacy = filters[0].legacy ?? true;\n    for (let i = 1; i < filters.length; i++) {\n      const filter = filters[i];\n      resolution = Math.min(resolution, filter.resolution);\n      multisample = Math.min(multisample, filter.multisample);\n      padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding;\n      autoFit = autoFit && filter.autoFit;\n      legacy = legacy || (filter.legacy ?? true);\n    }\n    if (filterStack.length === 1) {\n      this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;\n    }\n    filterStack.push(state);\n    state.resolution = resolution;\n    state.multisample = multisample;\n    state.legacy = legacy;\n    state.target = target;\n    state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));\n    state.sourceFrame.pad(padding);\n    const sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);\n    if (renderer.projection.transform) {\n      this.transformAABB(tempMatrix.copyFrom(renderer.projection.transform).invert(), sourceFrameProjected);\n    }\n    if (autoFit) {\n      state.sourceFrame.fit(sourceFrameProjected);\n      if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) {\n        state.sourceFrame.width = 0;\n        state.sourceFrame.height = 0;\n      }\n    } else if (!state.sourceFrame.intersects(sourceFrameProjected)) {\n      state.sourceFrame.width = 0;\n      state.sourceFrame.height = 0;\n    }\n    this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);\n    state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution, multisample);\n    state.filters = filters;\n    state.destinationFrame.width = state.renderTexture.width;\n    state.destinationFrame.height = state.renderTexture.height;\n    const destinationFrame = this.tempRect;\n    destinationFrame.x = 0;\n    destinationFrame.y = 0;\n    destinationFrame.width = state.sourceFrame.width;\n    destinationFrame.height = state.sourceFrame.height;\n    state.renderTexture.filterFrame = state.sourceFrame;\n    state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);\n    state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);\n    state.transform = renderer.projection.transform;\n    renderer.projection.transform = null;\n    renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);\n    renderer.framebuffer.clear(0, 0, 0, 0);\n  }\n  pop() {\n    const filterStack = this.defaultFilterStack;\n    const state = filterStack.pop();\n    const filters = state.filters;\n    this.activeState = state;\n    const globalUniforms = this.globalUniforms.uniforms;\n    globalUniforms.outputFrame = state.sourceFrame;\n    globalUniforms.resolution = state.resolution;\n    const inputSize = globalUniforms.inputSize;\n    const inputPixel = globalUniforms.inputPixel;\n    const inputClamp = globalUniforms.inputClamp;\n    inputSize[0] = state.destinationFrame.width;\n    inputSize[1] = state.destinationFrame.height;\n    inputSize[2] = 1 / inputSize[0];\n    inputSize[3] = 1 / inputSize[1];\n    inputPixel[0] = Math.round(inputSize[0] * state.resolution);\n    inputPixel[1] = Math.round(inputSize[1] * state.resolution);\n    inputPixel[2] = 1 / inputPixel[0];\n    inputPixel[3] = 1 / inputPixel[1];\n    inputClamp[0] = 0.5 * inputPixel[2];\n    inputClamp[1] = 0.5 * inputPixel[3];\n    inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];\n    inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];\n    if (state.legacy) {\n      const filterArea = globalUniforms.filterArea;\n      filterArea[0] = state.destinationFrame.width;\n      filterArea[1] = state.destinationFrame.height;\n      filterArea[2] = state.sourceFrame.x;\n      filterArea[3] = state.sourceFrame.y;\n      globalUniforms.filterClamp = globalUniforms.inputClamp;\n    }\n    this.globalUniforms.update();\n    const lastState = filterStack[filterStack.length - 1];\n    this.renderer.framebuffer.blit();\n    if (filters.length === 1) {\n      filters[0].apply(this, state.renderTexture, lastState.renderTexture, lib/* CLEAR_MODES */.yl.BLEND, state);\n      this.returnFilterTexture(state.renderTexture);\n    } else {\n      let flip = state.renderTexture;\n      let flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);\n      flop.filterFrame = flip.filterFrame;\n      let i = 0;\n      for (i = 0; i < filters.length - 1; ++i) {\n        if (i === 1 && state.multisample > 1) {\n          flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);\n          flop.filterFrame = flip.filterFrame;\n        }\n        filters[i].apply(this, flip, flop, lib/* CLEAR_MODES */.yl.CLEAR, state);\n        const t = flip;\n        flip = flop;\n        flop = t;\n      }\n      filters[i].apply(this, flip, lastState.renderTexture, lib/* CLEAR_MODES */.yl.BLEND, state);\n      if (i > 1 && state.multisample > 1) {\n        this.returnFilterTexture(state.renderTexture);\n      }\n      this.returnFilterTexture(flip);\n      this.returnFilterTexture(flop);\n    }\n    state.clear();\n    this.statePool.push(state);\n  }\n  bindAndClear(filterTexture, clearMode = lib/* CLEAR_MODES */.yl.CLEAR) {\n    const {\n      renderTexture: renderTextureSystem,\n      state: stateSystem\n    } = this.renderer;\n    if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {\n      this.renderer.projection.transform = this.activeState.transform;\n    } else {\n      this.renderer.projection.transform = null;\n    }\n    if (filterTexture?.filterFrame) {\n      const destinationFrame = this.tempRect;\n      destinationFrame.x = 0;\n      destinationFrame.y = 0;\n      destinationFrame.width = filterTexture.filterFrame.width;\n      destinationFrame.height = filterTexture.filterFrame.height;\n      renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);\n    } else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {\n      renderTextureSystem.bind(filterTexture);\n    } else {\n      this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);\n    }\n    const autoClear = stateSystem.stateId & 1 || this.forceClear;\n    if (clearMode === lib/* CLEAR_MODES */.yl.CLEAR || clearMode === lib/* CLEAR_MODES */.yl.BLIT && autoClear) {\n      this.renderer.framebuffer.clear(0, 0, 0, 0);\n    }\n  }\n  applyFilter(filter, input, output, clearMode) {\n    const renderer = this.renderer;\n    renderer.state.set(filter.state);\n    this.bindAndClear(output, clearMode);\n    filter.uniforms.uSampler = input;\n    filter.uniforms.filterGlobals = this.globalUniforms;\n    renderer.shader.bind(filter);\n    filter.legacy = !!filter.program.attributeData.aTextureCoord;\n    if (filter.legacy) {\n      this.quadUv.map(input._frame, input.filterFrame);\n      renderer.geometry.bind(this.quadUv);\n      renderer.geometry.draw(lib/* DRAW_MODES */.lg.TRIANGLES);\n    } else {\n      renderer.geometry.bind(this.quad);\n      renderer.geometry.draw(lib/* DRAW_MODES */.lg.TRIANGLE_STRIP);\n    }\n  }\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const { sourceFrame, destinationFrame } = this.activeState;\n    const { orig } = sprite._texture;\n    const mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);\n    const worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(1 / orig.width, 1 / orig.height);\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n    return mappedMatrix;\n  }\n  destroy() {\n    this.renderer = null;\n    this.texturePool.clear(false);\n  }\n  getOptimalFilterTexture(minWidth, minHeight, resolution = 1, multisample = lib/* MSAA_QUALITY */.G5.NONE) {\n    return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);\n  }\n  getFilterTexture(input, resolution, multisample) {\n    if (typeof input === "number") {\n      const swap = input;\n      input = resolution;\n      resolution = swap;\n    }\n    input = input || this.activeState.renderTexture;\n    const filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || lib/* MSAA_QUALITY */.G5.NONE);\n    filterTexture.filterFrame = input.filterFrame;\n    return filterTexture;\n  }\n  returnFilterTexture(renderTexture) {\n    this.texturePool.returnTexture(renderTexture);\n  }\n  emptyPool() {\n    this.texturePool.clear(true);\n  }\n  resize() {\n    this.texturePool.setScreenSize(this.renderer.view);\n  }\n  transformAABB(matrix, rect) {\n    const lt = FilterSystem_tempPoints[0];\n    const lb = FilterSystem_tempPoints[1];\n    const rt = FilterSystem_tempPoints[2];\n    const rb = FilterSystem_tempPoints[3];\n    lt.set(rect.left, rect.top);\n    lb.set(rect.left, rect.bottom);\n    rt.set(rect.right, rect.top);\n    rb.set(rect.right, rect.bottom);\n    matrix.apply(lt, lt);\n    matrix.apply(lb, lb);\n    matrix.apply(rt, rt);\n    matrix.apply(rb, rb);\n    const x0 = Math.min(lt.x, lb.x, rt.x, rb.x);\n    const y0 = Math.min(lt.y, lb.y, rt.y, rb.y);\n    const x1 = Math.max(lt.x, lb.x, rt.x, rb.x);\n    const y1 = Math.max(lt.y, lb.y, rt.y, rb.y);\n    rect.x = x0;\n    rect.y = y0;\n    rect.width = x1 - x0;\n    rect.height = y1 - y0;\n  }\n  roundFrame(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {\n    if (frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0) {\n      return;\n    }\n    if (transform) {\n      const { a, b, c, d } = transform;\n      if ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4)) {\n        return;\n      }\n    }\n    transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();\n    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);\n    this.transformAABB(transform, frame);\n    frame.ceil(resolution);\n    this.transformAABB(transform.invert(), frame);\n  }\n}\nFilterSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "filter"\n};\nextensions.add(FilterSystem);\n\n\n//# sourceMappingURL=FilterSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/framebuffer/GLFramebuffer.mjs\n\n\nclass GLFramebuffer {\n  constructor(framebuffer) {\n    this.framebuffer = framebuffer;\n    this.stencil = null;\n    this.dirtyId = -1;\n    this.dirtyFormat = -1;\n    this.dirtySize = -1;\n    this.multisample = lib/* MSAA_QUALITY */.G5.NONE;\n    this.msaaBuffer = null;\n    this.blitFramebuffer = null;\n    this.mipLevel = 0;\n  }\n}\n\n\n//# sourceMappingURL=GLFramebuffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/framebuffer/FramebufferSystem.mjs\n\n\n\n\n\n\n\nconst tempRectangle = new Rectangle_Rectangle();\nclass FramebufferSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.managedFramebuffers = [];\n    this.unknownFramebuffer = new Framebuffer(10, 10);\n    this.msaaSamples = null;\n  }\n  contextChange() {\n    this.disposeAll(true);\n    const gl = this.gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n    this.current = this.unknownFramebuffer;\n    this.viewport = new Rectangle_Rectangle();\n    this.hasMRT = true;\n    this.writeDepthTexture = true;\n    if (this.renderer.context.webGLVersion === 1) {\n      let nativeDrawBuffersExtension = this.renderer.context.extensions.drawBuffers;\n      let nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;\n      if (settings_lib/* settings */.Xd.PREFER_ENV === lib/* ENV */.Vi.WEBGL_LEGACY) {\n        nativeDrawBuffersExtension = null;\n        nativeDepthTextureExtension = null;\n      }\n      if (nativeDrawBuffersExtension) {\n        gl.drawBuffers = (activeTextures) => nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures);\n      } else {\n        this.hasMRT = false;\n        gl.drawBuffers = () => {\n        };\n      }\n      if (!nativeDepthTextureExtension) {\n        this.writeDepthTexture = false;\n      }\n    } else {\n      this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);\n    }\n  }\n  bind(framebuffer, frame, mipLevel = 0) {\n    const { gl } = this;\n    if (framebuffer) {\n      const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);\n      if (this.current !== framebuffer) {\n        this.current = framebuffer;\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);\n      }\n      if (fbo.mipLevel !== mipLevel) {\n        framebuffer.dirtyId++;\n        framebuffer.dirtyFormat++;\n        fbo.mipLevel = mipLevel;\n      }\n      if (fbo.dirtyId !== framebuffer.dirtyId) {\n        fbo.dirtyId = framebuffer.dirtyId;\n        if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {\n          fbo.dirtyFormat = framebuffer.dirtyFormat;\n          fbo.dirtySize = framebuffer.dirtySize;\n          this.updateFramebuffer(framebuffer, mipLevel);\n        } else if (fbo.dirtySize !== framebuffer.dirtySize) {\n          fbo.dirtySize = framebuffer.dirtySize;\n          this.resizeFramebuffer(framebuffer);\n        }\n      }\n      for (let i = 0; i < framebuffer.colorTextures.length; i++) {\n        const tex = framebuffer.colorTextures[i];\n        this.renderer.texture.unbind(tex.parentTextureArray || tex);\n      }\n      if (framebuffer.depthTexture) {\n        this.renderer.texture.unbind(framebuffer.depthTexture);\n      }\n      if (frame) {\n        const mipWidth = frame.width >> mipLevel;\n        const mipHeight = frame.height >> mipLevel;\n        const scale = mipWidth / frame.width;\n        this.setViewport(frame.x * scale, frame.y * scale, mipWidth, mipHeight);\n      } else {\n        const mipWidth = framebuffer.width >> mipLevel;\n        const mipHeight = framebuffer.height >> mipLevel;\n        this.setViewport(0, 0, mipWidth, mipHeight);\n      }\n    } else {\n      if (this.current) {\n        this.current = null;\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n      }\n      if (frame) {\n        this.setViewport(frame.x, frame.y, frame.width, frame.height);\n      } else {\n        this.setViewport(0, 0, this.renderer.width, this.renderer.height);\n      }\n    }\n  }\n  setViewport(x, y, width, height) {\n    const v = this.viewport;\n    x = Math.round(x);\n    y = Math.round(y);\n    width = Math.round(width);\n    height = Math.round(height);\n    if (v.width !== width || v.height !== height || v.x !== x || v.y !== y) {\n      v.x = x;\n      v.y = y;\n      v.width = width;\n      v.height = height;\n      this.gl.viewport(x, y, width, height);\n    }\n  }\n  get size() {\n    if (this.current) {\n      return { x: 0, y: 0, width: this.current.width, height: this.current.height };\n    }\n    return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };\n  }\n  clear(r, g, b, a, mask = lib/* BUFFER_BITS */.V0.COLOR | lib/* BUFFER_BITS */.V0.DEPTH) {\n    const { gl } = this;\n    gl.clearColor(r, g, b, a);\n    gl.clear(mask);\n  }\n  initFramebuffer(framebuffer) {\n    const { gl } = this;\n    const fbo = new GLFramebuffer(gl.createFramebuffer());\n    fbo.multisample = this.detectSamples(framebuffer.multisample);\n    framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;\n    this.managedFramebuffers.push(framebuffer);\n    framebuffer.disposeRunner.add(this);\n    return fbo;\n  }\n  resizeFramebuffer(framebuffer) {\n    const { gl } = this;\n    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];\n    if (fbo.stencil) {\n      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);\n      if (fbo.msaaBuffer) {\n        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);\n      } else {\n        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);\n      }\n    }\n    const colorTextures = framebuffer.colorTextures;\n    let count = colorTextures.length;\n    if (!gl.drawBuffers) {\n      count = Math.min(count, 1);\n    }\n    for (let i = 0; i < count; i++) {\n      const texture = colorTextures[i];\n      const parentTexture = texture.parentTextureArray || texture;\n      this.renderer.texture.bind(parentTexture, 0);\n      if (i === 0 && fbo.msaaBuffer) {\n        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);\n        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, parentTexture._glTextures[this.CONTEXT_UID].internalFormat, framebuffer.width, framebuffer.height);\n      }\n    }\n    if (framebuffer.depthTexture && this.writeDepthTexture) {\n      this.renderer.texture.bind(framebuffer.depthTexture, 0);\n    }\n  }\n  updateFramebuffer(framebuffer, mipLevel) {\n    const { gl } = this;\n    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];\n    const colorTextures = framebuffer.colorTextures;\n    let count = colorTextures.length;\n    if (!gl.drawBuffers) {\n      count = Math.min(count, 1);\n    }\n    if (fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer)) {\n      fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer();\n    } else if (fbo.msaaBuffer) {\n      gl.deleteRenderbuffer(fbo.msaaBuffer);\n      fbo.msaaBuffer = null;\n      if (fbo.blitFramebuffer) {\n        fbo.blitFramebuffer.dispose();\n        fbo.blitFramebuffer = null;\n      }\n    }\n    const activeTextures = [];\n    for (let i = 0; i < count; i++) {\n      const texture = colorTextures[i];\n      const parentTexture = texture.parentTextureArray || texture;\n      this.renderer.texture.bind(parentTexture, 0);\n      if (i === 0 && fbo.msaaBuffer) {\n        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);\n        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, parentTexture._glTextures[this.CONTEXT_UID].internalFormat, framebuffer.width, framebuffer.height);\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);\n      } else {\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);\n        activeTextures.push(gl.COLOR_ATTACHMENT0 + i);\n      }\n    }\n    if (activeTextures.length > 1) {\n      gl.drawBuffers(activeTextures);\n    }\n    if (framebuffer.depthTexture) {\n      const writeDepthTexture = this.writeDepthTexture;\n      if (writeDepthTexture) {\n        const depthTexture = framebuffer.depthTexture;\n        this.renderer.texture.bind(depthTexture, 0);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);\n      }\n    }\n    if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {\n      fbo.stencil = fbo.stencil || gl.createRenderbuffer();\n      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);\n      if (fbo.msaaBuffer) {\n        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);\n      } else {\n        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);\n      }\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);\n    } else if (fbo.stencil) {\n      gl.deleteRenderbuffer(fbo.stencil);\n      fbo.stencil = null;\n    }\n  }\n  canMultisampleFramebuffer(framebuffer) {\n    return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;\n  }\n  detectSamples(samples) {\n    const { msaaSamples } = this;\n    let res = lib/* MSAA_QUALITY */.G5.NONE;\n    if (samples <= 1 || msaaSamples === null) {\n      return res;\n    }\n    for (let i = 0; i < msaaSamples.length; i++) {\n      if (msaaSamples[i] <= samples) {\n        res = msaaSamples[i];\n        break;\n      }\n    }\n    if (res === 1) {\n      res = lib/* MSAA_QUALITY */.G5.NONE;\n    }\n    return res;\n  }\n  blit(framebuffer, sourcePixels, destPixels) {\n    const { current, renderer, gl, CONTEXT_UID } = this;\n    if (renderer.context.webGLVersion !== 2) {\n      return;\n    }\n    if (!current) {\n      return;\n    }\n    const fbo = current.glFramebuffers[CONTEXT_UID];\n    if (!fbo) {\n      return;\n    }\n    if (!framebuffer) {\n      if (!fbo.msaaBuffer) {\n        return;\n      }\n      const colorTexture = current.colorTextures[0];\n      if (!colorTexture) {\n        return;\n      }\n      if (!fbo.blitFramebuffer) {\n        fbo.blitFramebuffer = new Framebuffer(current.width, current.height);\n        fbo.blitFramebuffer.addColorTexture(0, colorTexture);\n      }\n      framebuffer = fbo.blitFramebuffer;\n      if (framebuffer.colorTextures[0] !== colorTexture) {\n        framebuffer.colorTextures[0] = colorTexture;\n        framebuffer.dirtyId++;\n        framebuffer.dirtyFormat++;\n      }\n      if (framebuffer.width !== current.width || framebuffer.height !== current.height) {\n        framebuffer.width = current.width;\n        framebuffer.height = current.height;\n        framebuffer.dirtyId++;\n        framebuffer.dirtySize++;\n      }\n    }\n    if (!sourcePixels) {\n      sourcePixels = tempRectangle;\n      sourcePixels.width = current.width;\n      sourcePixels.height = current.height;\n    }\n    if (!destPixels) {\n      destPixels = sourcePixels;\n    }\n    const sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;\n    this.bind(framebuffer);\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);\n    gl.blitFramebuffer(sourcePixels.left, sourcePixels.top, sourcePixels.right, sourcePixels.bottom, destPixels.left, destPixels.top, destPixels.right, destPixels.bottom, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, framebuffer.glFramebuffers[this.CONTEXT_UID].framebuffer);\n  }\n  disposeFramebuffer(framebuffer, contextLost) {\n    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];\n    const gl = this.gl;\n    if (!fbo) {\n      return;\n    }\n    delete framebuffer.glFramebuffers[this.CONTEXT_UID];\n    const index = this.managedFramebuffers.indexOf(framebuffer);\n    if (index >= 0) {\n      this.managedFramebuffers.splice(index, 1);\n    }\n    framebuffer.disposeRunner.remove(this);\n    if (!contextLost) {\n      gl.deleteFramebuffer(fbo.framebuffer);\n      if (fbo.msaaBuffer) {\n        gl.deleteRenderbuffer(fbo.msaaBuffer);\n      }\n      if (fbo.stencil) {\n        gl.deleteRenderbuffer(fbo.stencil);\n      }\n    }\n    if (fbo.blitFramebuffer) {\n      this.disposeFramebuffer(fbo.blitFramebuffer, contextLost);\n    }\n  }\n  disposeAll(contextLost) {\n    const list = this.managedFramebuffers;\n    this.managedFramebuffers = [];\n    for (let i = 0; i < list.length; i++) {\n      this.disposeFramebuffer(list[i], contextLost);\n    }\n  }\n  forceStencil() {\n    const framebuffer = this.current;\n    if (!framebuffer) {\n      return;\n    }\n    const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];\n    if (!fbo || fbo.stencil) {\n      return;\n    }\n    framebuffer.stencil = true;\n    const w = framebuffer.width;\n    const h = framebuffer.height;\n    const gl = this.gl;\n    const stencil = gl.createRenderbuffer();\n    gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);\n    if (fbo.msaaBuffer) {\n      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, w, h);\n    } else {\n      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w, h);\n    }\n    fbo.stencil = stencil;\n    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);\n  }\n  reset() {\n    this.current = this.unknownFramebuffer;\n    this.viewport = new Rectangle_Rectangle();\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nFramebufferSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "framebuffer"\n};\nextensions.add(FramebufferSystem);\n\n\n//# sourceMappingURL=FramebufferSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/GeometrySystem.mjs\n\n\n\n\nconst GeometrySystem_byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };\nclass GeometrySystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this._activeGeometry = null;\n    this._activeVao = null;\n    this.hasVao = true;\n    this.hasInstance = true;\n    this.canUseUInt32ElementIndex = false;\n    this.managedGeometries = {};\n  }\n  contextChange() {\n    this.disposeAll(true);\n    const gl = this.gl = this.renderer.gl;\n    const context = this.renderer.context;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n    if (context.webGLVersion !== 2) {\n      let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;\n      if (settings_lib/* settings */.Xd.PREFER_ENV === lib/* ENV */.Vi.WEBGL_LEGACY) {\n        nativeVaoExtension = null;\n      }\n      if (nativeVaoExtension) {\n        gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();\n        gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);\n        gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);\n      } else {\n        this.hasVao = false;\n        gl.createVertexArray = () => null;\n        gl.bindVertexArray = () => null;\n        gl.deleteVertexArray = () => null;\n      }\n    }\n    if (context.webGLVersion !== 2) {\n      const instanceExt = gl.getExtension("ANGLE_instanced_arrays");\n      if (instanceExt) {\n        gl.vertexAttribDivisor = (a, b) => instanceExt.vertexAttribDivisorANGLE(a, b);\n        gl.drawElementsInstanced = (a, b, c, d, e) => instanceExt.drawElementsInstancedANGLE(a, b, c, d, e);\n        gl.drawArraysInstanced = (a, b, c, d) => instanceExt.drawArraysInstancedANGLE(a, b, c, d);\n      } else {\n        this.hasInstance = false;\n      }\n    }\n    this.canUseUInt32ElementIndex = context.webGLVersion === 2 || !!context.extensions.uint32ElementIndex;\n  }\n  bind(geometry, shader) {\n    shader = shader || this.renderer.shader.shader;\n    const { gl } = this;\n    let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    let incRefCount = false;\n    if (!vaos) {\n      this.managedGeometries[geometry.id] = geometry;\n      geometry.disposeRunner.add(this);\n      geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};\n      incRefCount = true;\n    }\n    const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);\n    this._activeGeometry = geometry;\n    if (this._activeVao !== vao) {\n      this._activeVao = vao;\n      if (this.hasVao) {\n        gl.bindVertexArray(vao);\n      } else {\n        this.activateVao(geometry, shader.program);\n      }\n    }\n    this.updateBuffers();\n  }\n  reset() {\n    this.unbind();\n  }\n  updateBuffers() {\n    const geometry = this._activeGeometry;\n    const bufferSystem = this.renderer.buffer;\n    for (let i = 0; i < geometry.buffers.length; i++) {\n      const buffer = geometry.buffers[i];\n      bufferSystem.update(buffer);\n    }\n  }\n  checkCompatibility(geometry, program) {\n    const geometryAttributes = geometry.attributes;\n    const shaderAttributes = program.attributeData;\n    for (const j in shaderAttributes) {\n      if (!geometryAttributes[j]) {\n        throw new Error(`shader and geometry incompatible, geometry missing the "${j}" attribute`);\n      }\n    }\n  }\n  getSignature(geometry, program) {\n    const attribs = geometry.attributes;\n    const shaderAttributes = program.attributeData;\n    const strings = ["g", geometry.id];\n    for (const i in attribs) {\n      if (shaderAttributes[i]) {\n        strings.push(i, shaderAttributes[i].location);\n      }\n    }\n    return strings.join("-");\n  }\n  initGeometryVao(geometry, shader, incRefCount = true) {\n    const gl = this.gl;\n    const CONTEXT_UID = this.CONTEXT_UID;\n    const bufferSystem = this.renderer.buffer;\n    const program = shader.program;\n    if (!program.glPrograms[CONTEXT_UID]) {\n      this.renderer.shader.generateProgram(shader);\n    }\n    this.checkCompatibility(geometry, program);\n    const signature = this.getSignature(geometry, program);\n    const vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    let vao = vaoObjectHash[signature];\n    if (vao) {\n      vaoObjectHash[program.id] = vao;\n      return vao;\n    }\n    const buffers = geometry.buffers;\n    const attributes = geometry.attributes;\n    const tempStride = {};\n    const tempStart = {};\n    for (const j in buffers) {\n      tempStride[j] = 0;\n      tempStart[j] = 0;\n    }\n    for (const j in attributes) {\n      if (!attributes[j].size && program.attributeData[j]) {\n        attributes[j].size = program.attributeData[j].size;\n      } else if (!attributes[j].size) {\n        console.warn(`PIXI Geometry attribute \'${j}\' size cannot be determined (likely the bound shader does not have the attribute)`);\n      }\n      tempStride[attributes[j].buffer] += attributes[j].size * GeometrySystem_byteSizeMap[attributes[j].type];\n    }\n    for (const j in attributes) {\n      const attribute = attributes[j];\n      const attribSize = attribute.size;\n      if (attribute.stride === void 0) {\n        if (tempStride[attribute.buffer] === attribSize * GeometrySystem_byteSizeMap[attribute.type]) {\n          attribute.stride = 0;\n        } else {\n          attribute.stride = tempStride[attribute.buffer];\n        }\n      }\n      if (attribute.start === void 0) {\n        attribute.start = tempStart[attribute.buffer];\n        tempStart[attribute.buffer] += attribSize * GeometrySystem_byteSizeMap[attribute.type];\n      }\n    }\n    vao = gl.createVertexArray();\n    gl.bindVertexArray(vao);\n    for (let i = 0; i < buffers.length; i++) {\n      const buffer = buffers[i];\n      bufferSystem.bind(buffer);\n      if (incRefCount) {\n        buffer._glBuffers[CONTEXT_UID].refCount++;\n      }\n    }\n    this.activateVao(geometry, program);\n    vaoObjectHash[program.id] = vao;\n    vaoObjectHash[signature] = vao;\n    gl.bindVertexArray(null);\n    bufferSystem.unbind(lib/* BUFFER_TYPE */.mr.ARRAY_BUFFER);\n    return vao;\n  }\n  disposeGeometry(geometry, contextLost) {\n    if (!this.managedGeometries[geometry.id]) {\n      return;\n    }\n    delete this.managedGeometries[geometry.id];\n    const vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    const gl = this.gl;\n    const buffers = geometry.buffers;\n    const bufferSystem = this.renderer?.buffer;\n    geometry.disposeRunner.remove(this);\n    if (!vaos) {\n      return;\n    }\n    if (bufferSystem) {\n      for (let i = 0; i < buffers.length; i++) {\n        const buf = buffers[i]._glBuffers[this.CONTEXT_UID];\n        if (buf) {\n          buf.refCount--;\n          if (buf.refCount === 0 && !contextLost) {\n            bufferSystem.dispose(buffers[i], contextLost);\n          }\n        }\n      }\n    }\n    if (!contextLost) {\n      for (const vaoId in vaos) {\n        if (vaoId[0] === "g") {\n          const vao = vaos[vaoId];\n          if (this._activeVao === vao) {\n            this.unbind();\n          }\n          gl.deleteVertexArray(vao);\n        }\n      }\n    }\n    delete geometry.glVertexArrayObjects[this.CONTEXT_UID];\n  }\n  disposeAll(contextLost) {\n    const all = Object.keys(this.managedGeometries);\n    for (let i = 0; i < all.length; i++) {\n      this.disposeGeometry(this.managedGeometries[all[i]], contextLost);\n    }\n  }\n  activateVao(geometry, program) {\n    const gl = this.gl;\n    const CONTEXT_UID = this.CONTEXT_UID;\n    const bufferSystem = this.renderer.buffer;\n    const buffers = geometry.buffers;\n    const attributes = geometry.attributes;\n    if (geometry.indexBuffer) {\n      bufferSystem.bind(geometry.indexBuffer);\n    }\n    let lastBuffer = null;\n    for (const j in attributes) {\n      const attribute = attributes[j];\n      const buffer = buffers[attribute.buffer];\n      const glBuffer = buffer._glBuffers[CONTEXT_UID];\n      if (program.attributeData[j]) {\n        if (lastBuffer !== glBuffer) {\n          bufferSystem.bind(buffer);\n          lastBuffer = glBuffer;\n        }\n        const location = program.attributeData[j].location;\n        gl.enableVertexAttribArray(location);\n        gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);\n        if (attribute.instance) {\n          if (this.hasInstance) {\n            gl.vertexAttribDivisor(location, attribute.divisor);\n          } else {\n            throw new Error("geometry error, GPU Instancing is not supported on this device");\n          }\n        }\n      }\n    }\n  }\n  draw(type, size, start, instanceCount) {\n    const { gl } = this;\n    const geometry = this._activeGeometry;\n    if (geometry.indexBuffer) {\n      const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n      const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n      if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {\n        if (geometry.instanced) {\n          gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);\n        } else {\n          gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n        }\n      } else {\n        console.warn("unsupported index buffer type: uint32");\n      }\n    } else if (geometry.instanced) {\n      gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);\n    } else {\n      gl.drawArrays(type, start, size || geometry.getSize());\n    }\n    return this;\n  }\n  unbind() {\n    this.gl.bindVertexArray(null);\n    this._activeVao = null;\n    this._activeGeometry = null;\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nGeometrySystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "geometry"\n};\nextensions.add(GeometrySystem);\n\n\n//# sourceMappingURL=GeometrySystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/TextureMatrix.mjs\n\n\nconst tempMat = new Matrix();\nclass TextureMatrix_TextureMatrix {\n  constructor(texture, clampMargin) {\n    this._texture = texture;\n    this.mapCoord = new Matrix();\n    this.uClampFrame = new Float32Array(4);\n    this.uClampOffset = new Float32Array(2);\n    this._textureID = -1;\n    this._updateID = 0;\n    this.clampOffset = 0;\n    this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;\n    this.isSimple = false;\n  }\n  get texture() {\n    return this._texture;\n  }\n  set texture(value) {\n    this._texture = value;\n    this._textureID = -1;\n  }\n  multiplyUvs(uvs, out) {\n    if (out === void 0) {\n      out = uvs;\n    }\n    const mat = this.mapCoord;\n    for (let i = 0; i < uvs.length; i += 2) {\n      const x = uvs[i];\n      const y = uvs[i + 1];\n      out[i] = x * mat.a + y * mat.c + mat.tx;\n      out[i + 1] = x * mat.b + y * mat.d + mat.ty;\n    }\n    return out;\n  }\n  update(forceUpdate) {\n    const tex = this._texture;\n    if (!tex || !tex.valid) {\n      return false;\n    }\n    if (!forceUpdate && this._textureID === tex._updateID) {\n      return false;\n    }\n    this._textureID = tex._updateID;\n    this._updateID++;\n    const uvs = tex._uvs;\n    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n    const orig = tex.orig;\n    const trim = tex.trim;\n    if (trim) {\n      tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);\n      this.mapCoord.append(tempMat);\n    }\n    const texBase = tex.baseTexture;\n    const frame = this.uClampFrame;\n    const margin = this.clampMargin / texBase.resolution;\n    const offset = this.clampOffset;\n    frame[0] = (tex._frame.x + margin + offset) / texBase.width;\n    frame[1] = (tex._frame.y + margin + offset) / texBase.height;\n    frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;\n    frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;\n    this.uClampOffset[0] = offset / texBase.realWidth;\n    this.uClampOffset[1] = offset / texBase.realHeight;\n    this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;\n    return true;\n  }\n}\n\n\n//# sourceMappingURL=TextureMatrix.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter2.mjs\nvar fragment = "varying vec2 vMaskCoord;\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform sampler2D mask;\\nuniform float alpha;\\nuniform float npmAlpha;\\nuniform vec4 maskClamp;\\n\\nvoid main(void)\\n{\\n    float clip = step(3.5,\\n        step(maskClamp.x, vMaskCoord.x) +\\n        step(maskClamp.y, vMaskCoord.y) +\\n        step(vMaskCoord.x, maskClamp.z) +\\n        step(vMaskCoord.y, maskClamp.w));\\n\\n    vec4 original = texture2D(uSampler, vTextureCoord);\\n    vec4 masky = texture2D(mask, vMaskCoord);\\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\\n\\n    original *= (alphaMul * masky.r * alpha * clip);\\n\\n    gl_FragColor = original;\\n}\\n";\n\n\n//# sourceMappingURL=spriteMaskFilter2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/spriteMask/spriteMaskFilter3.mjs\nvar vertex = "attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 otherMatrix;\\n\\nvarying vec2 vMaskCoord;\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = aTextureCoord;\\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\\n}\\n";\n\n\n//# sourceMappingURL=spriteMaskFilter3.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/filters/spriteMask/SpriteMaskFilter.mjs\n\n\n\n\n\n\nclass SpriteMaskFilter extends Filter {\n  constructor(vertexSrc, fragmentSrc, uniforms) {\n    let sprite = null;\n    if (typeof vertexSrc !== "string" && fragmentSrc === void 0 && uniforms === void 0) {\n      sprite = vertexSrc;\n      vertexSrc = void 0;\n      fragmentSrc = void 0;\n      uniforms = void 0;\n    }\n    super(vertexSrc || vertex, fragmentSrc || fragment, uniforms);\n    this.maskSprite = sprite;\n    this.maskMatrix = new Matrix();\n  }\n  get maskSprite() {\n    return this._maskSprite;\n  }\n  set maskSprite(value) {\n    this._maskSprite = value;\n    if (this._maskSprite) {\n      this._maskSprite.renderable = false;\n    }\n  }\n  apply(filterManager, input, output, clearMode) {\n    const maskSprite = this._maskSprite;\n    const tex = maskSprite._texture;\n    if (!tex.valid) {\n      return;\n    }\n    if (!tex.uvMatrix) {\n      tex.uvMatrix = new TextureMatrix_TextureMatrix(tex, 0);\n    }\n    tex.uvMatrix.update();\n    this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;\n    this.uniforms.mask = tex;\n    this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);\n    this.uniforms.alpha = maskSprite.worldAlpha;\n    this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n}\n\n\n//# sourceMappingURL=SpriteMaskFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/mask/MaskData.mjs\n\n\n\nclass MaskData {\n  constructor(maskObject = null) {\n    this.type = lib/* MASK_TYPES */.A7.NONE;\n    this.autoDetect = true;\n    this.maskObject = maskObject || null;\n    this.pooled = false;\n    this.isMaskData = true;\n    this.resolution = null;\n    this.multisample = Filter.defaultMultisample;\n    this.enabled = true;\n    this.colorMask = 15;\n    this._filters = null;\n    this._stencilCounter = 0;\n    this._scissorCounter = 0;\n    this._scissorRect = null;\n    this._scissorRectLocal = null;\n    this._colorMask = 15;\n    this._target = null;\n  }\n  get filter() {\n    return this._filters ? this._filters[0] : null;\n  }\n  set filter(value) {\n    if (value) {\n      if (this._filters) {\n        this._filters[0] = value;\n      } else {\n        this._filters = [value];\n      }\n    } else {\n      this._filters = null;\n    }\n  }\n  reset() {\n    if (this.pooled) {\n      this.maskObject = null;\n      this.type = lib/* MASK_TYPES */.A7.NONE;\n      this.autoDetect = true;\n    }\n    this._target = null;\n    this._scissorRectLocal = null;\n  }\n  copyCountersOrReset(maskAbove) {\n    if (maskAbove) {\n      this._stencilCounter = maskAbove._stencilCounter;\n      this._scissorCounter = maskAbove._scissorCounter;\n      this._scissorRect = maskAbove._scissorRect;\n    } else {\n      this._stencilCounter = 0;\n      this._scissorCounter = 0;\n      this._scissorRect = null;\n    }\n  }\n}\n\n\n//# sourceMappingURL=MaskData.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/mask/MaskSystem.mjs\n\n\n\n\n\nclass MaskSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.enableScissor = true;\n    this.alphaMaskPool = [];\n    this.maskDataPool = [];\n    this.maskStack = [];\n    this.alphaMaskIndex = 0;\n  }\n  setMaskStack(maskStack) {\n    this.maskStack = maskStack;\n    this.renderer.scissor.setMaskStack(maskStack);\n    this.renderer.stencil.setMaskStack(maskStack);\n  }\n  push(target, maskDataOrTarget) {\n    let maskData = maskDataOrTarget;\n    if (!maskData.isMaskData) {\n      const d = this.maskDataPool.pop() || new MaskData();\n      d.pooled = true;\n      d.maskObject = maskDataOrTarget;\n      maskData = d;\n    }\n    const maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;\n    maskData.copyCountersOrReset(maskAbove);\n    maskData._colorMask = maskAbove ? maskAbove._colorMask : 15;\n    if (maskData.autoDetect) {\n      this.detect(maskData);\n    }\n    maskData._target = target;\n    if (maskData.type !== lib/* MASK_TYPES */.A7.SPRITE) {\n      this.maskStack.push(maskData);\n    }\n    if (maskData.enabled) {\n      switch (maskData.type) {\n        case lib/* MASK_TYPES */.A7.SCISSOR:\n          this.renderer.scissor.push(maskData);\n          break;\n        case lib/* MASK_TYPES */.A7.STENCIL:\n          this.renderer.stencil.push(maskData);\n          break;\n        case lib/* MASK_TYPES */.A7.SPRITE:\n          maskData.copyCountersOrReset(null);\n          this.pushSpriteMask(maskData);\n          break;\n        case lib/* MASK_TYPES */.A7.COLOR:\n          this.pushColorMask(maskData);\n          break;\n        default:\n          break;\n      }\n    }\n    if (maskData.type === lib/* MASK_TYPES */.A7.SPRITE) {\n      this.maskStack.push(maskData);\n    }\n  }\n  pop(target) {\n    const maskData = this.maskStack.pop();\n    if (!maskData || maskData._target !== target) {\n      return;\n    }\n    if (maskData.enabled) {\n      switch (maskData.type) {\n        case lib/* MASK_TYPES */.A7.SCISSOR:\n          this.renderer.scissor.pop(maskData);\n          break;\n        case lib/* MASK_TYPES */.A7.STENCIL:\n          this.renderer.stencil.pop(maskData.maskObject);\n          break;\n        case lib/* MASK_TYPES */.A7.SPRITE:\n          this.popSpriteMask(maskData);\n          break;\n        case lib/* MASK_TYPES */.A7.COLOR:\n          this.popColorMask(maskData);\n          break;\n        default:\n          break;\n      }\n    }\n    maskData.reset();\n    if (maskData.pooled) {\n      this.maskDataPool.push(maskData);\n    }\n    if (this.maskStack.length !== 0) {\n      const maskCurrent = this.maskStack[this.maskStack.length - 1];\n      if (maskCurrent.type === lib/* MASK_TYPES */.A7.SPRITE && maskCurrent._filters) {\n        maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;\n      }\n    }\n  }\n  detect(maskData) {\n    const maskObject = maskData.maskObject;\n    if (!maskObject) {\n      maskData.type = lib/* MASK_TYPES */.A7.COLOR;\n    } else if (maskObject.isSprite) {\n      maskData.type = lib/* MASK_TYPES */.A7.SPRITE;\n    } else if (this.enableScissor && this.renderer.scissor.testScissor(maskData)) {\n      maskData.type = lib/* MASK_TYPES */.A7.SCISSOR;\n    } else {\n      maskData.type = lib/* MASK_TYPES */.A7.STENCIL;\n    }\n  }\n  pushSpriteMask(maskData) {\n    const { maskObject } = maskData;\n    const target = maskData._target;\n    let alphaMaskFilter = maskData._filters;\n    if (!alphaMaskFilter) {\n      alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];\n      if (!alphaMaskFilter) {\n        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()];\n      }\n    }\n    const renderer = this.renderer;\n    const renderTextureSystem = renderer.renderTexture;\n    let resolution;\n    let multisample;\n    if (renderTextureSystem.current) {\n      const renderTexture = renderTextureSystem.current;\n      resolution = maskData.resolution || renderTexture.resolution;\n      multisample = maskData.multisample ?? renderTexture.multisample;\n    } else {\n      resolution = maskData.resolution || renderer.resolution;\n      multisample = maskData.multisample ?? renderer.multisample;\n    }\n    alphaMaskFilter[0].resolution = resolution;\n    alphaMaskFilter[0].multisample = multisample;\n    alphaMaskFilter[0].maskSprite = maskObject;\n    const stashFilterArea = target.filterArea;\n    target.filterArea = maskObject.getBounds(true);\n    renderer.filter.push(target, alphaMaskFilter);\n    target.filterArea = stashFilterArea;\n    if (!maskData._filters) {\n      this.alphaMaskIndex++;\n    }\n  }\n  popSpriteMask(maskData) {\n    this.renderer.filter.pop();\n    if (maskData._filters) {\n      maskData._filters[0].maskSprite = null;\n    } else {\n      this.alphaMaskIndex--;\n      this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;\n    }\n  }\n  pushColorMask(maskData) {\n    const currColorMask = maskData._colorMask;\n    const nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;\n    if (nextColorMask !== currColorMask) {\n      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);\n    }\n  }\n  popColorMask(maskData) {\n    const currColorMask = maskData._colorMask;\n    const nextColorMask = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;\n    if (nextColorMask !== currColorMask) {\n      this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);\n    }\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nMaskSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "mask"\n};\nextensions.add(MaskSystem);\n\n\n//# sourceMappingURL=MaskSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/mask/AbstractMaskSystem.mjs\nclass AbstractMaskSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.maskStack = [];\n    this.glConst = 0;\n  }\n  getStackLength() {\n    return this.maskStack.length;\n  }\n  setMaskStack(maskStack) {\n    const { gl } = this.renderer;\n    const curStackLen = this.getStackLength();\n    this.maskStack = maskStack;\n    const newStackLen = this.getStackLength();\n    if (newStackLen !== curStackLen) {\n      if (newStackLen === 0) {\n        gl.disable(this.glConst);\n      } else {\n        gl.enable(this.glConst);\n        this._useCurrent();\n      }\n    }\n  }\n  _useCurrent() {\n  }\n  destroy() {\n    this.renderer = null;\n    this.maskStack = null;\n  }\n}\n\n\n//# sourceMappingURL=AbstractMaskSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/mask/ScissorSystem.mjs\n\n\n\n\n\nconst ScissorSystem_tempMatrix = new Matrix();\nconst rectPool = [];\nconst _ScissorSystem = class extends AbstractMaskSystem {\n  constructor(renderer) {\n    super(renderer);\n    this.glConst = settings_lib/* settings */.Xd.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;\n  }\n  getStackLength() {\n    const maskData = this.maskStack[this.maskStack.length - 1];\n    if (maskData) {\n      return maskData._scissorCounter;\n    }\n    return 0;\n  }\n  calcScissorRect(maskData) {\n    if (maskData._scissorRectLocal) {\n      return;\n    }\n    const prevData = maskData._scissorRect;\n    const { maskObject } = maskData;\n    const { renderer } = this;\n    const renderTextureSystem = renderer.renderTexture;\n    const rect = maskObject.getBounds(true, rectPool.pop() ?? new Rectangle_Rectangle());\n    this.roundFrameToPixels(rect, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);\n    if (prevData) {\n      rect.fit(prevData);\n    }\n    maskData._scissorRectLocal = rect;\n  }\n  static isMatrixRotated(matrix) {\n    if (!matrix) {\n      return false;\n    }\n    const { a, b, c, d } = matrix;\n    return (Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4);\n  }\n  testScissor(maskData) {\n    const { maskObject } = maskData;\n    if (!maskObject.isFastRect || !maskObject.isFastRect()) {\n      return false;\n    }\n    if (_ScissorSystem.isMatrixRotated(maskObject.worldTransform)) {\n      return false;\n    }\n    if (_ScissorSystem.isMatrixRotated(this.renderer.projection.transform)) {\n      return false;\n    }\n    this.calcScissorRect(maskData);\n    const rect = maskData._scissorRectLocal;\n    return rect.width > 0 && rect.height > 0;\n  }\n  roundFrameToPixels(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {\n    if (_ScissorSystem.isMatrixRotated(transform)) {\n      return;\n    }\n    transform = transform ? ScissorSystem_tempMatrix.copyFrom(transform) : ScissorSystem_tempMatrix.identity();\n    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);\n    this.renderer.filter.transformAABB(transform, frame);\n    frame.fit(bindingDestinationFrame);\n    frame.x = Math.round(frame.x * resolution);\n    frame.y = Math.round(frame.y * resolution);\n    frame.width = Math.round(frame.width * resolution);\n    frame.height = Math.round(frame.height * resolution);\n  }\n  push(maskData) {\n    if (!maskData._scissorRectLocal) {\n      this.calcScissorRect(maskData);\n    }\n    const { gl } = this.renderer;\n    if (!maskData._scissorRect) {\n      gl.enable(gl.SCISSOR_TEST);\n    }\n    maskData._scissorCounter++;\n    maskData._scissorRect = maskData._scissorRectLocal;\n    this._useCurrent();\n  }\n  pop(maskData) {\n    const { gl } = this.renderer;\n    if (maskData) {\n      rectPool.push(maskData._scissorRectLocal);\n    }\n    if (this.getStackLength() > 0) {\n      this._useCurrent();\n    } else {\n      gl.disable(gl.SCISSOR_TEST);\n    }\n  }\n  _useCurrent() {\n    const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;\n    let y;\n    if (this.renderer.renderTexture.current) {\n      y = rect.y;\n    } else {\n      y = this.renderer.height - rect.height - rect.y;\n    }\n    this.renderer.gl.scissor(rect.x, y, rect.width, rect.height);\n  }\n};\nlet ScissorSystem = _ScissorSystem;\nScissorSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "scissor"\n};\nextensions.add(ScissorSystem);\n\n\n//# sourceMappingURL=ScissorSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/mask/StencilSystem.mjs\n\n\n\n\nclass StencilSystem extends AbstractMaskSystem {\n  constructor(renderer) {\n    super(renderer);\n    this.glConst = settings_lib/* settings */.Xd.ADAPTER.getWebGLRenderingContext().STENCIL_TEST;\n  }\n  getStackLength() {\n    const maskData = this.maskStack[this.maskStack.length - 1];\n    if (maskData) {\n      return maskData._stencilCounter;\n    }\n    return 0;\n  }\n  push(maskData) {\n    const maskObject = maskData.maskObject;\n    const { gl } = this.renderer;\n    const prevMaskCount = maskData._stencilCounter;\n    if (prevMaskCount === 0) {\n      this.renderer.framebuffer.forceStencil();\n      gl.clearStencil(0);\n      gl.clear(gl.STENCIL_BUFFER_BIT);\n      gl.enable(gl.STENCIL_TEST);\n    }\n    maskData._stencilCounter++;\n    const colorMask = maskData._colorMask;\n    if (colorMask !== 0) {\n      maskData._colorMask = 0;\n      gl.colorMask(false, false, false, false);\n    }\n    gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295);\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);\n    maskObject.renderable = true;\n    maskObject.render(this.renderer);\n    this.renderer.batch.flush();\n    maskObject.renderable = false;\n    if (colorMask !== 0) {\n      maskData._colorMask = colorMask;\n      gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);\n    }\n    this._useCurrent();\n  }\n  pop(maskObject) {\n    const gl = this.renderer.gl;\n    if (this.getStackLength() === 0) {\n      gl.disable(gl.STENCIL_TEST);\n    } else {\n      const maskData = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;\n      const colorMask = maskData ? maskData._colorMask : 15;\n      if (colorMask !== 0) {\n        maskData._colorMask = 0;\n        gl.colorMask(false, false, false, false);\n      }\n      gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);\n      maskObject.renderable = true;\n      maskObject.render(this.renderer);\n      this.renderer.batch.flush();\n      maskObject.renderable = false;\n      if (colorMask !== 0) {\n        maskData._colorMask = colorMask;\n        gl.colorMask((colorMask & 1) !== 0, (colorMask & 2) !== 0, (colorMask & 4) !== 0, (colorMask & 8) !== 0);\n      }\n      this._useCurrent();\n    }\n  }\n  _useCurrent() {\n    const gl = this.renderer.gl;\n    gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295);\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n  }\n}\nStencilSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "stencil"\n};\nextensions.add(StencilSystem);\n\n\n//# sourceMappingURL=StencilSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/plugin/PluginSystem.mjs\n\n\n\nclass PluginSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.plugins = {};\n    Object.defineProperties(this.plugins, {\n      extract: {\n        enumerable: false,\n        get() {\n          (0,utils_lib.deprecation)("7.0.0", "renderer.plugins.extract has moved to renderer.extract");\n          return renderer.extract;\n        }\n      },\n      prepare: {\n        enumerable: false,\n        get() {\n          (0,utils_lib.deprecation)("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare");\n          return renderer.prepare;\n        }\n      },\n      interaction: {\n        enumerable: false,\n        get() {\n          (0,utils_lib.deprecation)("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events");\n          return renderer.events;\n        }\n      }\n    });\n  }\n  init() {\n    const staticMap = this.rendererPlugins;\n    for (const o in staticMap) {\n      this.plugins[o] = new staticMap[o](this.renderer);\n    }\n  }\n  destroy() {\n    for (const o in this.plugins) {\n      this.plugins[o].destroy();\n      this.plugins[o] = null;\n    }\n  }\n}\nPluginSystem.extension = {\n  type: [\n    ExtensionType.RendererSystem,\n    ExtensionType.CanvasRendererSystem\n  ],\n  name: "_plugin"\n};\nextensions.add(PluginSystem);\n\n\n//# sourceMappingURL=PluginSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/projection/ProjectionSystem.mjs\n\n\n\nclass ProjectionSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.destinationFrame = null;\n    this.sourceFrame = null;\n    this.defaultFrame = null;\n    this.projectionMatrix = new Matrix();\n    this.transform = null;\n  }\n  update(destinationFrame, sourceFrame, resolution, root) {\n    this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;\n    this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;\n    this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root);\n    if (this.transform) {\n      this.projectionMatrix.append(this.transform);\n    }\n    const renderer = this.renderer;\n    renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;\n    renderer.globalUniforms.update();\n    if (renderer.shader.shader) {\n      renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);\n    }\n  }\n  calculateProjection(_destinationFrame, sourceFrame, _resolution, root) {\n    const pm = this.projectionMatrix;\n    const sign = !root ? 1 : -1;\n    pm.identity();\n    pm.a = 1 / sourceFrame.width * 2;\n    pm.d = sign * (1 / sourceFrame.height * 2);\n    pm.tx = -1 - sourceFrame.x * pm.a;\n    pm.ty = -sign - sourceFrame.y * pm.d;\n  }\n  setTransform(_matrix) {\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nProjectionSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "projection"\n};\nextensions.add(ProjectionSystem);\n\n\n//# sourceMappingURL=ProjectionSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/renderTexture/GenerateTextureSystem.mjs\n\n\n\n\nconst tempTransform = new Transform_Transform();\nclass GenerateTextureSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this._tempMatrix = new Matrix();\n  }\n  generateTexture(displayObject, options) {\n    const { region: manualRegion, ...textureOptions } = options || {};\n    const region = manualRegion || displayObject.getLocalBounds(null, true);\n    if (region.width === 0)\n      region.width = 1;\n    if (region.height === 0)\n      region.height = 1;\n    const renderTexture = RenderTexture.create({\n      width: region.width,\n      height: region.height,\n      ...textureOptions\n    });\n    this._tempMatrix.tx = -region.x;\n    this._tempMatrix.ty = -region.y;\n    const transform = displayObject.transform;\n    displayObject.transform = tempTransform;\n    this.renderer.render(displayObject, {\n      renderTexture,\n      transform: this._tempMatrix,\n      skipUpdateTransform: !!displayObject.parent,\n      blit: true\n    });\n    displayObject.transform = transform;\n    return renderTexture;\n  }\n  destroy() {\n  }\n}\nGenerateTextureSystem.extension = {\n  type: [\n    ExtensionType.RendererSystem,\n    ExtensionType.CanvasRendererSystem\n  ],\n  name: "textureGenerator"\n};\nextensions.add(GenerateTextureSystem);\n\n\n//# sourceMappingURL=GenerateTextureSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/renderTexture/RenderTextureSystem.mjs\n\n\n\n\nconst tempRect = new Rectangle_Rectangle();\nconst tempRect2 = new Rectangle_Rectangle();\nclass RenderTextureSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.defaultMaskStack = [];\n    this.current = null;\n    this.sourceFrame = new Rectangle_Rectangle();\n    this.destinationFrame = new Rectangle_Rectangle();\n    this.viewportFrame = new Rectangle_Rectangle();\n  }\n  contextChange() {\n    const attributes = this.renderer?.gl.getContextAttributes();\n    this._rendererPremultipliedAlpha = !!(attributes && attributes.alpha && attributes.premultipliedAlpha);\n  }\n  bind(renderTexture = null, sourceFrame, destinationFrame) {\n    const renderer = this.renderer;\n    this.current = renderTexture;\n    let baseTexture;\n    let framebuffer;\n    let resolution;\n    if (renderTexture) {\n      baseTexture = renderTexture.baseTexture;\n      resolution = baseTexture.resolution;\n      if (!sourceFrame) {\n        tempRect.width = renderTexture.frame.width;\n        tempRect.height = renderTexture.frame.height;\n        sourceFrame = tempRect;\n      }\n      if (!destinationFrame) {\n        tempRect2.x = renderTexture.frame.x;\n        tempRect2.y = renderTexture.frame.y;\n        tempRect2.width = sourceFrame.width;\n        tempRect2.height = sourceFrame.height;\n        destinationFrame = tempRect2;\n      }\n      framebuffer = baseTexture.framebuffer;\n    } else {\n      resolution = renderer.resolution;\n      if (!sourceFrame) {\n        tempRect.width = renderer._view.screen.width;\n        tempRect.height = renderer._view.screen.height;\n        sourceFrame = tempRect;\n      }\n      if (!destinationFrame) {\n        destinationFrame = tempRect;\n        destinationFrame.width = sourceFrame.width;\n        destinationFrame.height = sourceFrame.height;\n      }\n    }\n    const viewportFrame = this.viewportFrame;\n    viewportFrame.x = destinationFrame.x * resolution;\n    viewportFrame.y = destinationFrame.y * resolution;\n    viewportFrame.width = destinationFrame.width * resolution;\n    viewportFrame.height = destinationFrame.height * resolution;\n    if (!renderTexture) {\n      viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height);\n    }\n    viewportFrame.ceil();\n    this.renderer.framebuffer.bind(framebuffer, viewportFrame);\n    this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);\n    if (renderTexture) {\n      this.renderer.mask.setMaskStack(baseTexture.maskStack);\n    } else {\n      this.renderer.mask.setMaskStack(this.defaultMaskStack);\n    }\n    this.sourceFrame.copyFrom(sourceFrame);\n    this.destinationFrame.copyFrom(destinationFrame);\n  }\n  clear(clearColor, mask) {\n    const fallbackColor = this.current ? this.current.baseTexture.clear : this.renderer.background.backgroundColor;\n    const color = color_lib/* Color */.I.shared.setValue(clearColor ? clearColor : fallbackColor);\n    if (this.current && this.current.baseTexture.alphaMode > 0 || !this.current && this._rendererPremultipliedAlpha) {\n      color.premultiply(color.alpha);\n    }\n    const destinationFrame = this.destinationFrame;\n    const baseFrame = this.current ? this.current.baseTexture : this.renderer._view.screen;\n    const clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;\n    if (clearMask) {\n      let { x, y, width, height } = this.viewportFrame;\n      x = Math.round(x);\n      y = Math.round(y);\n      width = Math.round(width);\n      height = Math.round(height);\n      this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);\n      this.renderer.gl.scissor(x, y, width, height);\n    }\n    this.renderer.framebuffer.clear(color.red, color.green, color.blue, color.alpha, mask);\n    if (clearMask) {\n      this.renderer.scissor.pop();\n    }\n  }\n  resize() {\n    this.bind(null);\n  }\n  reset() {\n    this.bind(null);\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nRenderTextureSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "renderTexture"\n};\nextensions.add(RenderTextureSystem);\n\n\n//# sourceMappingURL=RenderTextureSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/GLProgram.mjs\nclass IGLUniformData {\n}\nclass GLProgram {\n  constructor(program, uniformData) {\n    this.program = program;\n    this.uniformData = uniformData;\n    this.uniformGroups = {};\n    this.uniformDirtyGroups = {};\n    this.uniformBufferBindings = {};\n  }\n  destroy() {\n    this.uniformData = null;\n    this.uniformGroups = null;\n    this.uniformDirtyGroups = null;\n    this.uniformBufferBindings = null;\n    this.program = null;\n  }\n}\n\n\n//# sourceMappingURL=GLProgram.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/compileShader.mjs\nfunction compileShader(gl, type, src) {\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, src);\n  gl.compileShader(shader);\n  return shader;\n}\n\n\n//# sourceMappingURL=compileShader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/defaultValue.mjs\nfunction booleanArray(size) {\n  const array = new Array(size);\n  for (let i = 0; i < array.length; i++) {\n    array[i] = false;\n  }\n  return array;\n}\nfunction defaultValue(type, size) {\n  switch (type) {\n    case "float":\n      return 0;\n    case "vec2":\n      return new Float32Array(2 * size);\n    case "vec3":\n      return new Float32Array(3 * size);\n    case "vec4":\n      return new Float32Array(4 * size);\n    case "int":\n    case "uint":\n    case "sampler2D":\n    case "sampler2DArray":\n      return 0;\n    case "ivec2":\n      return new Int32Array(2 * size);\n    case "ivec3":\n      return new Int32Array(3 * size);\n    case "ivec4":\n      return new Int32Array(4 * size);\n    case "uvec2":\n      return new Uint32Array(2 * size);\n    case "uvec3":\n      return new Uint32Array(3 * size);\n    case "uvec4":\n      return new Uint32Array(4 * size);\n    case "bool":\n      return false;\n    case "bvec2":\n      return booleanArray(2 * size);\n    case "bvec3":\n      return booleanArray(3 * size);\n    case "bvec4":\n      return booleanArray(4 * size);\n    case "mat2":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        1\n      ]);\n    case "mat3":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ]);\n    case "mat4":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ]);\n  }\n  return null;\n}\n\n\n//# sourceMappingURL=defaultValue.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/getAttributeData.mjs\n\n\n\nfunction getAttributeData(program, gl) {\n  const attributes = {};\n  const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n  for (let i = 0; i < totalAttributes; i++) {\n    const attribData = gl.getActiveAttrib(program, i);\n    if (attribData.name.startsWith("gl_")) {\n      continue;\n    }\n    const type = mapType(gl, attribData.type);\n    const data = {\n      type,\n      name: attribData.name,\n      size: mapSize(type),\n      location: gl.getAttribLocation(program, attribData.name)\n    };\n    attributes[attribData.name] = data;\n  }\n  return attributes;\n}\n\n\n//# sourceMappingURL=getAttributeData.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/getUniformData.mjs\n\n\n\nfunction getUniformData(program, gl) {\n  const uniforms = {};\n  const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n  for (let i = 0; i < totalUniforms; i++) {\n    const uniformData = gl.getActiveUniform(program, i);\n    const name = uniformData.name.replace(/\\[.*?\\]$/, "");\n    const isArray = !!uniformData.name.match(/\\[.*?\\]$/);\n    const type = mapType(gl, uniformData.type);\n    uniforms[name] = {\n      name,\n      index: i,\n      type,\n      size: uniformData.size,\n      isArray,\n      value: defaultValue(type, uniformData.size)\n    };\n  }\n  return uniforms;\n}\n\n\n//# sourceMappingURL=getUniformData.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/logProgramError.mjs\nfunction logPrettyShaderError(gl, shader) {\n  const shaderSrc = gl.getShaderSource(shader).split("\\n").map((line, index) => `${index}: ${line}`);\n  const shaderLog = gl.getShaderInfoLog(shader);\n  const splitShader = shaderLog.split("\\n");\n  const dedupe = {};\n  const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\\: 0\\:([\\d]+)\\:.*$/, "$1"))).filter((n) => {\n    if (n && !dedupe[n]) {\n      dedupe[n] = true;\n      return true;\n    }\n    return false;\n  });\n  const logArgs = [""];\n  lineNumbers.forEach((number) => {\n    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;\n    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");\n  });\n  const fragmentSourceToLog = shaderSrc.join("\\n");\n  logArgs[0] = fragmentSourceToLog;\n  console.error(shaderLog);\n  console.groupCollapsed("click to view full shader code");\n  console.warn(...logArgs);\n  console.groupEnd();\n}\nfunction logProgramError(gl, program, vertexShader, fragmentShader) {\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n      logPrettyShaderError(gl, vertexShader);\n    }\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n      logPrettyShaderError(gl, fragmentShader);\n    }\n    console.error("PixiJS Error: Could not initialize shader.");\n    if (gl.getProgramInfoLog(program) !== "") {\n      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));\n    }\n  }\n}\n\n\n//# sourceMappingURL=logProgramError.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/generateProgram.mjs\n\n\n\n\n\n\n\nfunction generateProgram(gl, program) {\n  const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc);\n  const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc);\n  const webGLProgram = gl.createProgram();\n  gl.attachShader(webGLProgram, glVertShader);\n  gl.attachShader(webGLProgram, glFragShader);\n  const transformFeedbackVaryings = program.extra?.transformFeedbackVaryings;\n  if (transformFeedbackVaryings) {\n    if (typeof gl.transformFeedbackVaryings !== "function") {\n      console.warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);\n    } else {\n      gl.transformFeedbackVaryings(webGLProgram, transformFeedbackVaryings.names, transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS);\n    }\n  }\n  gl.linkProgram(webGLProgram);\n  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {\n    logProgramError(gl, webGLProgram, glVertShader, glFragShader);\n  }\n  program.attributeData = getAttributeData(webGLProgram, gl);\n  program.uniformData = getUniformData(webGLProgram, gl);\n  if (!/^[ \\t]*#[ \\t]*version[ \\t]+300[ \\t]+es[ \\t]*$/m.test(program.vertexSrc)) {\n    const keys = Object.keys(program.attributeData);\n    keys.sort((a, b) => a > b ? 1 : -1);\n    for (let i = 0; i < keys.length; i++) {\n      program.attributeData[keys[i]].location = i;\n      gl.bindAttribLocation(webGLProgram, i, keys[i]);\n    }\n    gl.linkProgram(webGLProgram);\n  }\n  gl.deleteShader(glVertShader);\n  gl.deleteShader(glFragShader);\n  const uniformData = {};\n  for (const i in program.uniformData) {\n    const data = program.uniformData[i];\n    uniformData[i] = {\n      location: gl.getUniformLocation(webGLProgram, i),\n      value: defaultValue(data.type, data.size)\n    };\n  }\n  const glProgram = new GLProgram(webGLProgram, uniformData);\n  return glProgram;\n}\n\n\n//# sourceMappingURL=generateProgram.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/generateUniformBufferSync.mjs\n\n\n\n\nfunction uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {\n  _renderer.buffer.update(buffer);\n}\nconst UBO_TO_SINGLE_SETTERS = {\n  float: `\n        data[offset] = v;\n    `,\n  vec2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    `,\n  vec3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    `,\n  vec4: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    `,\n  mat2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    `,\n  mat3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    `,\n  mat4: `\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    `\n};\nconst GLSL_TO_STD40_SIZE = {\n  float: 4,\n  vec2: 8,\n  vec3: 12,\n  vec4: 16,\n  int: 4,\n  ivec2: 8,\n  ivec3: 12,\n  ivec4: 16,\n  uint: 4,\n  uvec2: 8,\n  uvec3: 12,\n  uvec4: 16,\n  bool: 4,\n  bvec2: 8,\n  bvec3: 12,\n  bvec4: 16,\n  mat2: 16 * 2,\n  mat3: 16 * 3,\n  mat4: 16 * 4\n};\nfunction createUBOElements(uniformData) {\n  const uboElements = uniformData.map((data) => ({\n    data,\n    offset: 0,\n    dataLen: 0,\n    dirty: 0\n  }));\n  let size = 0;\n  let chunkSize = 0;\n  let offset = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    size = GLSL_TO_STD40_SIZE[uboElement.data.type];\n    if (uboElement.data.size > 1) {\n      size = Math.max(size, 16) * uboElement.data.size;\n    }\n    uboElement.dataLen = size;\n    if (chunkSize % size !== 0 && chunkSize < 16) {\n      const lineUpValue = chunkSize % size % 16;\n      chunkSize += lineUpValue;\n      offset += lineUpValue;\n    }\n    if (chunkSize + size > 16) {\n      offset = Math.ceil(offset / 16) * 16;\n      uboElement.offset = offset;\n      offset += size;\n      chunkSize = size;\n    } else {\n      uboElement.offset = offset;\n      chunkSize += size;\n      offset += size;\n    }\n  }\n  offset = Math.ceil(offset / 16) * 16;\n  return { uboElements, size: offset };\n}\nfunction getUBOData(uniforms, uniformData) {\n  const usedUniformDatas = [];\n  for (const i in uniforms) {\n    if (uniformData[i]) {\n      usedUniformDatas.push(uniformData[i]);\n    }\n  }\n  usedUniformDatas.sort((a, b) => a.index - b.index);\n  return usedUniformDatas;\n}\nfunction generateUniformBufferSync(group, uniformData) {\n  if (!group.autoManage) {\n    return { size: 0, syncFunc: uboUpdate };\n  }\n  const usedUniformDatas = getUBOData(group.uniforms, uniformData);\n  const { uboElements, size } = createUBOElements(usedUniformDatas);\n  const funcFragments = [`\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    `];\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    const uniform = group.uniforms[uboElement.data.name];\n    const name = uboElement.data.name;\n    let parsed = false;\n    for (let j = 0; j < uniformParsers.length; j++) {\n      const uniformParser = uniformParsers[j];\n      if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {\n        funcFragments.push(`offset = ${uboElement.offset / 4};`, uniformParsers[j].codeUbo(uboElement.data.name, uniform));\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      if (uboElement.data.size > 1) {\n        const size2 = mapSize(uboElement.data.type);\n        const rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);\n        const elementSize = size2 / rowSize;\n        const remainder = (4 - elementSize % 4) % 4;\n        funcFragments.push(`\n                cv = ud.${name}.value;\n                v = uv.${name};\n                offset = ${uboElement.offset / 4};\n\n                t = 0;\n\n                for(var i=0; i < ${uboElement.data.size * rowSize}; i++)\n                {\n                    for(var j = 0; j < ${elementSize}; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += ${remainder};\n                }\n\n                `);\n      } else {\n        const template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];\n        funcFragments.push(`\n                cv = ud.${name}.value;\n                v = uv.${name};\n                offset = ${uboElement.offset / 4};\n                ${template};\n                `);\n      }\n    }\n  }\n  funcFragments.push(`\n       renderer.buffer.update(buffer);\n    `);\n  return {\n    size,\n    syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", funcFragments.join("\\n"))\n  };\n}\n\n\n//# sourceMappingURL=generateUniformBufferSync.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/utils/unsafeEvalSupported.mjs\nlet unsafeEval;\nfunction unsafeEvalSupported() {\n  if (typeof unsafeEval === "boolean") {\n    return unsafeEval;\n  }\n  try {\n    const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");\n    unsafeEval = func({ a: "b" }, "a", "b") === true;\n  } catch (e) {\n    unsafeEval = false;\n  }\n  return unsafeEval;\n}\n\n\n//# sourceMappingURL=unsafeEvalSupported.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/shader/ShaderSystem.mjs\n\n\n\n\n\n\n\nlet ShaderSystem_UID = 0;\nconst defaultSyncData = { textureCount: 0, uboCount: 0 };\nclass ShaderSystem {\n  constructor(renderer) {\n    this.destroyed = false;\n    this.renderer = renderer;\n    this.systemCheck();\n    this.gl = null;\n    this.shader = null;\n    this.program = null;\n    this.cache = {};\n    this._uboCache = {};\n    this.id = ShaderSystem_UID++;\n  }\n  systemCheck() {\n    if (!unsafeEvalSupported()) {\n      throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");\n    }\n  }\n  contextChange(gl) {\n    this.gl = gl;\n    this.reset();\n  }\n  bind(shader, dontSync) {\n    shader.disposeRunner.add(this);\n    shader.uniforms.globals = this.renderer.globalUniforms;\n    const program = shader.program;\n    const glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);\n    this.shader = shader;\n    if (this.program !== program) {\n      this.program = program;\n      this.gl.useProgram(glProgram.program);\n    }\n    if (!dontSync) {\n      defaultSyncData.textureCount = 0;\n      defaultSyncData.uboCount = 0;\n      this.syncUniformGroup(shader.uniformGroup, defaultSyncData);\n    }\n    return glProgram;\n  }\n  setUniforms(uniforms) {\n    const shader = this.shader.program;\n    const glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];\n    shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);\n  }\n  syncUniformGroup(group, syncData) {\n    const glProgram = this.getGlProgram();\n    if (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) {\n      glProgram.uniformDirtyGroups[group.id] = group.dirtyId;\n      this.syncUniforms(group, glProgram, syncData);\n    }\n  }\n  syncUniforms(group, glProgram, syncData) {\n    const syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);\n    syncFunc(glProgram.uniformData, group.uniforms, this.renderer, syncData);\n  }\n  createSyncGroups(group) {\n    const id = this.getSignature(group, this.shader.program.uniformData, "u");\n    if (!this.cache[id]) {\n      this.cache[id] = generateUniformsSync(group, this.shader.program.uniformData);\n    }\n    group.syncUniforms[this.shader.program.id] = this.cache[id];\n    return group.syncUniforms[this.shader.program.id];\n  }\n  syncUniformBufferGroup(group, name) {\n    const glProgram = this.getGlProgram();\n    if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {\n      group.dirtyId = 0;\n      const syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name);\n      group.buffer.update();\n      syncFunc(glProgram.uniformData, group.uniforms, this.renderer, defaultSyncData, group.buffer);\n    }\n    this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name]);\n  }\n  createSyncBufferGroup(group, glProgram, name) {\n    const { gl } = this.renderer;\n    this.renderer.buffer.bind(group.buffer);\n    const uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name);\n    glProgram.uniformBufferBindings[name] = this.shader.uniformBindCount;\n    gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount);\n    this.shader.uniformBindCount++;\n    const id = this.getSignature(group, this.shader.program.uniformData, "ubo");\n    let uboData = this._uboCache[id];\n    if (!uboData) {\n      uboData = this._uboCache[id] = generateUniformBufferSync(group, this.shader.program.uniformData);\n    }\n    if (group.autoManage) {\n      const data = new Float32Array(uboData.size / 4);\n      group.buffer.update(data);\n    }\n    glProgram.uniformGroups[group.id] = uboData.syncFunc;\n    return glProgram.uniformGroups[group.id];\n  }\n  getSignature(group, uniformData, preFix) {\n    const uniforms = group.uniforms;\n    const strings = [`${preFix}-`];\n    for (const i in uniforms) {\n      strings.push(i);\n      if (uniformData[i]) {\n        strings.push(uniformData[i].type);\n      }\n    }\n    return strings.join("-");\n  }\n  getGlProgram() {\n    if (this.shader) {\n      return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];\n    }\n    return null;\n  }\n  generateProgram(shader) {\n    const gl = this.gl;\n    const program = shader.program;\n    const glProgram = generateProgram(gl, program);\n    program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;\n    return glProgram;\n  }\n  reset() {\n    this.program = null;\n    this.shader = null;\n  }\n  disposeShader(shader) {\n    if (this.shader === shader) {\n      this.shader = null;\n    }\n  }\n  destroy() {\n    this.renderer = null;\n    this.destroyed = true;\n  }\n}\nShaderSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "shader"\n};\nextensions.add(ShaderSystem);\n\n\n//# sourceMappingURL=ShaderSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/startup/StartupSystem.mjs\n\n\nclass StartupSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  run(options) {\n    const { renderer } = this;\n    renderer.runners.init.emit(renderer.options);\n    if (options.hello) {\n      console.log(`PixiJS ${"7.2.4"} - ${renderer.rendererLogId} - https://pixijs.com`);\n    }\n    renderer.resize(renderer.screen.width, renderer.screen.height);\n  }\n  destroy() {\n  }\n}\nStartupSystem.defaultOptions = {\n  hello: false\n};\nStartupSystem.extension = {\n  type: [\n    ExtensionType.RendererSystem,\n    ExtensionType.CanvasRendererSystem\n  ],\n  name: "startup"\n};\nextensions.add(StartupSystem);\n\n\n//# sourceMappingURL=StartupSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/state/utils/mapWebGLBlendModesToPixi.mjs\n\n\nfunction mapWebGLBlendModesToPixi(gl, array = []) {\n  array[lib/* BLEND_MODES */.T$.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES */.T$.ADD] = [gl.ONE, gl.ONE];\n  array[lib/* BLEND_MODES */.T$.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES */.T$.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES */.T$.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES */.T$.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES */.T$.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES */.T$.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES */.T$.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES */.T$.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES */.T$.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES */.T$.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES */.T$.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES */.T$.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES */.T$.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES */.T$.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES */.T$.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES */.T$.NONE] = [0, 0];\n  array[lib/* BLEND_MODES */.T$.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES */.T$.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];\n  array[lib/* BLEND_MODES */.T$.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES */.T$.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];\n  array[lib/* BLEND_MODES */.T$.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];\n  array[lib/* BLEND_MODES */.T$.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES */.T$.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];\n  array[lib/* BLEND_MODES */.T$.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];\n  array[lib/* BLEND_MODES */.T$.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES */.T$.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];\n  array[lib/* BLEND_MODES */.T$.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];\n  array[lib/* BLEND_MODES */.T$.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];\n  return array;\n}\n\n\n//# sourceMappingURL=mapWebGLBlendModesToPixi.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/state/StateSystem.mjs\n\n\n\n\n\nconst StateSystem_BLEND = 0;\nconst StateSystem_OFFSET = 1;\nconst StateSystem_CULLING = 2;\nconst StateSystem_DEPTH_TEST = 3;\nconst StateSystem_WINDING = 4;\nconst StateSystem_DEPTH_MASK = 5;\nconst _StateSystem = class {\n  constructor() {\n    this.gl = null;\n    this.stateId = 0;\n    this.polygonOffset = 0;\n    this.blendMode = lib/* BLEND_MODES */.T$.NONE;\n    this._blendEq = false;\n    this.map = [];\n    this.map[StateSystem_BLEND] = this.setBlend;\n    this.map[StateSystem_OFFSET] = this.setOffset;\n    this.map[StateSystem_CULLING] = this.setCullFace;\n    this.map[StateSystem_DEPTH_TEST] = this.setDepthTest;\n    this.map[StateSystem_WINDING] = this.setFrontFace;\n    this.map[StateSystem_DEPTH_MASK] = this.setDepthMask;\n    this.checks = [];\n    this.defaultState = new State();\n    this.defaultState.blend = true;\n  }\n  contextChange(gl) {\n    this.gl = gl;\n    this.blendModes = mapWebGLBlendModesToPixi(gl);\n    this.set(this.defaultState);\n    this.reset();\n  }\n  set(state) {\n    state = state || this.defaultState;\n    if (this.stateId !== state.data) {\n      let diff = this.stateId ^ state.data;\n      let i = 0;\n      while (diff) {\n        if (diff & 1) {\n          this.map[i].call(this, !!(state.data & 1 << i));\n        }\n        diff = diff >> 1;\n        i++;\n      }\n      this.stateId = state.data;\n    }\n    for (let i = 0; i < this.checks.length; i++) {\n      this.checks[i](this, state);\n    }\n  }\n  forceState(state) {\n    state = state || this.defaultState;\n    for (let i = 0; i < this.map.length; i++) {\n      this.map[i].call(this, !!(state.data & 1 << i));\n    }\n    for (let i = 0; i < this.checks.length; i++) {\n      this.checks[i](this, state);\n    }\n    this.stateId = state.data;\n  }\n  setBlend(value) {\n    this.updateCheck(_StateSystem.checkBlendMode, value);\n    this.gl[value ? "enable" : "disable"](this.gl.BLEND);\n  }\n  setOffset(value) {\n    this.updateCheck(_StateSystem.checkPolygonOffset, value);\n    this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);\n  }\n  setDepthTest(value) {\n    this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);\n  }\n  setDepthMask(value) {\n    this.gl.depthMask(value);\n  }\n  setCullFace(value) {\n    this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);\n  }\n  setFrontFace(value) {\n    this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);\n  }\n  setBlendMode(value) {\n    if (value === this.blendMode) {\n      return;\n    }\n    this.blendMode = value;\n    const mode = this.blendModes[value];\n    const gl = this.gl;\n    if (mode.length === 2) {\n      gl.blendFunc(mode[0], mode[1]);\n    } else {\n      gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);\n    }\n    if (mode.length === 6) {\n      this._blendEq = true;\n      gl.blendEquationSeparate(mode[4], mode[5]);\n    } else if (this._blendEq) {\n      this._blendEq = false;\n      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n    }\n  }\n  setPolygonOffset(value, scale) {\n    this.gl.polygonOffset(value, scale);\n  }\n  reset() {\n    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);\n    this.forceState(this.defaultState);\n    this._blendEq = true;\n    this.blendMode = -1;\n    this.setBlendMode(0);\n  }\n  updateCheck(func, value) {\n    const index = this.checks.indexOf(func);\n    if (value && index === -1) {\n      this.checks.push(func);\n    } else if (!value && index !== -1) {\n      this.checks.splice(index, 1);\n    }\n  }\n  static checkBlendMode(system, state) {\n    system.setBlendMode(state.blendMode);\n  }\n  static checkPolygonOffset(system, state) {\n    system.setPolygonOffset(1, state.polygonOffset);\n  }\n  destroy() {\n    this.gl = null;\n  }\n};\nlet StateSystem = _StateSystem;\nStateSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "state"\n};\nextensions.add(StateSystem);\n\n\n//# sourceMappingURL=StateSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/system/SystemManager.mjs\n\n\n\nclass SystemManager extends utils_lib.EventEmitter {\n  constructor() {\n    super(...arguments);\n    this.runners = {};\n    this._systemsHash = {};\n  }\n  setup(config) {\n    this.addRunners(...config.runners);\n    const priority = (config.priority ?? []).filter((key) => config.systems[key]);\n    const orderByPriority = [\n      ...priority,\n      ...Object.keys(config.systems).filter((key) => !priority.includes(key))\n    ];\n    for (const i of orderByPriority) {\n      this.addSystem(config.systems[i], i);\n    }\n  }\n  addRunners(...runnerIds) {\n    runnerIds.forEach((runnerId) => {\n      this.runners[runnerId] = new Runner_Runner(runnerId);\n    });\n  }\n  addSystem(ClassRef, name) {\n    const system = new ClassRef(this);\n    if (this[name]) {\n      throw new Error(`Whoops! The name "${name}" is already in use`);\n    }\n    this[name] = system;\n    this._systemsHash[name] = system;\n    for (const i in this.runners) {\n      this.runners[i].add(system);\n    }\n    return this;\n  }\n  emitWithCustomOptions(runner, options) {\n    const systemHashKeys = Object.keys(this._systemsHash);\n    runner.items.forEach((system) => {\n      const systemName = systemHashKeys.find((systemId) => this._systemsHash[systemId] === system);\n      system[runner.name](options[systemName]);\n    });\n  }\n  destroy() {\n    Object.values(this.runners).forEach((runner) => {\n      runner.destroy();\n    });\n    this._systemsHash = {};\n  }\n}\n\n\n//# sourceMappingURL=SystemManager.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/TextureGCSystem.mjs\n\n\n\nconst _TextureGCSystem = class {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.count = 0;\n    this.checkCount = 0;\n    this.maxIdle = _TextureGCSystem.defaultMaxIdle;\n    this.checkCountMax = _TextureGCSystem.defaultCheckCountMax;\n    this.mode = _TextureGCSystem.defaultMode;\n  }\n  postrender() {\n    if (!this.renderer.objectRenderer.renderingToScreen) {\n      return;\n    }\n    this.count++;\n    if (this.mode === lib/* GC_MODES */.UN.MANUAL) {\n      return;\n    }\n    this.checkCount++;\n    if (this.checkCount > this.checkCountMax) {\n      this.checkCount = 0;\n      this.run();\n    }\n  }\n  run() {\n    const tm = this.renderer.texture;\n    const managedTextures = tm.managedTextures;\n    let wasRemoved = false;\n    for (let i = 0; i < managedTextures.length; i++) {\n      const texture = managedTextures[i];\n      if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {\n        tm.destroyTexture(texture, true);\n        managedTextures[i] = null;\n        wasRemoved = true;\n      }\n    }\n    if (wasRemoved) {\n      let j = 0;\n      for (let i = 0; i < managedTextures.length; i++) {\n        if (managedTextures[i] !== null) {\n          managedTextures[j++] = managedTextures[i];\n        }\n      }\n      managedTextures.length = j;\n    }\n  }\n  unload(displayObject) {\n    const tm = this.renderer.texture;\n    const texture = displayObject._texture;\n    if (texture && !texture.framebuffer) {\n      tm.destroyTexture(texture);\n    }\n    for (let i = displayObject.children.length - 1; i >= 0; i--) {\n      this.unload(displayObject.children[i]);\n    }\n  }\n  destroy() {\n    this.renderer = null;\n  }\n};\nlet TextureGCSystem = _TextureGCSystem;\nTextureGCSystem.defaultMode = lib/* GC_MODES */.UN.AUTO;\nTextureGCSystem.defaultMaxIdle = 60 * 60;\nTextureGCSystem.defaultCheckCountMax = 60 * 10;\nTextureGCSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "textureGC"\n};\nextensions.add(TextureGCSystem);\n\n\n//# sourceMappingURL=TextureGCSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/GLTexture.mjs\n\n\nclass GLTexture {\n  constructor(texture) {\n    this.texture = texture;\n    this.width = -1;\n    this.height = -1;\n    this.dirtyId = -1;\n    this.dirtyStyleId = -1;\n    this.mipmap = false;\n    this.wrapMode = 33071;\n    this.type = lib/* TYPES */.vK.UNSIGNED_BYTE;\n    this.internalFormat = lib/* FORMATS */.I2.RGBA;\n    this.samplerType = 0;\n  }\n}\n\n\n//# sourceMappingURL=GLTexture.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/utils/mapTypeAndFormatToInternalFormat.mjs\n\n\nfunction mapTypeAndFormatToInternalFormat(gl) {\n  let table;\n  if ("WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext) {\n    table = {\n      [lib/* TYPES */.vK.UNSIGNED_BYTE]: {\n        [lib/* FORMATS */.I2.RGBA]: gl.RGBA8,\n        [lib/* FORMATS */.I2.RGB]: gl.RGB8,\n        [lib/* FORMATS */.I2.RG]: gl.RG8,\n        [lib/* FORMATS */.I2.RED]: gl.R8,\n        [lib/* FORMATS */.I2.RGBA_INTEGER]: gl.RGBA8UI,\n        [lib/* FORMATS */.I2.RGB_INTEGER]: gl.RGB8UI,\n        [lib/* FORMATS */.I2.RG_INTEGER]: gl.RG8UI,\n        [lib/* FORMATS */.I2.RED_INTEGER]: gl.R8UI,\n        [lib/* FORMATS */.I2.ALPHA]: gl.ALPHA,\n        [lib/* FORMATS */.I2.LUMINANCE]: gl.LUMINANCE,\n        [lib/* FORMATS */.I2.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA\n      },\n      [lib/* TYPES */.vK.BYTE]: {\n        [lib/* FORMATS */.I2.RGBA]: gl.RGBA8_SNORM,\n        [lib/* FORMATS */.I2.RGB]: gl.RGB8_SNORM,\n        [lib/* FORMATS */.I2.RG]: gl.RG8_SNORM,\n        [lib/* FORMATS */.I2.RED]: gl.R8_SNORM,\n        [lib/* FORMATS */.I2.RGBA_INTEGER]: gl.RGBA8I,\n        [lib/* FORMATS */.I2.RGB_INTEGER]: gl.RGB8I,\n        [lib/* FORMATS */.I2.RG_INTEGER]: gl.RG8I,\n        [lib/* FORMATS */.I2.RED_INTEGER]: gl.R8I\n      },\n      [lib/* TYPES */.vK.UNSIGNED_SHORT]: {\n        [lib/* FORMATS */.I2.RGBA_INTEGER]: gl.RGBA16UI,\n        [lib/* FORMATS */.I2.RGB_INTEGER]: gl.RGB16UI,\n        [lib/* FORMATS */.I2.RG_INTEGER]: gl.RG16UI,\n        [lib/* FORMATS */.I2.RED_INTEGER]: gl.R16UI,\n        [lib/* FORMATS */.I2.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT16\n      },\n      [lib/* TYPES */.vK.SHORT]: {\n        [lib/* FORMATS */.I2.RGBA_INTEGER]: gl.RGBA16I,\n        [lib/* FORMATS */.I2.RGB_INTEGER]: gl.RGB16I,\n        [lib/* FORMATS */.I2.RG_INTEGER]: gl.RG16I,\n        [lib/* FORMATS */.I2.RED_INTEGER]: gl.R16I\n      },\n      [lib/* TYPES */.vK.UNSIGNED_INT]: {\n        [lib/* FORMATS */.I2.RGBA_INTEGER]: gl.RGBA32UI,\n        [lib/* FORMATS */.I2.RGB_INTEGER]: gl.RGB32UI,\n        [lib/* FORMATS */.I2.RG_INTEGER]: gl.RG32UI,\n        [lib/* FORMATS */.I2.RED_INTEGER]: gl.R32UI,\n        [lib/* FORMATS */.I2.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT24\n      },\n      [lib/* TYPES */.vK.INT]: {\n        [lib/* FORMATS */.I2.RGBA_INTEGER]: gl.RGBA32I,\n        [lib/* FORMATS */.I2.RGB_INTEGER]: gl.RGB32I,\n        [lib/* FORMATS */.I2.RG_INTEGER]: gl.RG32I,\n        [lib/* FORMATS */.I2.RED_INTEGER]: gl.R32I\n      },\n      [lib/* TYPES */.vK.FLOAT]: {\n        [lib/* FORMATS */.I2.RGBA]: gl.RGBA32F,\n        [lib/* FORMATS */.I2.RGB]: gl.RGB32F,\n        [lib/* FORMATS */.I2.RG]: gl.RG32F,\n        [lib/* FORMATS */.I2.RED]: gl.R32F,\n        [lib/* FORMATS */.I2.DEPTH_COMPONENT]: gl.DEPTH_COMPONENT32F\n      },\n      [lib/* TYPES */.vK.HALF_FLOAT]: {\n        [lib/* FORMATS */.I2.RGBA]: gl.RGBA16F,\n        [lib/* FORMATS */.I2.RGB]: gl.RGB16F,\n        [lib/* FORMATS */.I2.RG]: gl.RG16F,\n        [lib/* FORMATS */.I2.RED]: gl.R16F\n      },\n      [lib/* TYPES */.vK.UNSIGNED_SHORT_5_6_5]: {\n        [lib/* FORMATS */.I2.RGB]: gl.RGB565\n      },\n      [lib/* TYPES */.vK.UNSIGNED_SHORT_4_4_4_4]: {\n        [lib/* FORMATS */.I2.RGBA]: gl.RGBA4\n      },\n      [lib/* TYPES */.vK.UNSIGNED_SHORT_5_5_5_1]: {\n        [lib/* FORMATS */.I2.RGBA]: gl.RGB5_A1\n      },\n      [lib/* TYPES */.vK.UNSIGNED_INT_2_10_10_10_REV]: {\n        [lib/* FORMATS */.I2.RGBA]: gl.RGB10_A2,\n        [lib/* FORMATS */.I2.RGBA_INTEGER]: gl.RGB10_A2UI\n      },\n      [lib/* TYPES */.vK.UNSIGNED_INT_10F_11F_11F_REV]: {\n        [lib/* FORMATS */.I2.RGB]: gl.R11F_G11F_B10F\n      },\n      [lib/* TYPES */.vK.UNSIGNED_INT_5_9_9_9_REV]: {\n        [lib/* FORMATS */.I2.RGB]: gl.RGB9_E5\n      },\n      [lib/* TYPES */.vK.UNSIGNED_INT_24_8]: {\n        [lib/* FORMATS */.I2.DEPTH_STENCIL]: gl.DEPTH24_STENCIL8\n      },\n      [lib/* TYPES */.vK.FLOAT_32_UNSIGNED_INT_24_8_REV]: {\n        [lib/* FORMATS */.I2.DEPTH_STENCIL]: gl.DEPTH32F_STENCIL8\n      }\n    };\n  } else {\n    table = {\n      [lib/* TYPES */.vK.UNSIGNED_BYTE]: {\n        [lib/* FORMATS */.I2.RGBA]: gl.RGBA,\n        [lib/* FORMATS */.I2.RGB]: gl.RGB,\n        [lib/* FORMATS */.I2.ALPHA]: gl.ALPHA,\n        [lib/* FORMATS */.I2.LUMINANCE]: gl.LUMINANCE,\n        [lib/* FORMATS */.I2.LUMINANCE_ALPHA]: gl.LUMINANCE_ALPHA\n      },\n      [lib/* TYPES */.vK.UNSIGNED_SHORT_5_6_5]: {\n        [lib/* FORMATS */.I2.RGB]: gl.RGB\n      },\n      [lib/* TYPES */.vK.UNSIGNED_SHORT_4_4_4_4]: {\n        [lib/* FORMATS */.I2.RGBA]: gl.RGBA\n      },\n      [lib/* TYPES */.vK.UNSIGNED_SHORT_5_5_5_1]: {\n        [lib/* FORMATS */.I2.RGBA]: gl.RGBA\n      }\n    };\n  }\n  return table;\n}\n\n\n//# sourceMappingURL=mapTypeAndFormatToInternalFormat.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/TextureSystem.mjs\n\n\n\n\n\n\n\nclass TextureSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.boundTextures = [];\n    this.currentLocation = -1;\n    this.managedTextures = [];\n    this._unknownBoundTextures = false;\n    this.unknownTexture = new BaseTexture();\n    this.hasIntegerTextures = false;\n  }\n  contextChange() {\n    const gl = this.gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n    this.webGLVersion = this.renderer.context.webGLVersion;\n    this.internalFormats = mapTypeAndFormatToInternalFormat(gl);\n    const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    this.boundTextures.length = maxTextures;\n    for (let i = 0; i < maxTextures; i++) {\n      this.boundTextures[i] = null;\n    }\n    this.emptyTextures = {};\n    const emptyTexture2D = new GLTexture(gl.createTexture());\n    gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));\n    this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;\n    this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());\n    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);\n    for (let i = 0; i < 6; i++) {\n      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    }\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    for (let i = 0; i < this.boundTextures.length; i++) {\n      this.bind(null, i);\n    }\n  }\n  bind(texture, location = 0) {\n    const { gl } = this;\n    texture = texture?.castToBaseTexture();\n    if (texture?.valid && !texture.parentTextureArray) {\n      texture.touched = this.renderer.textureGC.count;\n      const glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);\n      if (this.boundTextures[location] !== texture) {\n        if (this.currentLocation !== location) {\n          this.currentLocation = location;\n          gl.activeTexture(gl.TEXTURE0 + location);\n        }\n        gl.bindTexture(texture.target, glTexture.texture);\n      }\n      if (glTexture.dirtyId !== texture.dirtyId) {\n        if (this.currentLocation !== location) {\n          this.currentLocation = location;\n          gl.activeTexture(gl.TEXTURE0 + location);\n        }\n        this.updateTexture(texture);\n      } else if (glTexture.dirtyStyleId !== texture.dirtyStyleId) {\n        this.updateTextureStyle(texture);\n      }\n      this.boundTextures[location] = texture;\n    } else {\n      if (this.currentLocation !== location) {\n        this.currentLocation = location;\n        gl.activeTexture(gl.TEXTURE0 + location);\n      }\n      gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);\n      this.boundTextures[location] = null;\n    }\n  }\n  reset() {\n    this._unknownBoundTextures = true;\n    this.hasIntegerTextures = false;\n    this.currentLocation = -1;\n    for (let i = 0; i < this.boundTextures.length; i++) {\n      this.boundTextures[i] = this.unknownTexture;\n    }\n  }\n  unbind(texture) {\n    const { gl, boundTextures } = this;\n    if (this._unknownBoundTextures) {\n      this._unknownBoundTextures = false;\n      for (let i = 0; i < boundTextures.length; i++) {\n        if (boundTextures[i] === this.unknownTexture) {\n          this.bind(null, i);\n        }\n      }\n    }\n    for (let i = 0; i < boundTextures.length; i++) {\n      if (boundTextures[i] === texture) {\n        if (this.currentLocation !== i) {\n          gl.activeTexture(gl.TEXTURE0 + i);\n          this.currentLocation = i;\n        }\n        gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);\n        boundTextures[i] = null;\n      }\n    }\n  }\n  ensureSamplerType(maxTextures) {\n    const { boundTextures, hasIntegerTextures, CONTEXT_UID } = this;\n    if (!hasIntegerTextures) {\n      return;\n    }\n    for (let i = maxTextures - 1; i >= 0; --i) {\n      const tex = boundTextures[i];\n      if (tex) {\n        const glTexture = tex._glTextures[CONTEXT_UID];\n        if (glTexture.samplerType !== lib/* SAMPLER_TYPES */.oT.FLOAT) {\n          this.renderer.texture.unbind(tex);\n        }\n      }\n    }\n  }\n  initTexture(texture) {\n    const glTexture = new GLTexture(this.gl.createTexture());\n    glTexture.dirtyId = -1;\n    texture._glTextures[this.CONTEXT_UID] = glTexture;\n    this.managedTextures.push(texture);\n    texture.on("dispose", this.destroyTexture, this);\n    return glTexture;\n  }\n  initTextureType(texture, glTexture) {\n    glTexture.internalFormat = this.internalFormats[texture.type]?.[texture.format] ?? texture.format;\n    if (this.webGLVersion === 2 && texture.type === lib/* TYPES */.vK.HALF_FLOAT) {\n      glTexture.type = this.gl.HALF_FLOAT;\n    } else {\n      glTexture.type = texture.type;\n    }\n  }\n  updateTexture(texture) {\n    const glTexture = texture._glTextures[this.CONTEXT_UID];\n    if (!glTexture) {\n      return;\n    }\n    const renderer = this.renderer;\n    this.initTextureType(texture, glTexture);\n    if (texture.resource?.upload(renderer, texture, glTexture)) {\n      if (glTexture.samplerType !== lib/* SAMPLER_TYPES */.oT.FLOAT) {\n        this.hasIntegerTextures = true;\n      }\n    } else {\n      const width = texture.realWidth;\n      const height = texture.realHeight;\n      const gl = renderer.gl;\n      if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {\n        glTexture.width = width;\n        glTexture.height = height;\n        gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);\n      }\n    }\n    if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {\n      this.updateTextureStyle(texture);\n    }\n    glTexture.dirtyId = texture.dirtyId;\n  }\n  destroyTexture(texture, skipRemove) {\n    const { gl } = this;\n    texture = texture.castToBaseTexture();\n    if (texture._glTextures[this.CONTEXT_UID]) {\n      this.unbind(texture);\n      gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);\n      texture.off("dispose", this.destroyTexture, this);\n      delete texture._glTextures[this.CONTEXT_UID];\n      if (!skipRemove) {\n        const i = this.managedTextures.indexOf(texture);\n        if (i !== -1) {\n          (0,utils_lib.removeItems)(this.managedTextures, i, 1);\n        }\n      }\n    }\n  }\n  updateTextureStyle(texture) {\n    const glTexture = texture._glTextures[this.CONTEXT_UID];\n    if (!glTexture) {\n      return;\n    }\n    if ((texture.mipmap === lib/* MIPMAP_MODES */.WB.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {\n      glTexture.mipmap = false;\n    } else {\n      glTexture.mipmap = texture.mipmap >= 1;\n    }\n    if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {\n      glTexture.wrapMode = lib/* WRAP_MODES */.Nt.CLAMP;\n    } else {\n      glTexture.wrapMode = texture.wrapMode;\n    }\n    if (texture.resource?.style(this.renderer, texture, glTexture)) {\n    } else {\n      this.setStyle(texture, glTexture);\n    }\n    glTexture.dirtyStyleId = texture.dirtyStyleId;\n  }\n  setStyle(texture, glTexture) {\n    const gl = this.gl;\n    if (glTexture.mipmap && texture.mipmap !== lib/* MIPMAP_MODES */.WB.ON_MANUAL) {\n      gl.generateMipmap(texture.target);\n    }\n    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);\n    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);\n    if (glTexture.mipmap) {\n      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === lib/* SCALE_MODES */.aH.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);\n      const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;\n      if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === lib/* SCALE_MODES */.aH.LINEAR) {\n        const level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n        gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n      }\n    } else {\n      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === lib/* SCALE_MODES */.aH.LINEAR ? gl.LINEAR : gl.NEAREST);\n    }\n    gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === lib/* SCALE_MODES */.aH.LINEAR ? gl.LINEAR : gl.NEAREST);\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nTextureSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "texture"\n};\nextensions.add(TextureSystem);\n\n\n//# sourceMappingURL=TextureSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/transformFeedback/TransformFeedbackSystem.mjs\n\n\nclass TransformFeedbackSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  contextChange() {\n    this.gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n  }\n  bind(transformFeedback) {\n    const { gl, CONTEXT_UID } = this;\n    const glTransformFeedback = transformFeedback._glTransformFeedbacks[CONTEXT_UID] || this.createGLTransformFeedback(transformFeedback);\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);\n  }\n  unbind() {\n    const { gl } = this;\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n  }\n  beginTransformFeedback(drawMode, shader) {\n    const { gl, renderer } = this;\n    if (shader) {\n      renderer.shader.bind(shader);\n    }\n    gl.beginTransformFeedback(drawMode);\n  }\n  endTransformFeedback() {\n    const { gl } = this;\n    gl.endTransformFeedback();\n  }\n  createGLTransformFeedback(tf) {\n    const { gl, renderer, CONTEXT_UID } = this;\n    const glTransformFeedback = gl.createTransformFeedback();\n    tf._glTransformFeedbacks[CONTEXT_UID] = glTransformFeedback;\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);\n    for (let i = 0; i < tf.buffers.length; i++) {\n      const buffer = tf.buffers[i];\n      if (!buffer)\n        continue;\n      renderer.buffer.update(buffer);\n      buffer._glBuffers[CONTEXT_UID].refCount++;\n      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, buffer._glBuffers[CONTEXT_UID].buffer || null);\n    }\n    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n    tf.disposeRunner.add(this);\n    return glTransformFeedback;\n  }\n  disposeTransformFeedback(tf, contextLost) {\n    const glTF = tf._glTransformFeedbacks[this.CONTEXT_UID];\n    const gl = this.gl;\n    tf.disposeRunner.remove(this);\n    const bufferSystem = this.renderer.buffer;\n    if (bufferSystem) {\n      for (let i = 0; i < tf.buffers.length; i++) {\n        const buffer = tf.buffers[i];\n        if (!buffer)\n          continue;\n        const buf = buffer._glBuffers[this.CONTEXT_UID];\n        if (buf) {\n          buf.refCount--;\n          if (buf.refCount === 0 && !contextLost) {\n            bufferSystem.dispose(buffer, contextLost);\n          }\n        }\n      }\n    }\n    if (!glTF) {\n      return;\n    }\n    if (!contextLost) {\n      gl.deleteTransformFeedback(glTF);\n    }\n    delete tf._glTransformFeedbacks[this.CONTEXT_UID];\n  }\n  destroy() {\n    this.renderer = null;\n  }\n}\nTransformFeedbackSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "transformFeedback"\n};\nextensions.add(TransformFeedbackSystem);\n\n\n//# sourceMappingURL=TransformFeedbackSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/view/ViewSystem.mjs\n\n\n\n\nclass ViewSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  init(options) {\n    this.screen = new Rectangle_Rectangle(0, 0, options.width, options.height);\n    this.element = options.view || settings_lib/* settings */.Xd.ADAPTER.createCanvas();\n    this.resolution = options.resolution || settings_lib/* settings */.Xd.RESOLUTION;\n    this.autoDensity = !!options.autoDensity;\n  }\n  resizeView(desiredScreenWidth, desiredScreenHeight) {\n    this.element.width = Math.round(desiredScreenWidth * this.resolution);\n    this.element.height = Math.round(desiredScreenHeight * this.resolution);\n    const screenWidth = this.element.width / this.resolution;\n    const screenHeight = this.element.height / this.resolution;\n    this.screen.width = screenWidth;\n    this.screen.height = screenHeight;\n    if (this.autoDensity) {\n      this.element.style.width = `${screenWidth}px`;\n      this.element.style.height = `${screenHeight}px`;\n    }\n    this.renderer.emit("resize", screenWidth, screenHeight);\n    this.renderer.runners.resize.emit(this.screen.width, this.screen.height);\n  }\n  destroy(removeView) {\n    if (removeView) {\n      this.element.parentNode?.removeChild(this.element);\n    }\n    this.renderer = null;\n    this.element = null;\n    this.screen = null;\n  }\n}\nViewSystem.defaultOptions = {\n  width: 800,\n  height: 600,\n  resolution: settings_lib/* settings */.Xd.RESOLUTION,\n  autoDensity: false\n};\nViewSystem.extension = {\n  type: [\n    ExtensionType.RendererSystem,\n    ExtensionType.CanvasRendererSystem\n  ],\n  name: "_view"\n};\nextensions.add(ViewSystem);\n\n\n//# sourceMappingURL=ViewSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/systems.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=systems.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/settings.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsettings_lib/* settings */.Xd.PREFER_ENV = lib/* ENV */.Vi.WEBGL2;\nsettings_lib/* settings */.Xd.STRICT_TEXTURE_CACHE = false;\nsettings_lib/* settings */.Xd.RENDER_OPTIONS = {\n  ...ContextSystem.defaultOptions,\n  ...BackgroundSystem.defaultOptions,\n  ...ViewSystem.defaultOptions,\n  ...StartupSystem.defaultOptions\n};\nObject.defineProperties(settings_lib/* settings */.Xd, {\n  WRAP_MODE: {\n    get() {\n      return BaseTexture.defaultOptions.wrapMode;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode");\n      BaseTexture.defaultOptions.wrapMode = value;\n    }\n  },\n  SCALE_MODE: {\n    get() {\n      return BaseTexture.defaultOptions.scaleMode;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode");\n      BaseTexture.defaultOptions.scaleMode = value;\n    }\n  },\n  MIPMAP_TEXTURES: {\n    get() {\n      return BaseTexture.defaultOptions.mipmap;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap");\n      BaseTexture.defaultOptions.mipmap = value;\n    }\n  },\n  ANISOTROPIC_LEVEL: {\n    get() {\n      return BaseTexture.defaultOptions.anisotropicLevel;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel");\n      BaseTexture.defaultOptions.anisotropicLevel = value;\n    }\n  },\n  FILTER_RESOLUTION: {\n    get() {\n      (0,utils_lib.deprecation)("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution");\n      return Filter.defaultResolution;\n    },\n    set(value) {\n      Filter.defaultResolution = value;\n    }\n  },\n  FILTER_MULTISAMPLE: {\n    get() {\n      (0,utils_lib.deprecation)("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample");\n      return Filter.defaultMultisample;\n    },\n    set(value) {\n      Filter.defaultMultisample = value;\n    }\n  },\n  SPRITE_MAX_TEXTURES: {\n    get() {\n      return BatchRenderer.defaultMaxTextures;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures");\n      BatchRenderer.defaultMaxTextures = value;\n    }\n  },\n  SPRITE_BATCH_SIZE: {\n    get() {\n      return BatchRenderer.defaultBatchSize;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize");\n      BatchRenderer.defaultBatchSize = value;\n    }\n  },\n  CAN_UPLOAD_SAME_BUFFER: {\n    get() {\n      return BatchRenderer.canUploadSameBuffer;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer");\n      BatchRenderer.canUploadSameBuffer = value;\n    }\n  },\n  GC_MODE: {\n    get() {\n      return TextureGCSystem.defaultMode;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode");\n      TextureGCSystem.defaultMode = value;\n    }\n  },\n  GC_MAX_IDLE: {\n    get() {\n      return TextureGCSystem.defaultMaxIdle;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle");\n      TextureGCSystem.defaultMaxIdle = value;\n    }\n  },\n  GC_MAX_CHECK_COUNT: {\n    get() {\n      return TextureGCSystem.defaultCheckCountMax;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax");\n      TextureGCSystem.defaultCheckCountMax = value;\n    }\n  },\n  PRECISION_VERTEX: {\n    get() {\n      return Program.defaultVertexPrecision;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision");\n      Program.defaultVertexPrecision = value;\n    }\n  },\n  PRECISION_FRAGMENT: {\n    get() {\n      return Program.defaultFragmentPrecision;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision");\n      Program.defaultFragmentPrecision = value;\n    }\n  }\n});\n//# sourceMappingURL=settings.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/ticker/lib/const.mjs\nvar const_UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";\n  return UPDATE_PRIORITY2;\n})(const_UPDATE_PRIORITY || {});\n\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/ticker/lib/TickerListener.mjs\nclass TickerListener {\n  constructor(fn, context = null, priority = 0, once = false) {\n    this.next = null;\n    this.previous = null;\n    this._destroyed = false;\n    this.fn = fn;\n    this.context = context;\n    this.priority = priority;\n    this.once = once;\n  }\n  match(fn, context = null) {\n    return this.fn === fn && this.context === context;\n  }\n  emit(deltaTime) {\n    if (this.fn) {\n      if (this.context) {\n        this.fn.call(this.context, deltaTime);\n      } else {\n        this.fn(deltaTime);\n      }\n    }\n    const redirect = this.next;\n    if (this.once) {\n      this.destroy(true);\n    }\n    if (this._destroyed) {\n      this.next = null;\n    }\n    return redirect;\n  }\n  connect(previous) {\n    this.previous = previous;\n    if (previous.next) {\n      previous.next.previous = this;\n    }\n    this.next = previous.next;\n    previous.next = this;\n  }\n  destroy(hard = false) {\n    this._destroyed = true;\n    this.fn = null;\n    this.context = null;\n    if (this.previous) {\n      this.previous.next = this.next;\n    }\n    if (this.next) {\n      this.next.previous = this.previous;\n    }\n    const redirect = this.next;\n    this.next = hard ? null : redirect;\n    this.previous = null;\n    return redirect;\n  }\n}\n\n\n//# sourceMappingURL=TickerListener.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/ticker/lib/Ticker.mjs\n\n\n\nconst _Ticker = class {\n  constructor() {\n    this.autoStart = false;\n    this.deltaTime = 1;\n    this.lastTime = -1;\n    this.speed = 1;\n    this.started = false;\n    this._requestId = null;\n    this._maxElapsedMS = 100;\n    this._minElapsedMS = 0;\n    this._protected = false;\n    this._lastFrame = -1;\n    this._head = new TickerListener(null, null, Infinity);\n    this.deltaMS = 1 / _Ticker.targetFPMS;\n    this.elapsedMS = 1 / _Ticker.targetFPMS;\n    this._tick = (time) => {\n      this._requestId = null;\n      if (this.started) {\n        this.update(time);\n        if (this.started && this._requestId === null && this._head.next) {\n          this._requestId = requestAnimationFrame(this._tick);\n        }\n      }\n    };\n  }\n  _requestIfNeeded() {\n    if (this._requestId === null && this._head.next) {\n      this.lastTime = performance.now();\n      this._lastFrame = this.lastTime;\n      this._requestId = requestAnimationFrame(this._tick);\n    }\n  }\n  _cancelIfNeeded() {\n    if (this._requestId !== null) {\n      cancelAnimationFrame(this._requestId);\n      this._requestId = null;\n    }\n  }\n  _startIfPossible() {\n    if (this.started) {\n      this._requestIfNeeded();\n    } else if (this.autoStart) {\n      this.start();\n    }\n  }\n  add(fn, context, priority = const_UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority));\n  }\n  addOnce(fn, context, priority = const_UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority, true));\n  }\n  _addListener(listener) {\n    let current = this._head.next;\n    let previous = this._head;\n    if (!current) {\n      listener.connect(previous);\n    } else {\n      while (current) {\n        if (listener.priority > current.priority) {\n          listener.connect(previous);\n          break;\n        }\n        previous = current;\n        current = current.next;\n      }\n      if (!listener.previous) {\n        listener.connect(previous);\n      }\n    }\n    this._startIfPossible();\n    return this;\n  }\n  remove(fn, context) {\n    let listener = this._head.next;\n    while (listener) {\n      if (listener.match(fn, context)) {\n        listener = listener.destroy();\n      } else {\n        listener = listener.next;\n      }\n    }\n    if (!this._head.next) {\n      this._cancelIfNeeded();\n    }\n    return this;\n  }\n  get count() {\n    if (!this._head) {\n      return 0;\n    }\n    let count = 0;\n    let current = this._head;\n    while (current = current.next) {\n      count++;\n    }\n    return count;\n  }\n  start() {\n    if (!this.started) {\n      this.started = true;\n      this._requestIfNeeded();\n    }\n  }\n  stop() {\n    if (this.started) {\n      this.started = false;\n      this._cancelIfNeeded();\n    }\n  }\n  destroy() {\n    if (!this._protected) {\n      this.stop();\n      let listener = this._head.next;\n      while (listener) {\n        listener = listener.destroy(true);\n      }\n      this._head.destroy();\n      this._head = null;\n    }\n  }\n  update(currentTime = performance.now()) {\n    let elapsedMS;\n    if (currentTime > this.lastTime) {\n      elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n      if (elapsedMS > this._maxElapsedMS) {\n        elapsedMS = this._maxElapsedMS;\n      }\n      elapsedMS *= this.speed;\n      if (this._minElapsedMS) {\n        const delta = currentTime - this._lastFrame | 0;\n        if (delta < this._minElapsedMS) {\n          return;\n        }\n        this._lastFrame = currentTime - delta % this._minElapsedMS;\n      }\n      this.deltaMS = elapsedMS;\n      this.deltaTime = this.deltaMS * _Ticker.targetFPMS;\n      const head = this._head;\n      let listener = head.next;\n      while (listener) {\n        listener = listener.emit(this.deltaTime);\n      }\n      if (!head.next) {\n        this._cancelIfNeeded();\n      }\n    } else {\n      this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n    }\n    this.lastTime = currentTime;\n  }\n  get FPS() {\n    return 1e3 / this.elapsedMS;\n  }\n  get minFPS() {\n    return 1e3 / this._maxElapsedMS;\n  }\n  set minFPS(fps) {\n    const minFPS = Math.min(this.maxFPS, fps);\n    const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);\n    this._maxElapsedMS = 1 / minFPMS;\n  }\n  get maxFPS() {\n    if (this._minElapsedMS) {\n      return Math.round(1e3 / this._minElapsedMS);\n    }\n    return 0;\n  }\n  set maxFPS(fps) {\n    if (fps === 0) {\n      this._minElapsedMS = 0;\n    } else {\n      const maxFPS = Math.max(this.minFPS, fps);\n      this._minElapsedMS = 1 / (maxFPS / 1e3);\n    }\n  }\n  static get shared() {\n    if (!_Ticker._shared) {\n      const shared = _Ticker._shared = new _Ticker();\n      shared.autoStart = true;\n      shared._protected = true;\n    }\n    return _Ticker._shared;\n  }\n  static get system() {\n    if (!_Ticker._system) {\n      const system = _Ticker._system = new _Ticker();\n      system.autoStart = true;\n      system._protected = true;\n    }\n    return _Ticker._system;\n  }\n};\nlet Ticker_Ticker = _Ticker;\nTicker_Ticker.targetFPMS = 0.06;\n\n\n//# sourceMappingURL=Ticker.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/ticker/lib/settings.mjs\n\n\n\n\n\nObject.defineProperties(settings_lib/* settings */.Xd, {\n  TARGET_FPMS: {\n    get() {\n      return Ticker_Ticker.targetFPMS;\n    },\n    set(value) {\n      (0,utils_lib.deprecation)("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS");\n      Ticker_Ticker.targetFPMS = value;\n    }\n  }\n});\n//# sourceMappingURL=settings.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/ticker/lib/TickerPlugin.mjs\n\n\n\n\nclass TickerPlugin {\n  static init(options) {\n    options = Object.assign({\n      autoStart: true,\n      sharedTicker: false\n    }, options);\n    Object.defineProperty(this, "ticker", {\n      set(ticker) {\n        if (this._ticker) {\n          this._ticker.remove(this.render, this);\n        }\n        this._ticker = ticker;\n        if (ticker) {\n          ticker.add(this.render, this, const_UPDATE_PRIORITY.LOW);\n        }\n      },\n      get() {\n        return this._ticker;\n      }\n    });\n    this.stop = () => {\n      this._ticker.stop();\n    };\n    this.start = () => {\n      this._ticker.start();\n    };\n    this._ticker = null;\n    this.ticker = options.sharedTicker ? Ticker_Ticker.shared : new Ticker_Ticker();\n    if (options.autoStart) {\n      this.start();\n    }\n  }\n  static destroy() {\n    if (this._ticker) {\n      const oldTicker = this._ticker;\n      this.ticker = null;\n      oldTicker.destroy();\n    }\n  }\n}\nTickerPlugin.extension = ExtensionType.Application;\nextensions.add(TickerPlugin);\n\n\n//# sourceMappingURL=TickerPlugin.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/ticker/lib/index.mjs\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/autoDetectRenderer.mjs\n\n\nconst renderers = [];\nextensions.handleByList(ExtensionType.Renderer, renderers);\nfunction autoDetectRenderer(options) {\n  for (const RendererType of renderers) {\n    if (RendererType.test(options)) {\n      return new RendererType(options);\n    }\n  }\n  throw new Error("Unable to auto-detect a suitable renderer.");\n}\n\n\n//# sourceMappingURL=autoDetectRenderer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/fragments/default.mjs\nvar $defaultVertex = "attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    vTextureCoord = aTextureCoord;\\n}";\n\n\n//# sourceMappingURL=default.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/fragments/defaultFilter.mjs\nvar $defaultFilterVertex = "attribute vec2 aVertexPosition;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform vec4 inputSize;\\nuniform vec4 outputFrame;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\\n\\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n}\\n";\n\n\n//# sourceMappingURL=defaultFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/fragments/index.mjs\n\n\n\nconst fragments_defaultVertex = $defaultVertex;\nconst defaultFilterVertex = $defaultFilterVertex;\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/framebuffer/MultisampleSystem.mjs\n\n\n\nclass MultisampleSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  contextChange(gl) {\n    let samples;\n    if (this.renderer.context.webGLVersion === 1) {\n      const framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n      samples = gl.getParameter(gl.SAMPLES);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    } else {\n      const framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);\n      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);\n      samples = gl.getParameter(gl.SAMPLES);\n      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);\n    }\n    if (samples >= lib/* MSAA_QUALITY */.G5.HIGH) {\n      this.multisample = lib/* MSAA_QUALITY */.G5.HIGH;\n    } else if (samples >= lib/* MSAA_QUALITY */.G5.MEDIUM) {\n      this.multisample = lib/* MSAA_QUALITY */.G5.MEDIUM;\n    } else if (samples >= lib/* MSAA_QUALITY */.G5.LOW) {\n      this.multisample = lib/* MSAA_QUALITY */.G5.LOW;\n    } else {\n      this.multisample = lib/* MSAA_QUALITY */.G5.NONE;\n    }\n  }\n  destroy() {\n  }\n}\nMultisampleSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "_multisample"\n};\nextensions.add(MultisampleSystem);\n\n\n//# sourceMappingURL=MultisampleSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/GLBuffer.mjs\nclass GLBuffer {\n  constructor(buffer) {\n    this.buffer = buffer || null;\n    this.updateID = -1;\n    this.byteLength = -1;\n    this.refCount = 0;\n  }\n}\n\n\n//# sourceMappingURL=GLBuffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/geometry/BufferSystem.mjs\n\n\n\nclass BufferSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.managedBuffers = {};\n    this.boundBufferBases = {};\n  }\n  destroy() {\n    this.renderer = null;\n  }\n  contextChange() {\n    this.disposeAll(true);\n    this.gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n  }\n  bind(buffer) {\n    const { gl, CONTEXT_UID } = this;\n    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n    gl.bindBuffer(buffer.type, glBuffer.buffer);\n  }\n  unbind(type) {\n    const { gl } = this;\n    gl.bindBuffer(type, null);\n  }\n  bindBufferBase(buffer, index) {\n    const { gl, CONTEXT_UID } = this;\n    if (this.boundBufferBases[index] !== buffer) {\n      const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n      this.boundBufferBases[index] = buffer;\n      gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n    }\n  }\n  bindBufferRange(buffer, index, offset) {\n    const { gl, CONTEXT_UID } = this;\n    offset = offset || 0;\n    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n    gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);\n  }\n  update(buffer) {\n    const { gl, CONTEXT_UID } = this;\n    const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n    if (buffer._updateID === glBuffer.updateID) {\n      return;\n    }\n    glBuffer.updateID = buffer._updateID;\n    gl.bindBuffer(buffer.type, glBuffer.buffer);\n    if (glBuffer.byteLength >= buffer.data.byteLength) {\n      gl.bufferSubData(buffer.type, 0, buffer.data);\n    } else {\n      const drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n      glBuffer.byteLength = buffer.data.byteLength;\n      gl.bufferData(buffer.type, buffer.data, drawType);\n    }\n  }\n  dispose(buffer, contextLost) {\n    if (!this.managedBuffers[buffer.id]) {\n      return;\n    }\n    delete this.managedBuffers[buffer.id];\n    const glBuffer = buffer._glBuffers[this.CONTEXT_UID];\n    const gl = this.gl;\n    buffer.disposeRunner.remove(this);\n    if (!glBuffer) {\n      return;\n    }\n    if (!contextLost) {\n      gl.deleteBuffer(glBuffer.buffer);\n    }\n    delete buffer._glBuffers[this.CONTEXT_UID];\n  }\n  disposeAll(contextLost) {\n    const all = Object.keys(this.managedBuffers);\n    for (let i = 0; i < all.length; i++) {\n      this.dispose(this.managedBuffers[all[i]], contextLost);\n    }\n  }\n  createGLBuffer(buffer) {\n    const { CONTEXT_UID, gl } = this;\n    buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());\n    this.managedBuffers[buffer.id] = buffer;\n    buffer.disposeRunner.add(this);\n    return buffer._glBuffers[CONTEXT_UID];\n  }\n}\nBufferSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "buffer"\n};\nextensions.add(BufferSystem);\n\n\n//# sourceMappingURL=BufferSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/render/ObjectRendererSystem.mjs\n\n\nclass ObjectRendererSystem {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  render(displayObject, options) {\n    const renderer = this.renderer;\n    let renderTexture;\n    let clear;\n    let transform;\n    let skipUpdateTransform;\n    if (options) {\n      renderTexture = options.renderTexture;\n      clear = options.clear;\n      transform = options.transform;\n      skipUpdateTransform = options.skipUpdateTransform;\n    }\n    this.renderingToScreen = !renderTexture;\n    renderer.runners.prerender.emit();\n    renderer.emit("prerender");\n    renderer.projection.transform = transform;\n    if (renderer.context.isLost) {\n      return;\n    }\n    if (!renderTexture) {\n      this.lastObjectRendered = displayObject;\n    }\n    if (!skipUpdateTransform) {\n      const cacheParent = displayObject.enableTempParent();\n      displayObject.updateTransform();\n      displayObject.disableTempParent(cacheParent);\n    }\n    renderer.renderTexture.bind(renderTexture);\n    renderer.batch.currentRenderer.start();\n    if (clear ?? renderer.background.clearBeforeRender) {\n      renderer.renderTexture.clear();\n    }\n    displayObject.render(renderer);\n    renderer.batch.currentRenderer.flush();\n    if (renderTexture) {\n      if (options.blit) {\n        renderer.framebuffer.blit();\n      }\n      renderTexture.baseTexture.update();\n    }\n    renderer.runners.postrender.emit();\n    renderer.projection.transform = null;\n    renderer.emit("postrender");\n  }\n  destroy() {\n    this.renderer = null;\n    this.lastObjectRendered = null;\n  }\n}\nObjectRendererSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: "objectRenderer"\n};\nextensions.add(ObjectRendererSystem);\n\n\n//# sourceMappingURL=ObjectRendererSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/Renderer.mjs\n\n\n\n\n\n\n\n\nconst _Renderer = class extends SystemManager {\n  constructor(options) {\n    super();\n    this.type = lib/* RENDERER_TYPE */.N3.WEBGL;\n    options = Object.assign({}, settings_lib/* settings */.Xd.RENDER_OPTIONS, options);\n    this.gl = null;\n    this.CONTEXT_UID = 0;\n    this.globalUniforms = new UniformGroup({\n      projectionMatrix: new Matrix()\n    }, true);\n    const systemConfig = {\n      runners: [\n        "init",\n        "destroy",\n        "contextChange",\n        "resolutionChange",\n        "reset",\n        "update",\n        "postrender",\n        "prerender",\n        "resize"\n      ],\n      systems: _Renderer.__systems,\n      priority: [\n        "_view",\n        "textureGenerator",\n        "background",\n        "_plugin",\n        "startup",\n        "context",\n        "state",\n        "texture",\n        "buffer",\n        "geometry",\n        "framebuffer",\n        "transformFeedback",\n        "mask",\n        "scissor",\n        "stencil",\n        "projection",\n        "textureGC",\n        "filter",\n        "renderTexture",\n        "batch",\n        "objectRenderer",\n        "_multisample"\n      ]\n    };\n    this.setup(systemConfig);\n    if ("useContextAlpha" in options) {\n      (0,utils_lib.deprecation)("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead");\n      options.premultipliedAlpha = options.useContextAlpha && options.useContextAlpha !== "notMultiplied";\n      options.backgroundAlpha = options.useContextAlpha === false ? 1 : options.backgroundAlpha;\n    }\n    this._plugin.rendererPlugins = _Renderer.__plugins;\n    this.options = options;\n    this.startup.run(this.options);\n  }\n  static test(options) {\n    if (options?.forceCanvas) {\n      return false;\n    }\n    return (0,utils_lib.isWebGLSupported)();\n  }\n  render(displayObject, options) {\n    this.objectRenderer.render(displayObject, options);\n  }\n  resize(desiredScreenWidth, desiredScreenHeight) {\n    this._view.resizeView(desiredScreenWidth, desiredScreenHeight);\n  }\n  reset() {\n    this.runners.reset.emit();\n    return this;\n  }\n  clear() {\n    this.renderTexture.bind();\n    this.renderTexture.clear();\n  }\n  destroy(removeView = false) {\n    this.runners.destroy.items.reverse();\n    this.emitWithCustomOptions(this.runners.destroy, {\n      _view: removeView\n    });\n    super.destroy();\n  }\n  get plugins() {\n    return this._plugin.plugins;\n  }\n  get multisample() {\n    return this._multisample.multisample;\n  }\n  get width() {\n    return this._view.element.width;\n  }\n  get height() {\n    return this._view.element.height;\n  }\n  get resolution() {\n    return this._view.resolution;\n  }\n  set resolution(value) {\n    this._view.resolution = value;\n    this.runners.resolutionChange.emit(value);\n  }\n  get autoDensity() {\n    return this._view.autoDensity;\n  }\n  get view() {\n    return this._view.element;\n  }\n  get screen() {\n    return this._view.screen;\n  }\n  get lastObjectRendered() {\n    return this.objectRenderer.lastObjectRendered;\n  }\n  get renderingToScreen() {\n    return this.objectRenderer.renderingToScreen;\n  }\n  get rendererLogId() {\n    return `WebGL ${this.context.webGLVersion}`;\n  }\n  get clearBeforeRender() {\n    (0,utils_lib.deprecation)("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead.");\n    return this.background.clearBeforeRender;\n  }\n  get useContextAlpha() {\n    (0,utils_lib.deprecation)("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead.");\n    return this.context.useContextAlpha;\n  }\n  get preserveDrawingBuffer() {\n    (0,utils_lib.deprecation)("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context");\n    return this.context.preserveDrawingBuffer;\n  }\n  get backgroundColor() {\n    (0,utils_lib.deprecation)("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead.");\n    return this.background.color;\n  }\n  set backgroundColor(value) {\n    (0,utils_lib.deprecation)("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead.");\n    this.background.color = value;\n  }\n  get backgroundAlpha() {\n    (0,utils_lib.deprecation)("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.");\n    return this.background.alpha;\n  }\n  set backgroundAlpha(value) {\n    (0,utils_lib.deprecation)("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.");\n    this.background.alpha = value;\n  }\n  get powerPreference() {\n    (0,utils_lib.deprecation)("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context");\n    return this.context.powerPreference;\n  }\n  generateTexture(displayObject, options) {\n    return this.textureGenerator.generateTexture(displayObject, options);\n  }\n};\nlet Renderer = _Renderer;\nRenderer.extension = {\n  type: ExtensionType.Renderer,\n  priority: 1\n};\nRenderer.__plugins = {};\nRenderer.__systems = {};\nextensions.handleByMap(ExtensionType.RendererPlugin, Renderer.__plugins);\nextensions.handleByMap(ExtensionType.RendererSystem, Renderer.__systems);\nextensions.add(Renderer);\n\n\n//# sourceMappingURL=Renderer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/AbstractMultiResource.mjs\n\n\n\n\nclass AbstractMultiResource extends Resource {\n  constructor(length, options) {\n    const { width, height } = options || {};\n    super(width, height);\n    this.items = [];\n    this.itemDirtyIds = [];\n    for (let i = 0; i < length; i++) {\n      const partTexture = new BaseTexture();\n      this.items.push(partTexture);\n      this.itemDirtyIds.push(-2);\n    }\n    this.length = length;\n    this._load = null;\n    this.baseTexture = null;\n  }\n  initFromArray(resources, options) {\n    for (let i = 0; i < this.length; i++) {\n      if (!resources[i]) {\n        continue;\n      }\n      if (resources[i].castToBaseTexture) {\n        this.addBaseTextureAt(resources[i].castToBaseTexture(), i);\n      } else if (resources[i] instanceof Resource) {\n        this.addResourceAt(resources[i], i);\n      } else {\n        this.addResourceAt(autoDetectResource(resources[i], options), i);\n      }\n    }\n  }\n  dispose() {\n    for (let i = 0, len = this.length; i < len; i++) {\n      this.items[i].destroy();\n    }\n    this.items = null;\n    this.itemDirtyIds = null;\n    this._load = null;\n  }\n  addResourceAt(resource, index) {\n    if (!this.items[index]) {\n      throw new Error(`Index ${index} is out of bounds`);\n    }\n    if (resource.valid && !this.valid) {\n      this.resize(resource.width, resource.height);\n    }\n    this.items[index].setResource(resource);\n    return this;\n  }\n  bind(baseTexture) {\n    if (this.baseTexture !== null) {\n      throw new Error("Only one base texture per TextureArray is allowed");\n    }\n    super.bind(baseTexture);\n    for (let i = 0; i < this.length; i++) {\n      this.items[i].parentTextureArray = baseTexture;\n      this.items[i].on("update", baseTexture.update, baseTexture);\n    }\n  }\n  unbind(baseTexture) {\n    super.unbind(baseTexture);\n    for (let i = 0; i < this.length; i++) {\n      this.items[i].parentTextureArray = null;\n      this.items[i].off("update", baseTexture.update, baseTexture);\n    }\n  }\n  load() {\n    if (this._load) {\n      return this._load;\n    }\n    const resources = this.items.map((item) => item.resource).filter((item) => item);\n    const promises = resources.map((item) => item.load());\n    this._load = Promise.all(promises).then(() => {\n      const { realWidth, realHeight } = this.items[0];\n      this.resize(realWidth, realHeight);\n      return Promise.resolve(this);\n    });\n    return this._load;\n  }\n}\n\n\n//# sourceMappingURL=AbstractMultiResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/ArrayResource.mjs\n\n\n\nclass ArrayResource extends AbstractMultiResource {\n  constructor(source, options) {\n    const { width, height } = options || {};\n    let urls;\n    let length;\n    if (Array.isArray(source)) {\n      urls = source;\n      length = source.length;\n    } else {\n      length = source;\n    }\n    super(length, { width, height });\n    if (urls) {\n      this.initFromArray(urls, options);\n    }\n  }\n  addBaseTextureAt(baseTexture, index) {\n    if (baseTexture.resource) {\n      this.addResourceAt(baseTexture.resource, index);\n    } else {\n      throw new Error("ArrayResource does not support RenderTexture");\n    }\n    return this;\n  }\n  bind(baseTexture) {\n    super.bind(baseTexture);\n    baseTexture.target = lib/* TARGETS */.sp.TEXTURE_2D_ARRAY;\n  }\n  upload(renderer, texture, glTexture) {\n    const { length, itemDirtyIds, items } = this;\n    const { gl } = renderer;\n    if (glTexture.dirtyId < 0) {\n      gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, glTexture.internalFormat, this._width, this._height, length, 0, texture.format, glTexture.type, null);\n    }\n    for (let i = 0; i < length; i++) {\n      const item = items[i];\n      if (itemDirtyIds[i] < item.dirtyId) {\n        itemDirtyIds[i] = item.dirtyId;\n        if (item.valid) {\n          gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, i, item.resource.width, item.resource.height, 1, texture.format, glTexture.type, item.resource.source);\n        }\n      }\n    }\n    return true;\n  }\n}\n\n\n//# sourceMappingURL=ArrayResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/CanvasResource.mjs\n\n\nclass CanvasResource extends BaseImageResource {\n  constructor(source) {\n    super(source);\n  }\n  static test(source) {\n    const { OffscreenCanvas } = globalThis;\n    if (OffscreenCanvas && source instanceof OffscreenCanvas) {\n      return true;\n    }\n    return globalThis.HTMLCanvasElement && source instanceof HTMLCanvasElement;\n  }\n}\n\n\n//# sourceMappingURL=CanvasResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/CubeResource.mjs\n\n\n\nconst _CubeResource = class extends AbstractMultiResource {\n  constructor(source, options) {\n    const { width, height, autoLoad, linkBaseTexture } = options || {};\n    if (source && source.length !== _CubeResource.SIDES) {\n      throw new Error(`Invalid length. Got ${source.length}, expected 6`);\n    }\n    super(6, { width, height });\n    for (let i = 0; i < _CubeResource.SIDES; i++) {\n      this.items[i].target = lib/* TARGETS */.sp.TEXTURE_CUBE_MAP_POSITIVE_X + i;\n    }\n    this.linkBaseTexture = linkBaseTexture !== false;\n    if (source) {\n      this.initFromArray(source, options);\n    }\n    if (autoLoad !== false) {\n      this.load();\n    }\n  }\n  bind(baseTexture) {\n    super.bind(baseTexture);\n    baseTexture.target = lib/* TARGETS */.sp.TEXTURE_CUBE_MAP;\n  }\n  addBaseTextureAt(baseTexture, index, linkBaseTexture) {\n    if (linkBaseTexture === void 0) {\n      linkBaseTexture = this.linkBaseTexture;\n    }\n    if (!this.items[index]) {\n      throw new Error(`Index ${index} is out of bounds`);\n    }\n    if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {\n      if (baseTexture.resource) {\n        this.addResourceAt(baseTexture.resource, index);\n      } else {\n        throw new Error(`CubeResource does not support copying of renderTexture.`);\n      }\n    } else {\n      baseTexture.target = lib/* TARGETS */.sp.TEXTURE_CUBE_MAP_POSITIVE_X + index;\n      baseTexture.parentTextureArray = this.baseTexture;\n      this.items[index] = baseTexture;\n    }\n    if (baseTexture.valid && !this.valid) {\n      this.resize(baseTexture.realWidth, baseTexture.realHeight);\n    }\n    this.items[index] = baseTexture;\n    return this;\n  }\n  upload(renderer, _baseTexture, glTexture) {\n    const dirty = this.itemDirtyIds;\n    for (let i = 0; i < _CubeResource.SIDES; i++) {\n      const side = this.items[i];\n      if (dirty[i] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) {\n        if (side.valid && side.resource) {\n          side.resource.upload(renderer, side, glTexture);\n          dirty[i] = side.dirtyId;\n        } else if (dirty[i] < -1) {\n          renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);\n          dirty[i] = -1;\n        }\n      }\n    }\n    return true;\n  }\n  static test(source) {\n    return Array.isArray(source) && source.length === _CubeResource.SIDES;\n  }\n};\nlet CubeResource = _CubeResource;\nCubeResource.SIDES = 6;\n\n\n//# sourceMappingURL=CubeResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/ImageBitmapResource.mjs\n\n\n\n\nclass ImageBitmapResource extends BaseImageResource {\n  constructor(source, options) {\n    options = options || {};\n    let baseSource;\n    let url;\n    if (typeof source === "string") {\n      baseSource = ImageBitmapResource.EMPTY;\n      url = source;\n    } else {\n      baseSource = source;\n      url = null;\n    }\n    super(baseSource);\n    this.url = url;\n    this.crossOrigin = options.crossOrigin ?? true;\n    this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;\n    this._load = null;\n    if (options.autoLoad !== false) {\n      this.load();\n    }\n  }\n  load() {\n    if (this._load) {\n      return this._load;\n    }\n    this._load = new Promise(async (resolve, reject) => {\n      if (this.url === null) {\n        resolve(this);\n        return;\n      }\n      try {\n        const response = await settings_lib/* settings */.Xd.ADAPTER.fetch(this.url, {\n          mode: this.crossOrigin ? "cors" : "no-cors"\n        });\n        if (this.destroyed)\n          return;\n        const imageBlob = await response.blob();\n        if (this.destroyed)\n          return;\n        const imageBitmap = await createImageBitmap(imageBlob, {\n          premultiplyAlpha: this.alphaMode === null || this.alphaMode === lib/* ALPHA_MODES */.iw.UNPACK ? "premultiply" : "none"\n        });\n        if (this.destroyed)\n          return;\n        this.source = imageBitmap;\n        this.update();\n        resolve(this);\n      } catch (e) {\n        if (this.destroyed)\n          return;\n        reject(e);\n        this.onError.emit(e);\n      }\n    });\n    return this._load;\n  }\n  upload(renderer, baseTexture, glTexture) {\n    if (!(this.source instanceof ImageBitmap)) {\n      this.load();\n      return false;\n    }\n    if (typeof this.alphaMode === "number") {\n      baseTexture.alphaMode = this.alphaMode;\n    }\n    return super.upload(renderer, baseTexture, glTexture);\n  }\n  dispose() {\n    if (this.source instanceof ImageBitmap) {\n      this.source.close();\n    }\n    super.dispose();\n    this._load = null;\n  }\n  static test(source) {\n    return !!globalThis.createImageBitmap && typeof ImageBitmap !== "undefined" && (typeof source === "string" || source instanceof ImageBitmap);\n  }\n  static get EMPTY() {\n    ImageBitmapResource._EMPTY = ImageBitmapResource._EMPTY ?? settings_lib/* settings */.Xd.ADAPTER.createCanvas(0, 0);\n    return ImageBitmapResource._EMPTY;\n  }\n}\n\n\n//# sourceMappingURL=ImageBitmapResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/SVGResource.mjs\n\n\n\n\nconst _SVGResource = class extends BaseImageResource {\n  constructor(sourceBase64, options) {\n    options = options || {};\n    super(settings_lib/* settings */.Xd.ADAPTER.createCanvas());\n    this._width = 0;\n    this._height = 0;\n    this.svg = sourceBase64;\n    this.scale = options.scale || 1;\n    this._overrideWidth = options.width;\n    this._overrideHeight = options.height;\n    this._resolve = null;\n    this._crossorigin = options.crossorigin;\n    this._load = null;\n    if (options.autoLoad !== false) {\n      this.load();\n    }\n  }\n  load() {\n    if (this._load) {\n      return this._load;\n    }\n    this._load = new Promise((resolve) => {\n      this._resolve = () => {\n        this.resize(this.source.width, this.source.height);\n        resolve(this);\n      };\n      if (_SVGResource.SVG_XML.test(this.svg.trim())) {\n        if (!btoa) {\n          throw new Error("Your browser doesn\'t support base64 conversions.");\n        }\n        this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;\n      }\n      this._loadSvg();\n    });\n    return this._load;\n  }\n  _loadSvg() {\n    const tempImage = new Image();\n    BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);\n    tempImage.src = this.svg;\n    tempImage.onerror = (event) => {\n      if (!this._resolve) {\n        return;\n      }\n      tempImage.onerror = null;\n      this.onError.emit(event);\n    };\n    tempImage.onload = () => {\n      if (!this._resolve) {\n        return;\n      }\n      const svgWidth = tempImage.width;\n      const svgHeight = tempImage.height;\n      if (!svgWidth || !svgHeight) {\n        throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");\n      }\n      let width = svgWidth * this.scale;\n      let height = svgHeight * this.scale;\n      if (this._overrideWidth || this._overrideHeight) {\n        width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth;\n        height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight;\n      }\n      width = Math.round(width);\n      height = Math.round(height);\n      const canvas = this.source;\n      canvas.width = width;\n      canvas.height = height;\n      canvas._pixiId = `canvas_${(0,utils_lib.uid)()}`;\n      canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);\n      this._resolve();\n      this._resolve = null;\n    };\n  }\n  static getSize(svgString) {\n    const sizeMatch = _SVGResource.SVG_SIZE.exec(svgString);\n    const size = {};\n    if (sizeMatch) {\n      size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));\n      size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));\n    }\n    return size;\n  }\n  dispose() {\n    super.dispose();\n    this._resolve = null;\n    this._crossorigin = null;\n  }\n  static test(source, extension) {\n    return extension === "svg" || typeof source === "string" && source.startsWith("data:image/svg+xml") || typeof source === "string" && _SVGResource.SVG_XML.test(source);\n  }\n};\nlet SVGResource = _SVGResource;\nSVGResource.SVG_XML = /^(<\\?xml[^?]+\\?>)?\\s*(\x3c!--[^(--\x3e)]*--\x3e)?\\s*\\<svg/m;\nSVGResource.SVG_SIZE = /<svg[^>]*(?:\\s(width|height)=(\'|")(\\d*(?:\\.\\d+)?)(?:px)?(\'|"))[^>]*(?:\\s(width|height)=(\'|")(\\d*(?:\\.\\d+)?)(?:px)?(\'|"))[^>]*>/i;\n\n\n//# sourceMappingURL=SVGResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/VideoResource.mjs\n\n\n\nconst _VideoResource = class extends BaseImageResource {\n  constructor(source, options) {\n    options = options || {};\n    if (!(source instanceof HTMLVideoElement)) {\n      const videoElement = document.createElement("video");\n      videoElement.setAttribute("preload", "auto");\n      videoElement.setAttribute("webkit-playsinline", "");\n      videoElement.setAttribute("playsinline", "");\n      if (typeof source === "string") {\n        source = [source];\n      }\n      const firstSrc = source[0].src || source[0];\n      BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);\n      for (let i = 0; i < source.length; ++i) {\n        const sourceElement = document.createElement("source");\n        let { src, mime } = source[i];\n        src = src || source[i];\n        const baseSrc = src.split("?").shift().toLowerCase();\n        const ext = baseSrc.slice(baseSrc.lastIndexOf(".") + 1);\n        mime = mime || _VideoResource.MIME_TYPES[ext] || `video/${ext}`;\n        sourceElement.src = src;\n        sourceElement.type = mime;\n        videoElement.appendChild(sourceElement);\n      }\n      source = videoElement;\n    }\n    super(source);\n    this.noSubImage = true;\n    this._autoUpdate = true;\n    this._isConnectedToTicker = false;\n    this._updateFPS = options.updateFPS || 0;\n    this._msToNextUpdate = 0;\n    this.autoPlay = options.autoPlay !== false;\n    this._load = null;\n    this._resolve = null;\n    this._onCanPlay = this._onCanPlay.bind(this);\n    this._onError = this._onError.bind(this);\n    if (options.autoLoad !== false) {\n      this.load();\n    }\n  }\n  update(_deltaTime = 0) {\n    if (!this.destroyed) {\n      const elapsedMS = Ticker_Ticker.shared.elapsedMS * this.source.playbackRate;\n      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n      if (!this._updateFPS || this._msToNextUpdate <= 0) {\n        super.update();\n        this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;\n      }\n    }\n  }\n  load() {\n    if (this._load) {\n      return this._load;\n    }\n    const source = this.source;\n    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {\n      source.complete = true;\n    }\n    source.addEventListener("play", this._onPlayStart.bind(this));\n    source.addEventListener("pause", this._onPlayStop.bind(this));\n    if (!this._isSourceReady()) {\n      source.addEventListener("canplay", this._onCanPlay);\n      source.addEventListener("canplaythrough", this._onCanPlay);\n      source.addEventListener("error", this._onError, true);\n    } else {\n      this._onCanPlay();\n    }\n    this._load = new Promise((resolve) => {\n      if (this.valid) {\n        resolve(this);\n      } else {\n        this._resolve = resolve;\n        source.load();\n      }\n    });\n    return this._load;\n  }\n  _onError(event) {\n    this.source.removeEventListener("error", this._onError, true);\n    this.onError.emit(event);\n  }\n  _isSourcePlaying() {\n    const source = this.source;\n    return !source.paused && !source.ended && this._isSourceReady();\n  }\n  _isSourceReady() {\n    const source = this.source;\n    return source.readyState > 2;\n  }\n  _onPlayStart() {\n    if (!this.valid) {\n      this._onCanPlay();\n    }\n    if (this.autoUpdate && !this._isConnectedToTicker) {\n      Ticker_Ticker.shared.add(this.update, this);\n      this._isConnectedToTicker = true;\n    }\n  }\n  _onPlayStop() {\n    if (this._isConnectedToTicker) {\n      Ticker_Ticker.shared.remove(this.update, this);\n      this._isConnectedToTicker = false;\n    }\n  }\n  _onCanPlay() {\n    const source = this.source;\n    source.removeEventListener("canplay", this._onCanPlay);\n    source.removeEventListener("canplaythrough", this._onCanPlay);\n    const valid = this.valid;\n    this.resize(source.videoWidth, source.videoHeight);\n    if (!valid && this._resolve) {\n      this._resolve(this);\n      this._resolve = null;\n    }\n    if (this._isSourcePlaying()) {\n      this._onPlayStart();\n    } else if (this.autoPlay) {\n      source.play();\n    }\n  }\n  dispose() {\n    if (this._isConnectedToTicker) {\n      Ticker_Ticker.shared.remove(this.update, this);\n      this._isConnectedToTicker = false;\n    }\n    const source = this.source;\n    if (source) {\n      source.removeEventListener("error", this._onError, true);\n      source.pause();\n      source.src = "";\n      source.load();\n    }\n    super.dispose();\n  }\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    if (value !== this._autoUpdate) {\n      this._autoUpdate = value;\n      if (!this._autoUpdate && this._isConnectedToTicker) {\n        Ticker_Ticker.shared.remove(this.update, this);\n        this._isConnectedToTicker = false;\n      } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {\n        Ticker_Ticker.shared.add(this.update, this);\n        this._isConnectedToTicker = true;\n      }\n    }\n  }\n  get updateFPS() {\n    return this._updateFPS;\n  }\n  set updateFPS(value) {\n    if (value !== this._updateFPS) {\n      this._updateFPS = value;\n    }\n  }\n  static test(source, extension) {\n    return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || _VideoResource.TYPES.includes(extension);\n  }\n};\nlet VideoResource = _VideoResource;\nVideoResource.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];\nVideoResource.MIME_TYPES = {\n  ogv: "video/ogg",\n  mov: "video/quicktime",\n  m4v: "video/mp4"\n};\n\n\n//# sourceMappingURL=VideoResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/textures/resources/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nINSTALLED.push(ImageBitmapResource, ImageResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/transformFeedback/TransformFeedback.mjs\n\n\nclass TransformFeedback {\n  constructor() {\n    this._glTransformFeedbacks = {};\n    this.buffers = [];\n    this.disposeRunner = new Runner("disposeTransformFeedback");\n  }\n  bindBuffer(index, buffer) {\n    this.buffers[index] = buffer;\n  }\n  destroy() {\n    this.disposeRunner.emit(this, false);\n  }\n}\n\n\n//# sourceMappingURL=TransformFeedback.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/core/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst VERSION = "7.2.4";\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/display/lib/Bounds.mjs\n\n\nclass Bounds {\n  constructor() {\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = -Infinity;\n    this.maxY = -Infinity;\n    this.rect = null;\n    this.updateID = -1;\n  }\n  isEmpty() {\n    return this.minX > this.maxX || this.minY > this.maxY;\n  }\n  clear() {\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = -Infinity;\n    this.maxY = -Infinity;\n  }\n  getRectangle(rect) {\n    if (this.minX > this.maxX || this.minY > this.maxY) {\n      return Rectangle_Rectangle.EMPTY;\n    }\n    rect = rect || new Rectangle_Rectangle(0, 0, 1, 1);\n    rect.x = this.minX;\n    rect.y = this.minY;\n    rect.width = this.maxX - this.minX;\n    rect.height = this.maxY - this.minY;\n    return rect;\n  }\n  addPoint(point) {\n    this.minX = Math.min(this.minX, point.x);\n    this.maxX = Math.max(this.maxX, point.x);\n    this.minY = Math.min(this.minY, point.y);\n    this.maxY = Math.max(this.maxY, point.y);\n  }\n  addPointMatrix(matrix, point) {\n    const { a, b, c, d, tx, ty } = matrix;\n    const x = a * point.x + c * point.y + tx;\n    const y = b * point.x + d * point.y + ty;\n    this.minX = Math.min(this.minX, x);\n    this.maxX = Math.max(this.maxX, x);\n    this.minY = Math.min(this.minY, y);\n    this.maxY = Math.max(this.maxY, y);\n  }\n  addQuad(vertices) {\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    let x = vertices[0];\n    let y = vertices[1];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = vertices[2];\n    y = vertices[3];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = vertices[4];\n    y = vertices[5];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = vertices[6];\n    y = vertices[7];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  addFrame(transform, x0, y0, x1, y1) {\n    this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);\n  }\n  addFrameMatrix(matrix, x0, y0, x1, y1) {\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    let x = a * x0 + c * y0 + tx;\n    let y = b * x0 + d * y0 + ty;\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = a * x1 + c * y0 + tx;\n    y = b * x1 + d * y0 + ty;\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = a * x0 + c * y1 + tx;\n    y = b * x0 + d * y1 + ty;\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = a * x1 + c * y1 + tx;\n    y = b * x1 + d * y1 + ty;\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  addVertexData(vertexData, beginOffset, endOffset) {\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    for (let i = beginOffset; i < endOffset; i += 2) {\n      const x = vertexData[i];\n      const y = vertexData[i + 1];\n      minX = x < minX ? x : minX;\n      minY = y < minY ? y : minY;\n      maxX = x > maxX ? x : maxX;\n      maxY = y > maxY ? y : maxY;\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  addVertices(transform, vertices, beginOffset, endOffset) {\n    this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);\n  }\n  addVerticesMatrix(matrix, vertices, beginOffset, endOffset, padX = 0, padY = padX) {\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    for (let i = beginOffset; i < endOffset; i += 2) {\n      const rawX = vertices[i];\n      const rawY = vertices[i + 1];\n      const x = a * rawX + c * rawY + tx;\n      const y = d * rawY + b * rawX + ty;\n      minX = Math.min(minX, x - padX);\n      maxX = Math.max(maxX, x + padX);\n      minY = Math.min(minY, y - padY);\n      maxY = Math.max(maxY, y + padY);\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  addBounds(bounds) {\n    const minX = this.minX;\n    const minY = this.minY;\n    const maxX = this.maxX;\n    const maxY = this.maxY;\n    this.minX = bounds.minX < minX ? bounds.minX : minX;\n    this.minY = bounds.minY < minY ? bounds.minY : minY;\n    this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;\n    this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;\n  }\n  addBoundsMask(bounds, mask) {\n    const _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;\n    const _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;\n    const _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;\n    const _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;\n    if (_minX <= _maxX && _minY <= _maxY) {\n      const minX = this.minX;\n      const minY = this.minY;\n      const maxX = this.maxX;\n      const maxY = this.maxY;\n      this.minX = _minX < minX ? _minX : minX;\n      this.minY = _minY < minY ? _minY : minY;\n      this.maxX = _maxX > maxX ? _maxX : maxX;\n      this.maxY = _maxY > maxY ? _maxY : maxY;\n    }\n  }\n  addBoundsMatrix(bounds, matrix) {\n    this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);\n  }\n  addBoundsArea(bounds, area) {\n    const _minX = bounds.minX > area.x ? bounds.minX : area.x;\n    const _minY = bounds.minY > area.y ? bounds.minY : area.y;\n    const _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width;\n    const _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height;\n    if (_minX <= _maxX && _minY <= _maxY) {\n      const minX = this.minX;\n      const minY = this.minY;\n      const maxX = this.maxX;\n      const maxY = this.maxY;\n      this.minX = _minX < minX ? _minX : minX;\n      this.minY = _minY < minY ? _minY : minY;\n      this.maxX = _maxX > maxX ? _maxX : maxX;\n      this.maxY = _maxY > maxY ? _maxY : maxY;\n    }\n  }\n  pad(paddingX = 0, paddingY = paddingX) {\n    if (!this.isEmpty()) {\n      this.minX -= paddingX;\n      this.maxX += paddingX;\n      this.minY -= paddingY;\n      this.maxY += paddingY;\n    }\n  }\n  addFramePad(x0, y0, x1, y1, padX, padY) {\n    x0 -= padX;\n    y0 -= padY;\n    x1 += padX;\n    y1 += padY;\n    this.minX = this.minX < x0 ? this.minX : x0;\n    this.maxX = this.maxX > x1 ? this.maxX : x1;\n    this.minY = this.minY < y0 ? this.minY : y0;\n    this.maxY = this.maxY > y1 ? this.maxY : y1;\n  }\n}\n\n\n//# sourceMappingURL=Bounds.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/display/lib/DisplayObject.mjs\n\n\n\nclass DisplayObject extends utils_lib.EventEmitter {\n  constructor() {\n    super();\n    this.tempDisplayObjectParent = null;\n    this.transform = new Transform_Transform();\n    this.alpha = 1;\n    this.visible = true;\n    this.renderable = true;\n    this.cullable = false;\n    this.cullArea = null;\n    this.parent = null;\n    this.worldAlpha = 1;\n    this._lastSortedIndex = 0;\n    this._zIndex = 0;\n    this.filterArea = null;\n    this.filters = null;\n    this._enabledFilters = null;\n    this._bounds = new Bounds();\n    this._localBounds = null;\n    this._boundsID = 0;\n    this._boundsRect = null;\n    this._localBoundsRect = null;\n    this._mask = null;\n    this._maskRefCount = 0;\n    this._destroyed = false;\n    this.isSprite = false;\n    this.isMask = false;\n  }\n  static mixin(source) {\n    const keys = Object.keys(source);\n    for (let i = 0; i < keys.length; ++i) {\n      const propertyName = keys[i];\n      Object.defineProperty(DisplayObject.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));\n    }\n  }\n  get destroyed() {\n    return this._destroyed;\n  }\n  _recursivePostUpdateTransform() {\n    if (this.parent) {\n      this.parent._recursivePostUpdateTransform();\n      this.transform.updateTransform(this.parent.transform);\n    } else {\n      this.transform.updateTransform(this._tempDisplayObjectParent.transform);\n    }\n  }\n  updateTransform() {\n    this._boundsID++;\n    this.transform.updateTransform(this.parent.transform);\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n  }\n  getBounds(skipUpdate, rect) {\n    if (!skipUpdate) {\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.updateTransform();\n        this.parent = null;\n      } else {\n        this._recursivePostUpdateTransform();\n        this.updateTransform();\n      }\n    }\n    if (this._bounds.updateID !== this._boundsID) {\n      this.calculateBounds();\n      this._bounds.updateID = this._boundsID;\n    }\n    if (!rect) {\n      if (!this._boundsRect) {\n        this._boundsRect = new Rectangle_Rectangle();\n      }\n      rect = this._boundsRect;\n    }\n    return this._bounds.getRectangle(rect);\n  }\n  getLocalBounds(rect) {\n    if (!rect) {\n      if (!this._localBoundsRect) {\n        this._localBoundsRect = new Rectangle_Rectangle();\n      }\n      rect = this._localBoundsRect;\n    }\n    if (!this._localBounds) {\n      this._localBounds = new Bounds();\n    }\n    const transformRef = this.transform;\n    const parentRef = this.parent;\n    this.parent = null;\n    this.transform = this._tempDisplayObjectParent.transform;\n    const worldBounds = this._bounds;\n    const worldBoundsID = this._boundsID;\n    this._bounds = this._localBounds;\n    const bounds = this.getBounds(false, rect);\n    this.parent = parentRef;\n    this.transform = transformRef;\n    this._bounds = worldBounds;\n    this._bounds.updateID += this._boundsID - worldBoundsID;\n    return bounds;\n  }\n  toGlobal(position, point, skipUpdate = false) {\n    if (!skipUpdate) {\n      this._recursivePostUpdateTransform();\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.displayObjectUpdateTransform();\n        this.parent = null;\n      } else {\n        this.displayObjectUpdateTransform();\n      }\n    }\n    return this.worldTransform.apply(position, point);\n  }\n  toLocal(position, from, point, skipUpdate) {\n    if (from) {\n      position = from.toGlobal(position, point, skipUpdate);\n    }\n    if (!skipUpdate) {\n      this._recursivePostUpdateTransform();\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.displayObjectUpdateTransform();\n        this.parent = null;\n      } else {\n        this.displayObjectUpdateTransform();\n      }\n    }\n    return this.worldTransform.applyInverse(position, point);\n  }\n  setParent(container) {\n    if (!container || !container.addChild) {\n      throw new Error("setParent: Argument must be a Container");\n    }\n    container.addChild(this);\n    return container;\n  }\n  removeFromParent() {\n    this.parent?.removeChild(this);\n  }\n  setTransform(x = 0, y = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0) {\n    this.position.x = x;\n    this.position.y = y;\n    this.scale.x = !scaleX ? 1 : scaleX;\n    this.scale.y = !scaleY ? 1 : scaleY;\n    this.rotation = rotation;\n    this.skew.x = skewX;\n    this.skew.y = skewY;\n    this.pivot.x = pivotX;\n    this.pivot.y = pivotY;\n    return this;\n  }\n  destroy(_options) {\n    this.removeFromParent();\n    this._destroyed = true;\n    this.transform = null;\n    this.parent = null;\n    this._bounds = null;\n    this.mask = null;\n    this.cullArea = null;\n    this.filters = null;\n    this.filterArea = null;\n    this.hitArea = null;\n    this.eventMode = "auto";\n    this.interactiveChildren = false;\n    this.emit("destroyed");\n    this.removeAllListeners();\n  }\n  get _tempDisplayObjectParent() {\n    if (this.tempDisplayObjectParent === null) {\n      this.tempDisplayObjectParent = new TemporaryDisplayObject();\n    }\n    return this.tempDisplayObjectParent;\n  }\n  enableTempParent() {\n    const myParent = this.parent;\n    this.parent = this._tempDisplayObjectParent;\n    return myParent;\n  }\n  disableTempParent(cacheParent) {\n    this.parent = cacheParent;\n  }\n  get x() {\n    return this.position.x;\n  }\n  set x(value) {\n    this.transform.position.x = value;\n  }\n  get y() {\n    return this.position.y;\n  }\n  set y(value) {\n    this.transform.position.y = value;\n  }\n  get worldTransform() {\n    return this.transform.worldTransform;\n  }\n  get localTransform() {\n    return this.transform.localTransform;\n  }\n  get position() {\n    return this.transform.position;\n  }\n  set position(value) {\n    this.transform.position.copyFrom(value);\n  }\n  get scale() {\n    return this.transform.scale;\n  }\n  set scale(value) {\n    this.transform.scale.copyFrom(value);\n  }\n  get pivot() {\n    return this.transform.pivot;\n  }\n  set pivot(value) {\n    this.transform.pivot.copyFrom(value);\n  }\n  get skew() {\n    return this.transform.skew;\n  }\n  set skew(value) {\n    this.transform.skew.copyFrom(value);\n  }\n  get rotation() {\n    return this.transform.rotation;\n  }\n  set rotation(value) {\n    this.transform.rotation = value;\n  }\n  get angle() {\n    return this.transform.rotation * RAD_TO_DEG;\n  }\n  set angle(value) {\n    this.transform.rotation = value * DEG_TO_RAD;\n  }\n  get zIndex() {\n    return this._zIndex;\n  }\n  set zIndex(value) {\n    this._zIndex = value;\n    if (this.parent) {\n      this.parent.sortDirty = true;\n    }\n  }\n  get worldVisible() {\n    let item = this;\n    do {\n      if (!item.visible) {\n        return false;\n      }\n      item = item.parent;\n    } while (item);\n    return true;\n  }\n  get mask() {\n    return this._mask;\n  }\n  set mask(value) {\n    if (this._mask === value) {\n      return;\n    }\n    if (this._mask) {\n      const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;\n      if (maskObject) {\n        maskObject._maskRefCount--;\n        if (maskObject._maskRefCount === 0) {\n          maskObject.renderable = true;\n          maskObject.isMask = false;\n        }\n      }\n    }\n    this._mask = value;\n    if (this._mask) {\n      const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;\n      if (maskObject) {\n        if (maskObject._maskRefCount === 0) {\n          maskObject.renderable = false;\n          maskObject.isMask = true;\n        }\n        maskObject._maskRefCount++;\n      }\n    }\n  }\n}\nclass TemporaryDisplayObject extends DisplayObject {\n  constructor() {\n    super(...arguments);\n    this.sortDirty = null;\n  }\n}\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;\n\n\n//# sourceMappingURL=DisplayObject.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/display/lib/Container.mjs\n\n\n\nconst Container_tempMatrix = new Matrix();\nfunction sortChildren(a, b) {\n  if (a.zIndex === b.zIndex) {\n    return a._lastSortedIndex - b._lastSortedIndex;\n  }\n  return a.zIndex - b.zIndex;\n}\nconst _Container = class extends DisplayObject {\n  constructor() {\n    super();\n    this.children = [];\n    this.sortableChildren = _Container.defaultSortableChildren;\n    this.sortDirty = false;\n  }\n  onChildrenChange(_length) {\n  }\n  addChild(...children) {\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.addChild(children[i]);\n      }\n    } else {\n      const child = children[0];\n      if (child.parent) {\n        child.parent.removeChild(child);\n      }\n      child.parent = this;\n      this.sortDirty = true;\n      child.transform._parentID = -1;\n      this.children.push(child);\n      this._boundsID++;\n      this.onChildrenChange(this.children.length - 1);\n      this.emit("childAdded", child, this, this.children.length - 1);\n      child.emit("added", this);\n    }\n    return children[0];\n  }\n  addChildAt(child, index) {\n    if (index < 0 || index > this.children.length) {\n      throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${this.children.length}`);\n    }\n    if (child.parent) {\n      child.parent.removeChild(child);\n    }\n    child.parent = this;\n    this.sortDirty = true;\n    child.transform._parentID = -1;\n    this.children.splice(index, 0, child);\n    this._boundsID++;\n    this.onChildrenChange(index);\n    child.emit("added", this);\n    this.emit("childAdded", child, this, index);\n    return child;\n  }\n  swapChildren(child, child2) {\n    if (child === child2) {\n      return;\n    }\n    const index1 = this.getChildIndex(child);\n    const index2 = this.getChildIndex(child2);\n    this.children[index1] = child2;\n    this.children[index2] = child;\n    this.onChildrenChange(index1 < index2 ? index1 : index2);\n  }\n  getChildIndex(child) {\n    const index = this.children.indexOf(child);\n    if (index === -1) {\n      throw new Error("The supplied DisplayObject must be a child of the caller");\n    }\n    return index;\n  }\n  setChildIndex(child, index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n    }\n    const currentIndex = this.getChildIndex(child);\n    utils_lib.removeItems(this.children, currentIndex, 1);\n    this.children.splice(index, 0, child);\n    this.onChildrenChange(index);\n  }\n  getChildAt(index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`getChildAt: Index (${index}) does not exist.`);\n    }\n    return this.children[index];\n  }\n  removeChild(...children) {\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.removeChild(children[i]);\n      }\n    } else {\n      const child = children[0];\n      const index = this.children.indexOf(child);\n      if (index === -1)\n        return null;\n      child.parent = null;\n      child.transform._parentID = -1;\n      utils_lib.removeItems(this.children, index, 1);\n      this._boundsID++;\n      this.onChildrenChange(index);\n      child.emit("removed", this);\n      this.emit("childRemoved", child, this, index);\n    }\n    return children[0];\n  }\n  removeChildAt(index) {\n    const child = this.getChildAt(index);\n    child.parent = null;\n    child.transform._parentID = -1;\n    utils_lib.removeItems(this.children, index, 1);\n    this._boundsID++;\n    this.onChildrenChange(index);\n    child.emit("removed", this);\n    this.emit("childRemoved", child, this, index);\n    return child;\n  }\n  removeChildren(beginIndex = 0, endIndex = this.children.length) {\n    const begin = beginIndex;\n    const end = endIndex;\n    const range = end - begin;\n    let removed;\n    if (range > 0 && range <= end) {\n      removed = this.children.splice(begin, range);\n      for (let i = 0; i < removed.length; ++i) {\n        removed[i].parent = null;\n        if (removed[i].transform) {\n          removed[i].transform._parentID = -1;\n        }\n      }\n      this._boundsID++;\n      this.onChildrenChange(beginIndex);\n      for (let i = 0; i < removed.length; ++i) {\n        removed[i].emit("removed", this);\n        this.emit("childRemoved", removed[i], this, i);\n      }\n      return removed;\n    } else if (range === 0 && this.children.length === 0) {\n      return [];\n    }\n    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");\n  }\n  sortChildren() {\n    let sortRequired = false;\n    for (let i = 0, j = this.children.length; i < j; ++i) {\n      const child = this.children[i];\n      child._lastSortedIndex = i;\n      if (!sortRequired && child.zIndex !== 0) {\n        sortRequired = true;\n      }\n    }\n    if (sortRequired && this.children.length > 1) {\n      this.children.sort(sortChildren);\n    }\n    this.sortDirty = false;\n  }\n  updateTransform() {\n    if (this.sortableChildren && this.sortDirty) {\n      this.sortChildren();\n    }\n    this._boundsID++;\n    this.transform.updateTransform(this.parent.transform);\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    for (let i = 0, j = this.children.length; i < j; ++i) {\n      const child = this.children[i];\n      if (child.visible) {\n        child.updateTransform();\n      }\n    }\n  }\n  calculateBounds() {\n    this._bounds.clear();\n    this._calculateBounds();\n    for (let i = 0; i < this.children.length; i++) {\n      const child = this.children[i];\n      if (!child.visible || !child.renderable) {\n        continue;\n      }\n      child.calculateBounds();\n      if (child._mask) {\n        const maskObject = child._mask.isMaskData ? child._mask.maskObject : child._mask;\n        if (maskObject) {\n          maskObject.calculateBounds();\n          this._bounds.addBoundsMask(child._bounds, maskObject._bounds);\n        } else {\n          this._bounds.addBounds(child._bounds);\n        }\n      } else if (child.filterArea) {\n        this._bounds.addBoundsArea(child._bounds, child.filterArea);\n      } else {\n        this._bounds.addBounds(child._bounds);\n      }\n    }\n    this._bounds.updateID = this._boundsID;\n  }\n  getLocalBounds(rect, skipChildrenUpdate = false) {\n    const result = super.getLocalBounds(rect);\n    if (!skipChildrenUpdate) {\n      for (let i = 0, j = this.children.length; i < j; ++i) {\n        const child = this.children[i];\n        if (child.visible) {\n          child.updateTransform();\n        }\n      }\n    }\n    return result;\n  }\n  _calculateBounds() {\n  }\n  _renderWithCulling(renderer) {\n    const sourceFrame = renderer.renderTexture.sourceFrame;\n    if (!(sourceFrame.width > 0 && sourceFrame.height > 0)) {\n      return;\n    }\n    let bounds;\n    let transform;\n    if (this.cullArea) {\n      bounds = this.cullArea;\n      transform = this.worldTransform;\n    } else if (this._render !== _Container.prototype._render) {\n      bounds = this.getBounds(true);\n    }\n    const projectionTransform = renderer.projection.transform;\n    if (projectionTransform) {\n      if (transform) {\n        transform = Container_tempMatrix.copyFrom(transform);\n        transform.prepend(projectionTransform);\n      } else {\n        transform = projectionTransform;\n      }\n    }\n    if (bounds && sourceFrame.intersects(bounds, transform)) {\n      this._render(renderer);\n    } else if (this.cullArea) {\n      return;\n    }\n    for (let i = 0, j = this.children.length; i < j; ++i) {\n      const child = this.children[i];\n      const childCullable = child.cullable;\n      child.cullable = childCullable || !this.cullArea;\n      child.render(renderer);\n      child.cullable = childCullable;\n    }\n  }\n  render(renderer) {\n    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n      return;\n    }\n    if (this._mask || this.filters?.length) {\n      this.renderAdvanced(renderer);\n    } else if (this.cullable) {\n      this._renderWithCulling(renderer);\n    } else {\n      this._render(renderer);\n      for (let i = 0, j = this.children.length; i < j; ++i) {\n        this.children[i].render(renderer);\n      }\n    }\n  }\n  renderAdvanced(renderer) {\n    const filters = this.filters;\n    const mask = this._mask;\n    if (filters) {\n      if (!this._enabledFilters) {\n        this._enabledFilters = [];\n      }\n      this._enabledFilters.length = 0;\n      for (let i = 0; i < filters.length; i++) {\n        if (filters[i].enabled) {\n          this._enabledFilters.push(filters[i]);\n        }\n      }\n    }\n    const flush = filters && this._enabledFilters?.length || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== lib/* MASK_TYPES */.A7.NONE));\n    if (flush) {\n      renderer.batch.flush();\n    }\n    if (filters && this._enabledFilters?.length) {\n      renderer.filter.push(this, this._enabledFilters);\n    }\n    if (mask) {\n      renderer.mask.push(this, this._mask);\n    }\n    if (this.cullable) {\n      this._renderWithCulling(renderer);\n    } else {\n      this._render(renderer);\n      for (let i = 0, j = this.children.length; i < j; ++i) {\n        this.children[i].render(renderer);\n      }\n    }\n    if (flush) {\n      renderer.batch.flush();\n    }\n    if (mask) {\n      renderer.mask.pop(this);\n    }\n    if (filters && this._enabledFilters?.length) {\n      renderer.filter.pop();\n    }\n  }\n  _render(_renderer) {\n  }\n  destroy(options) {\n    super.destroy();\n    this.sortDirty = false;\n    const destroyChildren = typeof options === "boolean" ? options : options?.children;\n    const oldChildren = this.removeChildren(0, this.children.length);\n    if (destroyChildren) {\n      for (let i = 0; i < oldChildren.length; ++i) {\n        oldChildren[i].destroy(options);\n      }\n    }\n  }\n  get width() {\n    return this.scale.x * this.getLocalBounds().width;\n  }\n  set width(value) {\n    const width = this.getLocalBounds().width;\n    if (width !== 0) {\n      this.scale.x = value / width;\n    } else {\n      this.scale.x = 1;\n    }\n    this._width = value;\n  }\n  get height() {\n    return this.scale.y * this.getLocalBounds().height;\n  }\n  set height(value) {\n    const height = this.getLocalBounds().height;\n    if (height !== 0) {\n      this.scale.y = value / height;\n    } else {\n      this.scale.y = 1;\n    }\n    this._height = value;\n  }\n};\nlet Container_Container = _Container;\nContainer_Container.defaultSortableChildren = false;\nContainer_Container.prototype.containerUpdateTransform = Container_Container.prototype.updateTransform;\n\n\n//# sourceMappingURL=Container.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/display/lib/settings.mjs\n\n\n\n\nObject.defineProperties(settings_lib/* settings */.Xd, {\n  SORTABLE_CHILDREN: {\n    get() {\n      return Container_Container.defaultSortableChildren;\n    },\n    set(value) {\n      utils_lib.deprecation("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren");\n      Container_Container.defaultSortableChildren = value;\n    }\n  }\n});\n//# sourceMappingURL=settings.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/display/lib/index.mjs\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite/lib/Sprite.mjs\n\n\n\nconst tempPoint = new Point();\nconst indices = new Uint16Array([0, 1, 2, 0, 2, 3]);\nclass Sprite_Sprite extends Container_Container {\n  constructor(texture) {\n    super();\n    this._anchor = new ObservablePoint(this._onAnchorUpdate, this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);\n    this._texture = null;\n    this._width = 0;\n    this._height = 0;\n    this._tintColor = new color_lib/* Color */.I(16777215);\n    this._tintRGB = null;\n    this.tint = 16777215;\n    this.blendMode = lib/* BLEND_MODES */.T$.NORMAL;\n    this._cachedTint = 16777215;\n    this.uvs = null;\n    this.texture = texture || Texture_Texture.EMPTY;\n    this.vertexData = new Float32Array(8);\n    this.vertexTrimmedData = null;\n    this._transformID = -1;\n    this._textureID = -1;\n    this._transformTrimmedID = -1;\n    this._textureTrimmedID = -1;\n    this.indices = indices;\n    this.pluginName = "batch";\n    this.isSprite = true;\n    this._roundPixels = settings_lib/* settings */.Xd.ROUND_PIXELS;\n  }\n  _onTextureUpdate() {\n    this._textureID = -1;\n    this._textureTrimmedID = -1;\n    this._cachedTint = 16777215;\n    if (this._width) {\n      this.scale.x = utils_lib.sign(this.scale.x) * this._width / this._texture.orig.width;\n    }\n    if (this._height) {\n      this.scale.y = utils_lib.sign(this.scale.y) * this._height / this._texture.orig.height;\n    }\n  }\n  _onAnchorUpdate() {\n    this._transformID = -1;\n    this._transformTrimmedID = -1;\n  }\n  calculateVertices() {\n    const texture = this._texture;\n    if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {\n      return;\n    }\n    if (this._textureID !== texture._updateID) {\n      this.uvs = this._texture._uvs.uvsFloat32;\n    }\n    this._transformID = this.transform._worldID;\n    this._textureID = texture._updateID;\n    const wt = this.transform.worldTransform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const vertexData = this.vertexData;\n    const trim = texture.trim;\n    const orig = texture.orig;\n    const anchor = this._anchor;\n    let w0 = 0;\n    let w1 = 0;\n    let h0 = 0;\n    let h1 = 0;\n    if (trim) {\n      w1 = trim.x - anchor._x * orig.width;\n      w0 = w1 + trim.width;\n      h1 = trim.y - anchor._y * orig.height;\n      h0 = h1 + trim.height;\n    } else {\n      w1 = -anchor._x * orig.width;\n      w0 = w1 + orig.width;\n      h1 = -anchor._y * orig.height;\n      h0 = h1 + orig.height;\n    }\n    vertexData[0] = a * w1 + c * h1 + tx;\n    vertexData[1] = d * h1 + b * w1 + ty;\n    vertexData[2] = a * w0 + c * h1 + tx;\n    vertexData[3] = d * h1 + b * w0 + ty;\n    vertexData[4] = a * w0 + c * h0 + tx;\n    vertexData[5] = d * h0 + b * w0 + ty;\n    vertexData[6] = a * w1 + c * h0 + tx;\n    vertexData[7] = d * h0 + b * w1 + ty;\n    if (this._roundPixels) {\n      const resolution = settings_lib/* settings */.Xd.RESOLUTION;\n      for (let i = 0; i < vertexData.length; ++i) {\n        vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;\n      }\n    }\n  }\n  calculateTrimmedVertices() {\n    if (!this.vertexTrimmedData) {\n      this.vertexTrimmedData = new Float32Array(8);\n    } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {\n      return;\n    }\n    this._transformTrimmedID = this.transform._worldID;\n    this._textureTrimmedID = this._texture._updateID;\n    const texture = this._texture;\n    const vertexData = this.vertexTrimmedData;\n    const orig = texture.orig;\n    const anchor = this._anchor;\n    const wt = this.transform.worldTransform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const w1 = -anchor._x * orig.width;\n    const w0 = w1 + orig.width;\n    const h1 = -anchor._y * orig.height;\n    const h0 = h1 + orig.height;\n    vertexData[0] = a * w1 + c * h1 + tx;\n    vertexData[1] = d * h1 + b * w1 + ty;\n    vertexData[2] = a * w0 + c * h1 + tx;\n    vertexData[3] = d * h1 + b * w0 + ty;\n    vertexData[4] = a * w0 + c * h0 + tx;\n    vertexData[5] = d * h0 + b * w0 + ty;\n    vertexData[6] = a * w1 + c * h0 + tx;\n    vertexData[7] = d * h0 + b * w1 + ty;\n  }\n  _render(renderer) {\n    this.calculateVertices();\n    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n    renderer.plugins[this.pluginName].render(this);\n  }\n  _calculateBounds() {\n    const trim = this._texture.trim;\n    const orig = this._texture.orig;\n    if (!trim || trim.width === orig.width && trim.height === orig.height) {\n      this.calculateVertices();\n      this._bounds.addQuad(this.vertexData);\n    } else {\n      this.calculateTrimmedVertices();\n      this._bounds.addQuad(this.vertexTrimmedData);\n    }\n  }\n  getLocalBounds(rect) {\n    if (this.children.length === 0) {\n      if (!this._localBounds) {\n        this._localBounds = new Bounds();\n      }\n      this._localBounds.minX = this._texture.orig.width * -this._anchor._x;\n      this._localBounds.minY = this._texture.orig.height * -this._anchor._y;\n      this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x);\n      this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y);\n      if (!rect) {\n        if (!this._localBoundsRect) {\n          this._localBoundsRect = new Rectangle_Rectangle();\n        }\n        rect = this._localBoundsRect;\n      }\n      return this._localBounds.getRectangle(rect);\n    }\n    return super.getLocalBounds.call(this, rect);\n  }\n  containsPoint(point) {\n    this.worldTransform.applyInverse(point, tempPoint);\n    const width = this._texture.orig.width;\n    const height = this._texture.orig.height;\n    const x1 = -width * this.anchor.x;\n    let y1 = 0;\n    if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {\n      y1 = -height * this.anchor.y;\n      if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {\n        return true;\n      }\n    }\n    return false;\n  }\n  destroy(options) {\n    super.destroy(options);\n    this._texture.off("update", this._onTextureUpdate, this);\n    this._anchor = null;\n    const destroyTexture = typeof options === "boolean" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyBaseTexture = typeof options === "boolean" ? options : options?.baseTexture;\n      this._texture.destroy(!!destroyBaseTexture);\n    }\n    this._texture = null;\n  }\n  static from(source, options) {\n    const texture = source instanceof Texture_Texture ? source : Texture_Texture.from(source, options);\n    return new Sprite_Sprite(texture);\n  }\n  set roundPixels(value) {\n    if (this._roundPixels !== value) {\n      this._transformID = -1;\n    }\n    this._roundPixels = value;\n  }\n  get roundPixels() {\n    return this._roundPixels;\n  }\n  get width() {\n    return Math.abs(this.scale.x) * this._texture.orig.width;\n  }\n  set width(value) {\n    const s = utils_lib.sign(this.scale.x) || 1;\n    this.scale.x = s * value / this._texture.orig.width;\n    this._width = value;\n  }\n  get height() {\n    return Math.abs(this.scale.y) * this._texture.orig.height;\n  }\n  set height(value) {\n    const s = utils_lib.sign(this.scale.y) || 1;\n    this.scale.y = s * value / this._texture.orig.height;\n    this._height = value;\n  }\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    this._anchor.copyFrom(value);\n  }\n  get tint() {\n    return this._tintColor.value;\n  }\n  set tint(value) {\n    this._tintColor.setValue(value);\n    this._tintRGB = this._tintColor.toLittleEndianNumber();\n  }\n  get tintValue() {\n    return this._tintColor.toNumber();\n  }\n  get texture() {\n    return this._texture;\n  }\n  set texture(value) {\n    if (this._texture === value) {\n      return;\n    }\n    if (this._texture) {\n      this._texture.off("update", this._onTextureUpdate, this);\n    }\n    this._texture = value || Texture_Texture.EMPTY;\n    this._cachedTint = 16777215;\n    this._textureID = -1;\n    this._textureTrimmedID = -1;\n    if (value) {\n      if (value.baseTexture.valid) {\n        this._onTextureUpdate();\n      } else {\n        value.once("update", this._onTextureUpdate, this);\n      }\n    }\n  }\n}\n\n\n//# sourceMappingURL=Sprite.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite/lib/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mixin-cache-as-bitmap/lib/index.mjs\n\n\n\n\nconst _tempMatrix = new Matrix();\nDisplayObject.prototype._cacheAsBitmap = false;\nDisplayObject.prototype._cacheData = null;\nDisplayObject.prototype._cacheAsBitmapResolution = null;\nDisplayObject.prototype._cacheAsBitmapMultisample = null;\nclass CacheData {\n  constructor() {\n    this.textureCacheId = null;\n    this.originalRender = null;\n    this.originalRenderCanvas = null;\n    this.originalCalculateBounds = null;\n    this.originalGetLocalBounds = null;\n    this.originalUpdateTransform = null;\n    this.originalDestroy = null;\n    this.originalMask = null;\n    this.originalFilterArea = null;\n    this.originalContainsPoint = null;\n    this.sprite = null;\n  }\n}\nObject.defineProperties(DisplayObject.prototype, {\n  cacheAsBitmapResolution: {\n    get() {\n      return this._cacheAsBitmapResolution;\n    },\n    set(resolution) {\n      if (resolution === this._cacheAsBitmapResolution) {\n        return;\n      }\n      this._cacheAsBitmapResolution = resolution;\n      if (this.cacheAsBitmap) {\n        this.cacheAsBitmap = false;\n        this.cacheAsBitmap = true;\n      }\n    }\n  },\n  cacheAsBitmapMultisample: {\n    get() {\n      return this._cacheAsBitmapMultisample;\n    },\n    set(multisample) {\n      if (multisample === this._cacheAsBitmapMultisample) {\n        return;\n      }\n      this._cacheAsBitmapMultisample = multisample;\n      if (this.cacheAsBitmap) {\n        this.cacheAsBitmap = false;\n        this.cacheAsBitmap = true;\n      }\n    }\n  },\n  cacheAsBitmap: {\n    get() {\n      return this._cacheAsBitmap;\n    },\n    set(value) {\n      if (this._cacheAsBitmap === value) {\n        return;\n      }\n      this._cacheAsBitmap = value;\n      let data;\n      if (value) {\n        if (!this._cacheData) {\n          this._cacheData = new CacheData();\n        }\n        data = this._cacheData;\n        data.originalRender = this.render;\n        data.originalRenderCanvas = this.renderCanvas;\n        data.originalUpdateTransform = this.updateTransform;\n        data.originalCalculateBounds = this.calculateBounds;\n        data.originalGetLocalBounds = this.getLocalBounds;\n        data.originalDestroy = this.destroy;\n        data.originalContainsPoint = this.containsPoint;\n        data.originalMask = this._mask;\n        data.originalFilterArea = this.filterArea;\n        this.render = this._renderCached;\n        this.renderCanvas = this._renderCachedCanvas;\n        this.destroy = this._cacheAsBitmapDestroy;\n      } else {\n        data = this._cacheData;\n        if (data.sprite) {\n          this._destroyCachedDisplayObject();\n        }\n        this.render = data.originalRender;\n        this.renderCanvas = data.originalRenderCanvas;\n        this.calculateBounds = data.originalCalculateBounds;\n        this.getLocalBounds = data.originalGetLocalBounds;\n        this.destroy = data.originalDestroy;\n        this.updateTransform = data.originalUpdateTransform;\n        this.containsPoint = data.originalContainsPoint;\n        this._mask = data.originalMask;\n        this.filterArea = data.originalFilterArea;\n      }\n    }\n  }\n});\nDisplayObject.prototype._renderCached = function _renderCached(renderer) {\n  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n    return;\n  }\n  this._initCachedDisplayObject(renderer);\n  this._cacheData.sprite.transform._worldID = this.transform._worldID;\n  this._cacheData.sprite.worldAlpha = this.worldAlpha;\n  this._cacheData.sprite._render(renderer);\n};\nDisplayObject.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer) {\n  if (this._cacheData?.sprite) {\n    return;\n  }\n  const cacheAlpha = this.alpha;\n  this.alpha = 1;\n  renderer.batch.flush();\n  const bounds = this.getLocalBounds(null, true).clone();\n  if (this.filters?.length) {\n    const padding = this.filters[0].padding;\n    bounds.pad(padding);\n  }\n  bounds.ceil(settings_lib/* settings */.Xd.RESOLUTION);\n  const cachedRenderTexture = renderer.renderTexture.current;\n  const cachedSourceFrame = renderer.renderTexture.sourceFrame.clone();\n  const cachedDestinationFrame = renderer.renderTexture.destinationFrame.clone();\n  const cachedProjectionTransform = renderer.projection.transform;\n  const renderTexture = RenderTexture.create({\n    width: bounds.width,\n    height: bounds.height,\n    resolution: this.cacheAsBitmapResolution || renderer.resolution,\n    multisample: this.cacheAsBitmapMultisample ?? renderer.multisample\n  });\n  const textureCacheId = `cacheAsBitmap_${utils_lib.uid()}`;\n  this._cacheData.textureCacheId = textureCacheId;\n  BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);\n  Texture_Texture.addToCache(renderTexture, textureCacheId);\n  const m = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);\n  this.render = this._cacheData.originalRender;\n  renderer.render(this, { renderTexture, clear: true, transform: m, skipUpdateTransform: false });\n  renderer.framebuffer.blit();\n  renderer.projection.transform = cachedProjectionTransform;\n  renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame);\n  this.render = this._renderCached;\n  this.updateTransform = this.displayObjectUpdateTransform;\n  this.calculateBounds = this._calculateCachedBounds;\n  this.getLocalBounds = this._getCachedLocalBounds;\n  this._mask = null;\n  this.filterArea = null;\n  this.alpha = cacheAlpha;\n  const cachedSprite = new Sprite_Sprite(renderTexture);\n  cachedSprite.transform.worldTransform = this.transform.worldTransform;\n  cachedSprite.anchor.x = -(bounds.x / bounds.width);\n  cachedSprite.anchor.y = -(bounds.y / bounds.height);\n  cachedSprite.alpha = cacheAlpha;\n  cachedSprite._bounds = this._bounds;\n  this._cacheData.sprite = cachedSprite;\n  this.transform._parentID = -1;\n  if (!this.parent) {\n    this.enableTempParent();\n    this.updateTransform();\n    this.disableTempParent(null);\n  } else {\n    this.updateTransform();\n  }\n  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);\n};\nDisplayObject.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer) {\n  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n    return;\n  }\n  this._initCachedDisplayObjectCanvas(renderer);\n  this._cacheData.sprite.worldAlpha = this.worldAlpha;\n  this._cacheData.sprite._renderCanvas(renderer);\n};\nDisplayObject.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer) {\n  if (this._cacheData?.sprite) {\n    return;\n  }\n  const bounds = this.getLocalBounds(null, true);\n  const cacheAlpha = this.alpha;\n  this.alpha = 1;\n  const cachedRenderTarget = renderer.canvasContext.activeContext;\n  const cachedProjectionTransform = renderer._projTransform;\n  bounds.ceil(settings_lib/* settings */.Xd.RESOLUTION);\n  const renderTexture = RenderTexture.create({ width: bounds.width, height: bounds.height });\n  const textureCacheId = `cacheAsBitmap_${utils_lib.uid()}`;\n  this._cacheData.textureCacheId = textureCacheId;\n  BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);\n  Texture_Texture.addToCache(renderTexture, textureCacheId);\n  const m = _tempMatrix;\n  this.transform.localTransform.copyTo(m);\n  m.invert();\n  m.tx -= bounds.x;\n  m.ty -= bounds.y;\n  this.renderCanvas = this._cacheData.originalRenderCanvas;\n  renderer.render(this, { renderTexture, clear: true, transform: m, skipUpdateTransform: false });\n  renderer.canvasContext.activeContext = cachedRenderTarget;\n  renderer._projTransform = cachedProjectionTransform;\n  this.renderCanvas = this._renderCachedCanvas;\n  this.updateTransform = this.displayObjectUpdateTransform;\n  this.calculateBounds = this._calculateCachedBounds;\n  this.getLocalBounds = this._getCachedLocalBounds;\n  this._mask = null;\n  this.filterArea = null;\n  this.alpha = cacheAlpha;\n  const cachedSprite = new Sprite_Sprite(renderTexture);\n  cachedSprite.transform.worldTransform = this.transform.worldTransform;\n  cachedSprite.anchor.x = -(bounds.x / bounds.width);\n  cachedSprite.anchor.y = -(bounds.y / bounds.height);\n  cachedSprite.alpha = cacheAlpha;\n  cachedSprite._bounds = this._bounds;\n  this._cacheData.sprite = cachedSprite;\n  this.transform._parentID = -1;\n  if (!this.parent) {\n    this.parent = renderer._tempDisplayObjectParent;\n    this.updateTransform();\n    this.parent = null;\n  } else {\n    this.updateTransform();\n  }\n  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);\n};\nDisplayObject.prototype._calculateCachedBounds = function _calculateCachedBounds() {\n  this._bounds.clear();\n  this._cacheData.sprite.transform._worldID = this.transform._worldID;\n  this._cacheData.sprite._calculateBounds();\n  this._bounds.updateID = this._boundsID;\n};\nDisplayObject.prototype._getCachedLocalBounds = function _getCachedLocalBounds() {\n  return this._cacheData.sprite.getLocalBounds(null);\n};\nDisplayObject.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject() {\n  this._cacheData.sprite._texture.destroy(true);\n  this._cacheData.sprite = null;\n  BaseTexture.removeFromCache(this._cacheData.textureCacheId);\n  Texture_Texture.removeFromCache(this._cacheData.textureCacheId);\n  this._cacheData.textureCacheId = null;\n};\nDisplayObject.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options) {\n  this.cacheAsBitmap = false;\n  this.destroy(options);\n};\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mixin-get-child-by-name/lib/index.mjs\n\n\nDisplayObject.prototype.name = null;\nContainer_Container.prototype.getChildByName = function getChildByName(name, deep) {\n  for (let i = 0, j = this.children.length; i < j; i++) {\n    if (this.children[i].name === name) {\n      return this.children[i];\n    }\n  }\n  if (deep) {\n    for (let i = 0, j = this.children.length; i < j; i++) {\n      const child = this.children[i];\n      if (!child.getChildByName) {\n        continue;\n      }\n      const target = child.getChildByName(name, true);\n      if (target) {\n        return target;\n      }\n    }\n  }\n  return null;\n};\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mixin-get-global-position/lib/index.mjs\n\n\n\nDisplayObject.prototype.getGlobalPosition = function getGlobalPosition(point = new Point(), skipUpdate = false) {\n  if (this.parent) {\n    this.parent.toGlobal(this.position, point, skipUpdate);\n  } else {\n    point.x = this.position.x;\n    point.y = this.position.y;\n  }\n  return point;\n};\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-alpha/lib/alpha.mjs\nvar alpha_fragment = "varying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform float uAlpha;\\n\\nvoid main(void)\\n{\\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\\n}\\n";\n\n\n//# sourceMappingURL=alpha.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-alpha/lib/AlphaFilter.mjs\n\n\n\nclass AlphaFilter extends Filter {\n  constructor(alpha = 1) {\n    super(fragments_defaultVertex, alpha_fragment, { uAlpha: 1 });\n    this.alpha = alpha;\n  }\n  get alpha() {\n    return this.uniforms.uAlpha;\n  }\n  set alpha(value) {\n    this.uniforms.uAlpha = value;\n  }\n}\n\n\n//# sourceMappingURL=AlphaFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-alpha/lib/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-blur/lib/generateBlurFragSource.mjs\nconst GAUSSIAN_VALUES = {\n  5: [0.153388, 0.221461, 0.250301],\n  7: [0.071303, 0.131514, 0.189879, 0.214607],\n  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],\n  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],\n  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],\n  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]\n};\nconst generateBlurFragSource_fragTemplate = [\n  "varying vec2 vBlurTexCoords[%size%];",\n  "uniform sampler2D uSampler;",\n  "void main(void)",\n  "{",\n  "    gl_FragColor = vec4(0.0);",\n  "    %blur%",\n  "}"\n].join("\\n");\nfunction generateBlurFragSource(kernelSize) {\n  const kernel = GAUSSIAN_VALUES[kernelSize];\n  const halfLength = kernel.length;\n  let fragSource = generateBlurFragSource_fragTemplate;\n  let blurLoop = "";\n  const template = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";\n  let value;\n  for (let i = 0; i < kernelSize; i++) {\n    let blur = template.replace("%index%", i.toString());\n    value = i;\n    if (i >= halfLength) {\n      value = kernelSize - i - 1;\n    }\n    blur = blur.replace("%value%", kernel[value].toString());\n    blurLoop += blur;\n    blurLoop += "\\n";\n  }\n  fragSource = fragSource.replace("%blur%", blurLoop);\n  fragSource = fragSource.replace("%size%", kernelSize.toString());\n  return fragSource;\n}\n\n\n//# sourceMappingURL=generateBlurFragSource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-blur/lib/generateBlurVertSource.mjs\nconst vertTemplate = `\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }`;\nfunction generateBlurVertSource(kernelSize, x) {\n  const halfLength = Math.ceil(kernelSize / 2);\n  let vertSource = vertTemplate;\n  let blurLoop = "";\n  let template;\n  if (x) {\n    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);";\n  } else {\n    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";\n  }\n  for (let i = 0; i < kernelSize; i++) {\n    let blur = template.replace("%index%", i.toString());\n    blur = blur.replace("%sampleIndex%", `${i - (halfLength - 1)}.0`);\n    blurLoop += blur;\n    blurLoop += "\\n";\n  }\n  vertSource = vertSource.replace("%blur%", blurLoop);\n  vertSource = vertSource.replace("%size%", kernelSize.toString());\n  return vertSource;\n}\n\n\n//# sourceMappingURL=generateBlurVertSource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-blur/lib/BlurFilterPass.mjs\n\n\n\n\nclass BlurFilterPass extends Filter {\n  constructor(horizontal, strength = 8, quality = 4, resolution = Filter.defaultResolution, kernelSize = 5) {\n    const vertSrc = generateBlurVertSource(kernelSize, horizontal);\n    const fragSrc = generateBlurFragSource(kernelSize);\n    super(vertSrc, fragSrc);\n    this.horizontal = horizontal;\n    this.resolution = resolution;\n    this._quality = 0;\n    this.quality = quality;\n    this.blur = strength;\n  }\n  apply(filterManager, input, output, clearMode) {\n    if (output) {\n      if (this.horizontal) {\n        this.uniforms.strength = 1 / output.width * (output.width / input.width);\n      } else {\n        this.uniforms.strength = 1 / output.height * (output.height / input.height);\n      }\n    } else {\n      if (this.horizontal) {\n        this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width);\n      } else {\n        this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height);\n      }\n    }\n    this.uniforms.strength *= this.strength;\n    this.uniforms.strength /= this.passes;\n    if (this.passes === 1) {\n      filterManager.applyFilter(this, input, output, clearMode);\n    } else {\n      const renderTarget = filterManager.getFilterTexture();\n      const renderer = filterManager.renderer;\n      let flip = input;\n      let flop = renderTarget;\n      this.state.blend = false;\n      filterManager.applyFilter(this, flip, flop, lib/* CLEAR_MODES */.yl.CLEAR);\n      for (let i = 1; i < this.passes - 1; i++) {\n        filterManager.bindAndClear(flip, lib/* CLEAR_MODES */.yl.BLIT);\n        this.uniforms.uSampler = flop;\n        const temp = flop;\n        flop = flip;\n        flip = temp;\n        renderer.shader.bind(this);\n        renderer.geometry.draw(5);\n      }\n      this.state.blend = true;\n      filterManager.applyFilter(this, flop, output, clearMode);\n      filterManager.returnFilterTexture(renderTarget);\n    }\n  }\n  get blur() {\n    return this.strength;\n  }\n  set blur(value) {\n    this.padding = 1 + Math.abs(value) * 2;\n    this.strength = value;\n  }\n  get quality() {\n    return this._quality;\n  }\n  set quality(value) {\n    this._quality = value;\n    this.passes = value;\n  }\n}\n\n\n//# sourceMappingURL=BlurFilterPass.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-blur/lib/BlurFilter.mjs\n\n\n\nclass BlurFilter extends Filter {\n  constructor(strength = 8, quality = 4, resolution = Filter.defaultResolution, kernelSize = 5) {\n    super();\n    this._repeatEdgePixels = false;\n    this.blurXFilter = new BlurFilterPass(true, strength, quality, resolution, kernelSize);\n    this.blurYFilter = new BlurFilterPass(false, strength, quality, resolution, kernelSize);\n    this.resolution = resolution;\n    this.quality = quality;\n    this.blur = strength;\n    this.repeatEdgePixels = false;\n  }\n  apply(filterManager, input, output, clearMode) {\n    const xStrength = Math.abs(this.blurXFilter.strength);\n    const yStrength = Math.abs(this.blurYFilter.strength);\n    if (xStrength && yStrength) {\n      const renderTarget = filterManager.getFilterTexture();\n      this.blurXFilter.apply(filterManager, input, renderTarget, lib/* CLEAR_MODES */.yl.CLEAR);\n      this.blurYFilter.apply(filterManager, renderTarget, output, clearMode);\n      filterManager.returnFilterTexture(renderTarget);\n    } else if (yStrength) {\n      this.blurYFilter.apply(filterManager, input, output, clearMode);\n    } else {\n      this.blurXFilter.apply(filterManager, input, output, clearMode);\n    }\n  }\n  updatePadding() {\n    if (this._repeatEdgePixels) {\n      this.padding = 0;\n    } else {\n      this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;\n    }\n  }\n  get blur() {\n    return this.blurXFilter.blur;\n  }\n  set blur(value) {\n    this.blurXFilter.blur = this.blurYFilter.blur = value;\n    this.updatePadding();\n  }\n  get quality() {\n    return this.blurXFilter.quality;\n  }\n  set quality(value) {\n    this.blurXFilter.quality = this.blurYFilter.quality = value;\n  }\n  get blurX() {\n    return this.blurXFilter.blur;\n  }\n  set blurX(value) {\n    this.blurXFilter.blur = value;\n    this.updatePadding();\n  }\n  get blurY() {\n    return this.blurYFilter.blur;\n  }\n  set blurY(value) {\n    this.blurYFilter.blur = value;\n    this.updatePadding();\n  }\n  get blendMode() {\n    return this.blurYFilter.blendMode;\n  }\n  set blendMode(value) {\n    this.blurYFilter.blendMode = value;\n  }\n  get repeatEdgePixels() {\n    return this._repeatEdgePixels;\n  }\n  set repeatEdgePixels(value) {\n    this._repeatEdgePixels = value;\n    this.updatePadding();\n  }\n}\n\n\n//# sourceMappingURL=BlurFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-blur/lib/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-color-matrix/lib/colorMatrix.mjs\nvar colorMatrix_fragment = "varying vec2 vTextureCoord;\\nuniform sampler2D uSampler;\\nuniform float m[20];\\nuniform float uAlpha;\\n\\nvoid main(void)\\n{\\n    vec4 c = texture2D(uSampler, vTextureCoord);\\n\\n    if (uAlpha == 0.0) {\\n        gl_FragColor = c;\\n        return;\\n    }\\n\\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\\n    if (c.a > 0.0) {\\n      c.rgb /= c.a;\\n    }\\n\\n    vec4 result;\\n\\n    result.r = (m[0] * c.r);\\n        result.r += (m[1] * c.g);\\n        result.r += (m[2] * c.b);\\n        result.r += (m[3] * c.a);\\n        result.r += m[4];\\n\\n    result.g = (m[5] * c.r);\\n        result.g += (m[6] * c.g);\\n        result.g += (m[7] * c.b);\\n        result.g += (m[8] * c.a);\\n        result.g += m[9];\\n\\n    result.b = (m[10] * c.r);\\n       result.b += (m[11] * c.g);\\n       result.b += (m[12] * c.b);\\n       result.b += (m[13] * c.a);\\n       result.b += m[14];\\n\\n    result.a = (m[15] * c.r);\\n       result.a += (m[16] * c.g);\\n       result.a += (m[17] * c.b);\\n       result.a += (m[18] * c.a);\\n       result.a += m[19];\\n\\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\\n\\n    // Premultiply alpha again.\\n    rgb *= result.a;\\n\\n    gl_FragColor = vec4(rgb, result.a);\\n}\\n";\n\n\n//# sourceMappingURL=colorMatrix.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-color-matrix/lib/ColorMatrixFilter.mjs\n\n\n\nclass ColorMatrixFilter extends Filter {\n  constructor() {\n    const uniforms = {\n      m: new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ]),\n      uAlpha: 1\n    };\n    super(defaultFilterVertex, colorMatrix_fragment, uniforms);\n    this.alpha = 1;\n  }\n  _loadMatrix(matrix, multiply = false) {\n    let newMatrix = matrix;\n    if (multiply) {\n      this._multiply(newMatrix, this.uniforms.m, matrix);\n      newMatrix = this._colorMatrix(newMatrix);\n    }\n    this.uniforms.m = newMatrix;\n  }\n  _multiply(out, a, b) {\n    out[0] = a[0] * b[0] + a[1] * b[5] + a[2] * b[10] + a[3] * b[15];\n    out[1] = a[0] * b[1] + a[1] * b[6] + a[2] * b[11] + a[3] * b[16];\n    out[2] = a[0] * b[2] + a[1] * b[7] + a[2] * b[12] + a[3] * b[17];\n    out[3] = a[0] * b[3] + a[1] * b[8] + a[2] * b[13] + a[3] * b[18];\n    out[4] = a[0] * b[4] + a[1] * b[9] + a[2] * b[14] + a[3] * b[19] + a[4];\n    out[5] = a[5] * b[0] + a[6] * b[5] + a[7] * b[10] + a[8] * b[15];\n    out[6] = a[5] * b[1] + a[6] * b[6] + a[7] * b[11] + a[8] * b[16];\n    out[7] = a[5] * b[2] + a[6] * b[7] + a[7] * b[12] + a[8] * b[17];\n    out[8] = a[5] * b[3] + a[6] * b[8] + a[7] * b[13] + a[8] * b[18];\n    out[9] = a[5] * b[4] + a[6] * b[9] + a[7] * b[14] + a[8] * b[19] + a[9];\n    out[10] = a[10] * b[0] + a[11] * b[5] + a[12] * b[10] + a[13] * b[15];\n    out[11] = a[10] * b[1] + a[11] * b[6] + a[12] * b[11] + a[13] * b[16];\n    out[12] = a[10] * b[2] + a[11] * b[7] + a[12] * b[12] + a[13] * b[17];\n    out[13] = a[10] * b[3] + a[11] * b[8] + a[12] * b[13] + a[13] * b[18];\n    out[14] = a[10] * b[4] + a[11] * b[9] + a[12] * b[14] + a[13] * b[19] + a[14];\n    out[15] = a[15] * b[0] + a[16] * b[5] + a[17] * b[10] + a[18] * b[15];\n    out[16] = a[15] * b[1] + a[16] * b[6] + a[17] * b[11] + a[18] * b[16];\n    out[17] = a[15] * b[2] + a[16] * b[7] + a[17] * b[12] + a[18] * b[17];\n    out[18] = a[15] * b[3] + a[16] * b[8] + a[17] * b[13] + a[18] * b[18];\n    out[19] = a[15] * b[4] + a[16] * b[9] + a[17] * b[14] + a[18] * b[19] + a[19];\n    return out;\n  }\n  _colorMatrix(matrix) {\n    const m = new Float32Array(matrix);\n    m[4] /= 255;\n    m[9] /= 255;\n    m[14] /= 255;\n    m[19] /= 255;\n    return m;\n  }\n  brightness(b, multiply) {\n    const matrix = [\n      b,\n      0,\n      0,\n      0,\n      0,\n      0,\n      b,\n      0,\n      0,\n      0,\n      0,\n      0,\n      b,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  tint(color, multiply) {\n    const [r, g, b] = color_lib/* Color */.I.shared.setValue(color).toArray();\n    const matrix = [\n      r,\n      0,\n      0,\n      0,\n      0,\n      0,\n      g,\n      0,\n      0,\n      0,\n      0,\n      0,\n      b,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  greyscale(scale, multiply) {\n    const matrix = [\n      scale,\n      scale,\n      scale,\n      0,\n      0,\n      scale,\n      scale,\n      scale,\n      0,\n      0,\n      scale,\n      scale,\n      scale,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  blackAndWhite(multiply) {\n    const matrix = [\n      0.3,\n      0.6,\n      0.1,\n      0,\n      0,\n      0.3,\n      0.6,\n      0.1,\n      0,\n      0,\n      0.3,\n      0.6,\n      0.1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  hue(rotation, multiply) {\n    rotation = (rotation || 0) / 180 * Math.PI;\n    const cosR = Math.cos(rotation);\n    const sinR = Math.sin(rotation);\n    const sqrt = Math.sqrt;\n    const w = 1 / 3;\n    const sqrW = sqrt(w);\n    const a00 = cosR + (1 - cosR) * w;\n    const a01 = w * (1 - cosR) - sqrW * sinR;\n    const a02 = w * (1 - cosR) + sqrW * sinR;\n    const a10 = w * (1 - cosR) + sqrW * sinR;\n    const a11 = cosR + w * (1 - cosR);\n    const a12 = w * (1 - cosR) - sqrW * sinR;\n    const a20 = w * (1 - cosR) - sqrW * sinR;\n    const a21 = w * (1 - cosR) + sqrW * sinR;\n    const a22 = cosR + w * (1 - cosR);\n    const matrix = [\n      a00,\n      a01,\n      a02,\n      0,\n      0,\n      a10,\n      a11,\n      a12,\n      0,\n      0,\n      a20,\n      a21,\n      a22,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  contrast(amount, multiply) {\n    const v = (amount || 0) + 1;\n    const o = -0.5 * (v - 1);\n    const matrix = [\n      v,\n      0,\n      0,\n      0,\n      o,\n      0,\n      v,\n      0,\n      0,\n      o,\n      0,\n      0,\n      v,\n      0,\n      o,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  saturate(amount = 0, multiply) {\n    const x = amount * 2 / 3 + 1;\n    const y = (x - 1) * -0.5;\n    const matrix = [\n      x,\n      y,\n      y,\n      0,\n      0,\n      y,\n      x,\n      y,\n      0,\n      0,\n      y,\n      y,\n      x,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  desaturate() {\n    this.saturate(-1);\n  }\n  negative(multiply) {\n    const matrix = [\n      -1,\n      0,\n      0,\n      1,\n      0,\n      0,\n      -1,\n      0,\n      1,\n      0,\n      0,\n      0,\n      -1,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  sepia(multiply) {\n    const matrix = [\n      0.393,\n      0.7689999,\n      0.18899999,\n      0,\n      0,\n      0.349,\n      0.6859999,\n      0.16799999,\n      0,\n      0,\n      0.272,\n      0.5339999,\n      0.13099999,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  technicolor(multiply) {\n    const matrix = [\n      1.9125277891456083,\n      -0.8545344976951645,\n      -0.09155508482755585,\n      0,\n      11.793603434377337,\n      -0.3087833385928097,\n      1.7658908555458428,\n      -0.10601743074722245,\n      0,\n      -70.35205161461398,\n      -0.231103377548616,\n      -0.7501899197440212,\n      1.847597816108189,\n      0,\n      30.950940869491138,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  polaroid(multiply) {\n    const matrix = [\n      1.438,\n      -0.062,\n      -0.062,\n      0,\n      0,\n      -0.122,\n      1.378,\n      -0.122,\n      0,\n      0,\n      -0.016,\n      -0.016,\n      1.483,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  toBGR(multiply) {\n    const matrix = [\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  kodachrome(multiply) {\n    const matrix = [\n      1.1285582396593525,\n      -0.3967382283601348,\n      -0.03992559172921793,\n      0,\n      63.72958762196502,\n      -0.16404339962244616,\n      1.0835251566291304,\n      -0.05498805115633132,\n      0,\n      24.732407896706203,\n      -0.16786010706155763,\n      -0.5603416277695248,\n      1.6014850761964943,\n      0,\n      35.62982807460946,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  browni(multiply) {\n    const matrix = [\n      0.5997023498159715,\n      0.34553243048391263,\n      -0.2708298674538042,\n      0,\n      47.43192855600873,\n      -0.037703249837783157,\n      0.8609577587992641,\n      0.15059552388459913,\n      0,\n      -36.96841498319127,\n      0.24113635128153335,\n      -0.07441037908422492,\n      0.44972182064877153,\n      0,\n      -7.562075277591283,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  vintage(multiply) {\n    const matrix = [\n      0.6279345635605994,\n      0.3202183420819367,\n      -0.03965408211312453,\n      0,\n      9.651285835294123,\n      0.02578397704808868,\n      0.6441188644374771,\n      0.03259127616149294,\n      0,\n      7.462829176470591,\n      0.0466055556782719,\n      -0.0851232987247891,\n      0.5241648018700465,\n      0,\n      5.159190588235296,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  colorTone(desaturation, toned, lightColor, darkColor, multiply) {\n    desaturation = desaturation || 0.2;\n    toned = toned || 0.15;\n    lightColor = lightColor || 16770432;\n    darkColor = darkColor || 3375104;\n    const temp = color_lib/* Color */.I.shared;\n    const [lR, lG, lB] = temp.setValue(lightColor).toArray();\n    const [dR, dG, dB] = temp.setValue(darkColor).toArray();\n    const matrix = [\n      0.3,\n      0.59,\n      0.11,\n      0,\n      0,\n      lR,\n      lG,\n      lB,\n      desaturation,\n      0,\n      dR,\n      dG,\n      dB,\n      toned,\n      0,\n      lR - dR,\n      lG - dG,\n      lB - dB,\n      0,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  night(intensity, multiply) {\n    intensity = intensity || 0.1;\n    const matrix = [\n      intensity * -2,\n      -intensity,\n      0,\n      0,\n      0,\n      -intensity,\n      0,\n      intensity,\n      0,\n      0,\n      0,\n      intensity,\n      intensity * 2,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  predator(amount, multiply) {\n    const matrix = [\n      11.224130630493164 * amount,\n      -4.794486999511719 * amount,\n      -2.8746118545532227 * amount,\n      0 * amount,\n      0.40342438220977783 * amount,\n      -3.6330697536468506 * amount,\n      9.193157196044922 * amount,\n      -2.951810836791992 * amount,\n      0 * amount,\n      -1.316135048866272 * amount,\n      -3.2184197902679443 * amount,\n      -4.2375030517578125 * amount,\n      7.476448059082031 * amount,\n      0 * amount,\n      0.8044459223747253 * amount,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  lsd(multiply) {\n    const matrix = [\n      2,\n      -0.4,\n      0.5,\n      0,\n      0,\n      -0.5,\n      2,\n      -0.4,\n      0,\n      0,\n      -0.4,\n      -0.5,\n      3,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, multiply);\n  }\n  reset() {\n    const matrix = [\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0\n    ];\n    this._loadMatrix(matrix, false);\n  }\n  get matrix() {\n    return this.uniforms.m;\n  }\n  set matrix(value) {\n    this.uniforms.m = value;\n  }\n  get alpha() {\n    return this.uniforms.uAlpha;\n  }\n  set alpha(value) {\n    this.uniforms.uAlpha = value;\n  }\n}\nColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;\n\n\n//# sourceMappingURL=ColorMatrixFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-color-matrix/lib/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-displacement/lib/displacement.mjs\nvar displacement_fragment = "varying vec2 vFilterCoord;\\nvarying vec2 vTextureCoord;\\n\\nuniform vec2 scale;\\nuniform mat2 rotation;\\nuniform sampler2D uSampler;\\nuniform sampler2D mapSampler;\\n\\nuniform highp vec4 inputSize;\\nuniform vec4 inputClamp;\\n\\nvoid main(void)\\n{\\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\\n\\n  map -= 0.5;\\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\\n\\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\\n}\\n";\n\n\n//# sourceMappingURL=displacement.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-displacement/lib/displacement2.mjs\nvar displacement2_vertex = "attribute vec2 aVertexPosition;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 filterMatrix;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec2 vFilterCoord;\\n\\nuniform vec4 inputSize;\\nuniform vec4 outputFrame;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\\n\\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n\\tgl_Position = filterVertexPosition();\\n\\tvTextureCoord = filterTextureCoord();\\n\\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\\n}\\n";\n\n\n//# sourceMappingURL=displacement2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-displacement/lib/DisplacementFilter.mjs\n\n\n\n\nclass DisplacementFilter extends Filter {\n  constructor(sprite, scale) {\n    const maskMatrix = new Matrix();\n    sprite.renderable = false;\n    super(displacement2_vertex, displacement_fragment, {\n      mapSampler: sprite._texture,\n      filterMatrix: maskMatrix,\n      scale: { x: 1, y: 1 },\n      rotation: new Float32Array([1, 0, 0, 1])\n    });\n    this.maskSprite = sprite;\n    this.maskMatrix = maskMatrix;\n    if (scale === null || scale === void 0) {\n      scale = 20;\n    }\n    this.scale = new Point(scale, scale);\n  }\n  apply(filterManager, input, output, clearMode) {\n    this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);\n    this.uniforms.scale.x = this.scale.x;\n    this.uniforms.scale.y = this.scale.y;\n    const wt = this.maskSprite.worldTransform;\n    const lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);\n    const lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);\n    if (lenX !== 0 && lenY !== 0) {\n      this.uniforms.rotation[0] = wt.a / lenX;\n      this.uniforms.rotation[1] = wt.b / lenX;\n      this.uniforms.rotation[2] = wt.c / lenY;\n      this.uniforms.rotation[3] = wt.d / lenY;\n    }\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  get map() {\n    return this.uniforms.mapSampler;\n  }\n  set map(value) {\n    this.uniforms.mapSampler = value;\n  }\n}\n\n\n//# sourceMappingURL=DisplacementFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-displacement/lib/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-fxaa/lib/fxaa.mjs\nvar fxaa_fragment = "varying vec2 v_rgbNW;\\nvarying vec2 v_rgbNE;\\nvarying vec2 v_rgbSW;\\nvarying vec2 v_rgbSE;\\nvarying vec2 v_rgbM;\\n\\nvarying vec2 vFragCoord;\\nuniform sampler2D uSampler;\\nuniform highp vec4 inputSize;\\n\\n\\n/**\\n Basic FXAA implementation based on the code on geeks3d.com with the\\n modification that the texture2DLod stuff was removed since it\'s\\n unsupported by WebGL.\\n\\n --\\n\\n From:\\n https://github.com/mitsuhiko/webgl-meincraft\\n\\n Copyright (c) 2011 by Armin Ronacher.\\n\\n Some rights reserved.\\n\\n Redistribution and use in source and binary forms, with or without\\n modification, are permitted provided that the following conditions are\\n met:\\n\\n * Redistributions of source code must retain the above copyright\\n notice, this list of conditions and the following disclaimer.\\n\\n * Redistributions in binary form must reproduce the above\\n copyright notice, this list of conditions and the following\\n disclaimer in the documentation and/or other materials provided\\n with the distribution.\\n\\n * The names of the contributors may not be used to endorse or\\n promote products derived from this software without specific\\n prior written permission.\\n\\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\\n \\"AS IS\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n */\\n\\n#ifndef FXAA_REDUCE_MIN\\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\\n#endif\\n#ifndef FXAA_REDUCE_MUL\\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\\n#endif\\n#ifndef FXAA_SPAN_MAX\\n#define FXAA_SPAN_MAX     8.0\\n#endif\\n\\n//optimized version for mobile, where dependent\\n//texture reads can be a bottleneck\\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\\n          vec2 v_rgbNW, vec2 v_rgbNE,\\n          vec2 v_rgbSW, vec2 v_rgbSE,\\n          vec2 v_rgbM) {\\n    vec4 color;\\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\\n    vec4 texColor = texture2D(tex, v_rgbM);\\n    vec3 rgbM  = texColor.xyz;\\n    vec3 luma = vec3(0.299, 0.587, 0.114);\\n    float lumaNW = dot(rgbNW, luma);\\n    float lumaNE = dot(rgbNE, luma);\\n    float lumaSW = dot(rgbSW, luma);\\n    float lumaSE = dot(rgbSE, luma);\\n    float lumaM  = dot(rgbM,  luma);\\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\\n\\n    mediump vec2 dir;\\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\\n\\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\\n\\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\\n                  dir * rcpDirMin)) * inverseVP;\\n\\n    vec3 rgbA = 0.5 * (\\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\\n\\n    float lumaB = dot(rgbB, luma);\\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\\n        color = vec4(rgbA, texColor.a);\\n    else\\n        color = vec4(rgbB, texColor.a);\\n    return color;\\n}\\n\\nvoid main() {\\n\\n      vec4 color;\\n\\n      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\\n\\n      gl_FragColor = color;\\n}\\n";\n\n\n//# sourceMappingURL=fxaa.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-fxaa/lib/fxaa2.mjs\nvar fxaa2_vertex = "\\nattribute vec2 aVertexPosition;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 v_rgbNW;\\nvarying vec2 v_rgbNE;\\nvarying vec2 v_rgbSW;\\nvarying vec2 v_rgbSE;\\nvarying vec2 v_rgbM;\\n\\nvarying vec2 vFragCoord;\\n\\nuniform vec4 inputSize;\\nuniform vec4 outputFrame;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\\n\\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\\n}\\n\\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\\n               out vec2 v_rgbM) {\\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\\n    v_rgbM = vec2(fragCoord * inverseVP);\\n}\\n\\nvoid main(void) {\\n\\n   gl_Position = filterVertexPosition();\\n\\n   vFragCoord = aVertexPosition * outputFrame.zw;\\n\\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\\n}\\n";\n\n\n//# sourceMappingURL=fxaa2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-fxaa/lib/FXAAFilter.mjs\n\n\n\n\nclass FXAAFilter extends Filter {\n  constructor() {\n    super(fxaa2_vertex, fxaa_fragment);\n  }\n}\n\n\n//# sourceMappingURL=FXAAFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-fxaa/lib/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-noise/lib/noise.mjs\nvar noise_fragment = "precision highp float;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\n\\nuniform float uNoise;\\nuniform float uSeed;\\nuniform sampler2D uSampler;\\n\\nfloat rand(vec2 co)\\n{\\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\\n}\\n\\nvoid main()\\n{\\n    vec4 color = texture2D(uSampler, vTextureCoord);\\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\\n    float diff = (randomValue - 0.5) * uNoise;\\n\\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\\n    if (color.a > 0.0) {\\n        color.rgb /= color.a;\\n    }\\n\\n    color.r += diff;\\n    color.g += diff;\\n    color.b += diff;\\n\\n    // Premultiply alpha again.\\n    color.rgb *= color.a;\\n\\n    gl_FragColor = color;\\n}\\n";\n\n\n//# sourceMappingURL=noise.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-noise/lib/NoiseFilter.mjs\n\n\n\nclass NoiseFilter extends Filter {\n  constructor(noise = 0.5, seed = Math.random()) {\n    super(defaultFilterVertex, noise_fragment, {\n      uNoise: 0,\n      uSeed: 0\n    });\n    this.noise = noise;\n    this.seed = seed;\n  }\n  get noise() {\n    return this.uniforms.uNoise;\n  }\n  set noise(value) {\n    this.uniforms.uNoise = value;\n  }\n  get seed() {\n    return this.uniforms.uSeed;\n  }\n  set seed(value) {\n    this.uniforms.uSeed = value;\n  }\n}\n\n\n//# sourceMappingURL=NoiseFilter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/filter-noise/lib/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/filters.mjs\n\n\n\n\n\n\n\n\nconst filters = {\n  AlphaFilter: AlphaFilter,\n  BlurFilter: BlurFilter,\n  BlurFilterPass: BlurFilterPass,\n  ColorMatrixFilter: ColorMatrixFilter,\n  DisplacementFilter: DisplacementFilter,\n  FXAAFilter: FXAAFilter,\n  NoiseFilter: NoiseFilter\n};\nObject.entries(filters).forEach(([key, FilterClass]) => {\n  Object.defineProperty(filters, key, {\n    get() {\n      utils_lib.deprecation("7.1.0", `filters.${key} has moved to ${key}`);\n      return FilterClass;\n    }\n  });\n});\n\n\n//# sourceMappingURL=filters.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/EventTicker.mjs\n\n\nclass EventsTickerClass {\n  constructor() {\n    this.interactionFrequency = 10;\n    this._deltaTime = 0;\n    this._didMove = false;\n    this.tickerAdded = false;\n    this._pauseUpdate = true;\n  }\n  init(events) {\n    this.removeTickerListener();\n    this.events = events;\n    this.interactionFrequency = 10;\n    this._deltaTime = 0;\n    this._didMove = false;\n    this.tickerAdded = false;\n    this._pauseUpdate = true;\n  }\n  get pauseUpdate() {\n    return this._pauseUpdate;\n  }\n  set pauseUpdate(paused) {\n    this._pauseUpdate = paused;\n  }\n  addTickerListener() {\n    if (this.tickerAdded || !this.domElement) {\n      return;\n    }\n    Ticker_Ticker.system.add(this.tickerUpdate, this, const_UPDATE_PRIORITY.INTERACTION);\n    this.tickerAdded = true;\n  }\n  removeTickerListener() {\n    if (!this.tickerAdded) {\n      return;\n    }\n    Ticker_Ticker.system.remove(this.tickerUpdate, this);\n    this.tickerAdded = false;\n  }\n  pointerMoved() {\n    this._didMove = true;\n  }\n  update() {\n    if (!this.domElement || this._pauseUpdate) {\n      return;\n    }\n    if (this._didMove) {\n      this._didMove = false;\n      return;\n    }\n    const rootPointerEvent = this.events["rootPointerEvent"];\n    if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {\n      return;\n    }\n    globalThis.document.dispatchEvent(new PointerEvent("pointermove", {\n      clientX: rootPointerEvent.clientX,\n      clientY: rootPointerEvent.clientY\n    }));\n  }\n  tickerUpdate(deltaTime) {\n    this._deltaTime += deltaTime;\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n    this._deltaTime = 0;\n    this.update();\n  }\n}\nconst EventsTicker = new EventsTickerClass();\n\n\n//# sourceMappingURL=EventTicker.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/FederatedEvent.mjs\n\n\nclass FederatedEvent {\n  constructor(manager) {\n    this.bubbles = true;\n    this.cancelBubble = true;\n    this.cancelable = false;\n    this.composed = false;\n    this.defaultPrevented = false;\n    this.eventPhase = FederatedEvent.prototype.NONE;\n    this.propagationStopped = false;\n    this.propagationImmediatelyStopped = false;\n    this.layer = new Point();\n    this.page = new Point();\n    this.NONE = 0;\n    this.CAPTURING_PHASE = 1;\n    this.AT_TARGET = 2;\n    this.BUBBLING_PHASE = 3;\n    this.manager = manager;\n  }\n  get layerX() {\n    return this.layer.x;\n  }\n  get layerY() {\n    return this.layer.y;\n  }\n  get pageX() {\n    return this.page.x;\n  }\n  get pageY() {\n    return this.page.y;\n  }\n  get data() {\n    return this;\n  }\n  composedPath() {\n    if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {\n      this.path = this.target ? this.manager.propagationPath(this.target) : [];\n    }\n    return this.path;\n  }\n  initEvent(_type, _bubbles, _cancelable) {\n    throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");\n  }\n  initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {\n    throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");\n  }\n  preventDefault() {\n    if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {\n      this.nativeEvent.preventDefault();\n    }\n    this.defaultPrevented = true;\n  }\n  stopImmediatePropagation() {\n    this.propagationImmediatelyStopped = true;\n  }\n  stopPropagation() {\n    this.propagationStopped = true;\n  }\n}\n\n\n//# sourceMappingURL=FederatedEvent.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/FederatedMouseEvent.mjs\n\n\n\nclass FederatedMouseEvent extends FederatedEvent {\n  constructor() {\n    super(...arguments);\n    this.client = new Point();\n    this.movement = new Point();\n    this.offset = new Point();\n    this.global = new Point();\n    this.screen = new Point();\n  }\n  get clientX() {\n    return this.client.x;\n  }\n  get clientY() {\n    return this.client.y;\n  }\n  get x() {\n    return this.clientX;\n  }\n  get y() {\n    return this.clientY;\n  }\n  get movementX() {\n    return this.movement.x;\n  }\n  get movementY() {\n    return this.movement.y;\n  }\n  get offsetX() {\n    return this.offset.x;\n  }\n  get offsetY() {\n    return this.offset.y;\n  }\n  get globalX() {\n    return this.global.x;\n  }\n  get globalY() {\n    return this.global.y;\n  }\n  get screenX() {\n    return this.screen.x;\n  }\n  get screenY() {\n    return this.screen.y;\n  }\n  getLocalPosition(displayObject, point, globalPos) {\n    return displayObject.worldTransform.applyInverse(globalPos || this.global, point);\n  }\n  getModifierState(key) {\n    return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);\n  }\n  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {\n    throw new Error("Method not implemented.");\n  }\n}\n\n\n//# sourceMappingURL=FederatedMouseEvent.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/FederatedPointerEvent.mjs\n\n\nclass FederatedPointerEvent extends FederatedMouseEvent {\n  constructor() {\n    super(...arguments);\n    this.width = 0;\n    this.height = 0;\n    this.isPrimary = false;\n  }\n  getCoalescedEvents() {\n    if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {\n      return [this];\n    }\n    return [];\n  }\n  getPredictedEvents() {\n    throw new Error("getPredictedEvents is not supported!");\n  }\n}\n\n\n//# sourceMappingURL=FederatedPointerEvent.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/FederatedWheelEvent.mjs\n\n\nclass FederatedWheelEvent extends FederatedMouseEvent {\n  constructor() {\n    super(...arguments);\n    this.DOM_DELTA_PIXEL = 0;\n    this.DOM_DELTA_LINE = 1;\n    this.DOM_DELTA_PAGE = 2;\n  }\n}\nFederatedWheelEvent.DOM_DELTA_PIXEL = 0;\nFederatedWheelEvent.DOM_DELTA_LINE = 1;\nFederatedWheelEvent.DOM_DELTA_PAGE = 2;\n\n\n//# sourceMappingURL=FederatedWheelEvent.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/EventBoundary.mjs\n\n\n\n\n\n\nconst PROPAGATION_LIMIT = 2048;\nconst tempHitLocation = new Point();\nconst tempLocalMapping = new Point();\nclass EventBoundary {\n  constructor(rootTarget) {\n    this.dispatch = new utils_lib.EventEmitter();\n    this.moveOnAll = false;\n    this.enableGlobalMoveEvents = true;\n    this.mappingState = {\n      trackingData: {}\n    };\n    this.eventPool = /* @__PURE__ */ new Map();\n    this._allInteractiveElements = [];\n    this._hitElements = [];\n    this._isPointerMoveEvent = false;\n    this.rootTarget = rootTarget;\n    this.hitPruneFn = this.hitPruneFn.bind(this);\n    this.hitTestFn = this.hitTestFn.bind(this);\n    this.mapPointerDown = this.mapPointerDown.bind(this);\n    this.mapPointerMove = this.mapPointerMove.bind(this);\n    this.mapPointerOut = this.mapPointerOut.bind(this);\n    this.mapPointerOver = this.mapPointerOver.bind(this);\n    this.mapPointerUp = this.mapPointerUp.bind(this);\n    this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);\n    this.mapWheel = this.mapWheel.bind(this);\n    this.mappingTable = {};\n    this.addEventMapping("pointerdown", this.mapPointerDown);\n    this.addEventMapping("pointermove", this.mapPointerMove);\n    this.addEventMapping("pointerout", this.mapPointerOut);\n    this.addEventMapping("pointerleave", this.mapPointerOut);\n    this.addEventMapping("pointerover", this.mapPointerOver);\n    this.addEventMapping("pointerup", this.mapPointerUp);\n    this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);\n    this.addEventMapping("wheel", this.mapWheel);\n  }\n  addEventMapping(type, fn) {\n    if (!this.mappingTable[type]) {\n      this.mappingTable[type] = [];\n    }\n    this.mappingTable[type].push({\n      fn,\n      priority: 0\n    });\n    this.mappingTable[type].sort((a, b) => a.priority - b.priority);\n  }\n  dispatchEvent(e, type) {\n    e.propagationStopped = false;\n    e.propagationImmediatelyStopped = false;\n    this.propagate(e, type);\n    this.dispatch.emit(type || e.type, e);\n  }\n  mapEvent(e) {\n    if (!this.rootTarget) {\n      return;\n    }\n    const mappers = this.mappingTable[e.type];\n    if (mappers) {\n      for (let i = 0, j = mappers.length; i < j; i++) {\n        mappers[i].fn(e);\n      }\n    } else {\n      console.warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);\n    }\n  }\n  hitTest(x, y) {\n    EventsTicker.pauseUpdate = true;\n    const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;\n    const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";\n    const invertedPath = this[fn](this.rootTarget, this.rootTarget.eventMode, tempHitLocation.set(x, y), this.hitTestFn, this.hitPruneFn);\n    return invertedPath && invertedPath[0];\n  }\n  propagate(e, type) {\n    if (!e.target) {\n      return;\n    }\n    const composedPath = e.composedPath();\n    e.eventPhase = e.CAPTURING_PHASE;\n    for (let i = 0, j = composedPath.length - 1; i < j; i++) {\n      e.currentTarget = composedPath[i];\n      this.notifyTarget(e, type);\n      if (e.propagationStopped || e.propagationImmediatelyStopped)\n        return;\n    }\n    e.eventPhase = e.AT_TARGET;\n    e.currentTarget = e.target;\n    this.notifyTarget(e, type);\n    if (e.propagationStopped || e.propagationImmediatelyStopped)\n      return;\n    e.eventPhase = e.BUBBLING_PHASE;\n    for (let i = composedPath.length - 2; i >= 0; i--) {\n      e.currentTarget = composedPath[i];\n      this.notifyTarget(e, type);\n      if (e.propagationStopped || e.propagationImmediatelyStopped)\n        return;\n    }\n  }\n  all(e, type, targets = this._allInteractiveElements) {\n    if (targets.length === 0)\n      return;\n    e.eventPhase = e.BUBBLING_PHASE;\n    const events = Array.isArray(type) ? type : [type];\n    for (let i = targets.length - 1; i >= 0; i--) {\n      events.forEach((event) => {\n        e.currentTarget = targets[i];\n        this.notifyTarget(e, event);\n      });\n    }\n  }\n  propagationPath(target) {\n    const propagationPath = [target];\n    for (let i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {\n      if (!target.parent) {\n        throw new Error("Cannot find propagation path to disconnected target");\n      }\n      propagationPath.push(target.parent);\n      target = target.parent;\n    }\n    propagationPath.reverse();\n    return propagationPath;\n  }\n  hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {\n    let shouldReturn = false;\n    if (this._interactivePrune(currentTarget))\n      return null;\n    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {\n      EventsTicker.pauseUpdate = false;\n    }\n    if (currentTarget.interactiveChildren && currentTarget.children) {\n      const children = currentTarget.children;\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const nestedHit = this.hitTestMoveRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location, testFn, pruneFn, ignore || pruneFn(currentTarget, location));\n        if (nestedHit) {\n          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {\n            continue;\n          }\n          const isInteractive = currentTarget.isInteractive();\n          if (nestedHit.length > 0 || isInteractive) {\n            if (isInteractive)\n              this._allInteractiveElements.push(currentTarget);\n            nestedHit.push(currentTarget);\n          }\n          if (this._hitElements.length === 0)\n            this._hitElements = nestedHit;\n          shouldReturn = true;\n        }\n      }\n    }\n    const isInteractiveMode = this._isInteractive(eventMode);\n    const isInteractiveTarget = currentTarget.isInteractive();\n    if (isInteractiveTarget && isInteractiveTarget)\n      this._allInteractiveElements.push(currentTarget);\n    if (ignore || this._hitElements.length > 0)\n      return null;\n    if (shouldReturn)\n      return this._hitElements;\n    if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {\n      return isInteractiveTarget ? [currentTarget] : [];\n    }\n    return null;\n  }\n  hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {\n    if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {\n      return null;\n    }\n    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {\n      EventsTicker.pauseUpdate = false;\n    }\n    if (currentTarget.interactiveChildren && currentTarget.children) {\n      const children = currentTarget.children;\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const nestedHit = this.hitTestRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location, testFn, pruneFn);\n        if (nestedHit) {\n          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {\n            continue;\n          }\n          const isInteractive = currentTarget.isInteractive();\n          if (nestedHit.length > 0 || isInteractive)\n            nestedHit.push(currentTarget);\n          return nestedHit;\n        }\n      }\n    }\n    const isInteractiveMode = this._isInteractive(eventMode);\n    const isInteractiveTarget = currentTarget.isInteractive();\n    if (isInteractiveMode && testFn(currentTarget, location)) {\n      return isInteractiveTarget ? [currentTarget] : [];\n    }\n    return null;\n  }\n  _isInteractive(int) {\n    return int === "static" || int === "dynamic";\n  }\n  _interactivePrune(displayObject) {\n    if (!displayObject || displayObject.isMask || !displayObject.visible || !displayObject.renderable) {\n      return true;\n    }\n    if (displayObject.eventMode === "none") {\n      return true;\n    }\n    if (displayObject.eventMode === "passive" && !displayObject.interactiveChildren) {\n      return true;\n    }\n    if (displayObject.isMask) {\n      return true;\n    }\n    return false;\n  }\n  hitPruneFn(displayObject, location) {\n    if (displayObject.hitArea) {\n      displayObject.worldTransform.applyInverse(location, tempLocalMapping);\n      if (!displayObject.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {\n        return true;\n      }\n    }\n    if (displayObject._mask) {\n      const maskObject = displayObject._mask.isMaskData ? displayObject._mask.maskObject : displayObject._mask;\n      if (maskObject && !maskObject.containsPoint?.(location)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  hitTestFn(displayObject, location) {\n    if (displayObject.eventMode === "passive") {\n      return false;\n    }\n    if (displayObject.hitArea) {\n      return true;\n    }\n    if (displayObject.containsPoint) {\n      return displayObject.containsPoint(location);\n    }\n    return false;\n  }\n  notifyTarget(e, type) {\n    type = type ?? e.type;\n    const handlerKey = `on${type}`;\n    e.currentTarget[handlerKey]?.(e);\n    const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;\n    this.notifyListeners(e, key);\n    if (e.eventPhase === e.AT_TARGET) {\n      this.notifyListeners(e, type);\n    }\n  }\n  mapPointerDown(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const e = this.createPointerEvent(from);\n    this.dispatchEvent(e, "pointerdown");\n    if (e.pointerType === "touch") {\n      this.dispatchEvent(e, "touchstart");\n    } else if (e.pointerType === "mouse" || e.pointerType === "pen") {\n      const isRightButton = e.button === 2;\n      this.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    trackingData.pressTargetsByButton[from.button] = e.composedPath();\n    this.freeEvent(e);\n  }\n  mapPointerMove(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    this._allInteractiveElements.length = 0;\n    this._hitElements.length = 0;\n    this._isPointerMoveEvent = true;\n    const e = this.createPointerEvent(from);\n    this._isPointerMoveEvent = false;\n    const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";\n    const trackingData = this.trackingData(from.pointerId);\n    const outTarget = this.findMountedTarget(trackingData.overTargets);\n    if (trackingData.overTargets?.length > 0 && outTarget !== e.target) {\n      const outType = from.type === "mousemove" ? "mouseout" : "pointerout";\n      const outEvent = this.createPointerEvent(from, outType, outTarget);\n      this.dispatchEvent(outEvent, "pointerout");\n      if (isMouse)\n        this.dispatchEvent(outEvent, "mouseout");\n      if (!e.composedPath().includes(outTarget)) {\n        const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);\n        leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n        while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {\n          leaveEvent.currentTarget = leaveEvent.target;\n          this.notifyTarget(leaveEvent);\n          if (isMouse)\n            this.notifyTarget(leaveEvent, "mouseleave");\n          leaveEvent.target = leaveEvent.target.parent;\n        }\n        this.freeEvent(leaveEvent);\n      }\n      this.freeEvent(outEvent);\n    }\n    if (outTarget !== e.target) {\n      const overType = from.type === "mousemove" ? "mouseover" : "pointerover";\n      const overEvent = this.clonePointerEvent(e, overType);\n      this.dispatchEvent(overEvent, "pointerover");\n      if (isMouse)\n        this.dispatchEvent(overEvent, "mouseover");\n      let overTargetAncestor = outTarget?.parent;\n      while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {\n        if (overTargetAncestor === e.target)\n          break;\n        overTargetAncestor = overTargetAncestor.parent;\n      }\n      const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;\n      if (didPointerEnter) {\n        const enterEvent = this.clonePointerEvent(e, "pointerenter");\n        enterEvent.eventPhase = enterEvent.AT_TARGET;\n        while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {\n          enterEvent.currentTarget = enterEvent.target;\n          this.notifyTarget(enterEvent);\n          if (isMouse)\n            this.notifyTarget(enterEvent, "mouseenter");\n          enterEvent.target = enterEvent.target.parent;\n        }\n        this.freeEvent(enterEvent);\n      }\n      this.freeEvent(overEvent);\n    }\n    const allMethods = [];\n    const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;\n    this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e, "pointermove");\n    allowGlobalPointerEvents && allMethods.push("globalpointermove");\n    if (e.pointerType === "touch") {\n      this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove");\n      allowGlobalPointerEvents && allMethods.push("globaltouchmove");\n    }\n    if (isMouse) {\n      this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove");\n      allowGlobalPointerEvents && allMethods.push("globalmousemove");\n      this.cursor = e.target?.cursor;\n    }\n    if (allMethods.length > 0) {\n      this.all(e, allMethods);\n    }\n    this._allInteractiveElements.length = 0;\n    this._hitElements.length = 0;\n    trackingData.overTargets = e.composedPath();\n    this.freeEvent(e);\n  }\n  mapPointerOver(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const e = this.createPointerEvent(from);\n    const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";\n    this.dispatchEvent(e, "pointerover");\n    if (isMouse)\n      this.dispatchEvent(e, "mouseover");\n    if (e.pointerType === "mouse")\n      this.cursor = e.target?.cursor;\n    const enterEvent = this.clonePointerEvent(e, "pointerenter");\n    enterEvent.eventPhase = enterEvent.AT_TARGET;\n    while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {\n      enterEvent.currentTarget = enterEvent.target;\n      this.notifyTarget(enterEvent);\n      if (isMouse)\n        this.notifyTarget(enterEvent, "mouseenter");\n      enterEvent.target = enterEvent.target.parent;\n    }\n    trackingData.overTargets = e.composedPath();\n    this.freeEvent(e);\n    this.freeEvent(enterEvent);\n  }\n  mapPointerOut(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    if (trackingData.overTargets) {\n      const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";\n      const outTarget = this.findMountedTarget(trackingData.overTargets);\n      const outEvent = this.createPointerEvent(from, "pointerout", outTarget);\n      this.dispatchEvent(outEvent);\n      if (isMouse)\n        this.dispatchEvent(outEvent, "mouseout");\n      const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);\n      leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n      while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {\n        leaveEvent.currentTarget = leaveEvent.target;\n        this.notifyTarget(leaveEvent);\n        if (isMouse)\n          this.notifyTarget(leaveEvent, "mouseleave");\n        leaveEvent.target = leaveEvent.target.parent;\n      }\n      trackingData.overTargets = null;\n      this.freeEvent(outEvent);\n      this.freeEvent(leaveEvent);\n    }\n    this.cursor = null;\n  }\n  mapPointerUp(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const now = performance.now();\n    const e = this.createPointerEvent(from);\n    this.dispatchEvent(e, "pointerup");\n    if (e.pointerType === "touch") {\n      this.dispatchEvent(e, "touchend");\n    } else if (e.pointerType === "mouse" || e.pointerType === "pen") {\n      const isRightButton = e.button === 2;\n      this.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n    let clickTarget = pressTarget;\n    if (pressTarget && !e.composedPath().includes(pressTarget)) {\n      let currentTarget = pressTarget;\n      while (currentTarget && !e.composedPath().includes(currentTarget)) {\n        e.currentTarget = currentTarget;\n        this.notifyTarget(e, "pointerupoutside");\n        if (e.pointerType === "touch") {\n          this.notifyTarget(e, "touchendoutside");\n        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {\n          const isRightButton = e.button === 2;\n          this.notifyTarget(e, isRightButton ? "rightupoutside" : "mouseupoutside");\n        }\n        currentTarget = currentTarget.parent;\n      }\n      delete trackingData.pressTargetsByButton[from.button];\n      clickTarget = currentTarget;\n    }\n    if (clickTarget) {\n      const clickEvent = this.clonePointerEvent(e, "click");\n      clickEvent.target = clickTarget;\n      clickEvent.path = null;\n      if (!trackingData.clicksByButton[from.button]) {\n        trackingData.clicksByButton[from.button] = {\n          clickCount: 0,\n          target: clickEvent.target,\n          timeStamp: now\n        };\n      }\n      const clickHistory = trackingData.clicksByButton[from.button];\n      if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {\n        ++clickHistory.clickCount;\n      } else {\n        clickHistory.clickCount = 1;\n      }\n      clickHistory.target = clickEvent.target;\n      clickHistory.timeStamp = now;\n      clickEvent.detail = clickHistory.clickCount;\n      if (clickEvent.pointerType === "mouse") {\n        const isRightButton = clickEvent.button === 2;\n        this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");\n      } else if (clickEvent.pointerType === "touch") {\n        this.dispatchEvent(clickEvent, "tap");\n      }\n      this.dispatchEvent(clickEvent, "pointertap");\n      this.freeEvent(clickEvent);\n    }\n    this.freeEvent(e);\n  }\n  mapPointerUpOutside(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      console.warn("EventBoundary cannot map a non-pointer event as a pointer event");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n    const e = this.createPointerEvent(from);\n    if (pressTarget) {\n      let currentTarget = pressTarget;\n      while (currentTarget) {\n        e.currentTarget = currentTarget;\n        this.notifyTarget(e, "pointerupoutside");\n        if (e.pointerType === "touch") {\n          this.notifyTarget(e, "touchendoutside");\n        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {\n          this.notifyTarget(e, e.button === 2 ? "rightupoutside" : "mouseupoutside");\n        }\n        currentTarget = currentTarget.parent;\n      }\n      delete trackingData.pressTargetsByButton[from.button];\n    }\n    this.freeEvent(e);\n  }\n  mapWheel(from) {\n    if (!(from instanceof FederatedWheelEvent)) {\n      console.warn("EventBoundary cannot map a non-wheel event as a wheel event");\n      return;\n    }\n    const wheelEvent = this.createWheelEvent(from);\n    this.dispatchEvent(wheelEvent);\n    this.freeEvent(wheelEvent);\n  }\n  findMountedTarget(propagationPath) {\n    if (!propagationPath) {\n      return null;\n    }\n    let currentTarget = propagationPath[0];\n    for (let i = 1; i < propagationPath.length; i++) {\n      if (propagationPath[i].parent === currentTarget) {\n        currentTarget = propagationPath[i];\n      } else {\n        break;\n      }\n    }\n    return currentTarget;\n  }\n  createPointerEvent(from, type, target) {\n    const event = this.allocateEvent(FederatedPointerEvent);\n    this.copyPointerData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from;\n    event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];\n    if (typeof type === "string") {\n      event.type = type;\n    }\n    return event;\n  }\n  createWheelEvent(from) {\n    const event = this.allocateEvent(FederatedWheelEvent);\n    this.copyWheelData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from;\n    event.target = this.hitTest(event.global.x, event.global.y);\n    return event;\n  }\n  clonePointerEvent(from, type) {\n    const event = this.allocateEvent(FederatedPointerEvent);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from.originalEvent;\n    this.copyPointerData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.target = from.target;\n    event.path = from.composedPath().slice();\n    event.type = type ?? event.type;\n    return event;\n  }\n  copyWheelData(from, to) {\n    to.deltaMode = from.deltaMode;\n    to.deltaX = from.deltaX;\n    to.deltaY = from.deltaY;\n    to.deltaZ = from.deltaZ;\n  }\n  copyPointerData(from, to) {\n    if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent))\n      return;\n    to.pointerId = from.pointerId;\n    to.width = from.width;\n    to.height = from.height;\n    to.isPrimary = from.isPrimary;\n    to.pointerType = from.pointerType;\n    to.pressure = from.pressure;\n    to.tangentialPressure = from.tangentialPressure;\n    to.tiltX = from.tiltX;\n    to.tiltY = from.tiltY;\n    to.twist = from.twist;\n  }\n  copyMouseData(from, to) {\n    if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent))\n      return;\n    to.altKey = from.altKey;\n    to.button = from.button;\n    to.buttons = from.buttons;\n    to.client.copyFrom(from.client);\n    to.ctrlKey = from.ctrlKey;\n    to.metaKey = from.metaKey;\n    to.movement.copyFrom(from.movement);\n    to.screen.copyFrom(from.screen);\n    to.shiftKey = from.shiftKey;\n    to.global.copyFrom(from.global);\n  }\n  copyData(from, to) {\n    to.isTrusted = from.isTrusted;\n    to.srcElement = from.srcElement;\n    to.timeStamp = performance.now();\n    to.type = from.type;\n    to.detail = from.detail;\n    to.view = from.view;\n    to.which = from.which;\n    to.layer.copyFrom(from.layer);\n    to.page.copyFrom(from.page);\n  }\n  trackingData(id) {\n    if (!this.mappingState.trackingData[id]) {\n      this.mappingState.trackingData[id] = {\n        pressTargetsByButton: {},\n        clicksByButton: {},\n        overTarget: null\n      };\n    }\n    return this.mappingState.trackingData[id];\n  }\n  allocateEvent(constructor) {\n    if (!this.eventPool.has(constructor)) {\n      this.eventPool.set(constructor, []);\n    }\n    const event = this.eventPool.get(constructor).pop() || new constructor(this);\n    event.eventPhase = event.NONE;\n    event.currentTarget = null;\n    event.path = null;\n    event.target = null;\n    return event;\n  }\n  freeEvent(event) {\n    if (event.manager !== this)\n      throw new Error("It is illegal to free an event not managed by this EventBoundary!");\n    const constructor = event.constructor;\n    if (!this.eventPool.has(constructor)) {\n      this.eventPool.set(constructor, []);\n    }\n    this.eventPool.get(constructor).push(event);\n  }\n  notifyListeners(e, type) {\n    const listeners = e.currentTarget._events[type];\n    if (!listeners)\n      return;\n    if (!e.currentTarget.isInteractive())\n      return;\n    if ("fn" in listeners) {\n      if (listeners.once)\n        e.currentTarget.removeListener(type, listeners.fn, void 0, true);\n      listeners.fn.call(listeners.context, e);\n    } else {\n      for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) {\n        if (listeners[i].once)\n          e.currentTarget.removeListener(type, listeners[i].fn, void 0, true);\n        listeners[i].fn.call(listeners[i].context, e);\n      }\n    }\n  }\n}\n\n\n//# sourceMappingURL=EventBoundary.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/EventSystem.mjs\n\n\n\n\n\n\nconst MOUSE_POINTER_ID = 1;\nconst TOUCH_TO_POINTER = {\n  touchstart: "pointerdown",\n  touchend: "pointerup",\n  touchendoutside: "pointerupoutside",\n  touchmove: "pointermove",\n  touchcancel: "pointercancel"\n};\nconst _EventSystem = class {\n  constructor(renderer) {\n    this.supportsTouchEvents = "ontouchstart" in globalThis;\n    this.supportsPointerEvents = !!globalThis.PointerEvent;\n    this.domElement = null;\n    this.resolution = 1;\n    this.renderer = renderer;\n    this.rootBoundary = new EventBoundary(null);\n    EventsTicker.init(this);\n    this.autoPreventDefault = true;\n    this.eventsAdded = false;\n    this.rootPointerEvent = new FederatedPointerEvent(null);\n    this.rootWheelEvent = new FederatedWheelEvent(null);\n    this.cursorStyles = {\n      default: "inherit",\n      pointer: "pointer"\n    };\n    this.features = new Proxy({ ..._EventSystem.defaultEventFeatures }, {\n      set: (target, key, value) => {\n        if (key === "globalMove") {\n          this.rootBoundary.enableGlobalMoveEvents = value;\n        }\n        target[key] = value;\n        return true;\n      }\n    });\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.onPointerOverOut = this.onPointerOverOut.bind(this);\n    this.onWheel = this.onWheel.bind(this);\n  }\n  static get defaultEventMode() {\n    return this._defaultEventMode;\n  }\n  init(options) {\n    const { view, resolution } = this.renderer;\n    this.setTargetElement(view);\n    this.resolution = resolution;\n    _EventSystem._defaultEventMode = options.eventMode ?? "auto";\n    Object.assign(this.features, options.eventFeatures ?? {});\n    this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;\n  }\n  resolutionChange(resolution) {\n    this.resolution = resolution;\n  }\n  destroy() {\n    this.setTargetElement(null);\n    this.renderer = null;\n  }\n  setCursor(mode) {\n    mode = mode || "default";\n    let applyStyles = true;\n    if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {\n      applyStyles = false;\n    }\n    if (this.currentCursor === mode) {\n      return;\n    }\n    this.currentCursor = mode;\n    const style = this.cursorStyles[mode];\n    if (style) {\n      switch (typeof style) {\n        case "string":\n          if (applyStyles) {\n            this.domElement.style.cursor = style;\n          }\n          break;\n        case "function":\n          style(mode);\n          break;\n        case "object":\n          if (applyStyles) {\n            Object.assign(this.domElement.style, style);\n          }\n          break;\n      }\n    } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      this.domElement.style.cursor = mode;\n    }\n  }\n  get pointer() {\n    return this.rootPointerEvent;\n  }\n  onPointerDown(nativeEvent) {\n    if (!this.features.click)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")\n      return;\n    const events = this.normalizeToPointerData(nativeEvent);\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);\n      if (cancelable) {\n        nativeEvent.preventDefault();\n      }\n    }\n    for (let i = 0, j = events.length; i < j; i++) {\n      const nativeEvent2 = events[i];\n      const federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent2);\n      this.rootBoundary.mapEvent(federatedEvent);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  onPointerMove(nativeEvent) {\n    if (!this.features.move)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")\n      return;\n    EventsTicker.pointerMoved();\n    const normalizedEvents = this.normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  onPointerUp(nativeEvent) {\n    if (!this.features.click)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")\n      return;\n    let target = nativeEvent.target;\n    if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {\n      target = nativeEvent.composedPath()[0];\n    }\n    const outside = target !== this.domElement ? "outside" : "";\n    const normalizedEvents = this.normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n      event.type += outside;\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  onPointerOverOut(nativeEvent) {\n    if (!this.features.click)\n      return;\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    if (this.supportsTouchEvents && nativeEvent.pointerType === "touch")\n      return;\n    const normalizedEvents = this.normalizeToPointerData(nativeEvent);\n    for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n      const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n      this.rootBoundary.mapEvent(event);\n    }\n    this.setCursor(this.rootBoundary.cursor);\n  }\n  onWheel(nativeEvent) {\n    if (!this.features.wheel)\n      return;\n    const wheelEvent = this.normalizeWheelEvent(nativeEvent);\n    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n    this.rootBoundary.mapEvent(wheelEvent);\n  }\n  setTargetElement(element) {\n    this.removeEvents();\n    this.domElement = element;\n    EventsTicker.domElement = element;\n    this.addEvents();\n  }\n  addEvents() {\n    if (this.eventsAdded || !this.domElement) {\n      return;\n    }\n    EventsTicker.addTickerListener();\n    const style = this.domElement.style;\n    if (style) {\n      if (globalThis.navigator.msPointerEnabled) {\n        style.msContentZooming = "none";\n        style.msTouchAction = "none";\n      } else if (this.supportsPointerEvents) {\n        style.touchAction = "none";\n      }\n    }\n    if (this.supportsPointerEvents) {\n      globalThis.document.addEventListener("pointermove", this.onPointerMove, true);\n      this.domElement.addEventListener("pointerdown", this.onPointerDown, true);\n      this.domElement.addEventListener("pointerleave", this.onPointerOverOut, true);\n      this.domElement.addEventListener("pointerover", this.onPointerOverOut, true);\n      globalThis.addEventListener("pointerup", this.onPointerUp, true);\n    } else {\n      globalThis.document.addEventListener("mousemove", this.onPointerMove, true);\n      this.domElement.addEventListener("mousedown", this.onPointerDown, true);\n      this.domElement.addEventListener("mouseout", this.onPointerOverOut, true);\n      this.domElement.addEventListener("mouseover", this.onPointerOverOut, true);\n      globalThis.addEventListener("mouseup", this.onPointerUp, true);\n    }\n    if (this.supportsTouchEvents) {\n      this.domElement.addEventListener("touchstart", this.onPointerDown, true);\n      this.domElement.addEventListener("touchend", this.onPointerUp, true);\n      this.domElement.addEventListener("touchmove", this.onPointerMove, true);\n    }\n    this.domElement.addEventListener("wheel", this.onWheel, {\n      passive: true,\n      capture: true\n    });\n    this.eventsAdded = true;\n  }\n  removeEvents() {\n    if (!this.eventsAdded || !this.domElement) {\n      return;\n    }\n    EventsTicker.removeTickerListener();\n    const style = this.domElement.style;\n    if (globalThis.navigator.msPointerEnabled) {\n      style.msContentZooming = "";\n      style.msTouchAction = "";\n    } else if (this.supportsPointerEvents) {\n      style.touchAction = "";\n    }\n    if (this.supportsPointerEvents) {\n      globalThis.document.removeEventListener("pointermove", this.onPointerMove, true);\n      this.domElement.removeEventListener("pointerdown", this.onPointerDown, true);\n      this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, true);\n      this.domElement.removeEventListener("pointerover", this.onPointerOverOut, true);\n      globalThis.removeEventListener("pointerup", this.onPointerUp, true);\n    } else {\n      globalThis.document.removeEventListener("mousemove", this.onPointerMove, true);\n      this.domElement.removeEventListener("mousedown", this.onPointerDown, true);\n      this.domElement.removeEventListener("mouseout", this.onPointerOverOut, true);\n      this.domElement.removeEventListener("mouseover", this.onPointerOverOut, true);\n      globalThis.removeEventListener("mouseup", this.onPointerUp, true);\n    }\n    if (this.supportsTouchEvents) {\n      this.domElement.removeEventListener("touchstart", this.onPointerDown, true);\n      this.domElement.removeEventListener("touchend", this.onPointerUp, true);\n      this.domElement.removeEventListener("touchmove", this.onPointerMove, true);\n    }\n    this.domElement.removeEventListener("wheel", this.onWheel, true);\n    this.domElement = null;\n    this.eventsAdded = false;\n  }\n  mapPositionToPoint(point, x, y) {\n    let rect;\n    if (!this.domElement.parentElement) {\n      rect = {\n        x: 0,\n        y: 0,\n        width: this.domElement.width,\n        height: this.domElement.height,\n        left: 0,\n        top: 0\n      };\n    } else {\n      rect = this.domElement.getBoundingClientRect();\n    }\n    const resolutionMultiplier = 1 / this.resolution;\n    point.x = (x - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;\n    point.y = (y - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;\n  }\n  normalizeToPointerData(event) {\n    const normalizedEvents = [];\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n        const touch = event.changedTouches[i];\n        if (typeof touch.button === "undefined")\n          touch.button = 0;\n        if (typeof touch.buttons === "undefined")\n          touch.buttons = 1;\n        if (typeof touch.isPrimary === "undefined") {\n          touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";\n        }\n        if (typeof touch.width === "undefined")\n          touch.width = touch.radiusX || 1;\n        if (typeof touch.height === "undefined")\n          touch.height = touch.radiusY || 1;\n        if (typeof touch.tiltX === "undefined")\n          touch.tiltX = 0;\n        if (typeof touch.tiltY === "undefined")\n          touch.tiltY = 0;\n        if (typeof touch.pointerType === "undefined")\n          touch.pointerType = "touch";\n        if (typeof touch.pointerId === "undefined")\n          touch.pointerId = touch.identifier || 0;\n        if (typeof touch.pressure === "undefined")\n          touch.pressure = touch.force || 0.5;\n        if (typeof touch.twist === "undefined")\n          touch.twist = 0;\n        if (typeof touch.tangentialPressure === "undefined")\n          touch.tangentialPressure = 0;\n        if (typeof touch.layerX === "undefined")\n          touch.layerX = touch.offsetX = touch.clientX;\n        if (typeof touch.layerY === "undefined")\n          touch.layerY = touch.offsetY = touch.clientY;\n        touch.isNormalized = true;\n        touch.type = event.type;\n        normalizedEvents.push(touch);\n      }\n    } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {\n      const tempEvent = event;\n      if (typeof tempEvent.isPrimary === "undefined")\n        tempEvent.isPrimary = true;\n      if (typeof tempEvent.width === "undefined")\n        tempEvent.width = 1;\n      if (typeof tempEvent.height === "undefined")\n        tempEvent.height = 1;\n      if (typeof tempEvent.tiltX === "undefined")\n        tempEvent.tiltX = 0;\n      if (typeof tempEvent.tiltY === "undefined")\n        tempEvent.tiltY = 0;\n      if (typeof tempEvent.pointerType === "undefined")\n        tempEvent.pointerType = "mouse";\n      if (typeof tempEvent.pointerId === "undefined")\n        tempEvent.pointerId = MOUSE_POINTER_ID;\n      if (typeof tempEvent.pressure === "undefined")\n        tempEvent.pressure = 0.5;\n      if (typeof tempEvent.twist === "undefined")\n        tempEvent.twist = 0;\n      if (typeof tempEvent.tangentialPressure === "undefined")\n        tempEvent.tangentialPressure = 0;\n      tempEvent.isNormalized = true;\n      normalizedEvents.push(tempEvent);\n    } else {\n      normalizedEvents.push(event);\n    }\n    return normalizedEvents;\n  }\n  normalizeWheelEvent(nativeEvent) {\n    const event = this.rootWheelEvent;\n    this.transferMouseData(event, nativeEvent);\n    event.deltaX = nativeEvent.deltaX;\n    event.deltaY = nativeEvent.deltaY;\n    event.deltaZ = nativeEvent.deltaZ;\n    event.deltaMode = nativeEvent.deltaMode;\n    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n    event.global.copyFrom(event.screen);\n    event.offset.copyFrom(event.screen);\n    event.nativeEvent = nativeEvent;\n    event.type = nativeEvent.type;\n    return event;\n  }\n  bootstrapEvent(event, nativeEvent) {\n    event.originalEvent = null;\n    event.nativeEvent = nativeEvent;\n    event.pointerId = nativeEvent.pointerId;\n    event.width = nativeEvent.width;\n    event.height = nativeEvent.height;\n    event.isPrimary = nativeEvent.isPrimary;\n    event.pointerType = nativeEvent.pointerType;\n    event.pressure = nativeEvent.pressure;\n    event.tangentialPressure = nativeEvent.tangentialPressure;\n    event.tiltX = nativeEvent.tiltX;\n    event.tiltY = nativeEvent.tiltY;\n    event.twist = nativeEvent.twist;\n    this.transferMouseData(event, nativeEvent);\n    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n    event.global.copyFrom(event.screen);\n    event.offset.copyFrom(event.screen);\n    event.isTrusted = nativeEvent.isTrusted;\n    if (event.type === "pointerleave") {\n      event.type = "pointerout";\n    }\n    if (event.type.startsWith("mouse")) {\n      event.type = event.type.replace("mouse", "pointer");\n    }\n    if (event.type.startsWith("touch")) {\n      event.type = TOUCH_TO_POINTER[event.type] || event.type;\n    }\n    return event;\n  }\n  transferMouseData(event, nativeEvent) {\n    event.isTrusted = nativeEvent.isTrusted;\n    event.srcElement = nativeEvent.srcElement;\n    event.timeStamp = performance.now();\n    event.type = nativeEvent.type;\n    event.altKey = nativeEvent.altKey;\n    event.button = nativeEvent.button;\n    event.buttons = nativeEvent.buttons;\n    event.client.x = nativeEvent.clientX;\n    event.client.y = nativeEvent.clientY;\n    event.ctrlKey = nativeEvent.ctrlKey;\n    event.metaKey = nativeEvent.metaKey;\n    event.movement.x = nativeEvent.movementX;\n    event.movement.y = nativeEvent.movementY;\n    event.page.x = nativeEvent.pageX;\n    event.page.y = nativeEvent.pageY;\n    event.relatedTarget = null;\n    event.shiftKey = nativeEvent.shiftKey;\n  }\n};\nlet EventSystem = _EventSystem;\nEventSystem.extension = {\n  name: "events",\n  type: [\n    ExtensionType.RendererSystem,\n    ExtensionType.CanvasRendererSystem\n  ]\n};\nEventSystem.defaultEventFeatures = {\n  move: true,\n  globalMove: true,\n  click: true,\n  wheel: true\n};\nextensions.add(EventSystem);\n\n\n//# sourceMappingURL=EventSystem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/FederatedEventTarget.mjs\n\n\n\n\n\nfunction convertEventModeToInteractiveMode(mode) {\n  return mode === "dynamic" || mode === "static";\n}\nconst FederatedDisplayObject = {\n  onclick: null,\n  onmousedown: null,\n  onmouseenter: null,\n  onmouseleave: null,\n  onmousemove: null,\n  onglobalmousemove: null,\n  onmouseout: null,\n  onmouseover: null,\n  onmouseup: null,\n  onmouseupoutside: null,\n  onpointercancel: null,\n  onpointerdown: null,\n  onpointerenter: null,\n  onpointerleave: null,\n  onpointermove: null,\n  onglobalpointermove: null,\n  onpointerout: null,\n  onpointerover: null,\n  onpointertap: null,\n  onpointerup: null,\n  onpointerupoutside: null,\n  onrightclick: null,\n  onrightdown: null,\n  onrightup: null,\n  onrightupoutside: null,\n  ontap: null,\n  ontouchcancel: null,\n  ontouchend: null,\n  ontouchendoutside: null,\n  ontouchmove: null,\n  onglobaltouchmove: null,\n  ontouchstart: null,\n  onwheel: null,\n  _internalInteractive: void 0,\n  get interactive() {\n    return this._internalInteractive ?? convertEventModeToInteractiveMode(EventSystem.defaultEventMode);\n  },\n  set interactive(value) {\n    utils_lib.deprecation("7.2.0", `Setting interactive is deprecated, use eventMode = \'none\'/\'passive\'/\'auto\'/\'static\'/\'dynamic\' instead.`);\n    this._internalInteractive = value;\n    this.eventMode = value ? "static" : "auto";\n  },\n  _internalEventMode: void 0,\n  get eventMode() {\n    return this._internalEventMode ?? EventSystem.defaultEventMode;\n  },\n  set eventMode(value) {\n    this._internalInteractive = convertEventModeToInteractiveMode(value);\n    this._internalEventMode = value;\n  },\n  isInteractive() {\n    return this.eventMode === "static" || this.eventMode === "dynamic";\n  },\n  interactiveChildren: true,\n  hitArea: null,\n  addEventListener(type, listener, options) {\n    const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;\n    const context = typeof listener === "function" ? void 0 : listener;\n    type = capture ? `${type}capture` : type;\n    listener = typeof listener === "function" ? listener : listener.handleEvent;\n    this.on(type, listener, context);\n  },\n  removeEventListener(type, listener, options) {\n    const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;\n    const context = typeof listener === "function" ? void 0 : listener;\n    type = capture ? `${type}capture` : type;\n    listener = typeof listener === "function" ? listener : listener.handleEvent;\n    this.off(type, listener, context);\n  },\n  dispatchEvent(e) {\n    if (!(e instanceof FederatedEvent)) {\n      throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");\n    }\n    e.defaultPrevented = false;\n    e.path = null;\n    e.target = this;\n    e.manager.dispatchEvent(e);\n    return !e.defaultPrevented;\n  }\n};\nDisplayObject.mixin(FederatedDisplayObject);\n\n\n//# sourceMappingURL=FederatedEventTarget.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/events/lib/index.mjs\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/accessibility/lib/accessibleTarget.mjs\nconst accessibleTarget = {\n  accessible: false,\n  accessibleTitle: null,\n  accessibleHint: null,\n  tabIndex: 0,\n  _accessibleActive: false,\n  _accessibleDiv: null,\n  accessibleType: "button",\n  accessiblePointerEvents: "auto",\n  accessibleChildren: true,\n  renderId: -1\n};\n\n\n//# sourceMappingURL=accessibleTarget.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/accessibility/lib/AccessibilityManager.mjs\n\n\n\n\n\nDisplayObject.mixin(accessibleTarget);\nconst KEY_CODE_TAB = 9;\nconst DIV_TOUCH_SIZE = 100;\nconst DIV_TOUCH_POS_X = 0;\nconst DIV_TOUCH_POS_Y = 0;\nconst DIV_TOUCH_ZINDEX = 2;\nconst DIV_HOOK_SIZE = 1;\nconst DIV_HOOK_POS_X = -1e3;\nconst DIV_HOOK_POS_Y = -1e3;\nconst DIV_HOOK_ZINDEX = 2;\nclass AccessibilityManager {\n  constructor(renderer) {\n    this.debug = false;\n    this._isActive = false;\n    this._isMobileAccessibility = false;\n    this.pool = [];\n    this.renderId = 0;\n    this.children = [];\n    this.androidUpdateCount = 0;\n    this.androidUpdateFrequency = 500;\n    this._hookDiv = null;\n    if (utils_lib.isMobile.tablet || utils_lib.isMobile.phone) {\n      this.createTouchHook();\n    }\n    const div = document.createElement("div");\n    div.style.width = `${DIV_TOUCH_SIZE}px`;\n    div.style.height = `${DIV_TOUCH_SIZE}px`;\n    div.style.position = "absolute";\n    div.style.top = `${DIV_TOUCH_POS_X}px`;\n    div.style.left = `${DIV_TOUCH_POS_Y}px`;\n    div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n    this.div = div;\n    this.renderer = renderer;\n    this._onKeyDown = this._onKeyDown.bind(this);\n    this._onMouseMove = this._onMouseMove.bind(this);\n    globalThis.addEventListener("keydown", this._onKeyDown, false);\n  }\n  get isActive() {\n    return this._isActive;\n  }\n  get isMobileAccessibility() {\n    return this._isMobileAccessibility;\n  }\n  createTouchHook() {\n    const hookDiv = document.createElement("button");\n    hookDiv.style.width = `${DIV_HOOK_SIZE}px`;\n    hookDiv.style.height = `${DIV_HOOK_SIZE}px`;\n    hookDiv.style.position = "absolute";\n    hookDiv.style.top = `${DIV_HOOK_POS_X}px`;\n    hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;\n    hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();\n    hookDiv.style.backgroundColor = "#FF0000";\n    hookDiv.title = "select to enable accessibility for this content";\n    hookDiv.addEventListener("focus", () => {\n      this._isMobileAccessibility = true;\n      this.activate();\n      this.destroyTouchHook();\n    });\n    document.body.appendChild(hookDiv);\n    this._hookDiv = hookDiv;\n  }\n  destroyTouchHook() {\n    if (!this._hookDiv) {\n      return;\n    }\n    document.body.removeChild(this._hookDiv);\n    this._hookDiv = null;\n  }\n  activate() {\n    if (this._isActive) {\n      return;\n    }\n    this._isActive = true;\n    globalThis.document.addEventListener("mousemove", this._onMouseMove, true);\n    globalThis.removeEventListener("keydown", this._onKeyDown, false);\n    this.renderer.on("postrender", this.update, this);\n    this.renderer.view.parentNode?.appendChild(this.div);\n  }\n  deactivate() {\n    if (!this._isActive || this._isMobileAccessibility) {\n      return;\n    }\n    this._isActive = false;\n    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);\n    globalThis.addEventListener("keydown", this._onKeyDown, false);\n    this.renderer.off("postrender", this.update);\n    this.div.parentNode?.removeChild(this.div);\n  }\n  updateAccessibleObjects(displayObject) {\n    if (!displayObject.visible || !displayObject.accessibleChildren) {\n      return;\n    }\n    if (displayObject.accessible && displayObject.isInteractive()) {\n      if (!displayObject._accessibleActive) {\n        this.addChild(displayObject);\n      }\n      displayObject.renderId = this.renderId;\n    }\n    const children = displayObject.children;\n    if (children) {\n      for (let i = 0; i < children.length; i++) {\n        this.updateAccessibleObjects(children[i]);\n      }\n    }\n  }\n  update() {\n    const now = performance.now();\n    if (utils_lib.isMobile.android.device && now < this.androidUpdateCount) {\n      return;\n    }\n    this.androidUpdateCount = now + this.androidUpdateFrequency;\n    if (!this.renderer.renderingToScreen) {\n      return;\n    }\n    if (this.renderer.lastObjectRendered) {\n      this.updateAccessibleObjects(this.renderer.lastObjectRendered);\n    }\n    const { x, y, width, height } = this.renderer.view.getBoundingClientRect();\n    const { width: viewWidth, height: viewHeight, resolution } = this.renderer;\n    const sx = width / viewWidth * resolution;\n    const sy = height / viewHeight * resolution;\n    let div = this.div;\n    div.style.left = `${x}px`;\n    div.style.top = `${y}px`;\n    div.style.width = `${viewWidth}px`;\n    div.style.height = `${viewHeight}px`;\n    for (let i = 0; i < this.children.length; i++) {\n      const child = this.children[i];\n      if (child.renderId !== this.renderId) {\n        child._accessibleActive = false;\n        utils_lib.removeItems(this.children, i, 1);\n        this.div.removeChild(child._accessibleDiv);\n        this.pool.push(child._accessibleDiv);\n        child._accessibleDiv = null;\n        i--;\n      } else {\n        div = child._accessibleDiv;\n        let hitArea = child.hitArea;\n        const wt = child.worldTransform;\n        if (child.hitArea) {\n          div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;\n          div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;\n          div.style.width = `${hitArea.width * wt.a * sx}px`;\n          div.style.height = `${hitArea.height * wt.d * sy}px`;\n        } else {\n          hitArea = child.getBounds();\n          this.capHitArea(hitArea);\n          div.style.left = `${hitArea.x * sx}px`;\n          div.style.top = `${hitArea.y * sy}px`;\n          div.style.width = `${hitArea.width * sx}px`;\n          div.style.height = `${hitArea.height * sy}px`;\n          if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {\n            div.title = child.accessibleTitle;\n          }\n          if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {\n            div.setAttribute("aria-label", child.accessibleHint);\n          }\n        }\n        if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {\n          div.title = child.accessibleTitle;\n          div.tabIndex = child.tabIndex;\n          if (this.debug)\n            this.updateDebugHTML(div);\n        }\n      }\n    }\n    this.renderId++;\n  }\n  updateDebugHTML(div) {\n    div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;\n  }\n  capHitArea(hitArea) {\n    if (hitArea.x < 0) {\n      hitArea.width += hitArea.x;\n      hitArea.x = 0;\n    }\n    if (hitArea.y < 0) {\n      hitArea.height += hitArea.y;\n      hitArea.y = 0;\n    }\n    const { width: viewWidth, height: viewHeight } = this.renderer;\n    if (hitArea.x + hitArea.width > viewWidth) {\n      hitArea.width = viewWidth - hitArea.x;\n    }\n    if (hitArea.y + hitArea.height > viewHeight) {\n      hitArea.height = viewHeight - hitArea.y;\n    }\n  }\n  addChild(displayObject) {\n    let div = this.pool.pop();\n    if (!div) {\n      div = document.createElement("button");\n      div.style.width = `${DIV_TOUCH_SIZE}px`;\n      div.style.height = `${DIV_TOUCH_SIZE}px`;\n      div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";\n      div.style.position = "absolute";\n      div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n      div.style.borderStyle = "none";\n      if (navigator.userAgent.toLowerCase().includes("chrome")) {\n        div.setAttribute("aria-live", "off");\n      } else {\n        div.setAttribute("aria-live", "polite");\n      }\n      if (navigator.userAgent.match(/rv:.*Gecko\\//)) {\n        div.setAttribute("aria-relevant", "additions");\n      } else {\n        div.setAttribute("aria-relevant", "text");\n      }\n      div.addEventListener("click", this._onClick.bind(this));\n      div.addEventListener("focus", this._onFocus.bind(this));\n      div.addEventListener("focusout", this._onFocusOut.bind(this));\n    }\n    div.style.pointerEvents = displayObject.accessiblePointerEvents;\n    div.type = displayObject.accessibleType;\n    if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {\n      div.title = displayObject.accessibleTitle;\n    } else if (!displayObject.accessibleHint || displayObject.accessibleHint === null) {\n      div.title = `displayObject ${displayObject.tabIndex}`;\n    }\n    if (displayObject.accessibleHint && displayObject.accessibleHint !== null) {\n      div.setAttribute("aria-label", displayObject.accessibleHint);\n    }\n    if (this.debug)\n      this.updateDebugHTML(div);\n    displayObject._accessibleActive = true;\n    displayObject._accessibleDiv = div;\n    div.displayObject = displayObject;\n    this.children.push(displayObject);\n    this.div.appendChild(displayObject._accessibleDiv);\n    displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;\n  }\n  _dispatchEvent(e, type) {\n    const { displayObject: target } = e.target;\n    const boundry = this.renderer.events.rootBoundary;\n    const event = Object.assign(new FederatedEvent(boundry), { target });\n    boundry.rootTarget = this.renderer.lastObjectRendered;\n    type.forEach((type2) => boundry.dispatchEvent(event, type2));\n  }\n  _onClick(e) {\n    this._dispatchEvent(e, ["click", "pointertap", "tap"]);\n  }\n  _onFocus(e) {\n    if (!e.target.getAttribute("aria-live")) {\n      e.target.setAttribute("aria-live", "assertive");\n    }\n    this._dispatchEvent(e, ["mouseover"]);\n  }\n  _onFocusOut(e) {\n    if (!e.target.getAttribute("aria-live")) {\n      e.target.setAttribute("aria-live", "polite");\n    }\n    this._dispatchEvent(e, ["mouseout"]);\n  }\n  _onKeyDown(e) {\n    if (e.keyCode !== KEY_CODE_TAB) {\n      return;\n    }\n    this.activate();\n  }\n  _onMouseMove(e) {\n    if (e.movementX === 0 && e.movementY === 0) {\n      return;\n    }\n    this.deactivate();\n  }\n  destroy() {\n    this.destroyTouchHook();\n    this.div = null;\n    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);\n    globalThis.removeEventListener("keydown", this._onKeyDown);\n    this.pool = null;\n    this.children = null;\n    this.renderer = null;\n  }\n}\nAccessibilityManager.extension = {\n  name: "accessibility",\n  type: [\n    ExtensionType.RendererPlugin,\n    ExtensionType.CanvasRendererPlugin\n  ]\n};\nextensions.add(AccessibilityManager);\n\n\n//# sourceMappingURL=AccessibilityManager.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/accessibility/lib/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/app/lib/Application.mjs\n\n\n\nconst _Application = class {\n  constructor(options) {\n    this.stage = new Container_Container();\n    options = Object.assign({\n      forceCanvas: false\n    }, options);\n    this.renderer = autoDetectRenderer(options);\n    _Application._plugins.forEach((plugin) => {\n      plugin.init.call(this, options);\n    });\n  }\n  render() {\n    this.renderer.render(this.stage);\n  }\n  get view() {\n    return this.renderer.view;\n  }\n  get screen() {\n    return this.renderer.screen;\n  }\n  destroy(removeView, stageOptions) {\n    const plugins = _Application._plugins.slice(0);\n    plugins.reverse();\n    plugins.forEach((plugin) => {\n      plugin.destroy.call(this);\n    });\n    this.stage.destroy(stageOptions);\n    this.stage = null;\n    this.renderer.destroy(removeView);\n    this.renderer = null;\n  }\n};\nlet Application = _Application;\nApplication._plugins = [];\nextensions.handleByList(ExtensionType.Application, Application._plugins);\n\n\n//# sourceMappingURL=Application.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/app/lib/ResizePlugin.mjs\n\n\nclass ResizePlugin {\n  static init(options) {\n    Object.defineProperty(this, "resizeTo", {\n      set(dom) {\n        globalThis.removeEventListener("resize", this.queueResize);\n        this._resizeTo = dom;\n        if (dom) {\n          globalThis.addEventListener("resize", this.queueResize);\n          this.resize();\n        }\n      },\n      get() {\n        return this._resizeTo;\n      }\n    });\n    this.queueResize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this.cancelResize();\n      this._resizeId = requestAnimationFrame(() => this.resize());\n    };\n    this.cancelResize = () => {\n      if (this._resizeId) {\n        cancelAnimationFrame(this._resizeId);\n        this._resizeId = null;\n      }\n    };\n    this.resize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this.cancelResize();\n      let width;\n      let height;\n      if (this._resizeTo === globalThis.window) {\n        width = globalThis.innerWidth;\n        height = globalThis.innerHeight;\n      } else {\n        const { clientWidth, clientHeight } = this._resizeTo;\n        width = clientWidth;\n        height = clientHeight;\n      }\n      this.renderer.resize(width, height);\n      this.render();\n    };\n    this._resizeId = null;\n    this._resizeTo = null;\n    this.resizeTo = options.resizeTo || null;\n  }\n  static destroy() {\n    globalThis.removeEventListener("resize", this.queueResize);\n    this.cancelResize();\n    this.cancelResize = null;\n    this.queueResize = null;\n    this.resizeTo = null;\n    this.resize = null;\n  }\n}\nResizePlugin.extension = ExtensionType.Application;\nextensions.add(ResizePlugin);\n\n\n//# sourceMappingURL=ResizePlugin.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/app/lib/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/AssetExtension.mjs\n\n\nconst assetKeyMap = {\n  loader: ExtensionType.LoadParser,\n  resolver: ExtensionType.ResolveParser,\n  cache: ExtensionType.CacheParser,\n  detection: ExtensionType.DetectionParser\n};\nextensions.handle(ExtensionType.Asset, (extension) => {\n  const ref = extension.ref;\n  Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => extensions.add(Object.assign(ref[key], { extension: ref[key].extension ?? type })));\n}, (extension) => {\n  const ref = extension.ref;\n  Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => extensions.remove(ref[key]));\n});\n//# sourceMappingURL=AssetExtension.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/BackgroundLoader.mjs\nclass BackgroundLoader {\n  constructor(loader, verbose = false) {\n    this._loader = loader;\n    this._assetList = [];\n    this._isLoading = false;\n    this._maxConcurrent = 1;\n    this.verbose = verbose;\n  }\n  add(assetUrls) {\n    assetUrls.forEach((a) => {\n      this._assetList.push(a);\n    });\n    if (this.verbose)\n      console.log("[BackgroundLoader] assets: ", this._assetList);\n    if (this._isActive && !this._isLoading) {\n      this._next();\n    }\n  }\n  async _next() {\n    if (this._assetList.length && this._isActive) {\n      this._isLoading = true;\n      const toLoad = [];\n      const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);\n      for (let i = 0; i < toLoadAmount; i++) {\n        toLoad.push(this._assetList.pop());\n      }\n      await this._loader.load(toLoad);\n      this._isLoading = false;\n      this._next();\n    }\n  }\n  get active() {\n    return this._isActive;\n  }\n  set active(value) {\n    if (this._isActive === value)\n      return;\n    this._isActive = value;\n    if (value && !this._isLoading) {\n      this._next();\n    }\n  }\n}\n\n\n//# sourceMappingURL=BackgroundLoader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/checkExtension.mjs\n\n\nfunction checkExtension(url, extension) {\n  const tempURL = url.split("?")[0];\n  const ext = utils_lib.path.extname(tempURL).toLowerCase();\n  if (Array.isArray(extension)) {\n    return extension.includes(ext);\n  }\n  return ext === extension;\n}\n\n\n//# sourceMappingURL=checkExtension.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/index.mjs\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/convertToList.mjs\nconst convertToList = (input, transform) => {\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n  if (!transform) {\n    return input;\n  }\n  return input.map((item) => {\n    if (typeof item === "string") {\n      return transform(item);\n    }\n    return item;\n  });\n};\n\n\n//# sourceMappingURL=convertToList.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/cache/Cache.mjs\n\n\n\n\nclass CacheClass {\n  constructor() {\n    this._parsers = [];\n    this._cache = /* @__PURE__ */ new Map();\n    this._cacheMap = /* @__PURE__ */ new Map();\n  }\n  reset() {\n    this._cacheMap.clear();\n    this._cache.clear();\n  }\n  has(key) {\n    return this._cache.has(key);\n  }\n  get(key) {\n    const result = this._cache.get(key);\n    if (!result) {\n      console.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n    }\n    return result;\n  }\n  set(key, value) {\n    const keys = convertToList(key);\n    let cacheableAssets;\n    for (let i = 0; i < this.parsers.length; i++) {\n      const parser = this.parsers[i];\n      if (parser.test(value)) {\n        cacheableAssets = parser.getCacheableAssets(keys, value);\n        break;\n      }\n    }\n    if (!cacheableAssets) {\n      cacheableAssets = {};\n      keys.forEach((key2) => {\n        cacheableAssets[key2] = value;\n      });\n    }\n    const cacheKeys = Object.keys(cacheableAssets);\n    const cachedAssets = {\n      cacheKeys,\n      keys\n    };\n    keys.forEach((key2) => {\n      this._cacheMap.set(key2, cachedAssets);\n    });\n    cacheKeys.forEach((key2) => {\n      if (this._cache.has(key2) && this._cache.get(key2) !== value) {\n        console.warn("[Cache] already has key:", key2);\n      }\n      this._cache.set(key2, cacheableAssets[key2]);\n    });\n    if (value instanceof Texture_Texture) {\n      const texture = value;\n      keys.forEach((key2) => {\n        if (texture.baseTexture !== Texture_Texture.EMPTY.baseTexture) {\n          BaseTexture.addToCache(texture.baseTexture, key2);\n        }\n        Texture_Texture.addToCache(texture, key2);\n      });\n    }\n  }\n  remove(key) {\n    this._cacheMap.get(key);\n    if (!this._cacheMap.has(key)) {\n      console.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n      return;\n    }\n    const cacheMap = this._cacheMap.get(key);\n    const cacheKeys = cacheMap.cacheKeys;\n    cacheKeys.forEach((key2) => {\n      this._cache.delete(key2);\n    });\n    cacheMap.keys.forEach((key2) => {\n      this._cacheMap.delete(key2);\n    });\n  }\n  get parsers() {\n    return this._parsers;\n  }\n}\nconst Cache = new CacheClass();\n\n\n//# sourceMappingURL=Cache.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/isSingleItem.mjs\nconst isSingleItem = (item) => !Array.isArray(item);\n\n\n//# sourceMappingURL=isSingleItem.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/Loader.mjs\n\n\n\n\n\nclass Loader {\n  constructor() {\n    this._parsers = [];\n    this._parsersValidated = false;\n    this.parsers = new Proxy(this._parsers, {\n      set: (target, key, value) => {\n        this._parsersValidated = false;\n        target[key] = value;\n        return true;\n      }\n    });\n    this.promiseCache = {};\n  }\n  reset() {\n    this._parsersValidated = false;\n    this.promiseCache = {};\n  }\n  _getLoadPromiseAndParser(url, data) {\n    const result = {\n      promise: null,\n      parser: null\n    };\n    result.promise = (async () => {\n      let asset = null;\n      let parser = null;\n      if (data.loadParser) {\n        parser = this._parserHash[data.loadParser];\n        if (!parser) {\n          console.warn(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url}`);\n        }\n      }\n      if (!parser) {\n        for (let i = 0; i < this.parsers.length; i++) {\n          const parserX = this.parsers[i];\n          if (parserX.load && parserX.test?.(url, data, this)) {\n            parser = parserX;\n            break;\n          }\n        }\n        if (!parser) {\n          console.warn(`[Assets] ${url} could not be loaded as we don\'t know how to parse it, ensure the correct parser has been added`);\n          return null;\n        }\n      }\n      asset = await parser.load(url, data, this);\n      result.parser = parser;\n      for (let i = 0; i < this.parsers.length; i++) {\n        const parser2 = this.parsers[i];\n        if (parser2.parse) {\n          if (parser2.parse && await parser2.testParse?.(asset, data, this)) {\n            asset = await parser2.parse(asset, data, this) || asset;\n            result.parser = parser2;\n          }\n        }\n      }\n      return asset;\n    })();\n    return result;\n  }\n  async load(assetsToLoadIn, onProgress) {\n    if (!this._parsersValidated) {\n      this._validateParsers();\n    }\n    let count = 0;\n    const assets = {};\n    const singleAsset = isSingleItem(assetsToLoadIn);\n    const assetsToLoad = convertToList(assetsToLoadIn, (item) => ({\n      src: item\n    }));\n    const total = assetsToLoad.length;\n    const promises = assetsToLoad.map(async (asset) => {\n      const url = utils_lib.path.toAbsolute(asset.src);\n      if (!assets[asset.src]) {\n        try {\n          if (!this.promiseCache[url]) {\n            this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n          }\n          assets[asset.src] = await this.promiseCache[url].promise;\n          if (onProgress)\n            onProgress(++count / total);\n        } catch (e) {\n          delete this.promiseCache[url];\n          delete assets[asset.src];\n          throw new Error(`[Loader.load] Failed to load ${url}.\n${e}`);\n        }\n      }\n    });\n    await Promise.all(promises);\n    return singleAsset ? assets[assetsToLoad[0].src] : assets;\n  }\n  async unload(assetsToUnloadIn) {\n    const assetsToUnload = convertToList(assetsToUnloadIn, (item) => ({\n      src: item\n    }));\n    const promises = assetsToUnload.map(async (asset) => {\n      const url = utils_lib.path.toAbsolute(asset.src);\n      const loadPromise = this.promiseCache[url];\n      if (loadPromise) {\n        const loadedAsset = await loadPromise.promise;\n        loadPromise.parser?.unload?.(loadedAsset, asset, this);\n        delete this.promiseCache[url];\n      }\n    });\n    await Promise.all(promises);\n  }\n  _validateParsers() {\n    this._parsersValidated = true;\n    this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => {\n      if (hash[parser.name]) {\n        console.warn(`[Assets] loadParser name conflict "${parser.name}"`);\n      }\n      return { ...hash, [parser.name]: parser };\n    }, {});\n  }\n}\n\n\n//# sourceMappingURL=Loader.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/LoaderParser.mjs\nvar LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {\n  LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";\n  LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";\n  LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";\n  return LoaderParserPriority2;\n})(LoaderParserPriority || {});\n\n\n//# sourceMappingURL=LoaderParser.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/checkDataUrl.mjs\nfunction checkDataUrl(url, mimes) {\n  if (Array.isArray(mimes)) {\n    for (const mime of mimes) {\n      if (url.startsWith(`data:${mime}`))\n        return true;\n    }\n    return false;\n  }\n  return url.startsWith(`data:${mimes}`);\n}\n\n\n//# sourceMappingURL=checkDataUrl.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/loadJson.mjs\n\n\n\n\n\nconst validJSONExtension = ".json";\nconst validJSONMIME = "application/json";\nconst loadJson = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Low\n  },\n  name: "loadJson",\n  test(url) {\n    return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);\n  },\n  async load(url) {\n    const response = await settings_lib/* settings */.Xd.ADAPTER.fetch(url);\n    const json = await response.json();\n    return json;\n  }\n};\nextensions.add(loadJson);\n\n\n//# sourceMappingURL=loadJson.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/loadTxt.mjs\n\n\n\n\n\nconst validTXTExtension = ".txt";\nconst validTXTMIME = "text/plain";\nconst loadTxt = {\n  name: "loadTxt",\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Low\n  },\n  test(url) {\n    return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);\n  },\n  async load(url) {\n    const response = await settings_lib/* settings */.Xd.ADAPTER.fetch(url);\n    const txt = await response.text();\n    return txt;\n  }\n};\nextensions.add(loadTxt);\n\n\n//# sourceMappingURL=loadTxt.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/loadWebFont.mjs\n\n\n\n\n\nconst validWeights = [\n  "normal",\n  "bold",\n  "100",\n  "200",\n  "300",\n  "400",\n  "500",\n  "600",\n  "700",\n  "800",\n  "900"\n];\nconst validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];\nconst validFontMIMEs = [\n  "font/ttf",\n  "font/otf",\n  "font/woff",\n  "font/woff2"\n];\nconst CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;\nfunction getFontFamilyName(url) {\n  const ext = utils_lib.path.extname(url);\n  const name = utils_lib.path.basename(url, ext);\n  const nameWithSpaces = name.replace(/(-|_)/g, " ");\n  const nameTokens = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));\n  let valid = nameTokens.length > 0;\n  for (const token of nameTokens) {\n    if (!token.match(CSS_IDENT_TOKEN_REGEX)) {\n      valid = false;\n      break;\n    }\n  }\n  let fontFamilyName = nameTokens.join(" ");\n  if (!valid) {\n    fontFamilyName = `"${fontFamilyName.replace(/[\\\\"]/g, "\\\\$&")}"`;\n  }\n  return fontFamilyName;\n}\nconst loadWebFont = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Low\n  },\n  name: "loadWebFont",\n  test(url) {\n    return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);\n  },\n  async load(url, options) {\n    const fonts = settings_lib/* settings */.Xd.ADAPTER.getFontFaceSet();\n    if (fonts) {\n      const fontFaces = [];\n      const name = options.data?.family ?? getFontFamilyName(url);\n      const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ["normal"];\n      const data = options.data ?? {};\n      for (let i = 0; i < weights.length; i++) {\n        const weight = weights[i];\n        const font = new FontFace(name, `url(${encodeURI(url)})`, {\n          ...data,\n          weight\n        });\n        await font.load();\n        fonts.add(font);\n        fontFaces.push(font);\n      }\n      return fontFaces.length === 1 ? fontFaces[0] : fontFaces;\n    }\n    console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font");\n    return null;\n  },\n  unload(font) {\n    (Array.isArray(font) ? font : [font]).forEach((t) => settings_lib/* settings */.Xd.ADAPTER.getFontFaceSet().delete(t));\n  }\n};\nextensions.add(loadWebFont);\n\n\n//# sourceMappingURL=loadWebFont.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/WorkerManager.mjs\nlet UUID = 0;\nlet MAX_WORKERS;\nconst WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";\nconst checkImageBitmapCode = {\n  id: "checkImageBitmap",\n  code: `\n    async function checkImageBitmap()\n    {\n        try\n        {\n            if (typeof createImageBitmap !== \'function\') return false;\n\n            const response = await fetch(\'${WHITE_PNG}\');\n            const imageBlob =  await response.blob();\n            const imageBitmap = await createImageBitmap(imageBlob);\n\n            return imageBitmap.width === 1 && imageBitmap.height === 1;\n        }\n        catch (e)\n        {\n            return false;\n        }\n    }\n    checkImageBitmap().then((result) => { self.postMessage(result); });\n    `\n};\nconst workerCode = {\n  id: "loadImageBitmap",\n  code: `\n    async function loadImageBitmap(url)\n    {\n        const response = await fetch(url);\n\n        if (!response.ok)\n        {\n            throw new Error(\\`[WorkerManager.loadImageBitmap] Failed to fetch \\${url}: \\`\n                + \\`\\${response.status} \\${response.statusText}\\`);\n        }\n\n        const imageBlob =  await response.blob();\n        const imageBitmap = await createImageBitmap(imageBlob);\n\n        return imageBitmap;\n    }\n    self.onmessage = async (event) =>\n    {\n        try\n        {\n            const imageBitmap = await loadImageBitmap(event.data.data[0]);\n\n            self.postMessage({\n                data: imageBitmap,\n                uuid: event.data.uuid,\n                id: event.data.id,\n            }, [imageBitmap]);\n        }\n        catch(e)\n        {\n            self.postMessage({\n                error: e,\n                uuid: event.data.uuid,\n                id: event.data.id,\n            });\n        }\n    };`\n};\nlet workerURL;\nclass WorkerManagerClass {\n  constructor() {\n    this._initialized = false;\n    this._createdWorkers = 0;\n    this.workerPool = [];\n    this.queue = [];\n    this.resolveHash = {};\n  }\n  isImageBitmapSupported() {\n    if (this._isImageBitmapSupported !== void 0)\n      return this._isImageBitmapSupported;\n    this._isImageBitmapSupported = new Promise((resolve) => {\n      const workerURL2 = URL.createObjectURL(new Blob([checkImageBitmapCode.code], { type: "application/javascript" }));\n      const worker = new Worker(workerURL2);\n      worker.addEventListener("message", (event) => {\n        worker.terminate();\n        URL.revokeObjectURL(workerURL2);\n        resolve(event.data);\n      });\n    });\n    return this._isImageBitmapSupported;\n  }\n  loadImageBitmap(src) {\n    return this._run("loadImageBitmap", [src]);\n  }\n  async _initWorkers() {\n    if (this._initialized)\n      return;\n    this._initialized = true;\n  }\n  getWorker() {\n    if (MAX_WORKERS === void 0) {\n      MAX_WORKERS = navigator.hardwareConcurrency || 4;\n    }\n    let worker = this.workerPool.pop();\n    if (!worker && this._createdWorkers < MAX_WORKERS) {\n      if (!workerURL) {\n        workerURL = URL.createObjectURL(new Blob([workerCode.code], { type: "application/javascript" }));\n      }\n      this._createdWorkers++;\n      worker = new Worker(workerURL);\n      worker.addEventListener("message", (event) => {\n        this.complete(event.data);\n        this.returnWorker(event.target);\n        this.next();\n      });\n    }\n    return worker;\n  }\n  returnWorker(worker) {\n    this.workerPool.push(worker);\n  }\n  complete(data) {\n    if (data.error !== void 0) {\n      this.resolveHash[data.uuid].reject(data.error);\n    } else {\n      this.resolveHash[data.uuid].resolve(data.data);\n    }\n    this.resolveHash[data.uuid] = null;\n  }\n  async _run(id, args) {\n    await this._initWorkers();\n    const promise = new Promise((resolve, reject) => {\n      this.queue.push({ id, arguments: args, resolve, reject });\n    });\n    this.next();\n    return promise;\n  }\n  next() {\n    if (!this.queue.length)\n      return;\n    const worker = this.getWorker();\n    if (!worker) {\n      return;\n    }\n    const toDo = this.queue.pop();\n    const id = toDo.id;\n    this.resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };\n    worker.postMessage({\n      data: toDo.arguments,\n      uuid: UUID++,\n      id\n    });\n  }\n}\nconst WorkerManager = new WorkerManagerClass();\n\n\n//# sourceMappingURL=WorkerManager.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/createTexture.mjs\n\n\nfunction createTexture(base, loader, url) {\n  const texture = new Texture_Texture(base);\n  texture.baseTexture.on("dispose", () => {\n    delete loader.promiseCache[url];\n  });\n  return texture;\n}\n\n\n//# sourceMappingURL=createTexture.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/textures/loadTextures.mjs\n\n\n\n\n\n\n\nconst validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];\nconst validImageMIMEs = [\n  "image/jpeg",\n  "image/png",\n  "image/webp",\n  "image/avif"\n];\nasync function loadImageBitmap(url) {\n  const response = await settings_lib/* settings */.Xd.ADAPTER.fetch(url);\n  if (!response.ok) {\n    throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n  }\n  const imageBlob = await response.blob();\n  const imageBitmap = await createImageBitmap(imageBlob);\n  return imageBitmap;\n}\nconst loadTextures = {\n  name: "loadTextures",\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.High\n  },\n  config: {\n    preferWorkers: true,\n    preferCreateImageBitmap: true,\n    crossOrigin: "anonymous"\n  },\n  test(url) {\n    return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);\n  },\n  async load(url, asset, loader) {\n    let src = null;\n    if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {\n      if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported()) {\n        src = await WorkerManager.loadImageBitmap(url);\n      } else {\n        src = await loadImageBitmap(url);\n      }\n    } else {\n      src = await new Promise((resolve) => {\n        src = new Image();\n        src.crossOrigin = this.config.crossOrigin;\n        src.src = url;\n        if (src.complete) {\n          resolve(src);\n        } else {\n          src.onload = () => {\n            resolve(src);\n          };\n        }\n      });\n    }\n    const base = new BaseTexture(src, {\n      resolution: utils_lib.getResolutionOfUrl(url),\n      ...asset.data\n    });\n    base.resource.src = url;\n    return createTexture(base, loader, url);\n  },\n  unload(texture) {\n    texture.destroy(true);\n  }\n};\nextensions.add(loadTextures);\n\n\n//# sourceMappingURL=loadTextures.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/textures/loadSVG.mjs\n\n\n\n\n\n\n\nconst validSVGExtension = ".svg";\nconst validSVGMIME = "image/svg+xml";\nconst loadSVG = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.High\n  },\n  name: "loadSVG",\n  test(url) {\n    return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);\n  },\n  async testParse(data) {\n    return SVGResource.test(data);\n  },\n  async parse(asset, data, loader) {\n    const src = new SVGResource(asset, data?.data?.resourceOptions);\n    await src.load();\n    const base = new BaseTexture(src, {\n      resolution: utils_lib.getResolutionOfUrl(asset),\n      ...data?.data\n    });\n    base.resource.src = asset;\n    const texture = createTexture(base, loader, asset);\n    return texture;\n  },\n  async load(url, _options) {\n    const response = await settings_lib/* settings */.Xd.ADAPTER.fetch(url);\n    return response.text();\n  },\n  unload: loadTextures.unload\n};\nextensions.add(loadSVG);\n\n\n//# sourceMappingURL=loadSVG.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/textures/utils/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/textures/index.mjs\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/parsers/index.mjs\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/createStringVariations.mjs\nfunction processX(base, ids, depth, result, tags) {\n  const id = ids[depth];\n  for (let i = 0; i < id.length; i++) {\n    const value = id[i];\n    if (depth < ids.length - 1) {\n      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n    } else {\n      tags.push(base.replace(result[depth], value));\n    }\n  }\n}\nfunction createStringVariations(string) {\n  const regex = /\\{(.*?)\\}/g;\n  const result = string.match(regex);\n  const tags = [];\n  if (result) {\n    const ids = [];\n    result.forEach((vars) => {\n      const split = vars.substring(1, vars.length - 1).split(",");\n      ids.push(split);\n    });\n    processX(string, ids, 0, result, tags);\n  } else {\n    tags.push(string);\n  }\n  return tags;\n}\n\n\n//# sourceMappingURL=createStringVariations.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/resolver/Resolver.mjs\n\n\n\n\n\nclass Resolver {\n  constructor() {\n    this._defaultBundleIdentifierOptions = {\n      connector: "-",\n      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,\n      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")\n    };\n    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;\n    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._parsers = [];\n    this._resolverHash = {};\n    this._bundles = {};\n  }\n  setBundleIdentifier(bundleIdentifier) {\n    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n    if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {\n      throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");\n    }\n  }\n  prefer(...preferOrders) {\n    preferOrders.forEach((prefer) => {\n      this._preferredOrder.push(prefer);\n      if (!prefer.priority) {\n        prefer.priority = Object.keys(prefer.params);\n      }\n    });\n    this._resolverHash = {};\n  }\n  set basePath(basePath) {\n    this._basePath = basePath;\n  }\n  get basePath() {\n    return this._basePath;\n  }\n  set rootPath(rootPath) {\n    this._rootPath = rootPath;\n  }\n  get rootPath() {\n    return this._rootPath;\n  }\n  get parsers() {\n    return this._parsers;\n  }\n  reset() {\n    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._resolverHash = {};\n    this._rootPath = null;\n    this._basePath = null;\n    this._manifest = null;\n    this._bundles = {};\n    this._defaultSearchParams = null;\n  }\n  setDefaultSearchParams(searchParams) {\n    if (typeof searchParams === "string") {\n      this._defaultSearchParams = searchParams;\n    } else {\n      const queryValues = searchParams;\n      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");\n    }\n  }\n  addManifest(manifest) {\n    if (this._manifest) {\n      console.warn("[Resolver] Manifest already exists, this will be overwritten");\n    }\n    this._manifest = manifest;\n    manifest.bundles.forEach((bundle) => {\n      this.addBundle(bundle.name, bundle.assets);\n    });\n  }\n  addBundle(bundleId, assets) {\n    const assetNames = [];\n    if (Array.isArray(assets)) {\n      assets.forEach((asset) => {\n        if (typeof asset.name === "string") {\n          const bundleAssetId = this._createBundleAssetId(bundleId, asset.name);\n          assetNames.push(bundleAssetId);\n          this.add([asset.name, bundleAssetId], asset.srcs, asset.data);\n        } else {\n          const bundleIds = asset.name.map((name) => this._createBundleAssetId(bundleId, name));\n          bundleIds.forEach((bundleId2) => {\n            assetNames.push(bundleId2);\n          });\n          this.add([...asset.name, ...bundleIds], asset.srcs);\n        }\n      });\n    } else {\n      Object.keys(assets).forEach((key) => {\n        assetNames.push(this._createBundleAssetId(bundleId, key));\n        this.add([key, this._createBundleAssetId(bundleId, key)], assets[key]);\n      });\n    }\n    this._bundles[bundleId] = assetNames;\n  }\n  add(keysIn, assetsIn, data) {\n    const keys = convertToList(keysIn);\n    keys.forEach((key) => {\n      if (this.hasKey(key)) {\n        console.warn(`[Resolver] already has key: ${key} overwriting`);\n      }\n    });\n    if (!Array.isArray(assetsIn)) {\n      if (typeof assetsIn === "string") {\n        assetsIn = createStringVariations(assetsIn);\n      } else {\n        assetsIn = [assetsIn];\n      }\n    }\n    const assetMap = assetsIn.map((asset) => {\n      let formattedAsset = asset;\n      if (typeof asset === "string") {\n        let parsed = false;\n        for (let i = 0; i < this._parsers.length; i++) {\n          const parser = this._parsers[i];\n          if (parser.test(asset)) {\n            formattedAsset = parser.parse(asset);\n            parsed = true;\n            break;\n          }\n        }\n        if (!parsed) {\n          formattedAsset = {\n            src: asset\n          };\n        }\n      }\n      if (!formattedAsset.format) {\n        formattedAsset.format = formattedAsset.src.split(".").pop();\n      }\n      if (!formattedAsset.alias) {\n        formattedAsset.alias = keys;\n      }\n      if (this._basePath || this._rootPath) {\n        formattedAsset.src = utils_lib.path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n      }\n      formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n      formattedAsset.data = formattedAsset.data ?? data;\n      return formattedAsset;\n    });\n    keys.forEach((key) => {\n      this._assetMap[key] = assetMap;\n    });\n  }\n  resolveBundle(bundleIds) {\n    const singleAsset = isSingleItem(bundleIds);\n    bundleIds = convertToList(bundleIds);\n    const out = {};\n    bundleIds.forEach((bundleId) => {\n      const assetNames = this._bundles[bundleId];\n      if (assetNames) {\n        const results = this.resolve(assetNames);\n        const assets = {};\n        for (const key in results) {\n          const asset = results[key];\n          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n        }\n        out[bundleId] = assets;\n      }\n    });\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  resolveUrl(key) {\n    const result = this.resolve(key);\n    if (typeof key !== "string") {\n      const out = {};\n      for (const i in result) {\n        out[i] = result[i].src;\n      }\n      return out;\n    }\n    return result.src;\n  }\n  resolve(keys) {\n    const singleAsset = isSingleItem(keys);\n    keys = convertToList(keys);\n    const result = {};\n    keys.forEach((key) => {\n      if (!this._resolverHash[key]) {\n        if (this._assetMap[key]) {\n          let assets = this._assetMap[key];\n          const preferredOrder = this._getPreferredOrder(assets);\n          const bestAsset = assets[0];\n          preferredOrder?.priority.forEach((priorityKey) => {\n            preferredOrder.params[priorityKey].forEach((value) => {\n              const filteredAssets = assets.filter((asset) => {\n                if (asset[priorityKey]) {\n                  return asset[priorityKey] === value;\n                }\n                return false;\n              });\n              if (filteredAssets.length) {\n                assets = filteredAssets;\n              }\n            });\n          });\n          this._resolverHash[key] = assets[0] ?? bestAsset;\n        } else {\n          let src = key;\n          if (this._basePath || this._rootPath) {\n            src = utils_lib.path.toAbsolute(src, this._basePath, this._rootPath);\n          }\n          src = this._appendDefaultSearchParams(src);\n          this._resolverHash[key] = {\n            src\n          };\n        }\n      }\n      result[key] = this._resolverHash[key];\n    });\n    return singleAsset ? result[keys[0]] : result;\n  }\n  hasKey(key) {\n    return !!this._assetMap[key];\n  }\n  hasBundle(key) {\n    return !!this._bundles[key];\n  }\n  _getPreferredOrder(assets) {\n    for (let i = 0; i < assets.length; i++) {\n      const asset = assets[0];\n      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));\n      if (preferred) {\n        return preferred;\n      }\n    }\n    return this._preferredOrder[0];\n  }\n  _appendDefaultSearchParams(url) {\n    if (!this._defaultSearchParams)\n      return url;\n    const paramConnector = /\\?/.test(url) ? "&" : "?";\n    return `${url}${paramConnector}${this._defaultSearchParams}`;\n  }\n}\n\n\n//# sourceMappingURL=Resolver.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/Assets.mjs\n\n\n\n\n\n\n\n\n\n\nclass AssetsClass {\n  constructor() {\n    this._detections = [];\n    this._initialized = false;\n    this.resolver = new Resolver();\n    this.loader = new Loader();\n    this.cache = Cache;\n    this._backgroundLoader = new BackgroundLoader(this.loader);\n    this._backgroundLoader.active = true;\n    this.reset();\n  }\n  async init(options = {}) {\n    if (this._initialized) {\n      console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");\n      return;\n    }\n    this._initialized = true;\n    if (options.defaultSearchParams) {\n      this.resolver.setDefaultSearchParams(options.defaultSearchParams);\n    }\n    if (options.basePath) {\n      this.resolver.basePath = options.basePath;\n    }\n    if (options.bundleIdentifier) {\n      this.resolver.setBundleIdentifier(options.bundleIdentifier);\n    }\n    if (options.manifest) {\n      let manifest = options.manifest;\n      if (typeof manifest === "string") {\n        manifest = await this.load(manifest);\n      }\n      this.resolver.addManifest(manifest);\n    }\n    const resolutionPref = options.texturePreference?.resolution ?? 1;\n    const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;\n    let formats = [];\n    if (options.texturePreference?.format) {\n      const formatPref = options.texturePreference?.format;\n      formats = typeof formatPref === "string" ? [formatPref] : formatPref;\n      for (const detection of this._detections) {\n        if (!await detection.test()) {\n          formats = await detection.remove(formats);\n        }\n      }\n    } else {\n      for (const detection of this._detections) {\n        if (await detection.test()) {\n          formats = await detection.add(formats);\n        }\n      }\n    }\n    this.resolver.prefer({\n      params: {\n        format: formats,\n        resolution\n      }\n    });\n    if (options.preferences) {\n      this.setPreferences(options.preferences);\n    }\n  }\n  add(keysIn, assetsIn, data) {\n    this.resolver.add(keysIn, assetsIn, data);\n  }\n  async load(urls, onProgress) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    const singleAsset = isSingleItem(urls);\n    const urlArray = convertToList(urls).map((url) => {\n      if (typeof url !== "string") {\n        this.resolver.add(url.src, url);\n        return url.src;\n      }\n      if (!this.resolver.hasKey(url)) {\n        this.resolver.add(url, url);\n      }\n      return url;\n    });\n    const resolveResults = this.resolver.resolve(urlArray);\n    const out = await this._mapLoadToResolve(resolveResults, onProgress);\n    return singleAsset ? out[urlArray[0]] : out;\n  }\n  addBundle(bundleId, assets) {\n    this.resolver.addBundle(bundleId, assets);\n  }\n  async loadBundle(bundleIds, onProgress) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    let singleAsset = false;\n    if (typeof bundleIds === "string") {\n      singleAsset = true;\n      bundleIds = [bundleIds];\n    }\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    const out = {};\n    const keys = Object.keys(resolveResults);\n    let count = 0;\n    let total = 0;\n    const _onProgress = () => {\n      onProgress?.(++count / total);\n    };\n    const promises = keys.map((bundleId) => {\n      const resolveResult = resolveResults[bundleId];\n      total += Object.keys(resolveResult).length;\n      return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {\n        out[bundleId] = resolveResult2;\n      });\n    });\n    await Promise.all(promises);\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  async backgroundLoad(urls) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    if (typeof urls === "string") {\n      urls = [urls];\n    }\n    const resolveResults = this.resolver.resolve(urls);\n    this._backgroundLoader.add(Object.values(resolveResults));\n  }\n  async backgroundLoadBundle(bundleIds) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    if (typeof bundleIds === "string") {\n      bundleIds = [bundleIds];\n    }\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    Object.values(resolveResults).forEach((resolveResult) => {\n      this._backgroundLoader.add(Object.values(resolveResult));\n    });\n  }\n  reset() {\n    this.resolver.reset();\n    this.loader.reset();\n    this.cache.reset();\n    this._initialized = false;\n  }\n  get(keys) {\n    if (typeof keys === "string") {\n      return Cache.get(keys);\n    }\n    const assets = {};\n    for (let i = 0; i < keys.length; i++) {\n      assets[i] = Cache.get(keys[i]);\n    }\n    return assets;\n  }\n  async _mapLoadToResolve(resolveResults, onProgress) {\n    const resolveArray = Object.values(resolveResults);\n    const resolveKeys = Object.keys(resolveResults);\n    this._backgroundLoader.active = false;\n    const loadedAssets = await this.loader.load(resolveArray, onProgress);\n    this._backgroundLoader.active = true;\n    const out = {};\n    resolveArray.forEach((resolveResult, i) => {\n      const asset = loadedAssets[resolveResult.src];\n      const keys = [resolveResult.src];\n      if (resolveResult.alias) {\n        keys.push(...resolveResult.alias);\n      }\n      out[resolveKeys[i]] = asset;\n      Cache.set(keys, asset);\n    });\n    return out;\n  }\n  async unload(urls) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    const urlArray = convertToList(urls).map((url) => typeof url !== "string" ? url.src : url);\n    const resolveResults = this.resolver.resolve(urlArray);\n    await this._unloadFromResolved(resolveResults);\n  }\n  async unloadBundle(bundleIds) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    bundleIds = convertToList(bundleIds);\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));\n    await Promise.all(promises);\n  }\n  async _unloadFromResolved(resolveResult) {\n    const resolveArray = Object.values(resolveResult);\n    resolveArray.forEach((resolveResult2) => {\n      Cache.remove(resolveResult2.src);\n    });\n    await this.loader.unload(resolveArray);\n  }\n  get detections() {\n    return this._detections;\n  }\n  get preferWorkers() {\n    return loadTextures.config.preferWorkers;\n  }\n  set preferWorkers(value) {\n    utils_lib.deprecation("7.2.0", "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead.");\n    this.setPreferences({ preferWorkers: value });\n  }\n  setPreferences(preferences) {\n    this.loader.parsers.forEach((parser) => {\n      if (!parser.config)\n        return;\n      Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {\n        parser.config[key] = preferences[key];\n      });\n    });\n  }\n}\nconst Assets = new AssetsClass();\nextensions.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);\n\n\n//# sourceMappingURL=Assets.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/cache/parsers/cacheTextureArray.mjs\n\n\nconst cacheTextureArray = {\n  extension: ExtensionType.CacheParser,\n  test: (asset) => Array.isArray(asset) && asset.every((t) => t instanceof Texture_Texture),\n  getCacheableAssets: (keys, asset) => {\n    const out = {};\n    keys.forEach((key) => {\n      asset.forEach((item, i) => {\n        out[key + (i === 0 ? "" : i + 1)] = item;\n      });\n    });\n    return out;\n  }\n};\nextensions.add(cacheTextureArray);\n\n\n//# sourceMappingURL=cacheTextureArray.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/cache/parsers/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/cache/index.mjs\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/parsers/detectAvif.mjs\n\n\nconst detectAvif = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 1\n  },\n  test: async () => {\n    if (!globalThis.createImageBitmap)\n      return false;\n    const avifData = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=";\n    const blob = await settings_lib/* settings */.Xd.ADAPTER.fetch(avifData).then((r) => r.blob());\n    return createImageBitmap(blob).then(() => true, () => false);\n  },\n  add: async (formats) => [...formats, "avif"],\n  remove: async (formats) => formats.filter((f) => f !== "avif")\n};\nextensions.add(detectAvif);\n\n\n//# sourceMappingURL=detectAvif.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/parsers/detectWebp.mjs\n\n\nconst detectWebp = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 0\n  },\n  test: async () => {\n    if (!globalThis.createImageBitmap)\n      return false;\n    const webpData = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=";\n    const blob = await settings_lib/* settings */.Xd.ADAPTER.fetch(webpData).then((r) => r.blob());\n    return createImageBitmap(blob).then(() => true, () => false);\n  },\n  add: async (formats) => [...formats, "webp"],\n  remove: async (formats) => formats.filter((f) => f !== "webp")\n};\nextensions.add(detectWebp);\n\n\n//# sourceMappingURL=detectWebp.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/parsers/detectDefaults.mjs\n\n\nconst imageFormats = ["png", "jpg", "jpeg"];\nconst detectDefaults = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: -1\n  },\n  test: () => Promise.resolve(true),\n  add: async (formats) => [...formats, ...imageFormats],\n  remove: async (formats) => formats.filter((f) => !imageFormats.includes(f))\n};\nextensions.add(detectDefaults);\n\n\n//# sourceMappingURL=detectDefaults.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/parsers/index.mjs\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/detections/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/loader/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/resolver/parsers/resolveTextureUrl.mjs\n\n\n\n\nconst resolveTextureUrl = {\n  extension: ExtensionType.ResolveParser,\n  test: loadTextures.test,\n  parse: (value) => ({\n    resolution: parseFloat(settings_lib/* settings */.Xd.RETINA_PREFIX.exec(value)?.[1] ?? "1"),\n    format: value.split(".").pop(),\n    src: value\n  })\n};\nextensions.add(resolveTextureUrl);\n\n\n//# sourceMappingURL=resolveTextureUrl.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/resolver/parsers/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/resolver/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/utils/copySearchParams.mjs\nconst copySearchParams = (targetUrl, sourceUrl) => {\n  const searchParams = sourceUrl.split("?")[1];\n  if (searchParams) {\n    targetUrl += `?${searchParams}`;\n  }\n  return targetUrl;\n};\n\n\n//# sourceMappingURL=copySearchParams.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/assets/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/const.mjs\nvar INTERNAL_FORMATS = /* @__PURE__ */ ((INTERNAL_FORMATS2) => {\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";\n  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";\n  return INTERNAL_FORMATS2;\n})(INTERNAL_FORMATS || {});\nconst INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = {\n  [33776 /* COMPRESSED_RGB_S3TC_DXT1_EXT */]: 0.5,\n  [33777 /* COMPRESSED_RGBA_S3TC_DXT1_EXT */]: 0.5,\n  [33778 /* COMPRESSED_RGBA_S3TC_DXT3_EXT */]: 1,\n  [33779 /* COMPRESSED_RGBA_S3TC_DXT5_EXT */]: 1,\n  [35916 /* COMPRESSED_SRGB_S3TC_DXT1_EXT */]: 0.5,\n  [35917 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT */]: 0.5,\n  [35918 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */]: 1,\n  [35919 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */]: 1,\n  [37488 /* COMPRESSED_R11_EAC */]: 0.5,\n  [37489 /* COMPRESSED_SIGNED_R11_EAC */]: 0.5,\n  [37490 /* COMPRESSED_RG11_EAC */]: 1,\n  [37491 /* COMPRESSED_SIGNED_RG11_EAC */]: 1,\n  [37492 /* COMPRESSED_RGB8_ETC2 */]: 0.5,\n  [37496 /* COMPRESSED_RGBA8_ETC2_EAC */]: 1,\n  [37493 /* COMPRESSED_SRGB8_ETC2 */]: 0.5,\n  [37497 /* COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */]: 1,\n  [37494 /* COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */]: 0.5,\n  [37495 /* COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */]: 0.5,\n  [35840 /* COMPRESSED_RGB_PVRTC_4BPPV1_IMG */]: 0.5,\n  [35842 /* COMPRESSED_RGBA_PVRTC_4BPPV1_IMG */]: 0.5,\n  [35841 /* COMPRESSED_RGB_PVRTC_2BPPV1_IMG */]: 0.25,\n  [35843 /* COMPRESSED_RGBA_PVRTC_2BPPV1_IMG */]: 0.25,\n  [36196 /* COMPRESSED_RGB_ETC1_WEBGL */]: 0.5,\n  [35986 /* COMPRESSED_RGB_ATC_WEBGL */]: 0.5,\n  [35986 /* COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL */]: 1,\n  [34798 /* COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL */]: 1,\n  [37808 /* COMPRESSED_RGBA_ASTC_4x4_KHR */]: 1\n};\n\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/loaders/compressedTextureExtensions.mjs\n\n//# sourceMappingURL=compressedTextureExtensions.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/loaders/detectCompressedTextures.mjs\n\n\nlet storedGl;\nlet detectCompressedTextures_extensions;\nfunction getCompressedTextureExtensions() {\n  detectCompressedTextures_extensions = {\n    s3tc: storedGl.getExtension("WEBGL_compressed_texture_s3tc"),\n    s3tc_sRGB: storedGl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),\n    etc: storedGl.getExtension("WEBGL_compressed_texture_etc"),\n    etc1: storedGl.getExtension("WEBGL_compressed_texture_etc1"),\n    pvrtc: storedGl.getExtension("WEBGL_compressed_texture_pvrtc") || storedGl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),\n    atc: storedGl.getExtension("WEBGL_compressed_texture_atc"),\n    astc: storedGl.getExtension("WEBGL_compressed_texture_astc")\n  };\n}\nconst detectCompressedTextures = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 2\n  },\n  test: async () => {\n    const canvas = settings_lib/* settings */.Xd.ADAPTER.createCanvas();\n    const gl = canvas.getContext("webgl");\n    if (!gl) {\n      console.warn("WebGL not available for compressed textures.");\n      return false;\n    }\n    storedGl = gl;\n    return true;\n  },\n  add: async (formats) => {\n    if (!detectCompressedTextures_extensions)\n      getCompressedTextureExtensions();\n    const textureFormats = [];\n    for (const extensionName in detectCompressedTextures_extensions) {\n      const extension = detectCompressedTextures_extensions[extensionName];\n      if (!extension) {\n        continue;\n      }\n      textureFormats.push(extensionName);\n    }\n    return [...textureFormats, ...formats];\n  },\n  remove: async (formats) => {\n    if (!detectCompressedTextures_extensions)\n      getCompressedTextureExtensions();\n    return formats.filter((f) => !(f in detectCompressedTextures_extensions));\n  }\n};\nextensions.add(detectCompressedTextures);\n\n\n//# sourceMappingURL=detectCompressedTextures.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/resources/BlobResource.mjs\n\n\nclass BlobResource extends BufferResource {\n  constructor(source, options = { width: 1, height: 1, autoLoad: true }) {\n    let origin;\n    let data;\n    if (typeof source === "string") {\n      origin = source;\n      data = new Uint8Array();\n    } else {\n      origin = null;\n      data = source;\n    }\n    super(data, options);\n    this.origin = origin;\n    this.buffer = data ? new ViewableBuffer(data) : null;\n    this._load = null;\n    this.loaded = false;\n    if (this.origin !== null && options.autoLoad !== false) {\n      this.load();\n    }\n    if (this.origin === null && this.buffer) {\n      this._load = Promise.resolve(this);\n      this.loaded = true;\n      this.onBlobLoaded(this.buffer.rawBinaryData);\n    }\n  }\n  onBlobLoaded(_data) {\n  }\n  load() {\n    if (this._load) {\n      return this._load;\n    }\n    this._load = fetch(this.origin).then((response) => response.blob()).then((blob) => blob.arrayBuffer()).then((arrayBuffer) => {\n      this.data = new Uint32Array(arrayBuffer);\n      this.buffer = new ViewableBuffer(arrayBuffer);\n      this.loaded = true;\n      this.onBlobLoaded(arrayBuffer);\n      this.update();\n      return this;\n    });\n    return this._load;\n  }\n}\n\n\n//# sourceMappingURL=BlobResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/resources/CompressedTextureResource.mjs\n\n\n\nclass CompressedTextureResource extends BlobResource {\n  constructor(source, options) {\n    super(source, options);\n    this.format = options.format;\n    this.levels = options.levels || 1;\n    this._width = options.width;\n    this._height = options.height;\n    this._extension = CompressedTextureResource._formatToExtension(this.format);\n    if (options.levelBuffers || this.buffer) {\n      this._levelBuffers = options.levelBuffers || CompressedTextureResource._createLevelBuffers(source instanceof Uint8Array ? source : this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);\n    }\n  }\n  upload(renderer, _texture, _glTexture) {\n    const gl = renderer.gl;\n    const extension = renderer.context.extensions[this._extension];\n    if (!extension) {\n      throw new Error(`${this._extension} textures are not supported on the current machine`);\n    }\n    if (!this._levelBuffers) {\n      return false;\n    }\n    for (let i = 0, j = this.levels; i < j; i++) {\n      const { levelID, levelWidth, levelHeight, levelBuffer } = this._levelBuffers[i];\n      gl.compressedTexImage2D(gl.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);\n    }\n    return true;\n  }\n  onBlobLoaded() {\n    this._levelBuffers = CompressedTextureResource._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);\n  }\n  static _formatToExtension(format) {\n    if (format >= 33776 && format <= 33779) {\n      return "s3tc";\n    } else if (format >= 37488 && format <= 37497) {\n      return "etc";\n    } else if (format >= 35840 && format <= 35843) {\n      return "pvrtc";\n    } else if (format >= 36196) {\n      return "etc1";\n    } else if (format >= 35986 && format <= 34798) {\n      return "atc";\n    }\n    throw new Error("Invalid (compressed) texture format given!");\n  }\n  static _createLevelBuffers(buffer, format, levels, blockWidth, blockHeight, imageWidth, imageHeight) {\n    const buffers = new Array(levels);\n    let offset = buffer.byteOffset;\n    let levelWidth = imageWidth;\n    let levelHeight = imageHeight;\n    let alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);\n    let alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);\n    let levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format];\n    for (let i = 0; i < levels; i++) {\n      buffers[i] = {\n        levelID: i,\n        levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,\n        levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,\n        levelBuffer: new Uint8Array(buffer.buffer, offset, levelSize)\n      };\n      offset += levelSize;\n      levelWidth = levelWidth >> 1 || 1;\n      levelHeight = levelHeight >> 1 || 1;\n      alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);\n      alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);\n      levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format];\n    }\n    return buffers;\n  }\n}\n\n\n//# sourceMappingURL=CompressedTextureResource.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/resources/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/parsers/parseDDS.mjs\n\n\n\n\nconst DDS_MAGIC_SIZE = 4;\nconst DDS_HEADER_SIZE = 124;\nconst DDS_HEADER_PF_SIZE = 32;\nconst DDS_HEADER_DX10_SIZE = 20;\nconst DDS_MAGIC = 542327876;\nconst DDS_FIELDS = {\n  SIZE: 1,\n  FLAGS: 2,\n  HEIGHT: 3,\n  WIDTH: 4,\n  MIPMAP_COUNT: 7,\n  PIXEL_FORMAT: 19\n};\nconst DDS_PF_FIELDS = {\n  SIZE: 0,\n  FLAGS: 1,\n  FOURCC: 2,\n  RGB_BITCOUNT: 3,\n  R_BIT_MASK: 4,\n  G_BIT_MASK: 5,\n  B_BIT_MASK: 6,\n  A_BIT_MASK: 7\n};\nconst DDS_DX10_FIELDS = {\n  DXGI_FORMAT: 0,\n  RESOURCE_DIMENSION: 1,\n  MISC_FLAG: 2,\n  ARRAY_SIZE: 3,\n  MISC_FLAGS2: 4\n};\nvar DXGI_FORMAT = /* @__PURE__ */ ((DXGI_FORMAT2) => {\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_UNKNOWN"] = 0] = "DXGI_FORMAT_UNKNOWN";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_TYPELESS"] = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_FLOAT"] = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_UINT"] = 3] = "DXGI_FORMAT_R32G32B32A32_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_SINT"] = 4] = "DXGI_FORMAT_R32G32B32A32_SINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_TYPELESS"] = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_FLOAT"] = 6] = "DXGI_FORMAT_R32G32B32_FLOAT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_UINT"] = 7] = "DXGI_FORMAT_R32G32B32_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_SINT"] = 8] = "DXGI_FORMAT_R32G32B32_SINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_TYPELESS"] = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_FLOAT"] = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UNORM"] = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UINT"] = 12] = "DXGI_FORMAT_R16G16B16A16_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SNORM"] = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SINT"] = 14] = "DXGI_FORMAT_R16G16B16A16_SINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_TYPELESS"] = 15] = "DXGI_FORMAT_R32G32_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_FLOAT"] = 16] = "DXGI_FORMAT_R32G32_FLOAT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_UINT"] = 17] = "DXGI_FORMAT_R32G32_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_SINT"] = 18] = "DXGI_FORMAT_R32G32_SINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G8X24_TYPELESS"] = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT_S8X24_UINT"] = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS"] = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X32_TYPELESS_G8X24_UINT"] = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_TYPELESS"] = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UNORM"] = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UINT"] = 25] = "DXGI_FORMAT_R10G10B10A2_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R11G11B10_FLOAT"] = 26] = "DXGI_FORMAT_R11G11B10_FLOAT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_TYPELESS"] = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM"] = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM_SRGB"] = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UINT"] = 30] = "DXGI_FORMAT_R8G8B8A8_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SNORM"] = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SINT"] = 32] = "DXGI_FORMAT_R8G8B8A8_SINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_TYPELESS"] = 33] = "DXGI_FORMAT_R16G16_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_FLOAT"] = 34] = "DXGI_FORMAT_R16G16_FLOAT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UNORM"] = 35] = "DXGI_FORMAT_R16G16_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UINT"] = 36] = "DXGI_FORMAT_R16G16_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SNORM"] = 37] = "DXGI_FORMAT_R16G16_SNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SINT"] = 38] = "DXGI_FORMAT_R16G16_SINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_TYPELESS"] = 39] = "DXGI_FORMAT_R32_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT"] = 40] = "DXGI_FORMAT_D32_FLOAT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT"] = 41] = "DXGI_FORMAT_R32_FLOAT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_UINT"] = 42] = "DXGI_FORMAT_R32_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_SINT"] = 43] = "DXGI_FORMAT_R32_SINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24G8_TYPELESS"] = 44] = "DXGI_FORMAT_R24G8_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D24_UNORM_S8_UINT"] = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24_UNORM_X8_TYPELESS"] = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X24_TYPELESS_G8_UINT"] = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_TYPELESS"] = 48] = "DXGI_FORMAT_R8G8_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UNORM"] = 49] = "DXGI_FORMAT_R8G8_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UINT"] = 50] = "DXGI_FORMAT_R8G8_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SNORM"] = 51] = "DXGI_FORMAT_R8G8_SNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SINT"] = 52] = "DXGI_FORMAT_R8G8_SINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_TYPELESS"] = 53] = "DXGI_FORMAT_R16_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_FLOAT"] = 54] = "DXGI_FORMAT_R16_FLOAT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D16_UNORM"] = 55] = "DXGI_FORMAT_D16_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UNORM"] = 56] = "DXGI_FORMAT_R16_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UINT"] = 57] = "DXGI_FORMAT_R16_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SNORM"] = 58] = "DXGI_FORMAT_R16_SNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SINT"] = 59] = "DXGI_FORMAT_R16_SINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_TYPELESS"] = 60] = "DXGI_FORMAT_R8_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UNORM"] = 61] = "DXGI_FORMAT_R8_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UINT"] = 62] = "DXGI_FORMAT_R8_UINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SNORM"] = 63] = "DXGI_FORMAT_R8_SNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SINT"] = 64] = "DXGI_FORMAT_R8_SINT";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8_UNORM"] = 65] = "DXGI_FORMAT_A8_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R1_UNORM"] = 66] = "DXGI_FORMAT_R1_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R9G9B9E5_SHAREDEXP"] = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_B8G8_UNORM"] = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_G8R8_G8B8_UNORM"] = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_TYPELESS"] = 70] = "DXGI_FORMAT_BC1_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM"] = 71] = "DXGI_FORMAT_BC1_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM_SRGB"] = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_TYPELESS"] = 73] = "DXGI_FORMAT_BC2_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM"] = 74] = "DXGI_FORMAT_BC2_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM_SRGB"] = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_TYPELESS"] = 76] = "DXGI_FORMAT_BC3_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM"] = 77] = "DXGI_FORMAT_BC3_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM_SRGB"] = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_TYPELESS"] = 79] = "DXGI_FORMAT_BC4_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_UNORM"] = 80] = "DXGI_FORMAT_BC4_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_SNORM"] = 81] = "DXGI_FORMAT_BC4_SNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_TYPELESS"] = 82] = "DXGI_FORMAT_BC5_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_UNORM"] = 83] = "DXGI_FORMAT_BC5_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_SNORM"] = 84] = "DXGI_FORMAT_BC5_SNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G6R5_UNORM"] = 85] = "DXGI_FORMAT_B5G6R5_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G5R5A1_UNORM"] = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM"] = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM"] = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM"] = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_TYPELESS"] = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM_SRGB"] = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_TYPELESS"] = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM_SRGB"] = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_TYPELESS"] = 94] = "DXGI_FORMAT_BC6H_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_UF16"] = 95] = "DXGI_FORMAT_BC6H_UF16";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_SF16"] = 96] = "DXGI_FORMAT_BC6H_SF16";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_TYPELESS"] = 97] = "DXGI_FORMAT_BC7_TYPELESS";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM"] = 98] = "DXGI_FORMAT_BC7_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM_SRGB"] = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AYUV"] = 100] = "DXGI_FORMAT_AYUV";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y410"] = 101] = "DXGI_FORMAT_Y410";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y416"] = 102] = "DXGI_FORMAT_Y416";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV12"] = 103] = "DXGI_FORMAT_NV12";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P010"] = 104] = "DXGI_FORMAT_P010";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P016"] = 105] = "DXGI_FORMAT_P016";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_420_OPAQUE"] = 106] = "DXGI_FORMAT_420_OPAQUE";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_YUY2"] = 107] = "DXGI_FORMAT_YUY2";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y210"] = 108] = "DXGI_FORMAT_Y210";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y216"] = 109] = "DXGI_FORMAT_Y216";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV11"] = 110] = "DXGI_FORMAT_NV11";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AI44"] = 111] = "DXGI_FORMAT_AI44";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_IA44"] = 112] = "DXGI_FORMAT_IA44";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P8"] = 113] = "DXGI_FORMAT_P8";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8P8"] = 114] = "DXGI_FORMAT_A8P8";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B4G4R4A4_UNORM"] = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P208"] = 116] = "DXGI_FORMAT_P208";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V208"] = 117] = "DXGI_FORMAT_V208";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V408"] = 118] = "DXGI_FORMAT_V408";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE"] = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE"] = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE";\n  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_FORCE_UINT"] = 121] = "DXGI_FORMAT_FORCE_UINT";\n  return DXGI_FORMAT2;\n})(DXGI_FORMAT || {});\nvar D3D10_RESOURCE_DIMENSION = /* @__PURE__ */ ((D3D10_RESOURCE_DIMENSION2) => {\n  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE1D"] = 2] = "DDS_DIMENSION_TEXTURE1D";\n  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE2D"] = 3] = "DDS_DIMENSION_TEXTURE2D";\n  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE3D"] = 6] = "DDS_DIMENSION_TEXTURE3D";\n  return D3D10_RESOURCE_DIMENSION2;\n})(D3D10_RESOURCE_DIMENSION || {});\nconst PF_FLAGS = 1;\nconst DDPF_ALPHA = 2;\nconst DDPF_FOURCC = 4;\nconst DDPF_RGB = 64;\nconst DDPF_YUV = 512;\nconst DDPF_LUMINANCE = 131072;\nconst FOURCC_DXT1 = 827611204;\nconst FOURCC_DXT3 = 861165636;\nconst FOURCC_DXT5 = 894720068;\nconst FOURCC_DX10 = 808540228;\nconst DDS_RESOURCE_MISC_TEXTURECUBE = 4;\nconst FOURCC_TO_FORMAT = {\n  [FOURCC_DXT1]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n  [FOURCC_DXT3]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n  [FOURCC_DXT5]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT\n};\nconst DXGI_TO_FORMAT = {\n  [70 /* DXGI_FORMAT_BC1_TYPELESS */]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n  [71 /* DXGI_FORMAT_BC1_UNORM */]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n  [73 /* DXGI_FORMAT_BC2_TYPELESS */]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n  [74 /* DXGI_FORMAT_BC2_UNORM */]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n  [76 /* DXGI_FORMAT_BC3_TYPELESS */]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n  [77 /* DXGI_FORMAT_BC3_UNORM */]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n  [72 /* DXGI_FORMAT_BC1_UNORM_SRGB */]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,\n  [75 /* DXGI_FORMAT_BC2_UNORM_SRGB */]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,\n  [78 /* DXGI_FORMAT_BC3_UNORM_SRGB */]: INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT\n};\nfunction parseDDS(arrayBuffer) {\n  const data = new Uint32Array(arrayBuffer);\n  const magicWord = data[0];\n  if (magicWord !== DDS_MAGIC) {\n    throw new Error("Invalid DDS file magic word");\n  }\n  const header = new Uint32Array(arrayBuffer, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);\n  const height = header[DDS_FIELDS.HEIGHT];\n  const width = header[DDS_FIELDS.WIDTH];\n  const mipmapCount = header[DDS_FIELDS.MIPMAP_COUNT];\n  const pixelFormat = new Uint32Array(arrayBuffer, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT);\n  const formatFlags = pixelFormat[PF_FLAGS];\n  if (formatFlags & DDPF_FOURCC) {\n    const fourCC = pixelFormat[DDS_PF_FIELDS.FOURCC];\n    if (fourCC !== FOURCC_DX10) {\n      const internalFormat2 = FOURCC_TO_FORMAT[fourCC];\n      const dataOffset2 = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;\n      const texData = new Uint8Array(arrayBuffer, dataOffset2);\n      const resource = new CompressedTextureResource(texData, {\n        format: internalFormat2,\n        width,\n        height,\n        levels: mipmapCount\n      });\n      return [resource];\n    }\n    const dx10Offset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;\n    const dx10Header = new Uint32Array(data.buffer, dx10Offset, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);\n    const dxgiFormat = dx10Header[DDS_DX10_FIELDS.DXGI_FORMAT];\n    const resourceDimension = dx10Header[DDS_DX10_FIELDS.RESOURCE_DIMENSION];\n    const miscFlag = dx10Header[DDS_DX10_FIELDS.MISC_FLAG];\n    const arraySize = dx10Header[DDS_DX10_FIELDS.ARRAY_SIZE];\n    const internalFormat = DXGI_TO_FORMAT[dxgiFormat];\n    if (internalFormat === void 0) {\n      throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);\n    }\n    if (miscFlag === DDS_RESOURCE_MISC_TEXTURECUBE) {\n      throw new Error("DDSParser does not support cubemap textures");\n    }\n    if (resourceDimension === 6 /* DDS_DIMENSION_TEXTURE3D */) {\n      throw new Error("DDSParser does not supported 3D texture data");\n    }\n    const imageBuffers = new Array();\n    const dataOffset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;\n    if (arraySize === 1) {\n      imageBuffers.push(new Uint8Array(arrayBuffer, dataOffset));\n    } else {\n      const pixelSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[internalFormat];\n      let imageSize = 0;\n      let levelWidth = width;\n      let levelHeight = height;\n      for (let i = 0; i < mipmapCount; i++) {\n        const alignedLevelWidth = Math.max(1, levelWidth + 3 & ~3);\n        const alignedLevelHeight = Math.max(1, levelHeight + 3 & ~3);\n        const levelSize = alignedLevelWidth * alignedLevelHeight * pixelSize;\n        imageSize += levelSize;\n        levelWidth = levelWidth >>> 1;\n        levelHeight = levelHeight >>> 1;\n      }\n      let imageOffset = dataOffset;\n      for (let i = 0; i < arraySize; i++) {\n        imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize));\n        imageOffset += imageSize;\n      }\n    }\n    return imageBuffers.map((buffer) => new CompressedTextureResource(buffer, {\n      format: internalFormat,\n      width,\n      height,\n      levels: mipmapCount\n    }));\n  }\n  if (formatFlags & DDPF_RGB) {\n    throw new Error("DDSParser does not support uncompressed texture data.");\n  }\n  if (formatFlags & DDPF_YUV) {\n    throw new Error("DDSParser does not supported YUV uncompressed texture data.");\n  }\n  if (formatFlags & DDPF_LUMINANCE) {\n    throw new Error("DDSParser does not support single-channel (lumninance) texture data!");\n  }\n  if (formatFlags & DDPF_ALPHA) {\n    throw new Error("DDSParser does not support single-channel (alpha) texture data!");\n  }\n  throw new Error("DDSParser failed to load a texture file due to an unknown reason!");\n}\n\n\n//# sourceMappingURL=parseDDS.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/parsers/parseKTX.mjs\n\n\n\n\n\nconst FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];\nconst ENDIANNESS = 67305985;\nconst KTX_FIELDS = {\n  FILE_IDENTIFIER: 0,\n  ENDIANNESS: 12,\n  GL_TYPE: 16,\n  GL_TYPE_SIZE: 20,\n  GL_FORMAT: 24,\n  GL_INTERNAL_FORMAT: 28,\n  GL_BASE_INTERNAL_FORMAT: 32,\n  PIXEL_WIDTH: 36,\n  PIXEL_HEIGHT: 40,\n  PIXEL_DEPTH: 44,\n  NUMBER_OF_ARRAY_ELEMENTS: 48,\n  NUMBER_OF_FACES: 52,\n  NUMBER_OF_MIPMAP_LEVELS: 56,\n  BYTES_OF_KEY_VALUE_DATA: 60\n};\nconst FILE_HEADER_SIZE = 64;\nconst TYPES_TO_BYTES_PER_COMPONENT = {\n  [lib/* TYPES */.vK.UNSIGNED_BYTE]: 1,\n  [lib/* TYPES */.vK.UNSIGNED_SHORT]: 2,\n  [lib/* TYPES */.vK.INT]: 4,\n  [lib/* TYPES */.vK.UNSIGNED_INT]: 4,\n  [lib/* TYPES */.vK.FLOAT]: 4,\n  [lib/* TYPES */.vK.HALF_FLOAT]: 8\n};\nconst FORMATS_TO_COMPONENTS = {\n  [lib/* FORMATS */.I2.RGBA]: 4,\n  [lib/* FORMATS */.I2.RGB]: 3,\n  [lib/* FORMATS */.I2.RG]: 2,\n  [lib/* FORMATS */.I2.RED]: 1,\n  [lib/* FORMATS */.I2.LUMINANCE]: 1,\n  [lib/* FORMATS */.I2.LUMINANCE_ALPHA]: 2,\n  [lib/* FORMATS */.I2.ALPHA]: 1\n};\nconst TYPES_TO_BYTES_PER_PIXEL = {\n  [lib/* TYPES */.vK.UNSIGNED_SHORT_4_4_4_4]: 2,\n  [lib/* TYPES */.vK.UNSIGNED_SHORT_5_5_5_1]: 2,\n  [lib/* TYPES */.vK.UNSIGNED_SHORT_5_6_5]: 2\n};\nfunction parseKTX(url, arrayBuffer, loadKeyValueData = false) {\n  const dataView = new DataView(arrayBuffer);\n  if (!validate(url, dataView)) {\n    return null;\n  }\n  const littleEndian = dataView.getUint32(KTX_FIELDS.ENDIANNESS, true) === ENDIANNESS;\n  const glType = dataView.getUint32(KTX_FIELDS.GL_TYPE, littleEndian);\n  const glFormat = dataView.getUint32(KTX_FIELDS.GL_FORMAT, littleEndian);\n  const glInternalFormat = dataView.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, littleEndian);\n  const pixelWidth = dataView.getUint32(KTX_FIELDS.PIXEL_WIDTH, littleEndian);\n  const pixelHeight = dataView.getUint32(KTX_FIELDS.PIXEL_HEIGHT, littleEndian) || 1;\n  const pixelDepth = dataView.getUint32(KTX_FIELDS.PIXEL_DEPTH, littleEndian) || 1;\n  const numberOfArrayElements = dataView.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;\n  const numberOfFaces = dataView.getUint32(KTX_FIELDS.NUMBER_OF_FACES, littleEndian);\n  const numberOfMipmapLevels = dataView.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);\n  const bytesOfKeyValueData = dataView.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);\n  if (pixelHeight === 0 || pixelDepth !== 1) {\n    throw new Error("Only 2D textures are supported");\n  }\n  if (numberOfFaces !== 1) {\n    throw new Error("CubeTextures are not supported by KTXLoader yet!");\n  }\n  if (numberOfArrayElements !== 1) {\n    throw new Error("WebGL does not support array textures");\n  }\n  const blockWidth = 4;\n  const blockHeight = 4;\n  const alignedWidth = pixelWidth + 3 & ~3;\n  const alignedHeight = pixelHeight + 3 & ~3;\n  const imageBuffers = new Array(numberOfArrayElements);\n  let imagePixels = pixelWidth * pixelHeight;\n  if (glType === 0) {\n    imagePixels = alignedWidth * alignedHeight;\n  }\n  let imagePixelByteSize;\n  if (glType !== 0) {\n    if (TYPES_TO_BYTES_PER_COMPONENT[glType]) {\n      imagePixelByteSize = TYPES_TO_BYTES_PER_COMPONENT[glType] * FORMATS_TO_COMPONENTS[glFormat];\n    } else {\n      imagePixelByteSize = TYPES_TO_BYTES_PER_PIXEL[glType];\n    }\n  } else {\n    imagePixelByteSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];\n  }\n  if (imagePixelByteSize === void 0) {\n    throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");\n  }\n  const kvData = loadKeyValueData ? parseKvData(dataView, bytesOfKeyValueData, littleEndian) : null;\n  const imageByteSize = imagePixels * imagePixelByteSize;\n  let mipByteSize = imageByteSize;\n  let mipWidth = pixelWidth;\n  let mipHeight = pixelHeight;\n  let alignedMipWidth = alignedWidth;\n  let alignedMipHeight = alignedHeight;\n  let imageOffset = FILE_HEADER_SIZE + bytesOfKeyValueData;\n  for (let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {\n    const imageSize = dataView.getUint32(imageOffset, littleEndian);\n    let elementOffset = imageOffset + 4;\n    for (let arrayElement = 0; arrayElement < numberOfArrayElements; arrayElement++) {\n      let mips = imageBuffers[arrayElement];\n      if (!mips) {\n        mips = imageBuffers[arrayElement] = new Array(numberOfMipmapLevels);\n      }\n      mips[mipmapLevel] = {\n        levelID: mipmapLevel,\n        levelWidth: numberOfMipmapLevels > 1 || glType !== 0 ? mipWidth : alignedMipWidth,\n        levelHeight: numberOfMipmapLevels > 1 || glType !== 0 ? mipHeight : alignedMipHeight,\n        levelBuffer: new Uint8Array(arrayBuffer, elementOffset, mipByteSize)\n      };\n      elementOffset += mipByteSize;\n    }\n    imageOffset += imageSize + 4;\n    imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;\n    mipWidth = mipWidth >> 1 || 1;\n    mipHeight = mipHeight >> 1 || 1;\n    alignedMipWidth = mipWidth + blockWidth - 1 & ~(blockWidth - 1);\n    alignedMipHeight = mipHeight + blockHeight - 1 & ~(blockHeight - 1);\n    mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;\n  }\n  if (glType !== 0) {\n    return {\n      uncompressed: imageBuffers.map((levelBuffers) => {\n        let buffer = levelBuffers[0].levelBuffer;\n        let convertToInt = false;\n        if (glType === lib/* TYPES */.vK.FLOAT) {\n          buffer = new Float32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);\n        } else if (glType === lib/* TYPES */.vK.UNSIGNED_INT) {\n          convertToInt = true;\n          buffer = new Uint32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);\n        } else if (glType === lib/* TYPES */.vK.INT) {\n          convertToInt = true;\n          buffer = new Int32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);\n        }\n        return {\n          resource: new BufferResource(buffer, {\n            width: levelBuffers[0].levelWidth,\n            height: levelBuffers[0].levelHeight\n          }),\n          type: glType,\n          format: convertToInt ? convertFormatToInteger(glFormat) : glFormat\n        };\n      }),\n      kvData\n    };\n  }\n  return {\n    compressed: imageBuffers.map((levelBuffers) => new CompressedTextureResource(null, {\n      format: glInternalFormat,\n      width: pixelWidth,\n      height: pixelHeight,\n      levels: numberOfMipmapLevels,\n      levelBuffers\n    })),\n    kvData\n  };\n}\nfunction validate(url, dataView) {\n  for (let i = 0; i < FILE_IDENTIFIER.length; i++) {\n    if (dataView.getUint8(i) !== FILE_IDENTIFIER[i]) {\n      console.error(`${url} is not a valid *.ktx file!`);\n      return false;\n    }\n  }\n  return true;\n}\nfunction convertFormatToInteger(format) {\n  switch (format) {\n    case lib/* FORMATS */.I2.RGBA:\n      return lib/* FORMATS */.I2.RGBA_INTEGER;\n    case lib/* FORMATS */.I2.RGB:\n      return lib/* FORMATS */.I2.RGB_INTEGER;\n    case lib/* FORMATS */.I2.RG:\n      return lib/* FORMATS */.I2.RG_INTEGER;\n    case lib/* FORMATS */.I2.RED:\n      return lib/* FORMATS */.I2.RED_INTEGER;\n    default:\n      return format;\n  }\n}\nfunction parseKvData(dataView, bytesOfKeyValueData, littleEndian) {\n  const kvData = /* @__PURE__ */ new Map();\n  let bytesIntoKeyValueData = 0;\n  while (bytesIntoKeyValueData < bytesOfKeyValueData) {\n    const keyAndValueByteSize = dataView.getUint32(FILE_HEADER_SIZE + bytesIntoKeyValueData, littleEndian);\n    const keyAndValueByteOffset = FILE_HEADER_SIZE + bytesIntoKeyValueData + 4;\n    const valuePadding = 3 - (keyAndValueByteSize + 3) % 4;\n    if (keyAndValueByteSize === 0 || keyAndValueByteSize > bytesOfKeyValueData - bytesIntoKeyValueData) {\n      console.error("KTXLoader: keyAndValueByteSize out of bounds");\n      break;\n    }\n    let keyNulByte = 0;\n    for (; keyNulByte < keyAndValueByteSize; keyNulByte++) {\n      if (dataView.getUint8(keyAndValueByteOffset + keyNulByte) === 0) {\n        break;\n      }\n    }\n    if (keyNulByte === -1) {\n      console.error("KTXLoader: Failed to find null byte terminating kvData key");\n      break;\n    }\n    const key = new TextDecoder().decode(new Uint8Array(dataView.buffer, keyAndValueByteOffset, keyNulByte));\n    const value = new DataView(dataView.buffer, keyAndValueByteOffset + keyNulByte + 1, keyAndValueByteSize - keyNulByte - 1);\n    kvData.set(key, value);\n    bytesIntoKeyValueData += 4 + keyAndValueByteSize + valuePadding;\n  }\n  return kvData;\n}\n\n\n//# sourceMappingURL=parseKTX.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/parsers/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/loaders/loadDDS.mjs\n\n\n\n\n\nconst loadDDS = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.High\n  },\n  name: "loadDDS",\n  test(url) {\n    return checkExtension(url, ".dds");\n  },\n  async load(url, asset, loader) {\n    const response = await settings_lib/* settings */.Xd.ADAPTER.fetch(url);\n    const arrayBuffer = await response.arrayBuffer();\n    const resources = parseDDS(arrayBuffer);\n    const textures = resources.map((resource) => {\n      const base = new BaseTexture(resource, {\n        mipmap: lib/* MIPMAP_MODES */.WB.OFF,\n        alphaMode: lib/* ALPHA_MODES */.iw.NO_PREMULTIPLIED_ALPHA,\n        resolution: utils_lib.getResolutionOfUrl(url),\n        ...asset.data\n      });\n      return createTexture(base, loader, url);\n    });\n    return textures.length === 1 ? textures[0] : textures;\n  },\n  unload(texture) {\n    if (Array.isArray(texture)) {\n      texture.forEach((t) => t.destroy(true));\n    } else {\n      texture.destroy(true);\n    }\n  }\n};\nextensions.add(loadDDS);\n\n\n//# sourceMappingURL=loadDDS.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/loaders/loadKTX.mjs\n\n\n\n\n\nconst loadKTX = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.High\n  },\n  name: "loadKTX",\n  test(url) {\n    return checkExtension(url, ".ktx");\n  },\n  async load(url, asset, loader) {\n    const response = await settings_lib/* settings */.Xd.ADAPTER.fetch(url);\n    const arrayBuffer = await response.arrayBuffer();\n    const { compressed, uncompressed, kvData } = parseKTX(url, arrayBuffer);\n    const resources = compressed ?? uncompressed;\n    const options = {\n      mipmap: lib/* MIPMAP_MODES */.WB.OFF,\n      alphaMode: lib/* ALPHA_MODES */.iw.NO_PREMULTIPLIED_ALPHA,\n      resolution: utils_lib.getResolutionOfUrl(url),\n      ...asset.data\n    };\n    const textures = resources.map((resource) => {\n      if (resources === uncompressed) {\n        Object.assign(options, {\n          type: resource.type,\n          format: resource.format\n        });\n      }\n      const base = new BaseTexture(resource, options);\n      base.ktxKeyValueData = kvData;\n      return createTexture(base, loader, url);\n    });\n    return textures.length === 1 ? textures[0] : textures;\n  },\n  unload(texture) {\n    if (Array.isArray(texture)) {\n      texture.forEach((t) => t.destroy(true));\n    } else {\n      texture.destroy(true);\n    }\n  }\n};\nextensions.add(loadKTX);\n\n\n//# sourceMappingURL=loadKTX.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/loaders/resolveCompressedTextureUrl.mjs\n\n\nconst resolveCompressedTextureUrl = {\n  extension: ExtensionType.ResolveParser,\n  test: (value) => {\n    const temp = value.split("?")[0];\n    const extension = temp.split(".").pop();\n    return ["basis", "ktx", "dds"].includes(extension);\n  },\n  parse: (value) => {\n    const temp = value.split("?")[0];\n    const extension = temp.split(".").pop();\n    if (extension === "ktx") {\n      const extensions2 = [\n        ".s3tc.ktx",\n        ".s3tc_sRGB.ktx",\n        ".etc.ktx",\n        ".etc1.ktx",\n        ".pvrt.ktx",\n        ".atc.ktx",\n        ".astc.ktx"\n      ];\n      if (extensions2.some((ext) => value.endsWith(ext))) {\n        return {\n          resolution: parseFloat(settings_lib/* settings */.Xd.RETINA_PREFIX.exec(value)?.[1] ?? "1"),\n          format: extensions2.find((ext) => value.endsWith(ext)),\n          src: value\n        };\n      }\n    }\n    return {\n      resolution: parseFloat(settings_lib/* settings */.Xd.RETINA_PREFIX.exec(value)?.[1] ?? "1"),\n      format: value.split(".").pop(),\n      src: value\n    };\n  }\n};\nextensions.add(resolveCompressedTextureUrl);\n\n\n//# sourceMappingURL=resolveCompressedTextureUrl.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/loaders/index.mjs\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/compressed-textures/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/extract/lib/Extract.mjs\n\n\nconst TEMP_RECT = new Rectangle_Rectangle();\nconst BYTES_PER_PIXEL = 4;\nconst _Extract = class {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n  async image(target, format, quality) {\n    const image = new Image();\n    image.src = await this.base64(target, format, quality);\n    return image;\n  }\n  async base64(target, format, quality) {\n    const canvas = this.canvas(target);\n    if (canvas.toBlob !== void 0) {\n      return new Promise((resolve, reject) => {\n        canvas.toBlob((blob) => {\n          if (!blob) {\n            reject(new Error("ICanvas.toBlob failed!"));\n            return;\n          }\n          const reader = new FileReader();\n          reader.onload = () => resolve(reader.result);\n          reader.onerror = reject;\n          reader.readAsDataURL(blob);\n        }, format, quality);\n      });\n    }\n    if (canvas.toDataURL !== void 0) {\n      return canvas.toDataURL(format, quality);\n    }\n    if (canvas.convertToBlob !== void 0) {\n      const blob = await canvas.convertToBlob({ type: format, quality });\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n      });\n    }\n    throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");\n  }\n  canvas(target, frame) {\n    const { pixels, width, height, flipY } = this._rawPixels(target, frame);\n    if (flipY) {\n      _Extract._flipY(pixels, width, height);\n    }\n    _Extract._unpremultiplyAlpha(pixels);\n    const canvasBuffer = new utils_lib.CanvasRenderTarget(width, height, 1);\n    const imageData = new ImageData(new Uint8ClampedArray(pixels.buffer), width, height);\n    canvasBuffer.context.putImageData(imageData, 0, 0);\n    return canvasBuffer.canvas;\n  }\n  pixels(target, frame) {\n    const { pixels, width, height, flipY } = this._rawPixels(target, frame);\n    if (flipY) {\n      _Extract._flipY(pixels, width, height);\n    }\n    _Extract._unpremultiplyAlpha(pixels);\n    return pixels;\n  }\n  _rawPixels(target, frame) {\n    const renderer = this.renderer;\n    if (!renderer) {\n      throw new Error("The Extract has already been destroyed");\n    }\n    let resolution;\n    let flipY = false;\n    let renderTexture;\n    let generated = false;\n    if (target) {\n      if (target instanceof RenderTexture) {\n        renderTexture = target;\n      } else {\n        renderTexture = renderer.generateTexture(target, {\n          resolution: renderer.resolution,\n          multisample: renderer.multisample\n        });\n        generated = true;\n      }\n    }\n    if (renderTexture) {\n      resolution = renderTexture.baseTexture.resolution;\n      frame = frame ?? renderTexture.frame;\n      flipY = false;\n      if (!generated) {\n        renderer.renderTexture.bind(renderTexture);\n        const fbo = renderTexture.framebuffer.glFramebuffers[renderer.CONTEXT_UID];\n        if (fbo.blitFramebuffer) {\n          renderer.framebuffer.bind(fbo.blitFramebuffer);\n        }\n      }\n    } else {\n      resolution = renderer.resolution;\n      if (!frame) {\n        frame = TEMP_RECT;\n        frame.width = renderer.width / resolution;\n        frame.height = renderer.height / resolution;\n      }\n      flipY = true;\n      renderer.renderTexture.bind();\n    }\n    const width = Math.round(frame.width * resolution);\n    const height = Math.round(frame.height * resolution);\n    const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n    const gl = renderer.gl;\n    gl.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n    if (generated) {\n      renderTexture?.destroy(true);\n    }\n    return { pixels, width, height, flipY };\n  }\n  destroy() {\n    this.renderer = null;\n  }\n  static _flipY(pixels, width, height) {\n    const w = width << 2;\n    const h = height >> 1;\n    const temp = new Uint8Array(w);\n    for (let y = 0; y < h; y++) {\n      const t = y * w;\n      const b = (height - y - 1) * w;\n      temp.set(pixels.subarray(t, t + w));\n      pixels.copyWithin(t, b, b + w);\n      pixels.set(temp, b);\n    }\n  }\n  static _unpremultiplyAlpha(pixels) {\n    if (pixels instanceof Uint8ClampedArray) {\n      pixels = new Uint8Array(pixels.buffer);\n    }\n    const n = pixels.length;\n    for (let i = 0; i < n; i += 4) {\n      const alpha = pixels[i + 3];\n      if (alpha !== 0) {\n        const a = 255.001 / alpha;\n        pixels[i] = pixels[i] * a + 0.5;\n        pixels[i + 1] = pixels[i + 1] * a + 0.5;\n        pixels[i + 2] = pixels[i + 2] * a + 0.5;\n      }\n    }\n  }\n};\nlet Extract = _Extract;\nExtract.extension = {\n  name: "extract",\n  type: ExtensionType.RendererSystem\n};\nextensions.add(Extract);\n\n\n//# sourceMappingURL=Extract.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/extract/lib/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/buildCircle.mjs\n\n\nconst buildCircle = {\n  build(graphicsData) {\n    const points = graphicsData.points;\n    let x;\n    let y;\n    let dx;\n    let dy;\n    let rx;\n    let ry;\n    if (graphicsData.type === SHAPES.CIRC) {\n      const circle = graphicsData.shape;\n      x = circle.x;\n      y = circle.y;\n      rx = ry = circle.radius;\n      dx = dy = 0;\n    } else if (graphicsData.type === SHAPES.ELIP) {\n      const ellipse = graphicsData.shape;\n      x = ellipse.x;\n      y = ellipse.y;\n      rx = ellipse.width;\n      ry = ellipse.height;\n      dx = dy = 0;\n    } else {\n      const roundedRect = graphicsData.shape;\n      const halfWidth = roundedRect.width / 2;\n      const halfHeight = roundedRect.height / 2;\n      x = roundedRect.x + halfWidth;\n      y = roundedRect.y + halfHeight;\n      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n      dx = halfWidth - rx;\n      dy = halfHeight - ry;\n    }\n    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {\n      points.length = 0;\n      return;\n    }\n    const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n    const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    points.length = m;\n    if (m === 0) {\n      return;\n    }\n    if (n === 0) {\n      points.length = 8;\n      points[0] = points[6] = x + dx;\n      points[1] = points[3] = y + dy;\n      points[2] = points[4] = x - dx;\n      points[5] = points[7] = y - dy;\n      return;\n    }\n    let j1 = 0;\n    let j2 = n * 4 + (dx ? 2 : 0) + 2;\n    let j3 = j2;\n    let j4 = m;\n    {\n      const x0 = dx + rx;\n      const y0 = dy;\n      const x1 = x + x0;\n      const x2 = x - x0;\n      const y1 = y + y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j2] = y1;\n      points[--j2] = x2;\n      if (dy) {\n        const y2 = y - y0;\n        points[j3++] = x2;\n        points[j3++] = y2;\n        points[--j4] = y2;\n        points[--j4] = x1;\n      }\n    }\n    for (let i = 1; i < n; i++) {\n      const a = Math.PI / 2 * (i / n);\n      const x0 = dx + Math.cos(a) * rx;\n      const y0 = dy + Math.sin(a) * ry;\n      const x1 = x + x0;\n      const x2 = x - x0;\n      const y1 = y + y0;\n      const y2 = y - y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j2] = y1;\n      points[--j2] = x2;\n      points[j3++] = x2;\n      points[j3++] = y2;\n      points[--j4] = y2;\n      points[--j4] = x1;\n    }\n    {\n      const x0 = dx;\n      const y0 = dy + ry;\n      const x1 = x + x0;\n      const x2 = x - x0;\n      const y1 = y + y0;\n      const y2 = y - y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j4] = y2;\n      points[--j4] = x1;\n      if (dx) {\n        points[j1++] = x2;\n        points[j1++] = y1;\n        points[--j4] = y2;\n        points[--j4] = x2;\n      }\n    }\n  },\n  triangulate(graphicsData, graphicsGeometry) {\n    const points = graphicsData.points;\n    const verts = graphicsGeometry.points;\n    const indices = graphicsGeometry.indices;\n    if (points.length === 0) {\n      return;\n    }\n    let vertPos = verts.length / 2;\n    const center = vertPos;\n    let x;\n    let y;\n    if (graphicsData.type !== SHAPES.RREC) {\n      const circle = graphicsData.shape;\n      x = circle.x;\n      y = circle.y;\n    } else {\n      const roundedRect = graphicsData.shape;\n      x = roundedRect.x + roundedRect.width / 2;\n      y = roundedRect.y + roundedRect.height / 2;\n    }\n    const matrix = graphicsData.matrix;\n    verts.push(graphicsData.matrix ? matrix.a * x + matrix.c * y + matrix.tx : x, graphicsData.matrix ? matrix.b * x + matrix.d * y + matrix.ty : y);\n    vertPos++;\n    verts.push(points[0], points[1]);\n    for (let i = 2; i < points.length; i += 2) {\n      verts.push(points[i], points[i + 1]);\n      indices.push(vertPos++, center, vertPos);\n    }\n    indices.push(center + 1, center, vertPos);\n  }\n};\n\n\n//# sourceMappingURL=buildCircle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/buildPoly.mjs\n\n\nfunction fixOrientation(points, hole = false) {\n  const m = points.length;\n  if (m < 6) {\n    return;\n  }\n  let area = 0;\n  for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {\n    const x2 = points[i];\n    const y2 = points[i + 1];\n    area += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  if (!hole && area > 0 || hole && area <= 0) {\n    const n = m / 2;\n    for (let i = n + n % 2; i < m; i += 2) {\n      const i1 = m - i - 2;\n      const i2 = m - i - 1;\n      const i3 = i;\n      const i4 = i + 1;\n      [points[i1], points[i3]] = [points[i3], points[i1]];\n      [points[i2], points[i4]] = [points[i4], points[i2]];\n    }\n  }\n}\nconst buildPoly = {\n  build(graphicsData) {\n    graphicsData.points = graphicsData.shape.points.slice();\n  },\n  triangulate(graphicsData, graphicsGeometry) {\n    let points = graphicsData.points;\n    const holes = graphicsData.holes;\n    const verts = graphicsGeometry.points;\n    const indices = graphicsGeometry.indices;\n    if (points.length >= 6) {\n      fixOrientation(points, false);\n      const holeArray = [];\n      for (let i = 0; i < holes.length; i++) {\n        const hole = holes[i];\n        fixOrientation(hole.points, true);\n        holeArray.push(points.length / 2);\n        points = points.concat(hole.points);\n      }\n      const triangles = utils_lib.earcut(points, holeArray, 2);\n      if (!triangles) {\n        return;\n      }\n      const vertPos = verts.length / 2;\n      for (let i = 0; i < triangles.length; i += 3) {\n        indices.push(triangles[i] + vertPos);\n        indices.push(triangles[i + 1] + vertPos);\n        indices.push(triangles[i + 2] + vertPos);\n      }\n      for (let i = 0; i < points.length; i++) {\n        verts.push(points[i]);\n      }\n    }\n  }\n};\n\n\n//# sourceMappingURL=buildPoly.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/buildRectangle.mjs\nconst buildRectangle = {\n  build(graphicsData) {\n    const rectData = graphicsData.shape;\n    const x = rectData.x;\n    const y = rectData.y;\n    const width = rectData.width;\n    const height = rectData.height;\n    const points = graphicsData.points;\n    points.length = 0;\n    if (!(width >= 0 && height >= 0)) {\n      return;\n    }\n    points.push(x, y, x + width, y, x + width, y + height, x, y + height);\n  },\n  triangulate(graphicsData, graphicsGeometry) {\n    const points = graphicsData.points;\n    const verts = graphicsGeometry.points;\n    if (points.length === 0) {\n      return;\n    }\n    const vertPos = verts.length / 2;\n    verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);\n    graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);\n  }\n};\n\n\n//# sourceMappingURL=buildRectangle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/buildRoundedRectangle.mjs\n\n\nconst buildRoundedRectangle = {\n  build(graphicsData) {\n    buildCircle.build(graphicsData);\n  },\n  triangulate(graphicsData, graphicsGeometry) {\n    buildCircle.triangulate(graphicsData, graphicsGeometry);\n  }\n};\n\n\n//# sourceMappingURL=buildRoundedRectangle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/const.mjs\nvar LINE_JOIN = /* @__PURE__ */ ((LINE_JOIN2) => {\n  LINE_JOIN2["MITER"] = "miter";\n  LINE_JOIN2["BEVEL"] = "bevel";\n  LINE_JOIN2["ROUND"] = "round";\n  return LINE_JOIN2;\n})(LINE_JOIN || {});\nvar LINE_CAP = /* @__PURE__ */ ((LINE_CAP2) => {\n  LINE_CAP2["BUTT"] = "butt";\n  LINE_CAP2["ROUND"] = "round";\n  LINE_CAP2["SQUARE"] = "square";\n  return LINE_CAP2;\n})(LINE_CAP || {});\nconst curves = {\n  adaptive: true,\n  maxLength: 10,\n  minSegments: 8,\n  maxSegments: 2048,\n  epsilon: 1e-4,\n  _segmentsCount(length, defaultSegments = 20) {\n    if (!this.adaptive || !length || isNaN(length)) {\n      return defaultSegments;\n    }\n    let result = Math.ceil(length / this.maxLength);\n    if (result < this.minSegments) {\n      result = this.minSegments;\n    } else if (result > this.maxSegments) {\n      result = this.maxSegments;\n    }\n    return result;\n  }\n};\nconst GRAPHICS_CURVES = (/* unused pure expression or super */ null && (curves));\n\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/ArcUtils.mjs\n\n\n\nclass ArcUtils {\n  static curveTo(x1, y1, x2, y2, radius, points) {\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    const a1 = fromY - y1;\n    const b1 = fromX - x1;\n    const a2 = y2 - y1;\n    const b2 = x2 - x1;\n    const mm = Math.abs(a1 * b2 - b1 * a2);\n    if (mm < 1e-8 || radius === 0) {\n      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n        points.push(x1, y1);\n      }\n      return null;\n    }\n    const dd = a1 * a1 + b1 * b1;\n    const cc = a2 * a2 + b2 * b2;\n    const tt = a1 * a2 + b1 * b2;\n    const k1 = radius * Math.sqrt(dd) / mm;\n    const k2 = radius * Math.sqrt(cc) / mm;\n    const j1 = k1 * tt / dd;\n    const j2 = k2 * tt / cc;\n    const cx = k1 * b2 + k2 * b1;\n    const cy = k1 * a2 + k2 * a1;\n    const px = b1 * (k2 + j1);\n    const py = a1 * (k2 + j1);\n    const qx = b2 * (k1 + j2);\n    const qy = a2 * (k1 + j2);\n    const startAngle = Math.atan2(py - cy, px - cx);\n    const endAngle = Math.atan2(qy - cy, qx - cx);\n    return {\n      cx: cx + x1,\n      cy: cy + y1,\n      radius,\n      startAngle,\n      endAngle,\n      anticlockwise: b1 * a2 > b2 * a1\n    };\n  }\n  static arc(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {\n    const sweep = endAngle - startAngle;\n    const n = curves._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / PI_2) * 40);\n    const theta = sweep / (n * 2);\n    const theta2 = theta * 2;\n    const cTheta = Math.cos(theta);\n    const sTheta = Math.sin(theta);\n    const segMinus = n - 1;\n    const remainder = segMinus % 1 / segMinus;\n    for (let i = 0; i <= segMinus; ++i) {\n      const real = i + remainder * i;\n      const angle = theta + startAngle + theta2 * real;\n      const c = Math.cos(angle);\n      const s = -Math.sin(angle);\n      points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);\n    }\n  }\n}\n\n\n//# sourceMappingURL=ArcUtils.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/BezierUtils.mjs\n\n\nclass BezierUtils {\n  static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {\n    const n = 10;\n    let result = 0;\n    let t = 0;\n    let t2 = 0;\n    let t3 = 0;\n    let nt = 0;\n    let nt2 = 0;\n    let nt3 = 0;\n    let x = 0;\n    let y = 0;\n    let dx = 0;\n    let dy = 0;\n    let prevX = fromX;\n    let prevY = fromY;\n    for (let i = 1; i <= n; ++i) {\n      t = i / n;\n      t2 = t * t;\n      t3 = t2 * t;\n      nt = 1 - t;\n      nt2 = nt * nt;\n      nt3 = nt2 * nt;\n      x = nt3 * fromX + 3 * nt2 * t * cpX + 3 * nt * t2 * cpX2 + t3 * toX;\n      y = nt3 * fromY + 3 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;\n      dx = prevX - x;\n      dy = prevY - y;\n      prevX = x;\n      prevY = y;\n      result += Math.sqrt(dx * dx + dy * dy);\n    }\n    return result;\n  }\n  static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points) {\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    points.length -= 2;\n    const n = curves._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));\n    let dt = 0;\n    let dt2 = 0;\n    let dt3 = 0;\n    let t2 = 0;\n    let t3 = 0;\n    points.push(fromX, fromY);\n    for (let i = 1, j = 0; i <= n; ++i) {\n      j = i / n;\n      dt = 1 - j;\n      dt2 = dt * dt;\n      dt3 = dt2 * dt;\n      t2 = j * j;\n      t3 = t2 * j;\n      points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);\n    }\n  }\n}\n\n\n//# sourceMappingURL=BezierUtils.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/buildLine.mjs\n\n\n\nfunction square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n  const ix = x - nx * innerWeight;\n  const iy = y - ny * innerWeight;\n  const ox = x + nx * outerWeight;\n  const oy = y + ny * outerWeight;\n  let exx;\n  let eyy;\n  if (clockwise) {\n    exx = ny;\n    eyy = -nx;\n  } else {\n    exx = -ny;\n    eyy = nx;\n  }\n  const eix = ix + exx;\n  const eiy = iy + eyy;\n  const eox = ox + exx;\n  const eoy = oy + eyy;\n  verts.push(eix, eiy, eox, eoy);\n  return 2;\n}\nfunction round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  const cx2p0x = sx - cx;\n  const cy2p0y = sy - cy;\n  let angle0 = Math.atan2(cx2p0x, cy2p0y);\n  let angle1 = Math.atan2(ex - cx, ey - cy);\n  if (clockwise && angle0 < angle1) {\n    angle0 += Math.PI * 2;\n  } else if (!clockwise && angle0 > angle1) {\n    angle1 += Math.PI * 2;\n  }\n  let startAngle = angle0;\n  const angleDiff = angle1 - angle0;\n  const absAngleDiff = Math.abs(angleDiff);\n  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n  const angleInc = angleDiff / segCount;\n  startAngle += angleInc;\n  if (clockwise) {\n    verts.push(cx, cy, sx, sy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx, cy, cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n    }\n    verts.push(cx, cy, ex, ey);\n  } else {\n    verts.push(sx, sy, cx, cy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius, cx, cy);\n    }\n    verts.push(ex, ey, cx, cy);\n  }\n  return segCount * 2;\n}\nfunction buildNonNativeLine(graphicsData, graphicsGeometry) {\n  const shape = graphicsData.shape;\n  let points = graphicsData.points || shape.points.slice();\n  const eps = graphicsGeometry.closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  const style = graphicsData.lineStyle;\n  const firstPoint = new Point(points[0], points[1]);\n  const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n  const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n  if (closedShape) {\n    points = points.slice();\n    if (closedPath) {\n      points.pop();\n      points.pop();\n      lastPoint.set(points[points.length - 2], points[points.length - 1]);\n    }\n    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY);\n    points.push(midPointX, midPointY);\n  }\n  const verts = graphicsGeometry.points;\n  const length = points.length / 2;\n  let indexCount = points.length;\n  const indexStart = verts.length / 2;\n  const width = style.width / 2;\n  const widthSquared = width * width;\n  const miterLimitSquared = style.miterLimit * style.miterLimit;\n  let x0 = points[0];\n  let y0 = points[1];\n  let x1 = points[2];\n  let y1 = points[3];\n  let x2 = 0;\n  let y2 = 0;\n  let perpx = -(y0 - y1);\n  let perpy = x0 - x1;\n  let perp1x = 0;\n  let perp1y = 0;\n  let dist = Math.sqrt(perpx * perpx + perpy * perpy);\n  perpx /= dist;\n  perpy /= dist;\n  perpx *= width;\n  perpy *= width;\n  const ratio = style.alignment;\n  const innerWeight = (1 - ratio) * 2;\n  const outerWeight = ratio * 2;\n  if (!closedShape) {\n    if (style.cap === LINE_CAP.ROUND) {\n      indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;\n    } else if (style.cap === LINE_CAP.SQUARE) {\n      indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);\n    }\n  }\n  verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight);\n  for (let i = 1; i < length - 1; ++i) {\n    x0 = points[(i - 1) * 2];\n    y0 = points[(i - 1) * 2 + 1];\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n    x2 = points[(i + 1) * 2];\n    y2 = points[(i + 1) * 2 + 1];\n    perpx = -(y0 - y1);\n    perpy = x0 - x1;\n    dist = Math.sqrt(perpx * perpx + perpy * perpy);\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n    perp1x = -(y1 - y2);\n    perp1y = x1 - x2;\n    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n    perp1x /= dist;\n    perp1y /= dist;\n    perp1x *= width;\n    perp1y *= width;\n    const dx0 = x1 - x0;\n    const dy0 = y0 - y1;\n    const dx1 = x1 - x2;\n    const dy1 = y2 - y1;\n    const dot = dx0 * dx1 + dy0 * dy1;\n    const cross = dy0 * dx1 - dy1 * dx0;\n    const clockwise = cross < 0;\n    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {\n      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n      if (dot >= 0) {\n        if (style.join === LINE_JOIN.ROUND) {\n          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n        } else {\n          indexCount += 2;\n        }\n        verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight, x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);\n      }\n      continue;\n    }\n    const c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);\n    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n    const px = (dx0 * c2 - dx1 * c1) / cross;\n    const py = (dy1 * c1 - dy0 * c2) / cross;\n    const pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n    const imx = x1 + (px - x1) * innerWeight;\n    const imy = y1 + (py - y1) * innerWeight;\n    const omx = x1 - (px - x1) * outerWeight;\n    const omy = y1 - (py - y1) * outerWeight;\n    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n    const insideWeight = clockwise ? innerWeight : outerWeight;\n    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n    const insideMiterOk = pdist <= smallerInsideDiagonalSq;\n    let join = style.join;\n    if (join === LINE_JOIN.MITER && pdist / widthSquared > miterLimitSquared) {\n      join = LINE_JOIN.BEVEL;\n    }\n    if (insideMiterOk) {\n      switch (join) {\n        case LINE_JOIN.MITER: {\n          verts.push(imx, imy, omx, omy);\n          break;\n        }\n        case LINE_JOIN.BEVEL: {\n          if (clockwise) {\n            verts.push(imx, imy, x1 + perpx * outerWeight, y1 + perpy * outerWeight, imx, imy, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n          } else {\n            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, omx, omy, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, omx, omy);\n          }\n          indexCount += 2;\n          break;\n        }\n        case LINE_JOIN.ROUND: {\n          if (clockwise) {\n            verts.push(imx, imy, x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;\n            verts.push(imx, imy, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n          } else {\n            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, omx, omy);\n            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, omx, omy);\n          }\n          break;\n        }\n      }\n    } else {\n      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n      switch (join) {\n        case LINE_JOIN.MITER: {\n          if (clockwise) {\n            verts.push(omx, omy, omx, omy);\n          } else {\n            verts.push(imx, imy, imx, imy);\n          }\n          indexCount += 2;\n          break;\n        }\n        case LINE_JOIN.ROUND: {\n          if (clockwise) {\n            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;\n          } else {\n            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;\n          }\n          break;\n        }\n      }\n      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n      indexCount += 2;\n    }\n  }\n  x0 = points[(length - 2) * 2];\n  y0 = points[(length - 2) * 2 + 1];\n  x1 = points[(length - 1) * 2];\n  y1 = points[(length - 1) * 2 + 1];\n  perpx = -(y0 - y1);\n  perpy = x0 - x1;\n  dist = Math.sqrt(perpx * perpx + perpy * perpy);\n  perpx /= dist;\n  perpy /= dist;\n  perpx *= width;\n  perpy *= width;\n  verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n  if (!closedShape) {\n    if (style.cap === LINE_CAP.ROUND) {\n      indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;\n    } else if (style.cap === LINE_CAP.SQUARE) {\n      indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);\n    }\n  }\n  const indices = graphicsGeometry.indices;\n  const eps2 = curves.epsilon * curves.epsilon;\n  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {\n    x0 = verts[i * 2];\n    y0 = verts[i * 2 + 1];\n    x1 = verts[(i + 1) * 2];\n    y1 = verts[(i + 1) * 2 + 1];\n    x2 = verts[(i + 2) * 2];\n    y2 = verts[(i + 2) * 2 + 1];\n    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {\n      continue;\n    }\n    indices.push(i, i + 1, i + 2);\n  }\n}\nfunction buildNativeLine(graphicsData, graphicsGeometry) {\n  let i = 0;\n  const shape = graphicsData.shape;\n  const points = graphicsData.points || shape.points;\n  const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n  if (points.length === 0)\n    return;\n  const verts = graphicsGeometry.points;\n  const indices = graphicsGeometry.indices;\n  const length = points.length / 2;\n  const startIndex = verts.length / 2;\n  let currentIndex = startIndex;\n  verts.push(points[0], points[1]);\n  for (i = 1; i < length; i++) {\n    verts.push(points[i * 2], points[i * 2 + 1]);\n    indices.push(currentIndex, currentIndex + 1);\n    currentIndex++;\n  }\n  if (closedShape) {\n    indices.push(currentIndex, startIndex);\n  }\n}\nfunction buildLine(graphicsData, graphicsGeometry) {\n  if (graphicsData.lineStyle.native) {\n    buildNativeLine(graphicsData, graphicsGeometry);\n  } else {\n    buildNonNativeLine(graphicsData, graphicsGeometry);\n  }\n}\n\n\n//# sourceMappingURL=buildLine.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/QuadraticUtils.mjs\n\n\nclass QuadraticUtils {\n  static curveLength(fromX, fromY, cpX, cpY, toX, toY) {\n    const ax = fromX - 2 * cpX + toX;\n    const ay = fromY - 2 * cpY + toY;\n    const bx = 2 * cpX - 2 * fromX;\n    const by = 2 * cpY - 2 * fromY;\n    const a = 4 * (ax * ax + ay * ay);\n    const b = 4 * (ax * bx + ay * by);\n    const c = bx * bx + by * by;\n    const s = 2 * Math.sqrt(a + b + c);\n    const a2 = Math.sqrt(a);\n    const a32 = 2 * a * a2;\n    const c2 = 2 * Math.sqrt(c);\n    const ba = b / a2;\n    return (a32 * s + a2 * b * (s - c2) + (4 * c * a - b * b) * Math.log((2 * a2 + ba + s) / (ba + c2))) / (4 * a32);\n  }\n  static curveTo(cpX, cpY, toX, toY, points) {\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    const n = curves._segmentsCount(QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY));\n    let xa = 0;\n    let ya = 0;\n    for (let i = 1; i <= n; ++i) {\n      const j = i / n;\n      xa = fromX + (cpX - fromX) * j;\n      ya = fromY + (cpY - fromY) * j;\n      points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);\n    }\n  }\n}\n\n\n//# sourceMappingURL=QuadraticUtils.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst FILL_COMMANDS = {\n  [SHAPES.POLY]: buildPoly,\n  [SHAPES.CIRC]: buildCircle,\n  [SHAPES.ELIP]: buildCircle,\n  [SHAPES.RECT]: buildRectangle,\n  [SHAPES.RREC]: buildRoundedRectangle\n};\nconst BATCH_POOL = [];\nconst DRAW_CALL_POOL = [];\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/GraphicsData.mjs\nclass GraphicsData {\n  constructor(shape, fillStyle = null, lineStyle = null, matrix = null) {\n    this.points = [];\n    this.holes = [];\n    this.shape = shape;\n    this.lineStyle = lineStyle;\n    this.fillStyle = fillStyle;\n    this.matrix = matrix;\n    this.type = shape.type;\n  }\n  clone() {\n    return new GraphicsData(this.shape, this.fillStyle, this.lineStyle, this.matrix);\n  }\n  destroy() {\n    this.shape = null;\n    this.holes.length = 0;\n    this.holes = null;\n    this.points.length = 0;\n    this.points = null;\n    this.lineStyle = null;\n    this.fillStyle = null;\n  }\n}\n\n\n//# sourceMappingURL=GraphicsData.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/utils/BatchPart.mjs\nclass BatchPart {\n  constructor() {\n    this.reset();\n  }\n  begin(style, startIndex, attribStart) {\n    this.reset();\n    this.style = style;\n    this.start = startIndex;\n    this.attribStart = attribStart;\n  }\n  end(endIndex, endAttrib) {\n    this.attribSize = endAttrib - this.attribStart;\n    this.size = endIndex - this.start;\n  }\n  reset() {\n    this.style = null;\n    this.size = 0;\n    this.start = 0;\n    this.attribStart = 0;\n    this.attribSize = 0;\n  }\n}\n\n\n//# sourceMappingURL=BatchPart.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/GraphicsGeometry.mjs\n\n\n\n\n\n\n\n\nconst tmpPoint = new Point();\nconst _GraphicsGeometry = class extends BatchGeometry {\n  constructor() {\n    super();\n    this.closePointEps = 1e-4;\n    this.boundsPadding = 0;\n    this.uvsFloat32 = null;\n    this.indicesUint16 = null;\n    this.batchable = false;\n    this.points = [];\n    this.colors = [];\n    this.uvs = [];\n    this.indices = [];\n    this.textureIds = [];\n    this.graphicsData = [];\n    this.drawCalls = [];\n    this.batchDirty = -1;\n    this.batches = [];\n    this.dirty = 0;\n    this.cacheDirty = -1;\n    this.clearDirty = 0;\n    this.shapeIndex = 0;\n    this._bounds = new Bounds();\n    this.boundsDirty = -1;\n  }\n  get bounds() {\n    this.updateBatches();\n    if (this.boundsDirty !== this.dirty) {\n      this.boundsDirty = this.dirty;\n      this.calculateBounds();\n    }\n    return this._bounds;\n  }\n  invalidate() {\n    this.boundsDirty = -1;\n    this.dirty++;\n    this.batchDirty++;\n    this.shapeIndex = 0;\n    this.points.length = 0;\n    this.colors.length = 0;\n    this.uvs.length = 0;\n    this.indices.length = 0;\n    this.textureIds.length = 0;\n    for (let i = 0; i < this.drawCalls.length; i++) {\n      this.drawCalls[i].texArray.clear();\n      DRAW_CALL_POOL.push(this.drawCalls[i]);\n    }\n    this.drawCalls.length = 0;\n    for (let i = 0; i < this.batches.length; i++) {\n      const batchPart = this.batches[i];\n      batchPart.reset();\n      BATCH_POOL.push(batchPart);\n    }\n    this.batches.length = 0;\n  }\n  clear() {\n    if (this.graphicsData.length > 0) {\n      this.invalidate();\n      this.clearDirty++;\n      this.graphicsData.length = 0;\n    }\n    return this;\n  }\n  drawShape(shape, fillStyle = null, lineStyle = null, matrix = null) {\n    const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n    this.graphicsData.push(data);\n    this.dirty++;\n    return this;\n  }\n  drawHole(shape, matrix = null) {\n    if (!this.graphicsData.length) {\n      return null;\n    }\n    const data = new GraphicsData(shape, null, null, matrix);\n    const lastShape = this.graphicsData[this.graphicsData.length - 1];\n    data.lineStyle = lastShape.lineStyle;\n    lastShape.holes.push(data);\n    this.dirty++;\n    return this;\n  }\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.graphicsData.length; ++i) {\n      this.graphicsData[i].destroy();\n    }\n    this.points.length = 0;\n    this.points = null;\n    this.colors.length = 0;\n    this.colors = null;\n    this.uvs.length = 0;\n    this.uvs = null;\n    this.indices.length = 0;\n    this.indices = null;\n    this.indexBuffer.destroy();\n    this.indexBuffer = null;\n    this.graphicsData.length = 0;\n    this.graphicsData = null;\n    this.drawCalls.length = 0;\n    this.drawCalls = null;\n    this.batches.length = 0;\n    this.batches = null;\n    this._bounds = null;\n  }\n  containsPoint(point) {\n    const graphicsData = this.graphicsData;\n    for (let i = 0; i < graphicsData.length; ++i) {\n      const data = graphicsData[i];\n      if (!data.fillStyle.visible) {\n        continue;\n      }\n      if (data.shape) {\n        if (data.matrix) {\n          data.matrix.applyInverse(point, tmpPoint);\n        } else {\n          tmpPoint.copyFrom(point);\n        }\n        if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {\n          let hitHole = false;\n          if (data.holes) {\n            for (let i2 = 0; i2 < data.holes.length; i2++) {\n              const hole = data.holes[i2];\n              if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {\n                hitHole = true;\n                break;\n              }\n            }\n          }\n          if (!hitHole) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  updateBatches() {\n    if (!this.graphicsData.length) {\n      this.batchable = true;\n      return;\n    }\n    if (!this.validateBatching()) {\n      return;\n    }\n    this.cacheDirty = this.dirty;\n    const uvs = this.uvs;\n    const graphicsData = this.graphicsData;\n    let batchPart = null;\n    let currentStyle = null;\n    if (this.batches.length > 0) {\n      batchPart = this.batches[this.batches.length - 1];\n      currentStyle = batchPart.style;\n    }\n    for (let i = this.shapeIndex; i < graphicsData.length; i++) {\n      this.shapeIndex++;\n      const data = graphicsData[i];\n      const fillStyle = data.fillStyle;\n      const lineStyle = data.lineStyle;\n      const command = FILL_COMMANDS[data.type];\n      command.build(data);\n      if (data.matrix) {\n        this.transformPoints(data.points, data.matrix);\n      }\n      if (fillStyle.visible || lineStyle.visible) {\n        this.processHoles(data.holes);\n      }\n      for (let j = 0; j < 2; j++) {\n        const style = j === 0 ? fillStyle : lineStyle;\n        if (!style.visible)\n          continue;\n        const nextTexture = style.texture.baseTexture;\n        const index2 = this.indices.length;\n        const attribIndex = this.points.length / 2;\n        nextTexture.wrapMode = lib/* WRAP_MODES */.Nt.REPEAT;\n        if (j === 0) {\n          this.processFill(data);\n        } else {\n          this.processLine(data);\n        }\n        const size = this.points.length / 2 - attribIndex;\n        if (size === 0)\n          continue;\n        if (batchPart && !this._compareStyles(currentStyle, style)) {\n          batchPart.end(index2, attribIndex);\n          batchPart = null;\n        }\n        if (!batchPart) {\n          batchPart = BATCH_POOL.pop() || new BatchPart();\n          batchPart.begin(style, index2, attribIndex);\n          this.batches.push(batchPart);\n          currentStyle = style;\n        }\n        this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);\n      }\n    }\n    const index = this.indices.length;\n    const attrib = this.points.length / 2;\n    if (batchPart) {\n      batchPart.end(index, attrib);\n    }\n    if (this.batches.length === 0) {\n      this.batchable = true;\n      return;\n    }\n    const need32 = attrib > 65535;\n    if (this.indicesUint16 && this.indices.length === this.indicesUint16.length && need32 === this.indicesUint16.BYTES_PER_ELEMENT > 2) {\n      this.indicesUint16.set(this.indices);\n    } else {\n      this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);\n    }\n    this.batchable = this.isBatchable();\n    if (this.batchable) {\n      this.packBatches();\n    } else {\n      this.buildDrawCalls();\n    }\n  }\n  _compareStyles(styleA, styleB) {\n    if (!styleA || !styleB) {\n      return false;\n    }\n    if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {\n      return false;\n    }\n    if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {\n      return false;\n    }\n    if (!!styleA.native !== !!styleB.native) {\n      return false;\n    }\n    return true;\n  }\n  validateBatching() {\n    if (this.dirty === this.cacheDirty || !this.graphicsData.length) {\n      return false;\n    }\n    for (let i = 0, l = this.graphicsData.length; i < l; i++) {\n      const data = this.graphicsData[i];\n      const fill = data.fillStyle;\n      const line = data.lineStyle;\n      if (fill && !fill.texture.baseTexture.valid)\n        return false;\n      if (line && !line.texture.baseTexture.valid)\n        return false;\n    }\n    return true;\n  }\n  packBatches() {\n    this.batchDirty++;\n    this.uvsFloat32 = new Float32Array(this.uvs);\n    const batches = this.batches;\n    for (let i = 0, l = batches.length; i < l; i++) {\n      const batch = batches[i];\n      for (let j = 0; j < batch.size; j++) {\n        const index = batch.start + j;\n        this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n      }\n    }\n  }\n  isBatchable() {\n    if (this.points.length > 65535 * 2) {\n      return false;\n    }\n    const batches = this.batches;\n    for (let i = 0; i < batches.length; i++) {\n      if (batches[i].style.native) {\n        return false;\n      }\n    }\n    return this.points.length < _GraphicsGeometry.BATCHABLE_SIZE * 2;\n  }\n  buildDrawCalls() {\n    let TICK = ++BaseTexture._globalBatch;\n    for (let i = 0; i < this.drawCalls.length; i++) {\n      this.drawCalls[i].texArray.clear();\n      DRAW_CALL_POOL.push(this.drawCalls[i]);\n    }\n    this.drawCalls.length = 0;\n    const colors = this.colors;\n    const textureIds = this.textureIds;\n    let currentGroup = DRAW_CALL_POOL.pop();\n    if (!currentGroup) {\n      currentGroup = new BatchDrawCall();\n      currentGroup.texArray = new BatchTextureArray();\n    }\n    currentGroup.texArray.count = 0;\n    currentGroup.start = 0;\n    currentGroup.size = 0;\n    currentGroup.type = lib/* DRAW_MODES */.lg.TRIANGLES;\n    let textureCount = 0;\n    let currentTexture = null;\n    let textureId = 0;\n    let native = false;\n    let drawMode = lib/* DRAW_MODES */.lg.TRIANGLES;\n    let index = 0;\n    this.drawCalls.push(currentGroup);\n    for (let i = 0; i < this.batches.length; i++) {\n      const data = this.batches[i];\n      const maxTextures = 8;\n      const style = data.style;\n      const nextTexture = style.texture.baseTexture;\n      if (native !== !!style.native) {\n        native = !!style.native;\n        drawMode = native ? lib/* DRAW_MODES */.lg.LINES : lib/* DRAW_MODES */.lg.TRIANGLES;\n        currentTexture = null;\n        textureCount = maxTextures;\n        TICK++;\n      }\n      if (currentTexture !== nextTexture) {\n        currentTexture = nextTexture;\n        if (nextTexture._batchEnabled !== TICK) {\n          if (textureCount === maxTextures) {\n            TICK++;\n            textureCount = 0;\n            if (currentGroup.size > 0) {\n              currentGroup = DRAW_CALL_POOL.pop();\n              if (!currentGroup) {\n                currentGroup = new BatchDrawCall();\n                currentGroup.texArray = new BatchTextureArray();\n              }\n              this.drawCalls.push(currentGroup);\n            }\n            currentGroup.start = index;\n            currentGroup.size = 0;\n            currentGroup.texArray.count = 0;\n            currentGroup.type = drawMode;\n          }\n          nextTexture.touched = 1;\n          nextTexture._batchEnabled = TICK;\n          nextTexture._batchLocation = textureCount;\n          nextTexture.wrapMode = lib/* WRAP_MODES */.Nt.REPEAT;\n          currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;\n          textureCount++;\n        }\n      }\n      currentGroup.size += data.size;\n      index += data.size;\n      textureId = nextTexture._batchLocation;\n      this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);\n      this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);\n    }\n    BaseTexture._globalBatch = TICK;\n    this.packAttributes();\n  }\n  packAttributes() {\n    const verts = this.points;\n    const uvs = this.uvs;\n    const colors = this.colors;\n    const textureIds = this.textureIds;\n    const glPoints = new ArrayBuffer(verts.length * 3 * 4);\n    const f32 = new Float32Array(glPoints);\n    const u32 = new Uint32Array(glPoints);\n    let p = 0;\n    for (let i = 0; i < verts.length / 2; i++) {\n      f32[p++] = verts[i * 2];\n      f32[p++] = verts[i * 2 + 1];\n      f32[p++] = uvs[i * 2];\n      f32[p++] = uvs[i * 2 + 1];\n      u32[p++] = colors[i];\n      f32[p++] = textureIds[i];\n    }\n    this._buffer.update(glPoints);\n    this._indexBuffer.update(this.indicesUint16);\n  }\n  processFill(data) {\n    if (data.holes.length) {\n      buildPoly.triangulate(data, this);\n    } else {\n      const command = FILL_COMMANDS[data.type];\n      command.triangulate(data, this);\n    }\n  }\n  processLine(data) {\n    buildLine(data, this);\n    for (let i = 0; i < data.holes.length; i++) {\n      buildLine(data.holes[i], this);\n    }\n  }\n  processHoles(holes) {\n    for (let i = 0; i < holes.length; i++) {\n      const hole = holes[i];\n      const command = FILL_COMMANDS[hole.type];\n      command.build(hole);\n      if (hole.matrix) {\n        this.transformPoints(hole.points, hole.matrix);\n      }\n    }\n  }\n  calculateBounds() {\n    const bounds = this._bounds;\n    bounds.clear();\n    bounds.addVertexData(this.points, 0, this.points.length);\n    bounds.pad(this.boundsPadding, this.boundsPadding);\n  }\n  transformPoints(points, matrix) {\n    for (let i = 0; i < points.length / 2; i++) {\n      const x = points[i * 2];\n      const y = points[i * 2 + 1];\n      points[i * 2] = matrix.a * x + matrix.c * y + matrix.tx;\n      points[i * 2 + 1] = matrix.b * x + matrix.d * y + matrix.ty;\n    }\n  }\n  addColors(colors, color, alpha, size, offset = 0) {\n    const bgr = color_lib/* Color */.I.shared.setValue(color).toLittleEndianNumber();\n    const result = color_lib/* Color */.I.shared.setValue(bgr).toPremultiplied(alpha);\n    colors.length = Math.max(colors.length, offset + size);\n    for (let i = 0; i < size; i++) {\n      colors[offset + i] = result;\n    }\n  }\n  addTextureIds(textureIds, id, size, offset = 0) {\n    textureIds.length = Math.max(textureIds.length, offset + size);\n    for (let i = 0; i < size; i++) {\n      textureIds[offset + i] = id;\n    }\n  }\n  addUvs(verts, uvs, texture, start, size, matrix = null) {\n    let index = 0;\n    const uvsStart = uvs.length;\n    const frame = texture.frame;\n    while (index < size) {\n      let x = verts[(start + index) * 2];\n      let y = verts[(start + index) * 2 + 1];\n      if (matrix) {\n        const nx = matrix.a * x + matrix.c * y + matrix.tx;\n        y = matrix.b * x + matrix.d * y + matrix.ty;\n        x = nx;\n      }\n      index++;\n      uvs.push(x / frame.width, y / frame.height);\n    }\n    const baseTexture = texture.baseTexture;\n    if (frame.width < baseTexture.width || frame.height < baseTexture.height) {\n      this.adjustUvs(uvs, texture, uvsStart, size);\n    }\n  }\n  adjustUvs(uvs, texture, start, size) {\n    const baseTexture = texture.baseTexture;\n    const eps = 1e-6;\n    const finish = start + size * 2;\n    const frame = texture.frame;\n    const scaleX = frame.width / baseTexture.width;\n    const scaleY = frame.height / baseTexture.height;\n    let offsetX = frame.x / frame.width;\n    let offsetY = frame.y / frame.height;\n    let minX = Math.floor(uvs[start] + eps);\n    let minY = Math.floor(uvs[start + 1] + eps);\n    for (let i = start + 2; i < finish; i += 2) {\n      minX = Math.min(minX, Math.floor(uvs[i] + eps));\n      minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n    }\n    offsetX -= minX;\n    offsetY -= minY;\n    for (let i = start; i < finish; i += 2) {\n      uvs[i] = (uvs[i] + offsetX) * scaleX;\n      uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;\n    }\n  }\n};\nlet GraphicsGeometry = _GraphicsGeometry;\nGraphicsGeometry.BATCHABLE_SIZE = 100;\n\n\n//# sourceMappingURL=GraphicsGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/styles/FillStyle.mjs\n\n\nclass FillStyle {\n  constructor() {\n    this.color = 16777215;\n    this.alpha = 1;\n    this.texture = Texture_Texture.WHITE;\n    this.matrix = null;\n    this.visible = false;\n    this.reset();\n  }\n  clone() {\n    const obj = new FillStyle();\n    obj.color = this.color;\n    obj.alpha = this.alpha;\n    obj.texture = this.texture;\n    obj.matrix = this.matrix;\n    obj.visible = this.visible;\n    return obj;\n  }\n  reset() {\n    this.color = 16777215;\n    this.alpha = 1;\n    this.texture = Texture_Texture.WHITE;\n    this.matrix = null;\n    this.visible = false;\n  }\n  destroy() {\n    this.texture = null;\n    this.matrix = null;\n  }\n}\n\n\n//# sourceMappingURL=FillStyle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/styles/LineStyle.mjs\n\n\n\nclass LineStyle extends FillStyle {\n  constructor() {\n    super(...arguments);\n    this.width = 0;\n    this.alignment = 0.5;\n    this.native = false;\n    this.cap = LINE_CAP.BUTT;\n    this.join = LINE_JOIN.MITER;\n    this.miterLimit = 10;\n  }\n  clone() {\n    const obj = new LineStyle();\n    obj.color = this.color;\n    obj.alpha = this.alpha;\n    obj.texture = this.texture;\n    obj.matrix = this.matrix;\n    obj.visible = this.visible;\n    obj.width = this.width;\n    obj.alignment = this.alignment;\n    obj.native = this.native;\n    obj.cap = this.cap;\n    obj.join = this.join;\n    obj.miterLimit = this.miterLimit;\n    return obj;\n  }\n  reset() {\n    super.reset();\n    this.color = 0;\n    this.alignment = 0.5;\n    this.width = 0;\n    this.native = false;\n  }\n}\n\n\n//# sourceMappingURL=LineStyle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/Graphics.mjs\n\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_SHADERS = {};\nconst _Graphics = class extends Container_Container {\n  constructor(geometry = null) {\n    super();\n    this.shader = null;\n    this.pluginName = "batch";\n    this.currentPath = null;\n    this.batches = [];\n    this.batchTint = -1;\n    this.batchDirty = -1;\n    this.vertexData = null;\n    this._fillStyle = new FillStyle();\n    this._lineStyle = new LineStyle();\n    this._matrix = null;\n    this._holeMode = false;\n    this.state = State.for2d();\n    this._geometry = geometry || new GraphicsGeometry();\n    this._geometry.refCount++;\n    this._transformID = -1;\n    this._tintColor = new color_lib/* Color */.I(16777215);\n    this.blendMode = lib/* BLEND_MODES */.T$.NORMAL;\n  }\n  get geometry() {\n    return this._geometry;\n  }\n  clone() {\n    this.finishPoly();\n    return new _Graphics(this._geometry);\n  }\n  set blendMode(value) {\n    this.state.blendMode = value;\n  }\n  get blendMode() {\n    return this.state.blendMode;\n  }\n  get tint() {\n    return this._tintColor.value;\n  }\n  set tint(value) {\n    this._tintColor.setValue(value);\n  }\n  get fill() {\n    return this._fillStyle;\n  }\n  get line() {\n    return this._lineStyle;\n  }\n  lineStyle(options = null, color = 0, alpha, alignment = 0.5, native = false) {\n    if (typeof options === "number") {\n      options = { width: options, color, alpha, alignment, native };\n    }\n    return this.lineTextureStyle(options);\n  }\n  lineTextureStyle(options) {\n    const defaultLineStyleOptions = {\n      width: 0,\n      texture: Texture_Texture.WHITE,\n      color: options?.texture ? 16777215 : 0,\n      matrix: null,\n      alignment: 0.5,\n      native: false,\n      cap: LINE_CAP.BUTT,\n      join: LINE_JOIN.MITER,\n      miterLimit: 10\n    };\n    options = Object.assign(defaultLineStyleOptions, options);\n    this.normalizeColor(options);\n    if (this.currentPath) {\n      this.startPoly();\n    }\n    const visible = options.width > 0 && options.alpha > 0;\n    if (!visible) {\n      this._lineStyle.reset();\n    } else {\n      if (options.matrix) {\n        options.matrix = options.matrix.clone();\n        options.matrix.invert();\n      }\n      Object.assign(this._lineStyle, { visible }, options);\n    }\n    return this;\n  }\n  startPoly() {\n    if (this.currentPath) {\n      const points = this.currentPath.points;\n      const len = this.currentPath.points.length;\n      if (len > 2) {\n        this.drawShape(this.currentPath);\n        this.currentPath = new Polygon();\n        this.currentPath.closeStroke = false;\n        this.currentPath.points.push(points[len - 2], points[len - 1]);\n      }\n    } else {\n      this.currentPath = new Polygon();\n      this.currentPath.closeStroke = false;\n    }\n  }\n  finishPoly() {\n    if (this.currentPath) {\n      if (this.currentPath.points.length > 2) {\n        this.drawShape(this.currentPath);\n        this.currentPath = null;\n      } else {\n        this.currentPath.points.length = 0;\n      }\n    }\n  }\n  moveTo(x, y) {\n    this.startPoly();\n    this.currentPath.points[0] = x;\n    this.currentPath.points[1] = y;\n    return this;\n  }\n  lineTo(x, y) {\n    if (!this.currentPath) {\n      this.moveTo(0, 0);\n    }\n    const points = this.currentPath.points;\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    if (fromX !== x || fromY !== y) {\n      points.push(x, y);\n    }\n    return this;\n  }\n  _initCurve(x = 0, y = 0) {\n    if (this.currentPath) {\n      if (this.currentPath.points.length === 0) {\n        this.currentPath.points = [x, y];\n      }\n    } else {\n      this.moveTo(x, y);\n    }\n  }\n  quadraticCurveTo(cpX, cpY, toX, toY) {\n    this._initCurve();\n    const points = this.currentPath.points;\n    if (points.length === 0) {\n      this.moveTo(0, 0);\n    }\n    QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);\n    return this;\n  }\n  bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {\n    this._initCurve();\n    BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);\n    return this;\n  }\n  arcTo(x1, y1, x2, y2, radius) {\n    this._initCurve(x1, y1);\n    const points = this.currentPath.points;\n    const result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);\n    if (result) {\n      const { cx, cy, radius: radius2, startAngle, endAngle, anticlockwise } = result;\n      this.arc(cx, cy, radius2, startAngle, endAngle, anticlockwise);\n    }\n    return this;\n  }\n  arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false) {\n    if (startAngle === endAngle) {\n      return this;\n    }\n    if (!anticlockwise && endAngle <= startAngle) {\n      endAngle += PI_2;\n    } else if (anticlockwise && startAngle <= endAngle) {\n      startAngle += PI_2;\n    }\n    const sweep = endAngle - startAngle;\n    if (sweep === 0) {\n      return this;\n    }\n    const startX = cx + Math.cos(startAngle) * radius;\n    const startY = cy + Math.sin(startAngle) * radius;\n    const eps = this._geometry.closePointEps;\n    let points = this.currentPath ? this.currentPath.points : null;\n    if (points) {\n      const xDiff = Math.abs(points[points.length - 2] - startX);\n      const yDiff = Math.abs(points[points.length - 1] - startY);\n      if (xDiff < eps && yDiff < eps) {\n      } else {\n        points.push(startX, startY);\n      }\n    } else {\n      this.moveTo(startX, startY);\n      points = this.currentPath.points;\n    }\n    ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);\n    return this;\n  }\n  beginFill(color = 0, alpha) {\n    return this.beginTextureFill({ texture: Texture_Texture.WHITE, color, alpha });\n  }\n  normalizeColor(options) {\n    const temp = color_lib/* Color */.I.shared.setValue(options.color ?? 0);\n    options.color = temp.toNumber();\n    options.alpha ?? (options.alpha = temp.alpha);\n  }\n  beginTextureFill(options) {\n    const defaultOptions = {\n      texture: Texture_Texture.WHITE,\n      color: 16777215,\n      matrix: null\n    };\n    options = Object.assign(defaultOptions, options);\n    this.normalizeColor(options);\n    if (this.currentPath) {\n      this.startPoly();\n    }\n    const visible = options.alpha > 0;\n    if (!visible) {\n      this._fillStyle.reset();\n    } else {\n      if (options.matrix) {\n        options.matrix = options.matrix.clone();\n        options.matrix.invert();\n      }\n      Object.assign(this._fillStyle, { visible }, options);\n    }\n    return this;\n  }\n  endFill() {\n    this.finishPoly();\n    this._fillStyle.reset();\n    return this;\n  }\n  drawRect(x, y, width, height) {\n    return this.drawShape(new Rectangle_Rectangle(x, y, width, height));\n  }\n  drawRoundedRect(x, y, width, height, radius) {\n    return this.drawShape(new RoundedRectangle(x, y, width, height, radius));\n  }\n  drawCircle(x, y, radius) {\n    return this.drawShape(new Circle(x, y, radius));\n  }\n  drawEllipse(x, y, width, height) {\n    return this.drawShape(new Ellipse(x, y, width, height));\n  }\n  drawPolygon(...path) {\n    let points;\n    let closeStroke = true;\n    const poly = path[0];\n    if (poly.points) {\n      closeStroke = poly.closeStroke;\n      points = poly.points;\n    } else if (Array.isArray(path[0])) {\n      points = path[0];\n    } else {\n      points = path;\n    }\n    const shape = new Polygon(points);\n    shape.closeStroke = closeStroke;\n    this.drawShape(shape);\n    return this;\n  }\n  drawShape(shape) {\n    if (!this._holeMode) {\n      this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);\n    } else {\n      this._geometry.drawHole(shape, this._matrix);\n    }\n    return this;\n  }\n  clear() {\n    this._geometry.clear();\n    this._lineStyle.reset();\n    this._fillStyle.reset();\n    this._boundsID++;\n    this._matrix = null;\n    this._holeMode = false;\n    this.currentPath = null;\n    return this;\n  }\n  isFastRect() {\n    const data = this._geometry.graphicsData;\n    return data.length === 1 && data[0].shape.type === SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);\n  }\n  _render(renderer) {\n    this.finishPoly();\n    const geometry = this._geometry;\n    geometry.updateBatches();\n    if (geometry.batchable) {\n      if (this.batchDirty !== geometry.batchDirty) {\n        this._populateBatches();\n      }\n      this._renderBatched(renderer);\n    } else {\n      renderer.batch.flush();\n      this._renderDirect(renderer);\n    }\n  }\n  _populateBatches() {\n    const geometry = this._geometry;\n    const blendMode = this.blendMode;\n    const len = geometry.batches.length;\n    this.batchTint = -1;\n    this._transformID = -1;\n    this.batchDirty = geometry.batchDirty;\n    this.batches.length = len;\n    this.vertexData = new Float32Array(geometry.points);\n    for (let i = 0; i < len; i++) {\n      const gI = geometry.batches[i];\n      const color = gI.style.color;\n      const vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);\n      const uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);\n      const indices = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);\n      const batch = {\n        vertexData,\n        blendMode,\n        indices,\n        uvs,\n        _batchRGB: color_lib/* Color */.I.shared.setValue(color).toRgbArray(),\n        _tintRGB: color,\n        _texture: gI.style.texture,\n        alpha: gI.style.alpha,\n        worldAlpha: 1\n      };\n      this.batches[i] = batch;\n    }\n  }\n  _renderBatched(renderer) {\n    if (!this.batches.length) {\n      return;\n    }\n    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n    this.calculateVertices();\n    this.calculateTints();\n    for (let i = 0, l = this.batches.length; i < l; i++) {\n      const batch = this.batches[i];\n      batch.worldAlpha = this.worldAlpha * batch.alpha;\n      renderer.plugins[this.pluginName].render(batch);\n    }\n  }\n  _renderDirect(renderer) {\n    const shader = this._resolveDirectShader(renderer);\n    const geometry = this._geometry;\n    const worldAlpha = this.worldAlpha;\n    const uniforms = shader.uniforms;\n    const drawCalls = geometry.drawCalls;\n    uniforms.translationMatrix = this.transform.worldTransform;\n    color_lib/* Color */.I.shared.setValue(this._tintColor).premultiply(worldAlpha).toArray(uniforms.tint);\n    renderer.shader.bind(shader);\n    renderer.geometry.bind(geometry, shader);\n    renderer.state.set(this.state);\n    for (let i = 0, l = drawCalls.length; i < l; i++) {\n      this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);\n    }\n  }\n  _renderDrawCallDirect(renderer, drawCall) {\n    const { texArray, type, size, start } = drawCall;\n    const groupTextureCount = texArray.count;\n    for (let j = 0; j < groupTextureCount; j++) {\n      renderer.texture.bind(texArray.elements[j], j);\n    }\n    renderer.geometry.draw(type, size, start);\n  }\n  _resolveDirectShader(renderer) {\n    let shader = this.shader;\n    const pluginName = this.pluginName;\n    if (!shader) {\n      if (!DEFAULT_SHADERS[pluginName]) {\n        const { maxTextures } = renderer.plugins[pluginName];\n        const sampleValues = new Int32Array(maxTextures);\n        for (let i = 0; i < maxTextures; i++) {\n          sampleValues[i] = i;\n        }\n        const uniforms = {\n          tint: new Float32Array([1, 1, 1, 1]),\n          translationMatrix: new Matrix(),\n          default: UniformGroup.from({ uSamplers: sampleValues }, true)\n        };\n        const program = renderer.plugins[pluginName]._shader.program;\n        DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);\n      }\n      shader = DEFAULT_SHADERS[pluginName];\n    }\n    return shader;\n  }\n  _calculateBounds() {\n    this.finishPoly();\n    const geometry = this._geometry;\n    if (!geometry.graphicsData.length) {\n      return;\n    }\n    const { minX, minY, maxX, maxY } = geometry.bounds;\n    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n  }\n  containsPoint(point) {\n    this.worldTransform.applyInverse(point, _Graphics._TEMP_POINT);\n    return this._geometry.containsPoint(_Graphics._TEMP_POINT);\n  }\n  calculateTints() {\n    if (this.batchTint !== this.tint) {\n      this.batchTint = this._tintColor.toNumber();\n      for (let i = 0; i < this.batches.length; i++) {\n        const batch = this.batches[i];\n        batch._tintRGB = color_lib/* Color */.I.shared.setValue(this._tintColor).multiply(batch._batchRGB).toLittleEndianNumber();\n      }\n    }\n  }\n  calculateVertices() {\n    const wtID = this.transform._worldID;\n    if (this._transformID === wtID) {\n      return;\n    }\n    this._transformID = wtID;\n    const wt = this.transform.worldTransform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const data = this._geometry.points;\n    const vertexData = this.vertexData;\n    let count = 0;\n    for (let i = 0; i < data.length; i += 2) {\n      const x = data[i];\n      const y = data[i + 1];\n      vertexData[count++] = a * x + c * y + tx;\n      vertexData[count++] = d * y + b * x + ty;\n    }\n  }\n  closePath() {\n    const currentPath = this.currentPath;\n    if (currentPath) {\n      currentPath.closeStroke = true;\n      this.finishPoly();\n    }\n    return this;\n  }\n  setMatrix(matrix) {\n    this._matrix = matrix;\n    return this;\n  }\n  beginHole() {\n    this.finishPoly();\n    this._holeMode = true;\n    return this;\n  }\n  endHole() {\n    this.finishPoly();\n    this._holeMode = false;\n    return this;\n  }\n  destroy(options) {\n    this._geometry.refCount--;\n    if (this._geometry.refCount === 0) {\n      this._geometry.dispose();\n    }\n    this._matrix = null;\n    this.currentPath = null;\n    this._lineStyle.destroy();\n    this._lineStyle = null;\n    this._fillStyle.destroy();\n    this._fillStyle = null;\n    this._geometry = null;\n    this.shader = null;\n    this.vertexData = null;\n    this.batches.length = 0;\n    this.batches = null;\n    super.destroy(options);\n  }\n};\nlet Graphics = _Graphics;\nGraphics.curves = curves;\nGraphics._TEMP_POINT = new Point();\n\n\n//# sourceMappingURL=Graphics.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/graphics/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst graphicsUtils = {\n  buildPoly: buildPoly,\n  buildCircle: buildCircle,\n  buildRectangle: buildRectangle,\n  buildRoundedRectangle: buildRoundedRectangle,\n  buildLine: buildLine,\n  ArcUtils: ArcUtils,\n  BezierUtils: BezierUtils,\n  QuadraticUtils: QuadraticUtils,\n  BatchPart: BatchPart,\n  FILL_COMMANDS: FILL_COMMANDS,\n  BATCH_POOL: BATCH_POOL,\n  DRAW_CALL_POOL: DRAW_CALL_POOL\n};\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/MeshBatchUvs.mjs\nclass MeshBatchUvs {\n  constructor(uvBuffer, uvMatrix) {\n    this.uvBuffer = uvBuffer;\n    this.uvMatrix = uvMatrix;\n    this.data = null;\n    this._bufferUpdateId = -1;\n    this._textureUpdateId = -1;\n    this._updateID = 0;\n  }\n  update(forceUpdate) {\n    if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) {\n      return;\n    }\n    this._bufferUpdateId = this.uvBuffer._updateID;\n    this._textureUpdateId = this.uvMatrix._updateID;\n    const data = this.uvBuffer.data;\n    if (!this.data || this.data.length !== data.length) {\n      this.data = new Float32Array(data.length);\n    }\n    this.uvMatrix.multiplyUvs(data, this.data);\n    this._updateID++;\n  }\n}\n\n\n//# sourceMappingURL=MeshBatchUvs.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/Mesh.mjs\n\n\n\n\nconst Mesh_tempPoint = new Point();\nconst tempPolygon = new Polygon();\nconst _Mesh = class extends Container_Container {\n  constructor(geometry, shader, state, drawMode = lib/* DRAW_MODES */.lg.TRIANGLES) {\n    super();\n    this.geometry = geometry;\n    this.shader = shader;\n    this.state = state || State.for2d();\n    this.drawMode = drawMode;\n    this.start = 0;\n    this.size = 0;\n    this.uvs = null;\n    this.indices = null;\n    this.vertexData = new Float32Array(1);\n    this.vertexDirty = -1;\n    this._transformID = -1;\n    this._roundPixels = settings_lib/* settings */.Xd.ROUND_PIXELS;\n    this.batchUvs = null;\n  }\n  get geometry() {\n    return this._geometry;\n  }\n  set geometry(value) {\n    if (this._geometry === value) {\n      return;\n    }\n    if (this._geometry) {\n      this._geometry.refCount--;\n      if (this._geometry.refCount === 0) {\n        this._geometry.dispose();\n      }\n    }\n    this._geometry = value;\n    if (this._geometry) {\n      this._geometry.refCount++;\n    }\n    this.vertexDirty = -1;\n  }\n  get uvBuffer() {\n    return this.geometry.buffers[1];\n  }\n  get verticesBuffer() {\n    return this.geometry.buffers[0];\n  }\n  set material(value) {\n    this.shader = value;\n  }\n  get material() {\n    return this.shader;\n  }\n  set blendMode(value) {\n    this.state.blendMode = value;\n  }\n  get blendMode() {\n    return this.state.blendMode;\n  }\n  set roundPixels(value) {\n    if (this._roundPixels !== value) {\n      this._transformID = -1;\n    }\n    this._roundPixels = value;\n  }\n  get roundPixels() {\n    return this._roundPixels;\n  }\n  get tint() {\n    return "tint" in this.shader ? this.shader.tint : null;\n  }\n  set tint(value) {\n    this.shader.tint = value;\n  }\n  get tintValue() {\n    return this.shader.tintValue;\n  }\n  get texture() {\n    return "texture" in this.shader ? this.shader.texture : null;\n  }\n  set texture(value) {\n    this.shader.texture = value;\n  }\n  _render(renderer) {\n    const vertices = this.geometry.buffers[0].data;\n    const shader = this.shader;\n    if (shader.batchable && this.drawMode === lib/* DRAW_MODES */.lg.TRIANGLES && vertices.length < _Mesh.BATCHABLE_SIZE * 2) {\n      this._renderToBatch(renderer);\n    } else {\n      this._renderDefault(renderer);\n    }\n  }\n  _renderDefault(renderer) {\n    const shader = this.shader;\n    shader.alpha = this.worldAlpha;\n    if (shader.update) {\n      shader.update();\n    }\n    renderer.batch.flush();\n    shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);\n    renderer.shader.bind(shader);\n    renderer.state.set(this.state);\n    renderer.geometry.bind(this.geometry, shader);\n    renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);\n  }\n  _renderToBatch(renderer) {\n    const geometry = this.geometry;\n    const shader = this.shader;\n    if (shader.uvMatrix) {\n      shader.uvMatrix.update();\n      this.calculateUvs();\n    }\n    this.calculateVertices();\n    this.indices = geometry.indexBuffer.data;\n    this._tintRGB = shader._tintRGB;\n    this._texture = shader.texture;\n    const pluginName = this.material.pluginName;\n    renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);\n    renderer.plugins[pluginName].render(this);\n  }\n  calculateVertices() {\n    const geometry = this.geometry;\n    const verticesBuffer = geometry.buffers[0];\n    const vertices = verticesBuffer.data;\n    const vertexDirtyId = verticesBuffer._updateID;\n    if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {\n      return;\n    }\n    this._transformID = this.transform._worldID;\n    if (this.vertexData.length !== vertices.length) {\n      this.vertexData = new Float32Array(vertices.length);\n    }\n    const wt = this.transform.worldTransform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const vertexData = this.vertexData;\n    for (let i = 0; i < vertexData.length / 2; i++) {\n      const x = vertices[i * 2];\n      const y = vertices[i * 2 + 1];\n      vertexData[i * 2] = a * x + c * y + tx;\n      vertexData[i * 2 + 1] = b * x + d * y + ty;\n    }\n    if (this._roundPixels) {\n      const resolution = settings_lib/* settings */.Xd.RESOLUTION;\n      for (let i = 0; i < vertexData.length; ++i) {\n        vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;\n      }\n    }\n    this.vertexDirty = vertexDirtyId;\n  }\n  calculateUvs() {\n    const geomUvs = this.geometry.buffers[1];\n    const shader = this.shader;\n    if (!shader.uvMatrix.isSimple) {\n      if (!this.batchUvs) {\n        this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);\n      }\n      this.batchUvs.update();\n      this.uvs = this.batchUvs.data;\n    } else {\n      this.uvs = geomUvs.data;\n    }\n  }\n  _calculateBounds() {\n    this.calculateVertices();\n    this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);\n  }\n  containsPoint(point) {\n    if (!this.getBounds().contains(point.x, point.y)) {\n      return false;\n    }\n    this.worldTransform.applyInverse(point, Mesh_tempPoint);\n    const vertices = this.geometry.getBuffer("aVertexPosition").data;\n    const points = tempPolygon.points;\n    const indices = this.geometry.getIndex().data;\n    const len = indices.length;\n    const step = this.drawMode === 4 ? 3 : 1;\n    for (let i = 0; i + 2 < len; i += step) {\n      const ind0 = indices[i] * 2;\n      const ind1 = indices[i + 1] * 2;\n      const ind2 = indices[i + 2] * 2;\n      points[0] = vertices[ind0];\n      points[1] = vertices[ind0 + 1];\n      points[2] = vertices[ind1];\n      points[3] = vertices[ind1 + 1];\n      points[4] = vertices[ind2];\n      points[5] = vertices[ind2 + 1];\n      if (tempPolygon.contains(Mesh_tempPoint.x, Mesh_tempPoint.y)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  destroy(options) {\n    super.destroy(options);\n    if (this._cachedTexture) {\n      this._cachedTexture.destroy();\n      this._cachedTexture = null;\n    }\n    this.geometry = null;\n    this.shader = null;\n    this.state = null;\n    this.uvs = null;\n    this.indices = null;\n    this.vertexData = null;\n  }\n};\nlet Mesh_Mesh = _Mesh;\nMesh_Mesh.BATCHABLE_SIZE = 100;\n\n\n//# sourceMappingURL=Mesh.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/MeshGeometry.mjs\n\n\nclass MeshGeometry_MeshGeometry extends Geometry {\n  constructor(vertices, uvs, index) {\n    super();\n    const verticesBuffer = new Buffer(vertices);\n    const uvsBuffer = new Buffer(uvs, true);\n    const indexBuffer = new Buffer(index, true, true);\n    this.addAttribute("aVertexPosition", verticesBuffer, 2, false, lib/* TYPES */.vK.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, false, lib/* TYPES */.vK.FLOAT).addIndex(indexBuffer);\n    this._updateId = -1;\n  }\n  get vertexDirtyId() {\n    return this.buffers[0]._updateID;\n  }\n}\n\n\n//# sourceMappingURL=MeshGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/shader/mesh.mjs\nvar mesh_fragment = "varying vec2 vTextureCoord;\\nuniform vec4 uColor;\\n\\nuniform sampler2D uSampler;\\n\\nvoid main(void)\\n{\\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\\n}\\n";\n\n\n//# sourceMappingURL=mesh.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/shader/mesh2.mjs\nvar mesh2_vertex = "attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTextureMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\\n}\\n";\n\n\n//# sourceMappingURL=mesh2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/MeshMaterial.mjs\n\n\n\n\nclass MeshMaterial_MeshMaterial extends Shader {\n  constructor(uSampler, options) {\n    const uniforms = {\n      uSampler,\n      alpha: 1,\n      uTextureMatrix: Matrix.IDENTITY,\n      uColor: new Float32Array([1, 1, 1, 1])\n    };\n    options = Object.assign({\n      tint: 16777215,\n      alpha: 1,\n      pluginName: "batch"\n    }, options);\n    if (options.uniforms) {\n      Object.assign(uniforms, options.uniforms);\n    }\n    super(options.program || Program.from(mesh2_vertex, mesh_fragment), uniforms);\n    this._colorDirty = false;\n    this.uvMatrix = new TextureMatrix_TextureMatrix(uSampler);\n    this.batchable = options.program === void 0;\n    this.pluginName = options.pluginName;\n    this._tintColor = new color_lib/* Color */.I(options.tint);\n    this._tintRGB = this._tintColor.toLittleEndianNumber();\n    this._colorDirty = true;\n    this.alpha = options.alpha;\n  }\n  get texture() {\n    return this.uniforms.uSampler;\n  }\n  set texture(value) {\n    if (this.uniforms.uSampler !== value) {\n      if (!this.uniforms.uSampler.baseTexture.alphaMode !== !value.baseTexture.alphaMode) {\n        this._colorDirty = true;\n      }\n      this.uniforms.uSampler = value;\n      this.uvMatrix.texture = value;\n    }\n  }\n  set alpha(value) {\n    if (value === this._alpha)\n      return;\n    this._alpha = value;\n    this._colorDirty = true;\n  }\n  get alpha() {\n    return this._alpha;\n  }\n  set tint(value) {\n    if (value === this.tint)\n      return;\n    this._tintColor.setValue(value);\n    this._tintRGB = this._tintColor.toLittleEndianNumber();\n    this._colorDirty = true;\n  }\n  get tint() {\n    return this._tintColor.value;\n  }\n  get tintValue() {\n    return this._tintColor.toNumber();\n  }\n  update() {\n    if (this._colorDirty) {\n      this._colorDirty = false;\n      const baseTexture = this.texture.baseTexture;\n      const applyToChannels = baseTexture.alphaMode;\n      color_lib/* Color */.I.shared.setValue(this._tintColor).premultiply(this._alpha, applyToChannels).toArray(this.uniforms.uColor);\n    }\n    if (this.uvMatrix.update()) {\n      this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;\n    }\n  }\n}\n\n\n//# sourceMappingURL=MeshMaterial.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh/lib/index.mjs\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/geometry/PlaneGeometry.mjs\n\n\nclass PlaneGeometry_PlaneGeometry extends (/* unused pure expression or super */ null && (MeshGeometry)) {\n  constructor(width = 100, height = 100, segWidth = 10, segHeight = 10) {\n    super();\n    this.segWidth = segWidth;\n    this.segHeight = segHeight;\n    this.width = width;\n    this.height = height;\n    this.build();\n  }\n  build() {\n    const total = this.segWidth * this.segHeight;\n    const verts = [];\n    const uvs = [];\n    const indices = [];\n    const segmentsX = this.segWidth - 1;\n    const segmentsY = this.segHeight - 1;\n    const sizeX = this.width / segmentsX;\n    const sizeY = this.height / segmentsY;\n    for (let i = 0; i < total; i++) {\n      const x = i % this.segWidth;\n      const y = i / this.segWidth | 0;\n      verts.push(x * sizeX, y * sizeY);\n      uvs.push(x / segmentsX, y / segmentsY);\n    }\n    const totalSub = segmentsX * segmentsY;\n    for (let i = 0; i < totalSub; i++) {\n      const xpos = i % segmentsX;\n      const ypos = i / segmentsX | 0;\n      const value = ypos * this.segWidth + xpos;\n      const value2 = ypos * this.segWidth + xpos + 1;\n      const value3 = (ypos + 1) * this.segWidth + xpos;\n      const value4 = (ypos + 1) * this.segWidth + xpos + 1;\n      indices.push(value, value2, value3, value2, value4, value3);\n    }\n    this.buffers[0].data = new Float32Array(verts);\n    this.buffers[1].data = new Float32Array(uvs);\n    this.indexBuffer.data = new Uint16Array(indices);\n    this.buffers[0].update();\n    this.buffers[1].update();\n    this.indexBuffer.update();\n  }\n}\n\n\n//# sourceMappingURL=PlaneGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.mjs\n\n\nclass RopeGeometry_RopeGeometry extends (/* unused pure expression or super */ null && (MeshGeometry)) {\n  constructor(width = 200, points, textureScale = 0) {\n    super(new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6));\n    this.points = points;\n    this._width = width;\n    this.textureScale = textureScale;\n    this.build();\n  }\n  get width() {\n    return this._width;\n  }\n  build() {\n    const points = this.points;\n    if (!points)\n      return;\n    const vertexBuffer = this.getBuffer("aVertexPosition");\n    const uvBuffer = this.getBuffer("aTextureCoord");\n    const indexBuffer = this.getIndex();\n    if (points.length < 1) {\n      return;\n    }\n    if (vertexBuffer.data.length / 4 !== points.length) {\n      vertexBuffer.data = new Float32Array(points.length * 4);\n      uvBuffer.data = new Float32Array(points.length * 4);\n      indexBuffer.data = new Uint16Array((points.length - 1) * 6);\n    }\n    const uvs = uvBuffer.data;\n    const indices = indexBuffer.data;\n    uvs[0] = 0;\n    uvs[1] = 0;\n    uvs[2] = 0;\n    uvs[3] = 1;\n    let amount = 0;\n    let prev = points[0];\n    const textureWidth = this._width * this.textureScale;\n    const total = points.length;\n    for (let i = 0; i < total; i++) {\n      const index = i * 4;\n      if (this.textureScale > 0) {\n        const dx = prev.x - points[i].x;\n        const dy = prev.y - points[i].y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        prev = points[i];\n        amount += distance / textureWidth;\n      } else {\n        amount = i / (total - 1);\n      }\n      uvs[index] = amount;\n      uvs[index + 1] = 0;\n      uvs[index + 2] = amount;\n      uvs[index + 3] = 1;\n    }\n    let indexCount = 0;\n    for (let i = 0; i < total - 1; i++) {\n      const index = i * 2;\n      indices[indexCount++] = index;\n      indices[indexCount++] = index + 1;\n      indices[indexCount++] = index + 2;\n      indices[indexCount++] = index + 2;\n      indices[indexCount++] = index + 1;\n      indices[indexCount++] = index + 3;\n    }\n    uvBuffer.update();\n    indexBuffer.update();\n    this.updateVertices();\n  }\n  updateVertices() {\n    const points = this.points;\n    if (points.length < 1) {\n      return;\n    }\n    let lastPoint = points[0];\n    let nextPoint;\n    let perpX = 0;\n    let perpY = 0;\n    const vertices = this.buffers[0].data;\n    const total = points.length;\n    const halfWidth = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;\n    for (let i = 0; i < total; i++) {\n      const point = points[i];\n      const index = i * 4;\n      if (i < points.length - 1) {\n        nextPoint = points[i + 1];\n      } else {\n        nextPoint = point;\n      }\n      perpY = -(nextPoint.x - lastPoint.x);\n      perpX = nextPoint.y - lastPoint.y;\n      let ratio = (1 - i / (total - 1)) * 10;\n      if (ratio > 1) {\n        ratio = 1;\n      }\n      const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);\n      if (perpLength < 1e-6) {\n        perpX = 0;\n        perpY = 0;\n      } else {\n        perpX /= perpLength;\n        perpY /= perpLength;\n        perpX *= halfWidth;\n        perpY *= halfWidth;\n      }\n      vertices[index] = point.x + perpX;\n      vertices[index + 1] = point.y + perpY;\n      vertices[index + 2] = point.x - perpX;\n      vertices[index + 3] = point.y - perpY;\n      lastPoint = point;\n    }\n    this.buffers[0].update();\n  }\n  update() {\n    if (this.textureScale > 0) {\n      this.build();\n    } else {\n      this.updateVertices();\n    }\n  }\n}\n\n\n//# sourceMappingURL=RopeGeometry.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/SimplePlane.mjs\n\n\n\n\nclass SimplePlane_SimplePlane extends (/* unused pure expression or super */ null && (Mesh)) {\n  constructor(texture, verticesX, verticesY) {\n    const planeGeometry = new PlaneGeometry(texture.width, texture.height, verticesX, verticesY);\n    const meshMaterial = new MeshMaterial(Texture.WHITE);\n    super(planeGeometry, meshMaterial);\n    this.texture = texture;\n    this.autoResize = true;\n  }\n  textureUpdated() {\n    this._textureID = this.shader.texture._updateID;\n    const geometry = this.geometry;\n    const { width, height } = this.shader.texture;\n    if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {\n      geometry.width = this.shader.texture.width;\n      geometry.height = this.shader.texture.height;\n      geometry.build();\n    }\n  }\n  set texture(value) {\n    if (this.shader.texture === value) {\n      return;\n    }\n    this.shader.texture = value;\n    this._textureID = -1;\n    if (value.baseTexture.valid) {\n      this.textureUpdated();\n    } else {\n      value.once("update", this.textureUpdated, this);\n    }\n  }\n  get texture() {\n    return this.shader.texture;\n  }\n  _render(renderer) {\n    if (this._textureID !== this.shader.texture._updateID) {\n      this.textureUpdated();\n    }\n    super._render(renderer);\n  }\n  destroy(options) {\n    this.shader.texture.off("update", this.textureUpdated, this);\n    super.destroy(options);\n  }\n}\n\n\n//# sourceMappingURL=SimplePlane.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/NineSlicePlane.mjs\n\n\n\nconst DEFAULT_BORDER_SIZE = 10;\nclass NineSlicePlane extends (/* unused pure expression or super */ null && (SimplePlane)) {\n  constructor(texture, leftWidth, topHeight, rightWidth, bottomHeight) {\n    super(Texture.WHITE, 4, 4);\n    this._origWidth = texture.orig.width;\n    this._origHeight = texture.orig.height;\n    this._width = this._origWidth;\n    this._height = this._origHeight;\n    this._leftWidth = leftWidth ?? texture.defaultBorders?.left ?? DEFAULT_BORDER_SIZE;\n    this._rightWidth = rightWidth ?? texture.defaultBorders?.right ?? DEFAULT_BORDER_SIZE;\n    this._topHeight = topHeight ?? texture.defaultBorders?.top ?? DEFAULT_BORDER_SIZE;\n    this._bottomHeight = bottomHeight ?? texture.defaultBorders?.bottom ?? DEFAULT_BORDER_SIZE;\n    this.texture = texture;\n  }\n  textureUpdated() {\n    this._textureID = this.shader.texture._updateID;\n    this._refresh();\n  }\n  get vertices() {\n    return this.geometry.getBuffer("aVertexPosition").data;\n  }\n  set vertices(value) {\n    this.geometry.getBuffer("aVertexPosition").data = value;\n  }\n  updateHorizontalVertices() {\n    const vertices = this.vertices;\n    const scale = this._getMinScale();\n    vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;\n    vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale;\n    vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;\n  }\n  updateVerticalVertices() {\n    const vertices = this.vertices;\n    const scale = this._getMinScale();\n    vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;\n    vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale;\n    vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;\n  }\n  _getMinScale() {\n    const w = this._leftWidth + this._rightWidth;\n    const scaleW = this._width > w ? 1 : this._width / w;\n    const h = this._topHeight + this._bottomHeight;\n    const scaleH = this._height > h ? 1 : this._height / h;\n    const scale = Math.min(scaleW, scaleH);\n    return scale;\n  }\n  get width() {\n    return this._width;\n  }\n  set width(value) {\n    this._width = value;\n    this._refresh();\n  }\n  get height() {\n    return this._height;\n  }\n  set height(value) {\n    this._height = value;\n    this._refresh();\n  }\n  get leftWidth() {\n    return this._leftWidth;\n  }\n  set leftWidth(value) {\n    this._leftWidth = value;\n    this._refresh();\n  }\n  get rightWidth() {\n    return this._rightWidth;\n  }\n  set rightWidth(value) {\n    this._rightWidth = value;\n    this._refresh();\n  }\n  get topHeight() {\n    return this._topHeight;\n  }\n  set topHeight(value) {\n    this._topHeight = value;\n    this._refresh();\n  }\n  get bottomHeight() {\n    return this._bottomHeight;\n  }\n  set bottomHeight(value) {\n    this._bottomHeight = value;\n    this._refresh();\n  }\n  _refresh() {\n    const texture = this.texture;\n    const uvs = this.geometry.buffers[1].data;\n    this._origWidth = texture.orig.width;\n    this._origHeight = texture.orig.height;\n    const _uvw = 1 / this._origWidth;\n    const _uvh = 1 / this._origHeight;\n    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;\n    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;\n    this.updateHorizontalVertices();\n    this.updateVerticalVertices();\n    this.geometry.buffers[0].update();\n    this.geometry.buffers[1].update();\n  }\n}\n\n\n//# sourceMappingURL=NineSlicePlane.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/SimpleMesh.mjs\n\n\n\nclass SimpleMesh extends (/* unused pure expression or super */ null && (Mesh)) {\n  constructor(texture = Texture.EMPTY, vertices, uvs, indices, drawMode) {\n    const geometry = new MeshGeometry(vertices, uvs, indices);\n    geometry.getBuffer("aVertexPosition").static = false;\n    const meshMaterial = new MeshMaterial(texture);\n    super(geometry, meshMaterial, null, drawMode);\n    this.autoUpdate = true;\n  }\n  get vertices() {\n    return this.geometry.getBuffer("aVertexPosition").data;\n  }\n  set vertices(value) {\n    this.geometry.getBuffer("aVertexPosition").data = value;\n  }\n  _render(renderer) {\n    if (this.autoUpdate) {\n      this.geometry.getBuffer("aVertexPosition").update();\n    }\n    super._render(renderer);\n  }\n}\n\n\n//# sourceMappingURL=SimpleMesh.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/SimpleRope.mjs\n\n\n\n\nclass SimpleRope extends (/* unused pure expression or super */ null && (Mesh)) {\n  constructor(texture, points, textureScale = 0) {\n    const ropeGeometry = new RopeGeometry(texture.height, points, textureScale);\n    const meshMaterial = new MeshMaterial(texture);\n    if (textureScale > 0) {\n      texture.baseTexture.wrapMode = WRAP_MODES.REPEAT;\n    }\n    super(ropeGeometry, meshMaterial);\n    this.autoUpdate = true;\n  }\n  _render(renderer) {\n    const geometry = this.geometry;\n    if (this.autoUpdate || geometry._width !== this.shader.texture.height) {\n      geometry._width = this.shader.texture.height;\n      geometry.update();\n    }\n    super._render(renderer);\n  }\n}\n\n\n//# sourceMappingURL=SimpleRope.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/mesh-extras/lib/index.mjs\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/particle-container/lib/ParticleContainer.mjs\n\n\n\nclass ParticleContainer extends (/* unused pure expression or super */ null && (Container)) {\n  constructor(maxSize = 1500, properties, batchSize = 16384, autoResize = false) {\n    super();\n    const maxBatchSize = 16384;\n    if (batchSize > maxBatchSize) {\n      batchSize = maxBatchSize;\n    }\n    this._properties = [false, true, false, false, false];\n    this._maxSize = maxSize;\n    this._batchSize = batchSize;\n    this._buffers = null;\n    this._bufferUpdateIDs = [];\n    this._updateID = 0;\n    this.interactiveChildren = false;\n    this.blendMode = BLEND_MODES.NORMAL;\n    this.autoResize = autoResize;\n    this.roundPixels = true;\n    this.baseTexture = null;\n    this.setProperties(properties);\n    this._tintColor = new Color(0);\n    this.tintRgb = new Float32Array(3);\n    this.tint = 16777215;\n  }\n  setProperties(properties) {\n    if (properties) {\n      this._properties[0] = "vertices" in properties || "scale" in properties ? !!properties.vertices || !!properties.scale : this._properties[0];\n      this._properties[1] = "position" in properties ? !!properties.position : this._properties[1];\n      this._properties[2] = "rotation" in properties ? !!properties.rotation : this._properties[2];\n      this._properties[3] = "uvs" in properties ? !!properties.uvs : this._properties[3];\n      this._properties[4] = "tint" in properties || "alpha" in properties ? !!properties.tint || !!properties.alpha : this._properties[4];\n    }\n  }\n  updateTransform() {\n    this.displayObjectUpdateTransform();\n  }\n  get tint() {\n    return this._tintColor.value;\n  }\n  set tint(value) {\n    this._tintColor.setValue(value);\n    this._tintColor.toRgbArray(this.tintRgb);\n  }\n  render(renderer) {\n    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {\n      return;\n    }\n    if (!this.baseTexture) {\n      this.baseTexture = this.children[0]._texture.baseTexture;\n      if (!this.baseTexture.valid) {\n        this.baseTexture.once("update", () => this.onChildrenChange(0));\n      }\n    }\n    renderer.batch.setObjectRenderer(renderer.plugins.particle);\n    renderer.plugins.particle.render(this);\n  }\n  onChildrenChange(smallestChildIndex) {\n    const bufferIndex = Math.floor(smallestChildIndex / this._batchSize);\n    while (this._bufferUpdateIDs.length < bufferIndex) {\n      this._bufferUpdateIDs.push(0);\n    }\n    this._bufferUpdateIDs[bufferIndex] = ++this._updateID;\n  }\n  dispose() {\n    if (this._buffers) {\n      for (let i = 0; i < this._buffers.length; ++i) {\n        this._buffers[i].destroy();\n      }\n      this._buffers = null;\n    }\n  }\n  destroy(options) {\n    super.destroy(options);\n    this.dispose();\n    this._properties = null;\n    this._buffers = null;\n    this._bufferUpdateIDs = null;\n  }\n}\n\n\n//# sourceMappingURL=ParticleContainer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/particle-container/lib/ParticleBuffer.mjs\n\n\nclass ParticleBuffer {\n  constructor(properties, dynamicPropertyFlags, size) {\n    this.geometry = new Geometry();\n    this.indexBuffer = null;\n    this.size = size;\n    this.dynamicProperties = [];\n    this.staticProperties = [];\n    for (let i = 0; i < properties.length; ++i) {\n      let property = properties[i];\n      property = {\n        attributeName: property.attributeName,\n        size: property.size,\n        uploadFunction: property.uploadFunction,\n        type: property.type || lib/* TYPES */.vK.FLOAT,\n        offset: property.offset\n      };\n      if (dynamicPropertyFlags[i]) {\n        this.dynamicProperties.push(property);\n      } else {\n        this.staticProperties.push(property);\n      }\n    }\n    this.staticStride = 0;\n    this.staticBuffer = null;\n    this.staticData = null;\n    this.staticDataUint32 = null;\n    this.dynamicStride = 0;\n    this.dynamicBuffer = null;\n    this.dynamicData = null;\n    this.dynamicDataUint32 = null;\n    this._updateID = 0;\n    this.initBuffers();\n  }\n  initBuffers() {\n    const geometry = this.geometry;\n    let dynamicOffset = 0;\n    this.indexBuffer = new Buffer(utils_lib.createIndicesForQuads(this.size), true, true);\n    geometry.addIndex(this.indexBuffer);\n    this.dynamicStride = 0;\n    for (let i = 0; i < this.dynamicProperties.length; ++i) {\n      const property = this.dynamicProperties[i];\n      property.offset = dynamicOffset;\n      dynamicOffset += property.size;\n      this.dynamicStride += property.size;\n    }\n    const dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);\n    this.dynamicData = new Float32Array(dynBuffer);\n    this.dynamicDataUint32 = new Uint32Array(dynBuffer);\n    this.dynamicBuffer = new Buffer(this.dynamicData, false, false);\n    let staticOffset = 0;\n    this.staticStride = 0;\n    for (let i = 0; i < this.staticProperties.length; ++i) {\n      const property = this.staticProperties[i];\n      property.offset = staticOffset;\n      staticOffset += property.size;\n      this.staticStride += property.size;\n    }\n    const statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);\n    this.staticData = new Float32Array(statBuffer);\n    this.staticDataUint32 = new Uint32Array(statBuffer);\n    this.staticBuffer = new Buffer(this.staticData, true, false);\n    for (let i = 0; i < this.dynamicProperties.length; ++i) {\n      const property = this.dynamicProperties[i];\n      geometry.addAttribute(property.attributeName, this.dynamicBuffer, 0, property.type === lib/* TYPES */.vK.UNSIGNED_BYTE, property.type, this.dynamicStride * 4, property.offset * 4);\n    }\n    for (let i = 0; i < this.staticProperties.length; ++i) {\n      const property = this.staticProperties[i];\n      geometry.addAttribute(property.attributeName, this.staticBuffer, 0, property.type === lib/* TYPES */.vK.UNSIGNED_BYTE, property.type, this.staticStride * 4, property.offset * 4);\n    }\n  }\n  uploadDynamic(children, startIndex, amount) {\n    for (let i = 0; i < this.dynamicProperties.length; i++) {\n      const property = this.dynamicProperties[i];\n      property.uploadFunction(children, startIndex, amount, property.type === lib/* TYPES */.vK.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);\n    }\n    this.dynamicBuffer._updateID++;\n  }\n  uploadStatic(children, startIndex, amount) {\n    for (let i = 0; i < this.staticProperties.length; i++) {\n      const property = this.staticProperties[i];\n      property.uploadFunction(children, startIndex, amount, property.type === lib/* TYPES */.vK.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);\n    }\n    this.staticBuffer._updateID++;\n  }\n  destroy() {\n    this.indexBuffer = null;\n    this.dynamicProperties = null;\n    this.dynamicBuffer = null;\n    this.dynamicData = null;\n    this.dynamicDataUint32 = null;\n    this.staticProperties = null;\n    this.staticBuffer = null;\n    this.staticData = null;\n    this.staticDataUint32 = null;\n    this.geometry.destroy();\n  }\n}\n\n\n//# sourceMappingURL=ParticleBuffer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/particle-container/lib/particles.mjs\nvar particles_fragment = "varying vec2 vTextureCoord;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler;\\n\\nvoid main(void){\\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\\n    gl_FragColor = color;\\n}";\n\n\n//# sourceMappingURL=particles.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/particle-container/lib/particles2.mjs\nvar particles2_vertex = "attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aColor;\\n\\nattribute vec2 aPositionCoord;\\nattribute float aRotation;\\n\\nuniform mat3 translationMatrix;\\nuniform vec4 uColor;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\n\\nvoid main(void){\\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\\n\\n    vec2 v = vec2(x, y);\\n    v = v + aPositionCoord;\\n\\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = aTextureCoord;\\n    vColor = aColor * uColor;\\n}\\n";\n\n\n//# sourceMappingURL=particles2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/particle-container/lib/ParticleRenderer.mjs\n\n\n\n\n\nclass ParticleRenderer extends ObjectRenderer {\n  constructor(renderer) {\n    super(renderer);\n    this.shader = null;\n    this.properties = null;\n    this.tempMatrix = new Matrix();\n    this.properties = [\n      {\n        attributeName: "aVertexPosition",\n        size: 2,\n        uploadFunction: this.uploadVertices,\n        offset: 0\n      },\n      {\n        attributeName: "aPositionCoord",\n        size: 2,\n        uploadFunction: this.uploadPosition,\n        offset: 0\n      },\n      {\n        attributeName: "aRotation",\n        size: 1,\n        uploadFunction: this.uploadRotation,\n        offset: 0\n      },\n      {\n        attributeName: "aTextureCoord",\n        size: 2,\n        uploadFunction: this.uploadUvs,\n        offset: 0\n      },\n      {\n        attributeName: "aColor",\n        size: 1,\n        type: lib/* TYPES */.vK.UNSIGNED_BYTE,\n        uploadFunction: this.uploadTint,\n        offset: 0\n      }\n    ];\n    this.shader = Shader.from(particles2_vertex, particles_fragment, {});\n    this.state = State.for2d();\n  }\n  render(container) {\n    const children = container.children;\n    const maxSize = container._maxSize;\n    const batchSize = container._batchSize;\n    const renderer = this.renderer;\n    let totalChildren = children.length;\n    if (totalChildren === 0) {\n      return;\n    } else if (totalChildren > maxSize && !container.autoResize) {\n      totalChildren = maxSize;\n    }\n    let buffers = container._buffers;\n    if (!buffers) {\n      buffers = container._buffers = this.generateBuffers(container);\n    }\n    const baseTexture = children[0]._texture.baseTexture;\n    const premultiplied = baseTexture.alphaMode > 0;\n    this.state.blendMode = utils_lib.correctBlendMode(container.blendMode, premultiplied);\n    renderer.state.set(this.state);\n    const gl = renderer.gl;\n    const m = container.worldTransform.copyTo(this.tempMatrix);\n    m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);\n    this.shader.uniforms.translationMatrix = m.toArray(true);\n    this.shader.uniforms.uColor = color_lib/* Color */.I.shared.setValue(container.tintRgb).premultiply(container.worldAlpha, premultiplied).toArray(this.shader.uniforms.uColor);\n    this.shader.uniforms.uSampler = baseTexture;\n    this.renderer.shader.bind(this.shader);\n    let updateStatic = false;\n    for (let i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {\n      let amount = totalChildren - i;\n      if (amount > batchSize) {\n        amount = batchSize;\n      }\n      if (j >= buffers.length) {\n        buffers.push(this._generateOneMoreBuffer(container));\n      }\n      const buffer = buffers[j];\n      buffer.uploadDynamic(children, i, amount);\n      const bid = container._bufferUpdateIDs[j] || 0;\n      updateStatic = updateStatic || buffer._updateID < bid;\n      if (updateStatic) {\n        buffer._updateID = container._updateID;\n        buffer.uploadStatic(children, i, amount);\n      }\n      renderer.geometry.bind(buffer.geometry);\n      gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);\n    }\n  }\n  generateBuffers(container) {\n    const buffers = [];\n    const size = container._maxSize;\n    const batchSize = container._batchSize;\n    const dynamicPropertyFlags = container._properties;\n    for (let i = 0; i < size; i += batchSize) {\n      buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));\n    }\n    return buffers;\n  }\n  _generateOneMoreBuffer(container) {\n    const batchSize = container._batchSize;\n    const dynamicPropertyFlags = container._properties;\n    return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);\n  }\n  uploadVertices(children, startIndex, amount, array, stride, offset) {\n    let w0 = 0;\n    let w1 = 0;\n    let h0 = 0;\n    let h1 = 0;\n    for (let i = 0; i < amount; ++i) {\n      const sprite = children[startIndex + i];\n      const texture = sprite._texture;\n      const sx = sprite.scale.x;\n      const sy = sprite.scale.y;\n      const trim = texture.trim;\n      const orig = texture.orig;\n      if (trim) {\n        w1 = trim.x - sprite.anchor.x * orig.width;\n        w0 = w1 + trim.width;\n        h1 = trim.y - sprite.anchor.y * orig.height;\n        h0 = h1 + trim.height;\n      } else {\n        w0 = orig.width * (1 - sprite.anchor.x);\n        w1 = orig.width * -sprite.anchor.x;\n        h0 = orig.height * (1 - sprite.anchor.y);\n        h1 = orig.height * -sprite.anchor.y;\n      }\n      array[offset] = w1 * sx;\n      array[offset + 1] = h1 * sy;\n      array[offset + stride] = w0 * sx;\n      array[offset + stride + 1] = h1 * sy;\n      array[offset + stride * 2] = w0 * sx;\n      array[offset + stride * 2 + 1] = h0 * sy;\n      array[offset + stride * 3] = w1 * sx;\n      array[offset + stride * 3 + 1] = h0 * sy;\n      offset += stride * 4;\n    }\n  }\n  uploadPosition(children, startIndex, amount, array, stride, offset) {\n    for (let i = 0; i < amount; i++) {\n      const spritePosition = children[startIndex + i].position;\n      array[offset] = spritePosition.x;\n      array[offset + 1] = spritePosition.y;\n      array[offset + stride] = spritePosition.x;\n      array[offset + stride + 1] = spritePosition.y;\n      array[offset + stride * 2] = spritePosition.x;\n      array[offset + stride * 2 + 1] = spritePosition.y;\n      array[offset + stride * 3] = spritePosition.x;\n      array[offset + stride * 3 + 1] = spritePosition.y;\n      offset += stride * 4;\n    }\n  }\n  uploadRotation(children, startIndex, amount, array, stride, offset) {\n    for (let i = 0; i < amount; i++) {\n      const spriteRotation = children[startIndex + i].rotation;\n      array[offset] = spriteRotation;\n      array[offset + stride] = spriteRotation;\n      array[offset + stride * 2] = spriteRotation;\n      array[offset + stride * 3] = spriteRotation;\n      offset += stride * 4;\n    }\n  }\n  uploadUvs(children, startIndex, amount, array, stride, offset) {\n    for (let i = 0; i < amount; ++i) {\n      const textureUvs = children[startIndex + i]._texture._uvs;\n      if (textureUvs) {\n        array[offset] = textureUvs.x0;\n        array[offset + 1] = textureUvs.y0;\n        array[offset + stride] = textureUvs.x1;\n        array[offset + stride + 1] = textureUvs.y1;\n        array[offset + stride * 2] = textureUvs.x2;\n        array[offset + stride * 2 + 1] = textureUvs.y2;\n        array[offset + stride * 3] = textureUvs.x3;\n        array[offset + stride * 3 + 1] = textureUvs.y3;\n        offset += stride * 4;\n      } else {\n        array[offset] = 0;\n        array[offset + 1] = 0;\n        array[offset + stride] = 0;\n        array[offset + stride + 1] = 0;\n        array[offset + stride * 2] = 0;\n        array[offset + stride * 2 + 1] = 0;\n        array[offset + stride * 3] = 0;\n        array[offset + stride * 3 + 1] = 0;\n        offset += stride * 4;\n      }\n    }\n  }\n  uploadTint(children, startIndex, amount, array, stride, offset) {\n    for (let i = 0; i < amount; ++i) {\n      const sprite = children[startIndex + i];\n      const result = color_lib/* Color */.I.shared.setValue(sprite._tintRGB).toPremultiplied(sprite.alpha, sprite.texture.baseTexture.alphaMode > 0);\n      array[offset] = result;\n      array[offset + stride] = result;\n      array[offset + stride * 2] = result;\n      array[offset + stride * 3] = result;\n      offset += stride * 4;\n    }\n  }\n  destroy() {\n    super.destroy();\n    if (this.shader) {\n      this.shader.destroy();\n      this.shader = null;\n    }\n    this.tempMatrix = null;\n  }\n}\nParticleRenderer.extension = {\n  name: "particle",\n  type: ExtensionType.RendererPlugin\n};\nextensions.add(ParticleRenderer);\n\n\n//# sourceMappingURL=ParticleRenderer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/particle-container/lib/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text/lib/const.mjs\nvar TEXT_GRADIENT = /* @__PURE__ */ ((TEXT_GRADIENT2) => {\n  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_VERTICAL"] = 0] = "LINEAR_VERTICAL";\n  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_HORIZONTAL"] = 1] = "LINEAR_HORIZONTAL";\n  return TEXT_GRADIENT2;\n})(TEXT_GRADIENT || {});\n\n\n//# sourceMappingURL=const.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text/lib/TextMetrics.mjs\n\n\nconst contextSettings = {\n  willReadFrequently: true\n};\nconst _TextMetrics = class {\n  static get experimentalLetterSpacingSupported() {\n    let result = _TextMetrics._experimentalLetterSpacingSupported;\n    if (result !== void 0) {\n      const proto = settings_lib/* settings */.Xd.ADAPTER.getCanvasRenderingContext2D().prototype;\n      result = _TextMetrics._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;\n    }\n    return result;\n  }\n  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {\n    this.text = text;\n    this.style = style;\n    this.width = width;\n    this.height = height;\n    this.lines = lines;\n    this.lineWidths = lineWidths;\n    this.lineHeight = lineHeight;\n    this.maxLineWidth = maxLineWidth;\n    this.fontProperties = fontProperties;\n  }\n  static measureText(text, style, wordWrap, canvas = _TextMetrics._canvas) {\n    wordWrap = wordWrap === void 0 || wordWrap === null ? style.wordWrap : wordWrap;\n    const font = style.toFontString();\n    const fontProperties = _TextMetrics.measureFont(font);\n    if (fontProperties.fontSize === 0) {\n      fontProperties.fontSize = style.fontSize;\n      fontProperties.ascent = style.fontSize;\n    }\n    const context = canvas.getContext("2d", contextSettings);\n    context.font = font;\n    const outputText = wordWrap ? _TextMetrics.wordWrap(text, style, canvas) : text;\n    const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n    const lineWidths = new Array(lines.length);\n    let maxLineWidth = 0;\n    for (let i = 0; i < lines.length; i++) {\n      const lineWidth = _TextMetrics._measureText(lines[i], style.letterSpacing, context);\n      lineWidths[i] = lineWidth;\n      maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n    let width = maxLineWidth + style.strokeThickness;\n    if (style.dropShadow) {\n      width += style.dropShadowDistance;\n    }\n    const lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;\n    let height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness * 2) + (lines.length - 1) * (lineHeight + style.leading);\n    if (style.dropShadow) {\n      height += style.dropShadowDistance;\n    }\n    return new _TextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);\n  }\n  static _measureText(text, letterSpacing, context) {\n    let useExperimentalLetterSpacing = false;\n    if (_TextMetrics.experimentalLetterSpacingSupported) {\n      if (_TextMetrics.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = "0px";\n        context.textLetterSpacing = "0px";\n      }\n    }\n    let width = context.measureText(text).width;\n    if (width > 0) {\n      if (useExperimentalLetterSpacing) {\n        width -= letterSpacing;\n      } else {\n        width += (_TextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n      }\n    }\n    return width;\n  }\n  static wordWrap(text, style, canvas = _TextMetrics._canvas) {\n    const context = canvas.getContext("2d", contextSettings);\n    let width = 0;\n    let line = "";\n    let lines = "";\n    const cache = /* @__PURE__ */ Object.create(null);\n    const { letterSpacing, whiteSpace } = style;\n    const collapseSpaces = _TextMetrics.collapseSpaces(whiteSpace);\n    const collapseNewlines = _TextMetrics.collapseNewlines(whiteSpace);\n    let canPrependSpaces = !collapseSpaces;\n    const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n    const tokens = _TextMetrics.tokenize(text);\n    for (let i = 0; i < tokens.length; i++) {\n      let token = tokens[i];\n      if (_TextMetrics.isNewline(token)) {\n        if (!collapseNewlines) {\n          lines += _TextMetrics.addLine(line);\n          canPrependSpaces = !collapseSpaces;\n          line = "";\n          width = 0;\n          continue;\n        }\n        token = " ";\n      }\n      if (collapseSpaces) {\n        const currIsBreakingSpace = _TextMetrics.isBreakingSpace(token);\n        const lastIsBreakingSpace = _TextMetrics.isBreakingSpace(line[line.length - 1]);\n        if (currIsBreakingSpace && lastIsBreakingSpace) {\n          continue;\n        }\n      }\n      const tokenWidth = _TextMetrics.getFromCache(token, letterSpacing, cache, context);\n      if (tokenWidth > wordWrapWidth) {\n        if (line !== "") {\n          lines += _TextMetrics.addLine(line);\n          line = "";\n          width = 0;\n        }\n        if (_TextMetrics.canBreakWords(token, style.breakWords)) {\n          const characters = _TextMetrics.wordWrapSplit(token);\n          for (let j = 0; j < characters.length; j++) {\n            let char = characters[j];\n            let lastChar = char;\n            let k = 1;\n            while (characters[j + k]) {\n              const nextChar = characters[j + k];\n              if (!_TextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {\n                char += nextChar;\n              } else {\n                break;\n              }\n              lastChar = nextChar;\n              k++;\n            }\n            j += k - 1;\n            const characterWidth = _TextMetrics.getFromCache(char, letterSpacing, cache, context);\n            if (characterWidth + width > wordWrapWidth) {\n              lines += _TextMetrics.addLine(line);\n              canPrependSpaces = false;\n              line = "";\n              width = 0;\n            }\n            line += char;\n            width += characterWidth;\n          }\n        } else {\n          if (line.length > 0) {\n            lines += _TextMetrics.addLine(line);\n            line = "";\n            width = 0;\n          }\n          const isLastToken = i === tokens.length - 1;\n          lines += _TextMetrics.addLine(token, !isLastToken);\n          canPrependSpaces = false;\n          line = "";\n          width = 0;\n        }\n      } else {\n        if (tokenWidth + width > wordWrapWidth) {\n          canPrependSpaces = false;\n          lines += _TextMetrics.addLine(line);\n          line = "";\n          width = 0;\n        }\n        if (line.length > 0 || !_TextMetrics.isBreakingSpace(token) || canPrependSpaces) {\n          line += token;\n          width += tokenWidth;\n        }\n      }\n    }\n    lines += _TextMetrics.addLine(line, false);\n    return lines;\n  }\n  static addLine(line, newLine = true) {\n    line = _TextMetrics.trimRight(line);\n    line = newLine ? `${line}\n` : line;\n    return line;\n  }\n  static getFromCache(key, letterSpacing, cache, context) {\n    let width = cache[key];\n    if (typeof width !== "number") {\n      width = _TextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n      cache[key] = width;\n    }\n    return width;\n  }\n  static collapseSpaces(whiteSpace) {\n    return whiteSpace === "normal" || whiteSpace === "pre-line";\n  }\n  static collapseNewlines(whiteSpace) {\n    return whiteSpace === "normal";\n  }\n  static trimRight(text) {\n    if (typeof text !== "string") {\n      return "";\n    }\n    for (let i = text.length - 1; i >= 0; i--) {\n      const char = text[i];\n      if (!_TextMetrics.isBreakingSpace(char)) {\n        break;\n      }\n      text = text.slice(0, -1);\n    }\n    return text;\n  }\n  static isNewline(char) {\n    if (typeof char !== "string") {\n      return false;\n    }\n    return _TextMetrics._newlines.includes(char.charCodeAt(0));\n  }\n  static isBreakingSpace(char, _nextChar) {\n    if (typeof char !== "string") {\n      return false;\n    }\n    return _TextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n  }\n  static tokenize(text) {\n    const tokens = [];\n    let token = "";\n    if (typeof text !== "string") {\n      return tokens;\n    }\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const nextChar = text[i + 1];\n      if (_TextMetrics.isBreakingSpace(char, nextChar) || _TextMetrics.isNewline(char)) {\n        if (token !== "") {\n          tokens.push(token);\n          token = "";\n        }\n        tokens.push(char);\n        continue;\n      }\n      token += char;\n    }\n    if (token !== "") {\n      tokens.push(token);\n    }\n    return tokens;\n  }\n  static canBreakWords(_token, breakWords) {\n    return breakWords;\n  }\n  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n    return true;\n  }\n  static wordWrapSplit(token) {\n    return _TextMetrics.graphemeSegmenter(token);\n  }\n  static measureFont(font) {\n    if (_TextMetrics._fonts[font]) {\n      return _TextMetrics._fonts[font];\n    }\n    const properties = {\n      ascent: 0,\n      descent: 0,\n      fontSize: 0\n    };\n    const canvas = _TextMetrics._canvas;\n    const context = _TextMetrics._context;\n    context.font = font;\n    const metricsString = _TextMetrics.METRICS_STRING + _TextMetrics.BASELINE_SYMBOL;\n    const width = Math.ceil(context.measureText(metricsString).width);\n    let baseline = Math.ceil(context.measureText(_TextMetrics.BASELINE_SYMBOL).width);\n    const height = Math.ceil(_TextMetrics.HEIGHT_MULTIPLIER * baseline);\n    baseline = baseline * _TextMetrics.BASELINE_MULTIPLIER | 0;\n    if (width === 0 || height === 0) {\n      _TextMetrics._fonts[font] = properties;\n      return properties;\n    }\n    canvas.width = width;\n    canvas.height = height;\n    context.fillStyle = "#f00";\n    context.fillRect(0, 0, width, height);\n    context.font = font;\n    context.textBaseline = "alphabetic";\n    context.fillStyle = "#000";\n    context.fillText(metricsString, 0, baseline);\n    const imagedata = context.getImageData(0, 0, width, height).data;\n    const pixels = imagedata.length;\n    const line = width * 4;\n    let i = 0;\n    let idx = 0;\n    let stop = false;\n    for (i = 0; i < baseline; ++i) {\n      for (let j = 0; j < line; j += 4) {\n        if (imagedata[idx + j] !== 255) {\n          stop = true;\n          break;\n        }\n      }\n      if (!stop) {\n        idx += line;\n      } else {\n        break;\n      }\n    }\n    properties.ascent = baseline - i;\n    idx = pixels - line;\n    stop = false;\n    for (i = height; i > baseline; --i) {\n      for (let j = 0; j < line; j += 4) {\n        if (imagedata[idx + j] !== 255) {\n          stop = true;\n          break;\n        }\n      }\n      if (!stop) {\n        idx -= line;\n      } else {\n        break;\n      }\n    }\n    properties.descent = i - baseline;\n    properties.fontSize = properties.ascent + properties.descent;\n    _TextMetrics._fonts[font] = properties;\n    return properties;\n  }\n  static clearMetrics(font = "") {\n    if (font) {\n      delete _TextMetrics._fonts[font];\n    } else {\n      _TextMetrics._fonts = {};\n    }\n  }\n  static get _canvas() {\n    if (!_TextMetrics.__canvas) {\n      let canvas;\n      try {\n        const c = new OffscreenCanvas(0, 0);\n        const context = c.getContext("2d", contextSettings);\n        if (context?.measureText) {\n          _TextMetrics.__canvas = c;\n          return c;\n        }\n        canvas = settings_lib/* settings */.Xd.ADAPTER.createCanvas();\n      } catch (ex) {\n        canvas = settings_lib/* settings */.Xd.ADAPTER.createCanvas();\n      }\n      canvas.width = canvas.height = 10;\n      _TextMetrics.__canvas = canvas;\n    }\n    return _TextMetrics.__canvas;\n  }\n  static get _context() {\n    if (!_TextMetrics.__context) {\n      _TextMetrics.__context = _TextMetrics._canvas.getContext("2d", contextSettings);\n    }\n    return _TextMetrics.__context;\n  }\n};\nlet TextMetrics = _TextMetrics;\nTextMetrics.METRICS_STRING = "|\\xC9q\\xC5";\nTextMetrics.BASELINE_SYMBOL = "M";\nTextMetrics.BASELINE_MULTIPLIER = 1.4;\nTextMetrics.HEIGHT_MULTIPLIER = 2;\nTextMetrics.graphemeSegmenter = (() => {\n  if (typeof Intl?.Segmenter === "function") {\n    const segmenter = new Intl.Segmenter();\n    return (s) => [...segmenter.segment(s)].map((x) => x.segment);\n  }\n  return (s) => [...s];\n})();\nTextMetrics.experimentalLetterSpacing = false;\nTextMetrics._fonts = {};\nTextMetrics._newlines = [\n  10,\n  13\n];\nTextMetrics._breakingSpaces = [\n  9,\n  32,\n  8192,\n  8193,\n  8194,\n  8195,\n  8196,\n  8197,\n  8198,\n  8200,\n  8201,\n  8202,\n  8287,\n  12288\n];\n\n\n//# sourceMappingURL=TextMetrics.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text/lib/TextStyle.mjs\n\n\n\nconst genericFontFamilies = [\n  "serif",\n  "sans-serif",\n  "monospace",\n  "cursive",\n  "fantasy",\n  "system-ui"\n];\nconst _TextStyle = class {\n  constructor(style) {\n    this.styleID = 0;\n    this.reset();\n    deepCopyProperties(this, style, style);\n  }\n  clone() {\n    const clonedProperties = {};\n    deepCopyProperties(clonedProperties, this, _TextStyle.defaultStyle);\n    return new _TextStyle(clonedProperties);\n  }\n  reset() {\n    deepCopyProperties(this, _TextStyle.defaultStyle, _TextStyle.defaultStyle);\n  }\n  get align() {\n    return this._align;\n  }\n  set align(align) {\n    if (this._align !== align) {\n      this._align = align;\n      this.styleID++;\n    }\n  }\n  get breakWords() {\n    return this._breakWords;\n  }\n  set breakWords(breakWords) {\n    if (this._breakWords !== breakWords) {\n      this._breakWords = breakWords;\n      this.styleID++;\n    }\n  }\n  get dropShadow() {\n    return this._dropShadow;\n  }\n  set dropShadow(dropShadow) {\n    if (this._dropShadow !== dropShadow) {\n      this._dropShadow = dropShadow;\n      this.styleID++;\n    }\n  }\n  get dropShadowAlpha() {\n    return this._dropShadowAlpha;\n  }\n  set dropShadowAlpha(dropShadowAlpha) {\n    if (this._dropShadowAlpha !== dropShadowAlpha) {\n      this._dropShadowAlpha = dropShadowAlpha;\n      this.styleID++;\n    }\n  }\n  get dropShadowAngle() {\n    return this._dropShadowAngle;\n  }\n  set dropShadowAngle(dropShadowAngle) {\n    if (this._dropShadowAngle !== dropShadowAngle) {\n      this._dropShadowAngle = dropShadowAngle;\n      this.styleID++;\n    }\n  }\n  get dropShadowBlur() {\n    return this._dropShadowBlur;\n  }\n  set dropShadowBlur(dropShadowBlur) {\n    if (this._dropShadowBlur !== dropShadowBlur) {\n      this._dropShadowBlur = dropShadowBlur;\n      this.styleID++;\n    }\n  }\n  get dropShadowColor() {\n    return this._dropShadowColor;\n  }\n  set dropShadowColor(dropShadowColor) {\n    const outputColor = getColor(dropShadowColor);\n    if (this._dropShadowColor !== outputColor) {\n      this._dropShadowColor = outputColor;\n      this.styleID++;\n    }\n  }\n  get dropShadowDistance() {\n    return this._dropShadowDistance;\n  }\n  set dropShadowDistance(dropShadowDistance) {\n    if (this._dropShadowDistance !== dropShadowDistance) {\n      this._dropShadowDistance = dropShadowDistance;\n      this.styleID++;\n    }\n  }\n  get fill() {\n    return this._fill;\n  }\n  set fill(fill) {\n    const outputColor = getColor(fill);\n    if (this._fill !== outputColor) {\n      this._fill = outputColor;\n      this.styleID++;\n    }\n  }\n  get fillGradientType() {\n    return this._fillGradientType;\n  }\n  set fillGradientType(fillGradientType) {\n    if (this._fillGradientType !== fillGradientType) {\n      this._fillGradientType = fillGradientType;\n      this.styleID++;\n    }\n  }\n  get fillGradientStops() {\n    return this._fillGradientStops;\n  }\n  set fillGradientStops(fillGradientStops) {\n    if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {\n      this._fillGradientStops = fillGradientStops;\n      this.styleID++;\n    }\n  }\n  get fontFamily() {\n    return this._fontFamily;\n  }\n  set fontFamily(fontFamily) {\n    if (this.fontFamily !== fontFamily) {\n      this._fontFamily = fontFamily;\n      this.styleID++;\n    }\n  }\n  get fontSize() {\n    return this._fontSize;\n  }\n  set fontSize(fontSize) {\n    if (this._fontSize !== fontSize) {\n      this._fontSize = fontSize;\n      this.styleID++;\n    }\n  }\n  get fontStyle() {\n    return this._fontStyle;\n  }\n  set fontStyle(fontStyle) {\n    if (this._fontStyle !== fontStyle) {\n      this._fontStyle = fontStyle;\n      this.styleID++;\n    }\n  }\n  get fontVariant() {\n    return this._fontVariant;\n  }\n  set fontVariant(fontVariant) {\n    if (this._fontVariant !== fontVariant) {\n      this._fontVariant = fontVariant;\n      this.styleID++;\n    }\n  }\n  get fontWeight() {\n    return this._fontWeight;\n  }\n  set fontWeight(fontWeight) {\n    if (this._fontWeight !== fontWeight) {\n      this._fontWeight = fontWeight;\n      this.styleID++;\n    }\n  }\n  get letterSpacing() {\n    return this._letterSpacing;\n  }\n  set letterSpacing(letterSpacing) {\n    if (this._letterSpacing !== letterSpacing) {\n      this._letterSpacing = letterSpacing;\n      this.styleID++;\n    }\n  }\n  get lineHeight() {\n    return this._lineHeight;\n  }\n  set lineHeight(lineHeight) {\n    if (this._lineHeight !== lineHeight) {\n      this._lineHeight = lineHeight;\n      this.styleID++;\n    }\n  }\n  get leading() {\n    return this._leading;\n  }\n  set leading(leading) {\n    if (this._leading !== leading) {\n      this._leading = leading;\n      this.styleID++;\n    }\n  }\n  get lineJoin() {\n    return this._lineJoin;\n  }\n  set lineJoin(lineJoin) {\n    if (this._lineJoin !== lineJoin) {\n      this._lineJoin = lineJoin;\n      this.styleID++;\n    }\n  }\n  get miterLimit() {\n    return this._miterLimit;\n  }\n  set miterLimit(miterLimit) {\n    if (this._miterLimit !== miterLimit) {\n      this._miterLimit = miterLimit;\n      this.styleID++;\n    }\n  }\n  get padding() {\n    return this._padding;\n  }\n  set padding(padding) {\n    if (this._padding !== padding) {\n      this._padding = padding;\n      this.styleID++;\n    }\n  }\n  get stroke() {\n    return this._stroke;\n  }\n  set stroke(stroke) {\n    const outputColor = getColor(stroke);\n    if (this._stroke !== outputColor) {\n      this._stroke = outputColor;\n      this.styleID++;\n    }\n  }\n  get strokeThickness() {\n    return this._strokeThickness;\n  }\n  set strokeThickness(strokeThickness) {\n    if (this._strokeThickness !== strokeThickness) {\n      this._strokeThickness = strokeThickness;\n      this.styleID++;\n    }\n  }\n  get textBaseline() {\n    return this._textBaseline;\n  }\n  set textBaseline(textBaseline) {\n    if (this._textBaseline !== textBaseline) {\n      this._textBaseline = textBaseline;\n      this.styleID++;\n    }\n  }\n  get trim() {\n    return this._trim;\n  }\n  set trim(trim) {\n    if (this._trim !== trim) {\n      this._trim = trim;\n      this.styleID++;\n    }\n  }\n  get whiteSpace() {\n    return this._whiteSpace;\n  }\n  set whiteSpace(whiteSpace) {\n    if (this._whiteSpace !== whiteSpace) {\n      this._whiteSpace = whiteSpace;\n      this.styleID++;\n    }\n  }\n  get wordWrap() {\n    return this._wordWrap;\n  }\n  set wordWrap(wordWrap) {\n    if (this._wordWrap !== wordWrap) {\n      this._wordWrap = wordWrap;\n      this.styleID++;\n    }\n  }\n  get wordWrapWidth() {\n    return this._wordWrapWidth;\n  }\n  set wordWrapWidth(wordWrapWidth) {\n    if (this._wordWrapWidth !== wordWrapWidth) {\n      this._wordWrapWidth = wordWrapWidth;\n      this.styleID++;\n    }\n  }\n  toFontString() {\n    const fontSizeString = typeof this.fontSize === "number" ? `${this.fontSize}px` : this.fontSize;\n    let fontFamilies = this.fontFamily;\n    if (!Array.isArray(this.fontFamily)) {\n      fontFamilies = this.fontFamily.split(",");\n    }\n    for (let i = fontFamilies.length - 1; i >= 0; i--) {\n      let fontFamily = fontFamilies[i].trim();\n      if (!/([\\"\\\'])[^\\\'\\"]+\\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {\n        fontFamily = `"${fontFamily}"`;\n      }\n      fontFamilies[i] = fontFamily;\n    }\n    return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;\n  }\n};\nlet TextStyle = _TextStyle;\nTextStyle.defaultStyle = {\n  align: "left",\n  breakWords: false,\n  dropShadow: false,\n  dropShadowAlpha: 1,\n  dropShadowAngle: Math.PI / 6,\n  dropShadowBlur: 0,\n  dropShadowColor: "black",\n  dropShadowDistance: 5,\n  fill: "black",\n  fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,\n  fillGradientStops: [],\n  fontFamily: "Arial",\n  fontSize: 26,\n  fontStyle: "normal",\n  fontVariant: "normal",\n  fontWeight: "normal",\n  leading: 0,\n  letterSpacing: 0,\n  lineHeight: 0,\n  lineJoin: "miter",\n  miterLimit: 10,\n  padding: 0,\n  stroke: "black",\n  strokeThickness: 0,\n  textBaseline: "alphabetic",\n  trim: false,\n  whiteSpace: "pre",\n  wordWrap: false,\n  wordWrapWidth: 100\n};\nfunction getColor(color) {\n  const temp = color_lib/* Color */.I.shared;\n  if (!Array.isArray(color)) {\n    return temp.setValue(color).toHex();\n  } else {\n    return color.map((c) => temp.setValue(c).toHex());\n  }\n}\nfunction areArraysEqual(array1, array2) {\n  if (!Array.isArray(array1) || !Array.isArray(array2)) {\n    return false;\n  }\n  if (array1.length !== array2.length) {\n    return false;\n  }\n  for (let i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction deepCopyProperties(target, source, propertyObj) {\n  for (const prop in propertyObj) {\n    if (Array.isArray(source[prop])) {\n      target[prop] = source[prop].slice();\n    } else {\n      target[prop] = source[prop];\n    }\n  }\n}\n\n\n//# sourceMappingURL=TextStyle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text/lib/Text.mjs\n\n\n\n\n\n\nconst defaultDestroyOptions = {\n  texture: true,\n  children: false,\n  baseTexture: true\n};\nconst _Text = class extends Sprite_Sprite {\n  constructor(text, style, canvas) {\n    let ownCanvas = false;\n    if (!canvas) {\n      canvas = settings_lib/* settings */.Xd.ADAPTER.createCanvas();\n      ownCanvas = true;\n    }\n    canvas.width = 3;\n    canvas.height = 3;\n    const texture = Texture_Texture.from(canvas);\n    texture.orig = new Rectangle_Rectangle();\n    texture.trim = new Rectangle_Rectangle();\n    super(texture);\n    this._ownCanvas = ownCanvas;\n    this.canvas = canvas;\n    this.context = canvas.getContext("2d", {\n      willReadFrequently: true\n    });\n    this._resolution = _Text.defaultResolution ?? settings_lib/* settings */.Xd.RESOLUTION;\n    this._autoResolution = _Text.defaultAutoResolution;\n    this._text = null;\n    this._style = null;\n    this._styleListener = null;\n    this._font = "";\n    this.text = text;\n    this.style = style;\n    this.localStyleID = -1;\n  }\n  static get experimentalLetterSpacing() {\n    return TextMetrics.experimentalLetterSpacing;\n  }\n  static set experimentalLetterSpacing(value) {\n    utils_lib.deprecation("7.1.0", "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing");\n    TextMetrics.experimentalLetterSpacing = value;\n  }\n  updateText(respectDirty) {\n    const style = this._style;\n    if (this.localStyleID !== style.styleID) {\n      this.dirty = true;\n      this.localStyleID = style.styleID;\n    }\n    if (!this.dirty && respectDirty) {\n      return;\n    }\n    this._font = this._style.toFontString();\n    const context = this.context;\n    const measured = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas);\n    const width = measured.width;\n    const height = measured.height;\n    const lines = measured.lines;\n    const lineHeight = measured.lineHeight;\n    const lineWidths = measured.lineWidths;\n    const maxLineWidth = measured.maxLineWidth;\n    const fontProperties = measured.fontProperties;\n    this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution);\n    this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution);\n    context.scale(this._resolution, this._resolution);\n    context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    context.font = this._font;\n    context.lineWidth = style.strokeThickness;\n    context.textBaseline = style.textBaseline;\n    context.lineJoin = style.lineJoin;\n    context.miterLimit = style.miterLimit;\n    let linePositionX;\n    let linePositionY;\n    const passesCount = style.dropShadow ? 2 : 1;\n    for (let i = 0; i < passesCount; ++i) {\n      const isShadowPass = style.dropShadow && i === 0;\n      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;\n      const dsOffsetShadow = dsOffsetText * this._resolution;\n      if (isShadowPass) {\n        context.fillStyle = "black";\n        context.strokeStyle = "black";\n        const dropShadowColor = style.dropShadowColor;\n        const dropShadowBlur = style.dropShadowBlur * this._resolution;\n        const dropShadowDistance = style.dropShadowDistance * this._resolution;\n        context.shadowColor = color_lib/* Color */.I.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString();\n        context.shadowBlur = dropShadowBlur;\n        context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;\n        context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;\n      } else {\n        context.fillStyle = this._generateFillStyle(style, lines, measured);\n        context.strokeStyle = style.stroke;\n        context.shadowColor = "black";\n        context.shadowBlur = 0;\n        context.shadowOffsetX = 0;\n        context.shadowOffsetY = 0;\n      }\n      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n      if (lineHeight - fontProperties.fontSize < 0) {\n        linePositionYShift = 0;\n      }\n      for (let i2 = 0; i2 < lines.length; i2++) {\n        linePositionX = style.strokeThickness / 2;\n        linePositionY = style.strokeThickness / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;\n        if (style.align === "right") {\n          linePositionX += maxLineWidth - lineWidths[i2];\n        } else if (style.align === "center") {\n          linePositionX += (maxLineWidth - lineWidths[i2]) / 2;\n        }\n        if (style.stroke && style.strokeThickness) {\n          this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);\n        }\n        if (style.fill) {\n          this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);\n        }\n      }\n    }\n    this.updateTexture();\n  }\n  drawLetterSpacing(text, x, y, isStroke = false) {\n    const style = this._style;\n    const letterSpacing = style.letterSpacing;\n    let useExperimentalLetterSpacing = false;\n    if (TextMetrics.experimentalLetterSpacingSupported) {\n      if (TextMetrics.experimentalLetterSpacing) {\n        this.context.letterSpacing = `${letterSpacing}px`;\n        this.context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        this.context.letterSpacing = "0px";\n        this.context.textLetterSpacing = "0px";\n      }\n    }\n    if (letterSpacing === 0 || useExperimentalLetterSpacing) {\n      if (isStroke) {\n        this.context.strokeText(text, x, y);\n      } else {\n        this.context.fillText(text, x, y);\n      }\n      return;\n    }\n    let currentPosition = x;\n    const stringArray = TextMetrics.graphemeSegmenter(text);\n    let previousWidth = this.context.measureText(text).width;\n    let currentWidth = 0;\n    for (let i = 0; i < stringArray.length; ++i) {\n      const currentChar = stringArray[i];\n      if (isStroke) {\n        this.context.strokeText(currentChar, currentPosition, y);\n      } else {\n        this.context.fillText(currentChar, currentPosition, y);\n      }\n      let textStr = "";\n      for (let j = i + 1; j < stringArray.length; ++j) {\n        textStr += stringArray[j];\n      }\n      currentWidth = this.context.measureText(textStr).width;\n      currentPosition += previousWidth - currentWidth + letterSpacing;\n      previousWidth = currentWidth;\n    }\n  }\n  updateTexture() {\n    const canvas = this.canvas;\n    if (this._style.trim) {\n      const trimmed = utils_lib.trimCanvas(canvas);\n      if (trimmed.data) {\n        canvas.width = trimmed.width;\n        canvas.height = trimmed.height;\n        this.context.putImageData(trimmed.data, 0, 0);\n      }\n    }\n    const texture = this._texture;\n    const style = this._style;\n    const padding = style.trim ? 0 : style.padding;\n    const baseTexture = texture.baseTexture;\n    texture.trim.width = texture._frame.width = canvas.width / this._resolution;\n    texture.trim.height = texture._frame.height = canvas.height / this._resolution;\n    texture.trim.x = -padding;\n    texture.trim.y = -padding;\n    texture.orig.width = texture._frame.width - padding * 2;\n    texture.orig.height = texture._frame.height - padding * 2;\n    this._onTextureUpdate();\n    baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);\n    texture.updateUvs();\n    this.dirty = false;\n  }\n  _render(renderer) {\n    if (this._autoResolution && this._resolution !== renderer.resolution) {\n      this._resolution = renderer.resolution;\n      this.dirty = true;\n    }\n    this.updateText(true);\n    super._render(renderer);\n  }\n  updateTransform() {\n    this.updateText(true);\n    super.updateTransform();\n  }\n  getBounds(skipUpdate, rect) {\n    this.updateText(true);\n    if (this._textureID === -1) {\n      skipUpdate = false;\n    }\n    return super.getBounds(skipUpdate, rect);\n  }\n  getLocalBounds(rect) {\n    this.updateText(true);\n    return super.getLocalBounds.call(this, rect);\n  }\n  _calculateBounds() {\n    this.calculateVertices();\n    this._bounds.addQuad(this.vertexData);\n  }\n  _generateFillStyle(style, lines, metrics) {\n    const fillStyle = style.fill;\n    if (!Array.isArray(fillStyle)) {\n      return fillStyle;\n    } else if (fillStyle.length === 1) {\n      return fillStyle[0];\n    }\n    let gradient;\n    const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;\n    const padding = style.padding || 0;\n    const width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2;\n    const height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2;\n    const fill = fillStyle.slice();\n    const fillGradientStops = style.fillGradientStops.slice();\n    if (!fillGradientStops.length) {\n      const lengthPlus1 = fill.length + 1;\n      for (let i = 1; i < lengthPlus1; ++i) {\n        fillGradientStops.push(i / lengthPlus1);\n      }\n    }\n    fill.unshift(fillStyle[0]);\n    fillGradientStops.unshift(0);\n    fill.push(fillStyle[fillStyle.length - 1]);\n    fillGradientStops.push(1);\n    if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {\n      gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);\n      const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;\n      for (let i = 0; i < lines.length; i++) {\n        const lastLineBottom = metrics.lineHeight * (i - 1) + textHeight;\n        const thisLineTop = metrics.lineHeight * i;\n        let thisLineGradientStart = thisLineTop;\n        if (i > 0 && lastLineBottom > thisLineTop) {\n          thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;\n        }\n        const thisLineBottom = thisLineTop + textHeight;\n        const nextLineTop = metrics.lineHeight * (i + 1);\n        let thisLineGradientEnd = thisLineBottom;\n        if (i + 1 < lines.length && nextLineTop < thisLineBottom) {\n          thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;\n        }\n        const gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;\n        for (let j = 0; j < fill.length; j++) {\n          let lineStop = 0;\n          if (typeof fillGradientStops[j] === "number") {\n            lineStop = fillGradientStops[j];\n          } else {\n            lineStop = j / fill.length;\n          }\n          let globalStop = Math.min(1, Math.max(0, thisLineGradientStart / height + lineStop * gradStopLineHeight));\n          globalStop = Number(globalStop.toFixed(5));\n          gradient.addColorStop(globalStop, fill[j]);\n        }\n      }\n    } else {\n      gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);\n      const totalIterations = fill.length + 1;\n      let currentIteration = 1;\n      for (let i = 0; i < fill.length; i++) {\n        let stop;\n        if (typeof fillGradientStops[i] === "number") {\n          stop = fillGradientStops[i];\n        } else {\n          stop = currentIteration / totalIterations;\n        }\n        gradient.addColorStop(stop, fill[i]);\n        currentIteration++;\n      }\n    }\n    return gradient;\n  }\n  destroy(options) {\n    if (typeof options === "boolean") {\n      options = { children: options };\n    }\n    options = Object.assign({}, defaultDestroyOptions, options);\n    super.destroy(options);\n    if (this._ownCanvas) {\n      this.canvas.height = this.canvas.width = 0;\n    }\n    this.context = null;\n    this.canvas = null;\n    this._style = null;\n  }\n  get width() {\n    this.updateText(true);\n    return Math.abs(this.scale.x) * this._texture.orig.width;\n  }\n  set width(value) {\n    this.updateText(true);\n    const s = utils_lib.sign(this.scale.x) || 1;\n    this.scale.x = s * value / this._texture.orig.width;\n    this._width = value;\n  }\n  get height() {\n    this.updateText(true);\n    return Math.abs(this.scale.y) * this._texture.orig.height;\n  }\n  set height(value) {\n    this.updateText(true);\n    const s = utils_lib.sign(this.scale.y) || 1;\n    this.scale.y = s * value / this._texture.orig.height;\n    this._height = value;\n  }\n  get style() {\n    return this._style;\n  }\n  set style(style) {\n    style = style || {};\n    if (style instanceof TextStyle) {\n      this._style = style;\n    } else {\n      this._style = new TextStyle(style);\n    }\n    this.localStyleID = -1;\n    this.dirty = true;\n  }\n  get text() {\n    return this._text;\n  }\n  set text(text) {\n    text = String(text === null || text === void 0 ? "" : text);\n    if (this._text === text) {\n      return;\n    }\n    this._text = text;\n    this.dirty = true;\n  }\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(value) {\n    this._autoResolution = false;\n    if (this._resolution === value) {\n      return;\n    }\n    this._resolution = value;\n    this.dirty = true;\n  }\n};\nlet Text = _Text;\nText.defaultAutoResolution = true;\n\n\n//# sourceMappingURL=Text.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text/lib/index.mjs\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/prepare/lib/CountLimiter.mjs\nclass CountLimiter {\n  constructor(maxItemsPerFrame) {\n    this.maxItemsPerFrame = maxItemsPerFrame;\n    this.itemsLeft = 0;\n  }\n  beginFrame() {\n    this.itemsLeft = this.maxItemsPerFrame;\n  }\n  allowedToUpload() {\n    return this.itemsLeft-- > 0;\n  }\n}\n\n\n//# sourceMappingURL=CountLimiter.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/prepare/lib/BasePrepare.mjs\n\n\n\n\n\nfunction findMultipleBaseTextures(item, queue) {\n  let result = false;\n  if (item?._textures?.length) {\n    for (let i = 0; i < item._textures.length; i++) {\n      if (item._textures[i] instanceof Texture_Texture) {\n        const baseTexture = item._textures[i].baseTexture;\n        if (!queue.includes(baseTexture)) {\n          queue.push(baseTexture);\n          result = true;\n        }\n      }\n    }\n  }\n  return result;\n}\nfunction findBaseTexture(item, queue) {\n  if (item.baseTexture instanceof BaseTexture) {\n    const texture = item.baseTexture;\n    if (!queue.includes(texture)) {\n      queue.push(texture);\n    }\n    return true;\n  }\n  return false;\n}\nfunction findTexture(item, queue) {\n  if (item._texture && item._texture instanceof Texture_Texture) {\n    const texture = item._texture.baseTexture;\n    if (!queue.includes(texture)) {\n      queue.push(texture);\n    }\n    return true;\n  }\n  return false;\n}\nfunction drawText(_helper, item) {\n  if (item instanceof Text) {\n    item.updateText(true);\n    return true;\n  }\n  return false;\n}\nfunction calculateTextStyle(_helper, item) {\n  if (item instanceof TextStyle) {\n    const font = item.toFontString();\n    TextMetrics.measureFont(font);\n    return true;\n  }\n  return false;\n}\nfunction findText(item, queue) {\n  if (item instanceof Text) {\n    if (!queue.includes(item.style)) {\n      queue.push(item.style);\n    }\n    if (!queue.includes(item)) {\n      queue.push(item);\n    }\n    const texture = item._texture.baseTexture;\n    if (!queue.includes(texture)) {\n      queue.push(texture);\n    }\n    return true;\n  }\n  return false;\n}\nfunction findTextStyle(item, queue) {\n  if (item instanceof TextStyle) {\n    if (!queue.includes(item)) {\n      queue.push(item);\n    }\n    return true;\n  }\n  return false;\n}\nconst _BasePrepare = class {\n  constructor(renderer) {\n    this.limiter = new CountLimiter(_BasePrepare.uploadsPerFrame);\n    this.renderer = renderer;\n    this.uploadHookHelper = null;\n    this.queue = [];\n    this.addHooks = [];\n    this.uploadHooks = [];\n    this.completes = [];\n    this.ticking = false;\n    this.delayedTick = () => {\n      if (!this.queue) {\n        return;\n      }\n      this.prepareItems();\n    };\n    this.registerFindHook(findText);\n    this.registerFindHook(findTextStyle);\n    this.registerFindHook(findMultipleBaseTextures);\n    this.registerFindHook(findBaseTexture);\n    this.registerFindHook(findTexture);\n    this.registerUploadHook(drawText);\n    this.registerUploadHook(calculateTextStyle);\n  }\n  upload(item) {\n    return new Promise((resolve) => {\n      if (item) {\n        this.add(item);\n      }\n      if (this.queue.length) {\n        this.completes.push(resolve);\n        if (!this.ticking) {\n          this.ticking = true;\n          Ticker_Ticker.system.addOnce(this.tick, this, const_UPDATE_PRIORITY.UTILITY);\n        }\n      } else {\n        resolve();\n      }\n    });\n  }\n  tick() {\n    setTimeout(this.delayedTick, 0);\n  }\n  prepareItems() {\n    this.limiter.beginFrame();\n    while (this.queue.length && this.limiter.allowedToUpload()) {\n      const item = this.queue[0];\n      let uploaded = false;\n      if (item && !item._destroyed) {\n        for (let i = 0, len = this.uploadHooks.length; i < len; i++) {\n          if (this.uploadHooks[i](this.uploadHookHelper, item)) {\n            this.queue.shift();\n            uploaded = true;\n            break;\n          }\n        }\n      }\n      if (!uploaded) {\n        this.queue.shift();\n      }\n    }\n    if (!this.queue.length) {\n      this.ticking = false;\n      const completes = this.completes.slice(0);\n      this.completes.length = 0;\n      for (let i = 0, len = completes.length; i < len; i++) {\n        completes[i]();\n      }\n    } else {\n      Ticker_Ticker.system.addOnce(this.tick, this, const_UPDATE_PRIORITY.UTILITY);\n    }\n  }\n  registerFindHook(addHook) {\n    if (addHook) {\n      this.addHooks.push(addHook);\n    }\n    return this;\n  }\n  registerUploadHook(uploadHook) {\n    if (uploadHook) {\n      this.uploadHooks.push(uploadHook);\n    }\n    return this;\n  }\n  add(item) {\n    for (let i = 0, len = this.addHooks.length; i < len; i++) {\n      if (this.addHooks[i](item, this.queue)) {\n        break;\n      }\n    }\n    if (item instanceof Container_Container) {\n      for (let i = item.children.length - 1; i >= 0; i--) {\n        this.add(item.children[i]);\n      }\n    }\n    return this;\n  }\n  destroy() {\n    if (this.ticking) {\n      Ticker_Ticker.system.remove(this.tick, this);\n    }\n    this.ticking = false;\n    this.addHooks = null;\n    this.uploadHooks = null;\n    this.renderer = null;\n    this.completes = null;\n    this.queue = null;\n    this.limiter = null;\n    this.uploadHookHelper = null;\n  }\n};\nlet BasePrepare = _BasePrepare;\nBasePrepare.uploadsPerFrame = 4;\n\n\n//# sourceMappingURL=BasePrepare.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/prepare/lib/settings.mjs\n\n\n\n\nObject.defineProperties(settings_lib/* settings */.Xd, {\n  UPLOADS_PER_FRAME: {\n    get() {\n      return BasePrepare.uploadsPerFrame;\n    },\n    set(value) {\n      utils_lib.deprecation("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame");\n      BasePrepare.uploadsPerFrame = value;\n    }\n  }\n});\n//# sourceMappingURL=settings.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/prepare/lib/Prepare.mjs\n\n\n\n\nfunction uploadBaseTextures(renderer, item) {\n  if (item instanceof BaseTexture) {\n    if (!item._glTextures[renderer.CONTEXT_UID]) {\n      renderer.texture.bind(item);\n    }\n    return true;\n  }\n  return false;\n}\nfunction uploadGraphics(renderer, item) {\n  if (!(item instanceof Graphics)) {\n    return false;\n  }\n  const { geometry } = item;\n  item.finishPoly();\n  geometry.updateBatches();\n  const { batches } = geometry;\n  for (let i = 0; i < batches.length; i++) {\n    const { texture } = batches[i].style;\n    if (texture) {\n      uploadBaseTextures(renderer, texture.baseTexture);\n    }\n  }\n  if (!geometry.batchable) {\n    renderer.geometry.bind(geometry, item._resolveDirectShader(renderer));\n  }\n  return true;\n}\nfunction findGraphics(item, queue) {\n  if (item instanceof Graphics) {\n    queue.push(item);\n    return true;\n  }\n  return false;\n}\nclass Prepare extends BasePrepare {\n  constructor(renderer) {\n    super(renderer);\n    this.uploadHookHelper = this.renderer;\n    this.registerFindHook(findGraphics);\n    this.registerUploadHook(uploadBaseTextures);\n    this.registerUploadHook(uploadGraphics);\n  }\n}\nPrepare.extension = {\n  name: "prepare",\n  type: ExtensionType.RendererSystem\n};\nextensions.add(Prepare);\n\n\n//# sourceMappingURL=Prepare.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/prepare/lib/index.mjs\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-animated/lib/AnimatedSprite.mjs\n\n\n\nclass AnimatedSprite extends (/* unused pure expression or super */ null && (Sprite)) {\n  constructor(textures, autoUpdate = true) {\n    super(textures[0] instanceof Texture ? textures[0] : textures[0].texture);\n    this._textures = null;\n    this._durations = null;\n    this._autoUpdate = autoUpdate;\n    this._isConnectedToTicker = false;\n    this.animationSpeed = 1;\n    this.loop = true;\n    this.updateAnchor = false;\n    this.onComplete = null;\n    this.onFrameChange = null;\n    this.onLoop = null;\n    this._currentTime = 0;\n    this._playing = false;\n    this._previousFrame = null;\n    this.textures = textures;\n  }\n  stop() {\n    if (!this._playing) {\n      return;\n    }\n    this._playing = false;\n    if (this._autoUpdate && this._isConnectedToTicker) {\n      Ticker.shared.remove(this.update, this);\n      this._isConnectedToTicker = false;\n    }\n  }\n  play() {\n    if (this._playing) {\n      return;\n    }\n    this._playing = true;\n    if (this._autoUpdate && !this._isConnectedToTicker) {\n      Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);\n      this._isConnectedToTicker = true;\n    }\n  }\n  gotoAndStop(frameNumber) {\n    this.stop();\n    this.currentFrame = frameNumber;\n  }\n  gotoAndPlay(frameNumber) {\n    this.currentFrame = frameNumber;\n    this.play();\n  }\n  update(deltaTime) {\n    if (!this._playing) {\n      return;\n    }\n    const elapsed = this.animationSpeed * deltaTime;\n    const previousFrame = this.currentFrame;\n    if (this._durations !== null) {\n      let lag = this._currentTime % 1 * this._durations[this.currentFrame];\n      lag += elapsed / 60 * 1e3;\n      while (lag < 0) {\n        this._currentTime--;\n        lag += this._durations[this.currentFrame];\n      }\n      const sign = Math.sign(this.animationSpeed * deltaTime);\n      this._currentTime = Math.floor(this._currentTime);\n      while (lag >= this._durations[this.currentFrame]) {\n        lag -= this._durations[this.currentFrame] * sign;\n        this._currentTime += sign;\n      }\n      this._currentTime += lag / this._durations[this.currentFrame];\n    } else {\n      this._currentTime += elapsed;\n    }\n    if (this._currentTime < 0 && !this.loop) {\n      this.gotoAndStop(0);\n      if (this.onComplete) {\n        this.onComplete();\n      }\n    } else if (this._currentTime >= this._textures.length && !this.loop) {\n      this.gotoAndStop(this._textures.length - 1);\n      if (this.onComplete) {\n        this.onComplete();\n      }\n    } else if (previousFrame !== this.currentFrame) {\n      if (this.loop && this.onLoop) {\n        if (this.animationSpeed > 0 && this.currentFrame < previousFrame || this.animationSpeed < 0 && this.currentFrame > previousFrame) {\n          this.onLoop();\n        }\n      }\n      this.updateTexture();\n    }\n  }\n  updateTexture() {\n    const currentFrame = this.currentFrame;\n    if (this._previousFrame === currentFrame) {\n      return;\n    }\n    this._previousFrame = currentFrame;\n    this._texture = this._textures[currentFrame];\n    this._textureID = -1;\n    this._textureTrimmedID = -1;\n    this._cachedTint = 16777215;\n    this.uvs = this._texture._uvs.uvsFloat32;\n    if (this.updateAnchor) {\n      this._anchor.copyFrom(this._texture.defaultAnchor);\n    }\n    if (this.onFrameChange) {\n      this.onFrameChange(this.currentFrame);\n    }\n  }\n  destroy(options) {\n    this.stop();\n    super.destroy(options);\n    this.onComplete = null;\n    this.onFrameChange = null;\n    this.onLoop = null;\n  }\n  static fromFrames(frames) {\n    const textures = [];\n    for (let i = 0; i < frames.length; ++i) {\n      textures.push(Texture.from(frames[i]));\n    }\n    return new AnimatedSprite(textures);\n  }\n  static fromImages(images) {\n    const textures = [];\n    for (let i = 0; i < images.length; ++i) {\n      textures.push(Texture.from(images[i]));\n    }\n    return new AnimatedSprite(textures);\n  }\n  get totalFrames() {\n    return this._textures.length;\n  }\n  get textures() {\n    return this._textures;\n  }\n  set textures(value) {\n    if (value[0] instanceof Texture) {\n      this._textures = value;\n      this._durations = null;\n    } else {\n      this._textures = [];\n      this._durations = [];\n      for (let i = 0; i < value.length; i++) {\n        this._textures.push(value[i].texture);\n        this._durations.push(value[i].time);\n      }\n    }\n    this._previousFrame = null;\n    this.gotoAndStop(0);\n    this.updateTexture();\n  }\n  get currentFrame() {\n    let currentFrame = Math.floor(this._currentTime) % this._textures.length;\n    if (currentFrame < 0) {\n      currentFrame += this._textures.length;\n    }\n    return currentFrame;\n  }\n  set currentFrame(value) {\n    if (value < 0 || value > this.totalFrames - 1) {\n      throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, expected to be between 0 and totalFrames ${this.totalFrames}.`);\n    }\n    const previousFrame = this.currentFrame;\n    this._currentTime = value;\n    if (previousFrame !== this.currentFrame) {\n      this.updateTexture();\n    }\n  }\n  get playing() {\n    return this._playing;\n  }\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    if (value !== this._autoUpdate) {\n      this._autoUpdate = value;\n      if (!this._autoUpdate && this._isConnectedToTicker) {\n        Ticker.shared.remove(this.update, this);\n        this._isConnectedToTicker = false;\n      } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {\n        Ticker.shared.add(this.update, this);\n        this._isConnectedToTicker = true;\n      }\n    }\n  }\n}\n\n\n//# sourceMappingURL=AnimatedSprite.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-animated/lib/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/TilingSprite.mjs\n\n\n\nconst TilingSprite_tempPoint = new Point();\nclass TilingSprite extends (/* unused pure expression or super */ null && (Sprite)) {\n  constructor(texture, width = 100, height = 100) {\n    super(texture);\n    this.tileTransform = new Transform();\n    this._width = width;\n    this._height = height;\n    this.uvMatrix = this.texture.uvMatrix || new TextureMatrix(texture);\n    this.pluginName = "tilingSprite";\n    this.uvRespectAnchor = false;\n  }\n  get clampMargin() {\n    return this.uvMatrix.clampMargin;\n  }\n  set clampMargin(value) {\n    this.uvMatrix.clampMargin = value;\n    this.uvMatrix.update(true);\n  }\n  get tileScale() {\n    return this.tileTransform.scale;\n  }\n  set tileScale(value) {\n    this.tileTransform.scale.copyFrom(value);\n  }\n  get tilePosition() {\n    return this.tileTransform.position;\n  }\n  set tilePosition(value) {\n    this.tileTransform.position.copyFrom(value);\n  }\n  _onTextureUpdate() {\n    if (this.uvMatrix) {\n      this.uvMatrix.texture = this._texture;\n    }\n    this._cachedTint = 16777215;\n  }\n  _render(renderer) {\n    const texture = this._texture;\n    if (!texture || !texture.valid) {\n      return;\n    }\n    this.tileTransform.updateLocalTransform();\n    this.uvMatrix.update();\n    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n    renderer.plugins[this.pluginName].render(this);\n  }\n  _calculateBounds() {\n    const minX = this._width * -this._anchor._x;\n    const minY = this._height * -this._anchor._y;\n    const maxX = this._width * (1 - this._anchor._x);\n    const maxY = this._height * (1 - this._anchor._y);\n    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n  }\n  getLocalBounds(rect) {\n    if (this.children.length === 0) {\n      this._bounds.minX = this._width * -this._anchor._x;\n      this._bounds.minY = this._height * -this._anchor._y;\n      this._bounds.maxX = this._width * (1 - this._anchor._x);\n      this._bounds.maxY = this._height * (1 - this._anchor._y);\n      if (!rect) {\n        if (!this._localBoundsRect) {\n          this._localBoundsRect = new Rectangle();\n        }\n        rect = this._localBoundsRect;\n      }\n      return this._bounds.getRectangle(rect);\n    }\n    return super.getLocalBounds.call(this, rect);\n  }\n  containsPoint(point) {\n    this.worldTransform.applyInverse(point, TilingSprite_tempPoint);\n    const width = this._width;\n    const height = this._height;\n    const x1 = -width * this.anchor._x;\n    if (TilingSprite_tempPoint.x >= x1 && TilingSprite_tempPoint.x < x1 + width) {\n      const y1 = -height * this.anchor._y;\n      if (TilingSprite_tempPoint.y >= y1 && TilingSprite_tempPoint.y < y1 + height) {\n        return true;\n      }\n    }\n    return false;\n  }\n  destroy(options) {\n    super.destroy(options);\n    this.tileTransform = null;\n    this.uvMatrix = null;\n  }\n  static from(source, options) {\n    const texture = source instanceof Texture ? source : Texture.from(source, options);\n    return new TilingSprite(texture, options.width, options.height);\n  }\n  get width() {\n    return this._width;\n  }\n  set width(value) {\n    this._width = value;\n  }\n  get height() {\n    return this._height;\n  }\n  set height(value) {\n    this._height = value;\n  }\n}\n\n\n//# sourceMappingURL=TilingSprite.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling.mjs\nvar gl2FragmentSrc = "#version 300 es\\n#define SHADER_NAME Tiling-Sprite-100\\n\\nprecision lowp float;\\n\\nin vec2 vTextureCoord;\\n\\nout vec4 fragmentColor;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\nuniform mat3 uMapCoord;\\nuniform vec4 uClampFrame;\\nuniform vec2 uClampOffset;\\n\\nvoid main(void)\\n{\\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\\n    vec2 unclamped = coord;\\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\\n\\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\\n\\n    fragmentColor = texSample * uColor;\\n}\\n";\n\n\n//# sourceMappingURL=sprite-tiling.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling2.mjs\nvar gl2VertexSrc = "#version 300 es\\n#define SHADER_NAME Tiling-Sprite-300\\n\\nprecision lowp float;\\n\\nin vec2 aVertexPosition;\\nin vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTransform;\\n\\nout vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\\n}\\n";\n\n\n//# sourceMappingURL=sprite-tiling2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback.mjs\nvar gl1FragmentSrc = "#version 100\\n#ifdef GL_EXT_shader_texture_lod\\n    #extension GL_EXT_shader_texture_lod : enable\\n#endif\\n#define SHADER_NAME Tiling-Sprite-100\\n\\nprecision lowp float;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\nuniform mat3 uMapCoord;\\nuniform vec4 uClampFrame;\\nuniform vec2 uClampOffset;\\n\\nvoid main(void)\\n{\\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\\n    vec2 unclamped = coord;\\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\\n\\n    #ifdef GL_EXT_shader_texture_lod\\n        vec4 texSample = unclamped == coord\\n            ? texture2D(uSampler, coord) \\n            : texture2DLodEXT(uSampler, coord, 0);\\n    #else\\n        vec4 texSample = texture2D(uSampler, coord);\\n    #endif\\n\\n    gl_FragColor = texSample * uColor;\\n}\\n";\n\n\n//# sourceMappingURL=sprite-tiling-fallback.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-fallback2.mjs\nvar gl1VertexSrc = "#version 100\\n#define SHADER_NAME Tiling-Sprite-100\\n\\nprecision lowp float;\\n\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTransform;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\\n}\\n";\n\n\n//# sourceMappingURL=sprite-tiling-fallback2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/sprite-tiling-simple.mjs\nvar fragmentSimpleSrc = "#version 100\\n#define SHADER_NAME Tiling-Sprite-Simple-100\\n\\nprecision lowp float;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\n\\nvoid main(void)\\n{\\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\\n    gl_FragColor = texSample * uColor;\\n}\\n";\n\n\n//# sourceMappingURL=sprite-tiling-simple.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/TilingSpriteRenderer.mjs\n\n\n\n\n\n\n\nconst TilingSpriteRenderer_tempMat = new Matrix();\nclass TilingSpriteRenderer extends ObjectRenderer {\n  constructor(renderer) {\n    super(renderer);\n    renderer.runners.contextChange.add(this);\n    this.quad = new QuadUv();\n    this.state = State.for2d();\n  }\n  contextChange() {\n    const renderer = this.renderer;\n    const uniforms = { globals: renderer.globalUniforms };\n    this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);\n    this.shader = renderer.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms) : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);\n  }\n  render(ts) {\n    const renderer = this.renderer;\n    const quad = this.quad;\n    let vertices = quad.vertices;\n    vertices[0] = vertices[6] = ts._width * -ts.anchor.x;\n    vertices[1] = vertices[3] = ts._height * -ts.anchor.y;\n    vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);\n    vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);\n    const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;\n    const anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;\n    vertices = quad.uvs;\n    vertices[0] = vertices[6] = -anchorX;\n    vertices[1] = vertices[3] = -anchorY;\n    vertices[2] = vertices[4] = 1 - anchorX;\n    vertices[5] = vertices[7] = 1 - anchorY;\n    quad.invalidate();\n    const tex = ts._texture;\n    const baseTex = tex.baseTexture;\n    const premultiplied = baseTex.alphaMode > 0;\n    const lt = ts.tileTransform.localTransform;\n    const uv = ts.uvMatrix;\n    let isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n    if (isSimple) {\n      if (!baseTex._glTextures[renderer.CONTEXT_UID]) {\n        if (baseTex.wrapMode === lib/* WRAP_MODES */.Nt.CLAMP) {\n          baseTex.wrapMode = lib/* WRAP_MODES */.Nt.REPEAT;\n        }\n      } else {\n        isSimple = baseTex.wrapMode !== lib/* WRAP_MODES */.Nt.CLAMP;\n      }\n    }\n    const shader = isSimple ? this.simpleShader : this.shader;\n    const w = tex.width;\n    const h = tex.height;\n    const W = ts._width;\n    const H = ts._height;\n    TilingSpriteRenderer_tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);\n    TilingSpriteRenderer_tempMat.invert();\n    if (isSimple) {\n      TilingSpriteRenderer_tempMat.prepend(uv.mapCoord);\n    } else {\n      shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\n      shader.uniforms.uClampFrame = uv.uClampFrame;\n      shader.uniforms.uClampOffset = uv.uClampOffset;\n    }\n    shader.uniforms.uTransform = TilingSpriteRenderer_tempMat.toArray(true);\n    shader.uniforms.uColor = color_lib/* Color */.I.shared.setValue(ts.tint).premultiply(ts.worldAlpha, premultiplied).toArray(shader.uniforms.uColor);\n    shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);\n    shader.uniforms.uSampler = tex;\n    renderer.shader.bind(shader);\n    renderer.geometry.bind(quad);\n    this.state.blendMode = utils_lib.correctBlendMode(ts.blendMode, premultiplied);\n    renderer.state.set(this.state);\n    renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);\n  }\n}\nTilingSpriteRenderer.extension = {\n  name: "tilingSprite",\n  type: ExtensionType.RendererPlugin\n};\nextensions.add(TilingSpriteRenderer);\n\n\n//# sourceMappingURL=TilingSpriteRenderer.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/sprite-tiling/lib/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/spritesheet/lib/Spritesheet.mjs\n\n\nconst _Spritesheet = class {\n  constructor(texture, data, resolutionFilename = null) {\n    this.linkedSheets = [];\n    this._texture = texture instanceof Texture_Texture ? texture : null;\n    this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture;\n    this.textures = {};\n    this.animations = {};\n    this.data = data;\n    const resource = this.baseTexture.resource;\n    this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));\n    this._frames = this.data.frames;\n    this._frameKeys = Object.keys(this._frames);\n    this._batchIndex = 0;\n    this._callback = null;\n  }\n  _updateResolution(resolutionFilename = null) {\n    const { scale } = this.data.meta;\n    let resolution = utils_lib.getResolutionOfUrl(resolutionFilename, null);\n    if (resolution === null) {\n      resolution = parseFloat(scale ?? "1");\n    }\n    if (resolution !== 1) {\n      this.baseTexture.setResolution(resolution);\n    }\n    return resolution;\n  }\n  parse() {\n    return new Promise((resolve) => {\n      this._callback = resolve;\n      this._batchIndex = 0;\n      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {\n        this._processFrames(0);\n        this._processAnimations();\n        this._parseComplete();\n      } else {\n        this._nextBatch();\n      }\n    });\n  }\n  _processFrames(initialFrameIndex) {\n    let frameIndex = initialFrameIndex;\n    const maxFrames = _Spritesheet.BATCH_SIZE;\n    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n      const i = this._frameKeys[frameIndex];\n      const data = this._frames[i];\n      const rect = data.frame;\n      if (rect) {\n        let frame = null;\n        let trim = null;\n        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n        const orig = new Rectangle_Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);\n        if (data.rotated) {\n          frame = new Rectangle_Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);\n        } else {\n          frame = new Rectangle_Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n        }\n        if (data.trimmed !== false && data.spriteSourceSize) {\n          trim = new Rectangle_Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n        }\n        this.textures[i] = new Texture_Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor, data.borders);\n        Texture_Texture.addToCache(this.textures[i], i);\n      }\n      frameIndex++;\n    }\n  }\n  _processAnimations() {\n    const animations = this.data.animations || {};\n    for (const animName in animations) {\n      this.animations[animName] = [];\n      for (let i = 0; i < animations[animName].length; i++) {\n        const frameName = animations[animName][i];\n        this.animations[animName].push(this.textures[frameName]);\n      }\n    }\n  }\n  _parseComplete() {\n    const callback = this._callback;\n    this._callback = null;\n    this._batchIndex = 0;\n    callback.call(this, this.textures);\n  }\n  _nextBatch() {\n    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);\n    this._batchIndex++;\n    setTimeout(() => {\n      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {\n        this._nextBatch();\n      } else {\n        this._processAnimations();\n        this._parseComplete();\n      }\n    }, 0);\n  }\n  destroy(destroyBase = false) {\n    for (const i in this.textures) {\n      this.textures[i].destroy();\n    }\n    this._frames = null;\n    this._frameKeys = null;\n    this.data = null;\n    this.textures = null;\n    if (destroyBase) {\n      this._texture?.destroy();\n      this.baseTexture.destroy();\n    }\n    this._texture = null;\n    this.baseTexture = null;\n    this.linkedSheets = [];\n  }\n};\nlet Spritesheet = _Spritesheet;\nSpritesheet.BATCH_SIZE = 1e3;\n\n\n//# sourceMappingURL=Spritesheet.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/spritesheet/lib/spritesheetAsset.mjs\n\n\n\n\nconst validImages = ["jpg", "png", "jpeg", "avif", "webp"];\nfunction getCacheableAssets(keys, asset, ignoreMultiPack) {\n  const out = {};\n  keys.forEach((key) => {\n    out[key] = asset;\n  });\n  Object.keys(asset.textures).forEach((key) => {\n    out[key] = asset.textures[key];\n  });\n  if (!ignoreMultiPack) {\n    const basePath = utils_lib.path.dirname(keys[0]);\n    asset.linkedSheets.forEach((item, i) => {\n      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);\n      Object.assign(out, out2);\n    });\n  }\n  return out;\n}\nconst spritesheetAsset = {\n  extension: ExtensionType.Asset,\n  cache: {\n    test: (asset) => asset instanceof Spritesheet,\n    getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)\n  },\n  resolver: {\n    test: (value) => {\n      const tempURL = value.split("?")[0];\n      const split = tempURL.split(".");\n      const extension = split.pop();\n      const format = split.pop();\n      return extension === "json" && validImages.includes(format);\n    },\n    parse: (value) => {\n      const split = value.split(".");\n      return {\n        resolution: parseFloat(settings_lib/* settings */.Xd.RETINA_PREFIX.exec(value)?.[1] ?? "1"),\n        format: split[split.length - 2],\n        src: value\n      };\n    }\n  },\n  loader: {\n    name: "spritesheetLoader",\n    extension: {\n      type: ExtensionType.LoadParser,\n      priority: LoaderParserPriority.Normal\n    },\n    async testParse(asset, options) {\n      return utils_lib.path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;\n    },\n    async parse(asset, options, loader) {\n      let basePath = utils_lib.path.dirname(options.src);\n      if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {\n        basePath += "/";\n      }\n      let imagePath = basePath + asset.meta.image;\n      imagePath = copySearchParams(imagePath, options.src);\n      const assets = await loader.load([imagePath]);\n      const texture = assets[imagePath];\n      const spritesheet = new Spritesheet(texture.baseTexture, asset, options.src);\n      await spritesheet.parse();\n      const multiPacks = asset?.meta?.related_multi_packs;\n      if (Array.isArray(multiPacks)) {\n        const promises = [];\n        for (const item of multiPacks) {\n          if (typeof item !== "string") {\n            continue;\n          }\n          let itemUrl = basePath + item;\n          if (options.data?.ignoreMultiPack) {\n            continue;\n          }\n          itemUrl = copySearchParams(itemUrl, options.src);\n          promises.push(loader.load({\n            src: itemUrl,\n            data: {\n              ignoreMultiPack: true\n            }\n          }));\n        }\n        const res = await Promise.all(promises);\n        spritesheet.linkedSheets = res;\n        res.forEach((item) => {\n          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));\n        });\n      }\n      return spritesheet;\n    },\n    unload(spritesheet) {\n      spritesheet.destroy(true);\n    }\n  }\n};\nextensions.add(spritesheetAsset);\n\n\n//# sourceMappingURL=spritesheetAsset.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/spritesheet/lib/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/BitmapFontData.mjs\nclass BitmapFontData {\n  constructor() {\n    this.info = [];\n    this.common = [];\n    this.page = [];\n    this.char = [];\n    this.kerning = [];\n    this.distanceField = [];\n  }\n}\n\n\n//# sourceMappingURL=BitmapFontData.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/formats/TextFormat.mjs\n\n\nclass TextFormat {\n  static test(data) {\n    return typeof data === "string" && data.startsWith("info face=");\n  }\n  static parse(txt) {\n    const items = txt.match(/^[a-z]+\\s+.+$/gm);\n    const rawData = {\n      info: [],\n      common: [],\n      page: [],\n      char: [],\n      chars: [],\n      kerning: [],\n      kernings: [],\n      distanceField: []\n    };\n    for (const i in items) {\n      const name = items[i].match(/^[a-z]+/gm)[0];\n      const attributeList = items[i].match(/[a-zA-Z]+=([^\\s"\']+|"([^"]*)")/gm);\n      const itemData = {};\n      for (const i2 in attributeList) {\n        const split = attributeList[i2].split("=");\n        const key = split[0];\n        const strValue = split[1].replace(/"/gm, "");\n        const floatValue = parseFloat(strValue);\n        const value = isNaN(floatValue) ? strValue : floatValue;\n        itemData[key] = value;\n      }\n      rawData[name].push(itemData);\n    }\n    const font = new BitmapFontData();\n    rawData.info.forEach((info) => font.info.push({\n      face: info.face,\n      size: parseInt(info.size, 10)\n    }));\n    rawData.common.forEach((common) => font.common.push({\n      lineHeight: parseInt(common.lineHeight, 10)\n    }));\n    rawData.page.forEach((page) => font.page.push({\n      id: parseInt(page.id, 10),\n      file: page.file\n    }));\n    rawData.char.forEach((char) => font.char.push({\n      id: parseInt(char.id, 10),\n      page: parseInt(char.page, 10),\n      x: parseInt(char.x, 10),\n      y: parseInt(char.y, 10),\n      width: parseInt(char.width, 10),\n      height: parseInt(char.height, 10),\n      xoffset: parseInt(char.xoffset, 10),\n      yoffset: parseInt(char.yoffset, 10),\n      xadvance: parseInt(char.xadvance, 10)\n    }));\n    rawData.kerning.forEach((kerning) => font.kerning.push({\n      first: parseInt(kerning.first, 10),\n      second: parseInt(kerning.second, 10),\n      amount: parseInt(kerning.amount, 10)\n    }));\n    rawData.distanceField.forEach((df) => font.distanceField.push({\n      distanceRange: parseInt(df.distanceRange, 10),\n      fieldType: df.fieldType\n    }));\n    return font;\n  }\n}\n\n\n//# sourceMappingURL=TextFormat.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/formats/XMLFormat.mjs\n\n\nclass XMLFormat {\n  static test(data) {\n    const xml = data;\n    return "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;\n  }\n  static parse(xml) {\n    const data = new BitmapFontData();\n    const info = xml.getElementsByTagName("info");\n    const common = xml.getElementsByTagName("common");\n    const page = xml.getElementsByTagName("page");\n    const char = xml.getElementsByTagName("char");\n    const kerning = xml.getElementsByTagName("kerning");\n    const distanceField = xml.getElementsByTagName("distanceField");\n    for (let i = 0; i < info.length; i++) {\n      data.info.push({\n        face: info[i].getAttribute("face"),\n        size: parseInt(info[i].getAttribute("size"), 10)\n      });\n    }\n    for (let i = 0; i < common.length; i++) {\n      data.common.push({\n        lineHeight: parseInt(common[i].getAttribute("lineHeight"), 10)\n      });\n    }\n    for (let i = 0; i < page.length; i++) {\n      data.page.push({\n        id: parseInt(page[i].getAttribute("id"), 10) || 0,\n        file: page[i].getAttribute("file")\n      });\n    }\n    for (let i = 0; i < char.length; i++) {\n      const letter = char[i];\n      data.char.push({\n        id: parseInt(letter.getAttribute("id"), 10),\n        page: parseInt(letter.getAttribute("page"), 10) || 0,\n        x: parseInt(letter.getAttribute("x"), 10),\n        y: parseInt(letter.getAttribute("y"), 10),\n        width: parseInt(letter.getAttribute("width"), 10),\n        height: parseInt(letter.getAttribute("height"), 10),\n        xoffset: parseInt(letter.getAttribute("xoffset"), 10),\n        yoffset: parseInt(letter.getAttribute("yoffset"), 10),\n        xadvance: parseInt(letter.getAttribute("xadvance"), 10)\n      });\n    }\n    for (let i = 0; i < kerning.length; i++) {\n      data.kerning.push({\n        first: parseInt(kerning[i].getAttribute("first"), 10),\n        second: parseInt(kerning[i].getAttribute("second"), 10),\n        amount: parseInt(kerning[i].getAttribute("amount"), 10)\n      });\n    }\n    for (let i = 0; i < distanceField.length; i++) {\n      data.distanceField.push({\n        fieldType: distanceField[i].getAttribute("fieldType"),\n        distanceRange: parseInt(distanceField[i].getAttribute("distanceRange"), 10)\n      });\n    }\n    return data;\n  }\n}\n\n\n//# sourceMappingURL=XMLFormat.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/formats/XMLStringFormat.mjs\n\n\n\nclass XMLStringFormat {\n  static test(data) {\n    if (typeof data === "string" && data.includes("<font>")) {\n      return XMLFormat.test(settings_lib/* settings */.Xd.ADAPTER.parseXML(data));\n    }\n    return false;\n  }\n  static parse(xmlTxt) {\n    return XMLFormat.parse(settings_lib/* settings */.Xd.ADAPTER.parseXML(xmlTxt));\n  }\n}\n\n\n//# sourceMappingURL=XMLStringFormat.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/formats/index.mjs\n\n\n\n\n\n\n\nconst formats = [\n  TextFormat,\n  XMLFormat,\n  XMLStringFormat\n];\nfunction autoDetectFormat(data) {\n  for (let i = 0; i < formats.length; i++) {\n    if (formats[i].test(data)) {\n      return formats[i];\n    }\n  }\n  return null;\n}\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/utils/generateFillStyle.mjs\n\n\nfunction generateFillStyle(canvas, context, style, resolution, lines, metrics) {\n  const fillStyle = style.fill;\n  if (!Array.isArray(fillStyle)) {\n    return fillStyle;\n  } else if (fillStyle.length === 1) {\n    return fillStyle[0];\n  }\n  let gradient;\n  const dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;\n  const padding = style.padding || 0;\n  const width = canvas.width / resolution - dropShadowCorrection - padding * 2;\n  const height = canvas.height / resolution - dropShadowCorrection - padding * 2;\n  const fill = fillStyle.slice();\n  const fillGradientStops = style.fillGradientStops.slice();\n  if (!fillGradientStops.length) {\n    const lengthPlus1 = fill.length + 1;\n    for (let i = 1; i < lengthPlus1; ++i) {\n      fillGradientStops.push(i / lengthPlus1);\n    }\n  }\n  fill.unshift(fillStyle[0]);\n  fillGradientStops.unshift(0);\n  fill.push(fillStyle[fillStyle.length - 1]);\n  fillGradientStops.push(1);\n  if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {\n    gradient = context.createLinearGradient(width / 2, padding, width / 2, height + padding);\n    let lastIterationStop = 0;\n    const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;\n    const gradStopLineHeight = textHeight / height;\n    for (let i = 0; i < lines.length; i++) {\n      const thisLineTop = metrics.lineHeight * i;\n      for (let j = 0; j < fill.length; j++) {\n        let lineStop = 0;\n        if (typeof fillGradientStops[j] === "number") {\n          lineStop = fillGradientStops[j];\n        } else {\n          lineStop = j / fill.length;\n        }\n        const globalStop = thisLineTop / height + lineStop * gradStopLineHeight;\n        let clampedStop = Math.max(lastIterationStop, globalStop);\n        clampedStop = Math.min(clampedStop, 1);\n        gradient.addColorStop(clampedStop, fill[j]);\n        lastIterationStop = clampedStop;\n      }\n    }\n  } else {\n    gradient = context.createLinearGradient(padding, height / 2, width + padding, height / 2);\n    const totalIterations = fill.length + 1;\n    let currentIteration = 1;\n    for (let i = 0; i < fill.length; i++) {\n      let stop;\n      if (typeof fillGradientStops[i] === "number") {\n        stop = fillGradientStops[i];\n      } else {\n        stop = currentIteration / totalIterations;\n      }\n      gradient.addColorStop(stop, fill[i]);\n      currentIteration++;\n    }\n  }\n  return gradient;\n}\n\n\n//# sourceMappingURL=generateFillStyle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/utils/drawGlyph.mjs\n\n\n\nfunction drawGlyph(canvas, context, metrics, x, y, resolution, style) {\n  const char = metrics.text;\n  const fontProperties = metrics.fontProperties;\n  context.translate(x, y);\n  context.scale(resolution, resolution);\n  const tx = style.strokeThickness / 2;\n  const ty = -(style.strokeThickness / 2);\n  context.font = style.toFontString();\n  context.lineWidth = style.strokeThickness;\n  context.textBaseline = style.textBaseline;\n  context.lineJoin = style.lineJoin;\n  context.miterLimit = style.miterLimit;\n  context.fillStyle = generateFillStyle(canvas, context, style, resolution, [char], metrics);\n  context.strokeStyle = style.stroke;\n  if (style.dropShadow) {\n    const dropShadowColor = style.dropShadowColor;\n    const dropShadowBlur = style.dropShadowBlur * resolution;\n    const dropShadowDistance = style.dropShadowDistance * resolution;\n    context.shadowColor = color_lib/* Color */.I.shared.setValue(dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString();\n    context.shadowBlur = dropShadowBlur;\n    context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;\n    context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;\n  } else {\n    context.shadowColor = "black";\n    context.shadowBlur = 0;\n    context.shadowOffsetX = 0;\n    context.shadowOffsetY = 0;\n  }\n  if (style.stroke && style.strokeThickness) {\n    context.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);\n  }\n  if (style.fill) {\n    context.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);\n  }\n  context.setTransform(1, 0, 0, 1, 0, 0);\n  context.fillStyle = "rgba(0, 0, 0, 0)";\n}\n\n\n//# sourceMappingURL=drawGlyph.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/utils/index.mjs\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/utils/splitTextToCharacters.mjs\nfunction splitTextToCharacters(text) {\n  return Array.from ? Array.from(text) : text.split("");\n}\n\n\n//# sourceMappingURL=splitTextToCharacters.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/utils/resolveCharacters.mjs\n\n\nfunction resolveCharacters(chars) {\n  if (typeof chars === "string") {\n    chars = [chars];\n  }\n  const result = [];\n  for (let i = 0, j = chars.length; i < j; i++) {\n    const item = chars[i];\n    if (Array.isArray(item)) {\n      if (item.length !== 2) {\n        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n      }\n      const startCode = item[0].charCodeAt(0);\n      const endCode = item[1].charCodeAt(0);\n      if (endCode < startCode) {\n        throw new Error("[BitmapFont]: Invalid character range.");\n      }\n      for (let i2 = startCode, j2 = endCode; i2 <= j2; i2++) {\n        result.push(String.fromCharCode(i2));\n      }\n    } else {\n      result.push(...splitTextToCharacters(item));\n    }\n  }\n  if (result.length === 0) {\n    throw new Error("[BitmapFont]: Empty set when resolving characters.");\n  }\n  return result;\n}\n\n\n//# sourceMappingURL=resolveCharacters.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/utils/extractCharCode.mjs\nfunction extractCharCode(str) {\n  return str.codePointAt ? str.codePointAt(0) : str.charCodeAt(0);\n}\n\n\n//# sourceMappingURL=extractCharCode.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/BitmapFont.mjs\n\n\n\n\n\n\n\n\n\nconst _BitmapFont = class {\n  constructor(data, textures, ownsTextures) {\n    const [info] = data.info;\n    const [common] = data.common;\n    const [page] = data.page;\n    const [distanceField] = data.distanceField;\n    const res = utils_lib.getResolutionOfUrl(page.file);\n    const pageTextures = {};\n    this._ownsTextures = ownsTextures;\n    this.font = info.face;\n    this.size = info.size;\n    this.lineHeight = common.lineHeight / res;\n    this.chars = {};\n    this.pageTextures = pageTextures;\n    for (let i = 0; i < data.page.length; i++) {\n      const { id, file } = data.page[i];\n      pageTextures[id] = textures instanceof Array ? textures[i] : textures[file];\n      if (distanceField?.fieldType && distanceField.fieldType !== "none") {\n        pageTextures[id].baseTexture.alphaMode = lib/* ALPHA_MODES */.iw.NO_PREMULTIPLIED_ALPHA;\n        pageTextures[id].baseTexture.mipmap = lib/* MIPMAP_MODES */.WB.OFF;\n      }\n    }\n    for (let i = 0; i < data.char.length; i++) {\n      const { id, page: page2 } = data.char[i];\n      let { x, y, width, height, xoffset, yoffset, xadvance } = data.char[i];\n      x /= res;\n      y /= res;\n      width /= res;\n      height /= res;\n      xoffset /= res;\n      yoffset /= res;\n      xadvance /= res;\n      const rect = new Rectangle_Rectangle(x + pageTextures[page2].frame.x / res, y + pageTextures[page2].frame.y / res, width, height);\n      this.chars[id] = {\n        xOffset: xoffset,\n        yOffset: yoffset,\n        xAdvance: xadvance,\n        kerning: {},\n        texture: new Texture_Texture(pageTextures[page2].baseTexture, rect),\n        page: page2\n      };\n    }\n    for (let i = 0; i < data.kerning.length; i++) {\n      let { first, second, amount } = data.kerning[i];\n      first /= res;\n      second /= res;\n      amount /= res;\n      if (this.chars[second]) {\n        this.chars[second].kerning[first] = amount;\n      }\n    }\n    this.distanceFieldRange = distanceField?.distanceRange;\n    this.distanceFieldType = distanceField?.fieldType?.toLowerCase() ?? "none";\n  }\n  destroy() {\n    for (const id in this.chars) {\n      this.chars[id].texture.destroy();\n      this.chars[id].texture = null;\n    }\n    for (const id in this.pageTextures) {\n      if (this._ownsTextures) {\n        this.pageTextures[id].destroy(true);\n      }\n      this.pageTextures[id] = null;\n    }\n    this.chars = null;\n    this.pageTextures = null;\n  }\n  static install(data, textures, ownsTextures) {\n    let fontData;\n    if (data instanceof BitmapFontData) {\n      fontData = data;\n    } else {\n      const format = autoDetectFormat(data);\n      if (!format) {\n        throw new Error("Unrecognized data format for font.");\n      }\n      fontData = format.parse(data);\n    }\n    if (textures instanceof Texture_Texture) {\n      textures = [textures];\n    }\n    const font = new _BitmapFont(fontData, textures, ownsTextures);\n    _BitmapFont.available[font.font] = font;\n    return font;\n  }\n  static uninstall(name) {\n    const font = _BitmapFont.available[name];\n    if (!font) {\n      throw new Error(`No font found named \'${name}\'`);\n    }\n    font.destroy();\n    delete _BitmapFont.available[name];\n  }\n  static from(name, textStyle, options) {\n    if (!name) {\n      throw new Error("[BitmapFont] Property `name` is required.");\n    }\n    const {\n      chars,\n      padding,\n      resolution,\n      textureWidth,\n      textureHeight,\n      ...baseOptions\n    } = Object.assign({}, _BitmapFont.defaultOptions, options);\n    const charsList = resolveCharacters(chars);\n    const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n    const lineWidth = textureWidth;\n    const fontData = new BitmapFontData();\n    fontData.info[0] = {\n      face: style.fontFamily,\n      size: style.fontSize\n    };\n    fontData.common[0] = {\n      lineHeight: style.fontSize\n    };\n    let positionX = 0;\n    let positionY = 0;\n    let canvas;\n    let context;\n    let baseTexture;\n    let maxCharHeight = 0;\n    const baseTextures = [];\n    const textures = [];\n    for (let i = 0; i < charsList.length; i++) {\n      if (!canvas) {\n        canvas = settings_lib/* settings */.Xd.ADAPTER.createCanvas();\n        canvas.width = textureWidth;\n        canvas.height = textureHeight;\n        context = canvas.getContext("2d");\n        baseTexture = new BaseTexture(canvas, { resolution, ...baseOptions });\n        baseTextures.push(baseTexture);\n        textures.push(new Texture_Texture(baseTexture));\n        fontData.page.push({\n          id: textures.length - 1,\n          file: ""\n        });\n      }\n      const character = charsList[i];\n      const metrics = TextMetrics.measureText(character, style, false, canvas);\n      const width = metrics.width;\n      const height = Math.ceil(metrics.height);\n      const textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);\n      if (positionY >= textureHeight - height * resolution) {\n        if (positionY === 0) {\n          throw new Error(`[BitmapFont] textureHeight ${textureHeight}px is too small (fontFamily: \'${style.fontFamily}\', fontSize: ${style.fontSize}px, char: \'${character}\')`);\n        }\n        --i;\n        canvas = null;\n        context = null;\n        baseTexture = null;\n        positionY = 0;\n        positionX = 0;\n        maxCharHeight = 0;\n        continue;\n      }\n      maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);\n      if (textureGlyphWidth * resolution + positionX >= lineWidth) {\n        if (positionX === 0) {\n          throw new Error(`[BitmapFont] textureWidth ${textureWidth}px is too small (fontFamily: \'${style.fontFamily}\', fontSize: ${style.fontSize}px, char: \'${character}\')`);\n        }\n        --i;\n        positionY += maxCharHeight * resolution;\n        positionY = Math.ceil(positionY);\n        positionX = 0;\n        maxCharHeight = 0;\n        continue;\n      }\n      drawGlyph(canvas, context, metrics, positionX, positionY, resolution, style);\n      const id = extractCharCode(metrics.text);\n      fontData.char.push({\n        id,\n        page: textures.length - 1,\n        x: positionX / resolution,\n        y: positionY / resolution,\n        width: textureGlyphWidth,\n        height,\n        xoffset: 0,\n        yoffset: 0,\n        xadvance: width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0)\n      });\n      positionX += (textureGlyphWidth + 2 * padding) * resolution;\n      positionX = Math.ceil(positionX);\n    }\n    for (let i = 0, len = charsList.length; i < len; i++) {\n      const first = charsList[i];\n      for (let j = 0; j < len; j++) {\n        const second = charsList[j];\n        const c1 = context.measureText(first).width;\n        const c2 = context.measureText(second).width;\n        const total = context.measureText(first + second).width;\n        const amount = total - (c1 + c2);\n        if (amount) {\n          fontData.kerning.push({\n            first: extractCharCode(first),\n            second: extractCharCode(second),\n            amount\n          });\n        }\n      }\n    }\n    const font = new _BitmapFont(fontData, textures, true);\n    if (_BitmapFont.available[name] !== void 0) {\n      _BitmapFont.uninstall(name);\n    }\n    _BitmapFont.available[name] = font;\n    return font;\n  }\n};\nlet BitmapFont = _BitmapFont;\nBitmapFont.ALPHA = [["a", "z"], ["A", "Z"], " "];\nBitmapFont.NUMERIC = [["0", "9"]];\nBitmapFont.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];\nBitmapFont.ASCII = [[" ", "~"]];\nBitmapFont.defaultOptions = {\n  resolution: 1,\n  textureWidth: 512,\n  textureHeight: 512,\n  padding: 4,\n  chars: _BitmapFont.ALPHANUMERIC\n};\nBitmapFont.available = {};\n\n\n//# sourceMappingURL=BitmapFont.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/shader/msdf.mjs\nvar msdfFrag = "// Pixi texture info\\r\\nvarying vec2 vTextureCoord;\\r\\nuniform sampler2D uSampler;\\r\\n\\r\\n// Tint\\r\\nuniform vec4 uColor;\\r\\n\\r\\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\\r\\nuniform float uFWidth;\\r\\n\\r\\nvoid main(void) {\\r\\n\\r\\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\\r\\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\\r\\n\\r\\n  // MSDF\\r\\n  float median = texColor.r + texColor.g + texColor.b -\\r\\n                  min(texColor.r, min(texColor.g, texColor.b)) -\\r\\n                  max(texColor.r, max(texColor.g, texColor.b));\\r\\n  // SDF\\r\\n  median = min(median, texColor.a);\\r\\n\\r\\n  float screenPxDistance = uFWidth * (median - 0.5);\\r\\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\\r\\n  if (median < 0.01) {\\r\\n    alpha = 0.0;\\r\\n  } else if (median > 0.99) {\\r\\n    alpha = 1.0;\\r\\n  }\\r\\n\\r\\n  // Gamma correction for coverage-like alpha\\r\\n  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\\r\\n  float gamma = mix(1.0, 1.0 / 2.2, luma);\\r\\n  float coverage = pow(uColor.a * alpha, gamma);  \\r\\n\\r\\n  // NPM Textures, NPM outputs\\r\\n  gl_FragColor = vec4(uColor.rgb, coverage);\\r\\n}\\r\\n";\n\n\n//# sourceMappingURL=msdf.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/shader/msdf2.mjs\nvar msdfVert = "// Mesh material default fragment\\r\\nattribute vec2 aVertexPosition;\\r\\nattribute vec2 aTextureCoord;\\r\\n\\r\\nuniform mat3 projectionMatrix;\\r\\nuniform mat3 translationMatrix;\\r\\nuniform mat3 uTextureMatrix;\\r\\n\\r\\nvarying vec2 vTextureCoord;\\r\\n\\r\\nvoid main(void)\\r\\n{\\r\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\r\\n\\r\\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\\r\\n}\\r\\n";\n\n\n//# sourceMappingURL=msdf2.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/BitmapText.mjs\n\n\n\n\n\n\n\n\n\n\nconst pageMeshDataDefaultPageMeshData = [];\nconst pageMeshDataMSDFPageMeshData = [];\nconst charRenderDataPool = [];\nconst _BitmapText = class extends Container_Container {\n  constructor(text, style = {}) {\n    super();\n    const { align, tint, maxWidth, letterSpacing, fontName, fontSize } = Object.assign({}, _BitmapText.styleDefaults, style);\n    if (!BitmapFont.available[fontName]) {\n      throw new Error(`Missing BitmapFont "${fontName}"`);\n    }\n    this._activePagesMeshData = [];\n    this._textWidth = 0;\n    this._textHeight = 0;\n    this._align = align;\n    this._tintColor = new color_lib/* Color */.I(tint);\n    this._font = void 0;\n    this._fontName = fontName;\n    this._fontSize = fontSize;\n    this.text = text;\n    this._maxWidth = maxWidth;\n    this._maxLineHeight = 0;\n    this._letterSpacing = letterSpacing;\n    this._anchor = new ObservablePoint(() => {\n      this.dirty = true;\n    }, this, 0, 0);\n    this._roundPixels = settings_lib/* settings */.Xd.ROUND_PIXELS;\n    this.dirty = true;\n    this._resolution = settings_lib/* settings */.Xd.RESOLUTION;\n    this._autoResolution = true;\n    this._textureCache = {};\n  }\n  updateText() {\n    const data = BitmapFont.available[this._fontName];\n    const fontSize = this.fontSize;\n    const scale = fontSize / data.size;\n    const pos = new Point();\n    const chars = [];\n    const lineWidths = [];\n    const lineSpaces = [];\n    const text = this._text.replace(/(?:\\r\\n|\\r)/g, "\\n") || " ";\n    const charsInput = splitTextToCharacters(text);\n    const maxWidth = this._maxWidth * data.size / fontSize;\n    const pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n    let prevCharCode = null;\n    let lastLineWidth = 0;\n    let maxLineWidth = 0;\n    let line = 0;\n    let lastBreakPos = -1;\n    let lastBreakWidth = 0;\n    let spacesRemoved = 0;\n    let maxLineHeight = 0;\n    let spaceCount = 0;\n    for (let i = 0; i < charsInput.length; i++) {\n      const char = charsInput[i];\n      const charCode = extractCharCode(char);\n      if (/(?:\\s)/.test(char)) {\n        lastBreakPos = i;\n        lastBreakWidth = lastLineWidth;\n        spaceCount++;\n      }\n      if (char === "\\r" || char === "\\n") {\n        lineWidths.push(lastLineWidth);\n        lineSpaces.push(-1);\n        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n        ++line;\n        ++spacesRemoved;\n        pos.x = 0;\n        pos.y += data.lineHeight;\n        prevCharCode = null;\n        spaceCount = 0;\n        continue;\n      }\n      const charData = data.chars[charCode];\n      if (!charData) {\n        continue;\n      }\n      if (prevCharCode && charData.kerning[prevCharCode]) {\n        pos.x += charData.kerning[prevCharCode];\n      }\n      const charRenderData = charRenderDataPool.pop() || {\n        texture: Texture_Texture.EMPTY,\n        line: 0,\n        charCode: 0,\n        prevSpaces: 0,\n        position: new Point()\n      };\n      charRenderData.texture = charData.texture;\n      charRenderData.line = line;\n      charRenderData.charCode = charCode;\n      charRenderData.position.x = Math.round(pos.x + charData.xOffset + this._letterSpacing / 2);\n      charRenderData.position.y = Math.round(pos.y + charData.yOffset);\n      charRenderData.prevSpaces = spaceCount;\n      chars.push(charRenderData);\n      lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width);\n      pos.x += charData.xAdvance + this._letterSpacing;\n      maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);\n      prevCharCode = charCode;\n      if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {\n        ++spacesRemoved;\n        utils_lib.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);\n        i = lastBreakPos;\n        lastBreakPos = -1;\n        lineWidths.push(lastBreakWidth);\n        lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);\n        maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);\n        line++;\n        pos.x = 0;\n        pos.y += data.lineHeight;\n        prevCharCode = null;\n        spaceCount = 0;\n      }\n    }\n    const lastChar = charsInput[charsInput.length - 1];\n    if (lastChar !== "\\r" && lastChar !== "\\n") {\n      if (/(?:\\s)/.test(lastChar)) {\n        lastLineWidth = lastBreakWidth;\n      }\n      lineWidths.push(lastLineWidth);\n      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n      lineSpaces.push(-1);\n    }\n    const lineAlignOffsets = [];\n    for (let i = 0; i <= line; i++) {\n      let alignOffset = 0;\n      if (this._align === "right") {\n        alignOffset = maxLineWidth - lineWidths[i];\n      } else if (this._align === "center") {\n        alignOffset = (maxLineWidth - lineWidths[i]) / 2;\n      } else if (this._align === "justify") {\n        alignOffset = lineSpaces[i] < 0 ? 0 : (maxLineWidth - lineWidths[i]) / lineSpaces[i];\n      }\n      lineAlignOffsets.push(alignOffset);\n    }\n    const lenChars = chars.length;\n    const pagesMeshData = {};\n    const newPagesMeshData = [];\n    const activePagesMeshData = this._activePagesMeshData;\n    pageMeshDataPool.push(...activePagesMeshData);\n    for (let i = 0; i < lenChars; i++) {\n      const texture = chars[i].texture;\n      const baseTextureUid = texture.baseTexture.uid;\n      if (!pagesMeshData[baseTextureUid]) {\n        let pageMeshData = pageMeshDataPool.pop();\n        if (!pageMeshData) {\n          const geometry = new MeshGeometry_MeshGeometry();\n          let material;\n          let meshBlendMode;\n          if (data.distanceFieldType === "none") {\n            material = new MeshMaterial_MeshMaterial(Texture_Texture.EMPTY);\n            meshBlendMode = lib/* BLEND_MODES */.T$.NORMAL;\n          } else {\n            material = new MeshMaterial_MeshMaterial(Texture_Texture.EMPTY, { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } });\n            meshBlendMode = lib/* BLEND_MODES */.T$.NORMAL_NPM;\n          }\n          const mesh = new Mesh_Mesh(geometry, material);\n          mesh.blendMode = meshBlendMode;\n          pageMeshData = {\n            index: 0,\n            indexCount: 0,\n            vertexCount: 0,\n            uvsCount: 0,\n            total: 0,\n            mesh,\n            vertices: null,\n            uvs: null,\n            indices: null\n          };\n        }\n        pageMeshData.index = 0;\n        pageMeshData.indexCount = 0;\n        pageMeshData.vertexCount = 0;\n        pageMeshData.uvsCount = 0;\n        pageMeshData.total = 0;\n        const { _textureCache } = this;\n        _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture_Texture(texture.baseTexture);\n        pageMeshData.mesh.texture = _textureCache[baseTextureUid];\n        pageMeshData.mesh.tint = this._tintColor.value;\n        newPagesMeshData.push(pageMeshData);\n        pagesMeshData[baseTextureUid] = pageMeshData;\n      }\n      pagesMeshData[baseTextureUid].total++;\n    }\n    for (let i = 0; i < activePagesMeshData.length; i++) {\n      if (!newPagesMeshData.includes(activePagesMeshData[i])) {\n        this.removeChild(activePagesMeshData[i].mesh);\n      }\n    }\n    for (let i = 0; i < newPagesMeshData.length; i++) {\n      if (newPagesMeshData[i].mesh.parent !== this) {\n        this.addChild(newPagesMeshData[i].mesh);\n      }\n    }\n    this._activePagesMeshData = newPagesMeshData;\n    for (const i in pagesMeshData) {\n      const pageMeshData = pagesMeshData[i];\n      const total = pageMeshData.total;\n      if (!(pageMeshData.indices?.length > 6 * total) || pageMeshData.vertices.length < Mesh_Mesh.BATCHABLE_SIZE * 2) {\n        pageMeshData.vertices = new Float32Array(4 * 2 * total);\n        pageMeshData.uvs = new Float32Array(4 * 2 * total);\n        pageMeshData.indices = new Uint16Array(6 * total);\n      } else {\n        const total2 = pageMeshData.total;\n        const vertices = pageMeshData.vertices;\n        for (let i2 = total2 * 4 * 2; i2 < vertices.length; i2++) {\n          vertices[i2] = 0;\n        }\n      }\n      pageMeshData.mesh.size = 6 * total;\n    }\n    for (let i = 0; i < lenChars; i++) {\n      const char = chars[i];\n      let offset = char.position.x + lineAlignOffsets[char.line] * (this._align === "justify" ? char.prevSpaces : 1);\n      if (this._roundPixels) {\n        offset = Math.round(offset);\n      }\n      const xPos = offset * scale;\n      const yPos = char.position.y * scale;\n      const texture = char.texture;\n      const pageMesh = pagesMeshData[texture.baseTexture.uid];\n      const textureFrame = texture.frame;\n      const textureUvs = texture._uvs;\n      const index = pageMesh.index++;\n      pageMesh.indices[index * 6 + 0] = 0 + index * 4;\n      pageMesh.indices[index * 6 + 1] = 1 + index * 4;\n      pageMesh.indices[index * 6 + 2] = 2 + index * 4;\n      pageMesh.indices[index * 6 + 3] = 0 + index * 4;\n      pageMesh.indices[index * 6 + 4] = 2 + index * 4;\n      pageMesh.indices[index * 6 + 5] = 3 + index * 4;\n      pageMesh.vertices[index * 8 + 0] = xPos;\n      pageMesh.vertices[index * 8 + 1] = yPos;\n      pageMesh.vertices[index * 8 + 2] = xPos + textureFrame.width * scale;\n      pageMesh.vertices[index * 8 + 3] = yPos;\n      pageMesh.vertices[index * 8 + 4] = xPos + textureFrame.width * scale;\n      pageMesh.vertices[index * 8 + 5] = yPos + textureFrame.height * scale;\n      pageMesh.vertices[index * 8 + 6] = xPos;\n      pageMesh.vertices[index * 8 + 7] = yPos + textureFrame.height * scale;\n      pageMesh.uvs[index * 8 + 0] = textureUvs.x0;\n      pageMesh.uvs[index * 8 + 1] = textureUvs.y0;\n      pageMesh.uvs[index * 8 + 2] = textureUvs.x1;\n      pageMesh.uvs[index * 8 + 3] = textureUvs.y1;\n      pageMesh.uvs[index * 8 + 4] = textureUvs.x2;\n      pageMesh.uvs[index * 8 + 5] = textureUvs.y2;\n      pageMesh.uvs[index * 8 + 6] = textureUvs.x3;\n      pageMesh.uvs[index * 8 + 7] = textureUvs.y3;\n    }\n    this._textWidth = maxLineWidth * scale;\n    this._textHeight = (pos.y + data.lineHeight) * scale;\n    for (const i in pagesMeshData) {\n      const pageMeshData = pagesMeshData[i];\n      if (this.anchor.x !== 0 || this.anchor.y !== 0) {\n        let vertexCount = 0;\n        const anchorOffsetX = this._textWidth * this.anchor.x;\n        const anchorOffsetY = this._textHeight * this.anchor.y;\n        for (let i2 = 0; i2 < pageMeshData.total; i2++) {\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n        }\n      }\n      this._maxLineHeight = maxLineHeight * scale;\n      const vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition");\n      const textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord");\n      const indexBuffer = pageMeshData.mesh.geometry.getIndex();\n      vertexBuffer.data = pageMeshData.vertices;\n      textureBuffer.data = pageMeshData.uvs;\n      indexBuffer.data = pageMeshData.indices;\n      vertexBuffer.update();\n      textureBuffer.update();\n      indexBuffer.update();\n    }\n    for (let i = 0; i < chars.length; i++) {\n      charRenderDataPool.push(chars[i]);\n    }\n    this._font = data;\n    this.dirty = false;\n  }\n  updateTransform() {\n    this.validate();\n    this.containerUpdateTransform();\n  }\n  _render(renderer) {\n    if (this._autoResolution && this._resolution !== renderer.resolution) {\n      this._resolution = renderer.resolution;\n      this.dirty = true;\n    }\n    const { distanceFieldRange, distanceFieldType, size } = BitmapFont.available[this._fontName];\n    if (distanceFieldType !== "none") {\n      const { a, b, c, d } = this.worldTransform;\n      const dx = Math.sqrt(a * a + b * b);\n      const dy = Math.sqrt(c * c + d * d);\n      const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n      const fontScale = this.fontSize / size;\n      const resolution = renderer._view.resolution;\n      for (const mesh of this._activePagesMeshData) {\n        mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;\n      }\n    }\n    super._render(renderer);\n  }\n  getLocalBounds() {\n    this.validate();\n    return super.getLocalBounds();\n  }\n  validate() {\n    const font = BitmapFont.available[this._fontName];\n    if (!font) {\n      throw new Error(`Missing BitmapFont "${this._fontName}"`);\n    }\n    if (this._font !== font) {\n      this.dirty = true;\n    }\n    if (this.dirty) {\n      this.updateText();\n    }\n  }\n  get tint() {\n    return this._tintColor.value;\n  }\n  set tint(value) {\n    if (this.tint === value)\n      return;\n    this._tintColor.setValue(value);\n    for (let i = 0; i < this._activePagesMeshData.length; i++) {\n      this._activePagesMeshData[i].mesh.tint = value;\n    }\n  }\n  get align() {\n    return this._align;\n  }\n  set align(value) {\n    if (this._align !== value) {\n      this._align = value;\n      this.dirty = true;\n    }\n  }\n  get fontName() {\n    return this._fontName;\n  }\n  set fontName(value) {\n    if (!BitmapFont.available[value]) {\n      throw new Error(`Missing BitmapFont "${value}"`);\n    }\n    if (this._fontName !== value) {\n      this._fontName = value;\n      this.dirty = true;\n    }\n  }\n  get fontSize() {\n    return this._fontSize ?? BitmapFont.available[this._fontName].size;\n  }\n  set fontSize(value) {\n    if (this._fontSize !== value) {\n      this._fontSize = value;\n      this.dirty = true;\n    }\n  }\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    if (typeof value === "number") {\n      this._anchor.set(value);\n    } else {\n      this._anchor.copyFrom(value);\n    }\n  }\n  get text() {\n    return this._text;\n  }\n  set text(text) {\n    text = String(text === null || text === void 0 ? "" : text);\n    if (this._text === text) {\n      return;\n    }\n    this._text = text;\n    this.dirty = true;\n  }\n  get maxWidth() {\n    return this._maxWidth;\n  }\n  set maxWidth(value) {\n    if (this._maxWidth === value) {\n      return;\n    }\n    this._maxWidth = value;\n    this.dirty = true;\n  }\n  get maxLineHeight() {\n    this.validate();\n    return this._maxLineHeight;\n  }\n  get textWidth() {\n    this.validate();\n    return this._textWidth;\n  }\n  get letterSpacing() {\n    return this._letterSpacing;\n  }\n  set letterSpacing(value) {\n    if (this._letterSpacing !== value) {\n      this._letterSpacing = value;\n      this.dirty = true;\n    }\n  }\n  get roundPixels() {\n    return this._roundPixels;\n  }\n  set roundPixels(value) {\n    if (value !== this._roundPixels) {\n      this._roundPixels = value;\n      this.dirty = true;\n    }\n  }\n  get textHeight() {\n    this.validate();\n    return this._textHeight;\n  }\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(value) {\n    this._autoResolution = false;\n    if (this._resolution === value) {\n      return;\n    }\n    this._resolution = value;\n    this.dirty = true;\n  }\n  destroy(options) {\n    const { _textureCache } = this;\n    const data = BitmapFont.available[this._fontName];\n    const pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n    pageMeshDataPool.push(...this._activePagesMeshData);\n    for (const pageMeshData of this._activePagesMeshData) {\n      this.removeChild(pageMeshData.mesh);\n    }\n    this._activePagesMeshData = [];\n    pageMeshDataPool.filter((page) => _textureCache[page.mesh.texture.baseTexture.uid]).forEach((page) => {\n      page.mesh.texture = Texture_Texture.EMPTY;\n    });\n    for (const id in _textureCache) {\n      const texture = _textureCache[id];\n      texture.destroy();\n      delete _textureCache[id];\n    }\n    this._font = null;\n    this._tintColor = null;\n    this._textureCache = null;\n    super.destroy(options);\n  }\n};\nlet BitmapText = _BitmapText;\nBitmapText.styleDefaults = {\n  align: "left",\n  tint: 16777215,\n  maxWidth: 0,\n  letterSpacing: 0\n};\n\n\n//# sourceMappingURL=BitmapText.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/loadBitmapFont.mjs\n\n\n\n\n\n\n\nconst validExtensions = [".xml", ".fnt"];\nconst loadBitmapFont = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Normal\n  },\n  name: "loadBitmapFont",\n  test(url) {\n    return validExtensions.includes(utils_lib.path.extname(url).toLowerCase());\n  },\n  async testParse(data) {\n    return TextFormat.test(data) || XMLStringFormat.test(data);\n  },\n  async parse(asset, data, loader) {\n    const fontData = TextFormat.test(asset) ? TextFormat.parse(asset) : XMLStringFormat.parse(asset);\n    const { src } = data;\n    const { page: pages } = fontData;\n    const textureUrls = [];\n    for (let i = 0; i < pages.length; ++i) {\n      const pageFile = pages[i].file;\n      let imagePath = utils_lib.path.join(utils_lib.path.dirname(src), pageFile);\n      imagePath = copySearchParams(imagePath, src);\n      textureUrls.push(imagePath);\n    }\n    const loadedTextures = await loader.load(textureUrls);\n    const textures = textureUrls.map((url) => loadedTextures[url]);\n    return BitmapFont.install(fontData, textures, true);\n  },\n  async load(url, _options) {\n    const response = await settings_lib/* settings */.Xd.ADAPTER.fetch(url);\n    return response.text();\n  },\n  unload(bitmapFont) {\n    bitmapFont.destroy();\n  }\n};\nextensions.add(loadBitmapFont);\n\n\n//# sourceMappingURL=loadBitmapFont.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-bitmap/lib/index.mjs\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-html/lib/HTMLTextStyle.mjs\n\n\n\nconst _HTMLTextStyle = class extends TextStyle {\n  constructor() {\n    super(...arguments);\n    this._fonts = [];\n    this._overrides = [];\n    this._stylesheet = "";\n    this.fontsDirty = false;\n  }\n  static from(originalStyle) {\n    return new _HTMLTextStyle(Object.keys(_HTMLTextStyle.defaultOptions).reduce((obj, prop) => ({ ...obj, [prop]: originalStyle[prop] }), {}));\n  }\n  cleanFonts() {\n    if (this._fonts.length > 0) {\n      this._fonts.forEach((font) => {\n        URL.revokeObjectURL(font.src);\n        font.refs--;\n        if (font.refs === 0) {\n          if (font.fontFace) {\n            document.fonts.delete(font.fontFace);\n          }\n          delete _HTMLTextStyle.availableFonts[font.originalUrl];\n        }\n      });\n      this.fontFamily = "Arial";\n      this._fonts.length = 0;\n      this.styleID++;\n      this.fontsDirty = true;\n    }\n  }\n  loadFont(url, options = {}) {\n    const { availableFonts } = _HTMLTextStyle;\n    if (availableFonts[url]) {\n      const font = availableFonts[url];\n      this._fonts.push(font);\n      font.refs++;\n      this.styleID++;\n      this.fontsDirty = true;\n      return Promise.resolve();\n    }\n    return settings_lib/* settings */.Xd.ADAPTER.fetch(url).then((response) => response.blob()).then(async (blob) => new Promise((resolve, reject) => {\n      const src = URL.createObjectURL(blob);\n      const reader = new FileReader();\n      reader.onload = () => resolve([src, reader.result]);\n      reader.onerror = reject;\n      reader.readAsDataURL(blob);\n    })).then(async ([src, dataSrc]) => {\n      const font = Object.assign({\n        family: utils_lib.path.basename(url, utils_lib.path.extname(url)),\n        weight: "normal",\n        style: "normal",\n        src,\n        dataSrc,\n        refs: 1,\n        originalUrl: url,\n        fontFace: null\n      }, options);\n      availableFonts[url] = font;\n      this._fonts.push(font);\n      this.styleID++;\n      const fontFace = new FontFace(font.family, `url(${font.src})`, {\n        weight: font.weight,\n        style: font.style\n      });\n      font.fontFace = fontFace;\n      await fontFace.load();\n      document.fonts.add(fontFace);\n      await document.fonts.ready;\n      this.styleID++;\n      this.fontsDirty = true;\n    });\n  }\n  addOverride(...value) {\n    const toAdd = value.filter((v) => !this._overrides.includes(v));\n    if (toAdd.length > 0) {\n      this._overrides.push(...toAdd);\n      this.styleID++;\n    }\n  }\n  removeOverride(...value) {\n    const toRemove = value.filter((v) => this._overrides.includes(v));\n    if (toRemove.length > 0) {\n      this._overrides = this._overrides.filter((v) => !toRemove.includes(v));\n      this.styleID++;\n    }\n  }\n  toCSS(scale) {\n    return [\n      `transform: scale(${scale})`,\n      `transform-origin: top left`,\n      "display: inline-block",\n      `color: ${this.normalizeColor(this.fill)}`,\n      `font-size: ${this.fontSize}px`,\n      `font-family: ${this.fontFamily}`,\n      `font-weight: ${this.fontWeight}`,\n      `font-style: ${this.fontStyle}`,\n      `font-variant: ${this.fontVariant}`,\n      `letter-spacing: ${this.letterSpacing}px`,\n      `text-align: ${this.align}`,\n      `padding: ${this.padding}px`,\n      `white-space: ${this.whiteSpace}`,\n      ...this.lineHeight ? [`line-height: ${this.lineHeight}px`] : [],\n      ...this.wordWrap ? [\n        `word-wrap: ${this.breakWords ? "break-all" : "break-word"}`,\n        `max-width: ${this.wordWrapWidth}px`\n      ] : [],\n      ...this.strokeThickness ? [\n        `-webkit-text-stroke-width: ${this.strokeThickness}px`,\n        `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`,\n        `text-stroke-width: ${this.strokeThickness}px`,\n        `text-stroke-color: ${this.normalizeColor(this.stroke)}`,\n        "paint-order: stroke"\n      ] : [],\n      ...this.dropShadow ? [this.dropShadowToCSS()] : [],\n      ...this._overrides\n    ].join(";");\n  }\n  toGlobalCSS() {\n    return this._fonts.reduce((result, font) => `${result}\n            @font-face {\n                font-family: "${font.family}";\n                src: url(\'${font.dataSrc}\');\n                font-weight: ${font.weight};\n                font-style: ${font.style}; \n            }`, this._stylesheet);\n  }\n  get stylesheet() {\n    return this._stylesheet;\n  }\n  set stylesheet(value) {\n    if (this._stylesheet !== value) {\n      this._stylesheet = value;\n      this.styleID++;\n    }\n  }\n  normalizeColor(color) {\n    if (Array.isArray(color)) {\n      color = utils_lib.rgb2hex(color);\n    }\n    if (typeof color === "number") {\n      return utils_lib.hex2string(color);\n    }\n    return color;\n  }\n  dropShadowToCSS() {\n    let color = this.normalizeColor(this.dropShadowColor);\n    const alpha = this.dropShadowAlpha;\n    const x = Math.round(Math.cos(this.dropShadowAngle) * this.dropShadowDistance);\n    const y = Math.round(Math.sin(this.dropShadowAngle) * this.dropShadowDistance);\n    if (color.startsWith("#") && alpha < 1) {\n      color += (alpha * 255 | 0).toString(16).padStart(2, "0");\n    }\n    const position = `${x}px ${y}px`;\n    if (this.dropShadowBlur > 0) {\n      return `text-shadow: ${position} ${this.dropShadowBlur}px ${color}`;\n    }\n    return `text-shadow: ${position} ${color}`;\n  }\n  reset() {\n    Object.assign(this, _HTMLTextStyle.defaultOptions);\n  }\n  onBeforeDraw() {\n    const { fontsDirty: prevFontsDirty } = this;\n    this.fontsDirty = false;\n    if (this.isSafari && this._fonts.length > 0 && prevFontsDirty) {\n      return new Promise((resolve) => setTimeout(resolve, 100));\n    }\n    return Promise.resolve();\n  }\n  get isSafari() {\n    const { userAgent } = settings_lib/* settings */.Xd.ADAPTER.getNavigator();\n    return /^((?!chrome|android).)*safari/i.test(userAgent);\n  }\n  set fillGradientStops(_value) {\n    console.warn("[HTMLTextStyle] fillGradientStops is not supported by HTMLText");\n  }\n  get fillGradientStops() {\n    return super.fillGradientStops;\n  }\n  set fillGradientType(_value) {\n    console.warn("[HTMLTextStyle] fillGradientType is not supported by HTMLText");\n  }\n  get fillGradientType() {\n    return super.fillGradientType;\n  }\n  set miterLimit(_value) {\n    console.warn("[HTMLTextStyle] miterLimit is not supported by HTMLText");\n  }\n  get miterLimit() {\n    return super.miterLimit;\n  }\n  set trim(_value) {\n    console.warn("[HTMLTextStyle] trim is not supported by HTMLText");\n  }\n  get trim() {\n    return super.trim;\n  }\n  set textBaseline(_value) {\n    console.warn("[HTMLTextStyle] textBaseline is not supported by HTMLText");\n  }\n  get textBaseline() {\n    return super.textBaseline;\n  }\n  set leading(_value) {\n    console.warn("[HTMLTextStyle] leading is not supported by HTMLText");\n  }\n  get leading() {\n    return super.leading;\n  }\n  set lineJoin(_value) {\n    console.warn("[HTMLTextStyle] lineJoin is not supported by HTMLText");\n  }\n  get lineJoin() {\n    return super.lineJoin;\n  }\n};\nlet HTMLTextStyle = _HTMLTextStyle;\nHTMLTextStyle.availableFonts = {};\nHTMLTextStyle.defaultOptions = {\n  align: "left",\n  breakWords: false,\n  dropShadow: false,\n  dropShadowAlpha: 1,\n  dropShadowAngle: Math.PI / 6,\n  dropShadowBlur: 0,\n  dropShadowColor: "black",\n  dropShadowDistance: 5,\n  fill: "black",\n  fontFamily: "Arial",\n  fontSize: 26,\n  fontStyle: "normal",\n  fontVariant: "normal",\n  fontWeight: "normal",\n  letterSpacing: 0,\n  lineHeight: 0,\n  padding: 0,\n  stroke: "black",\n  strokeThickness: 0,\n  whiteSpace: "normal",\n  wordWrap: false,\n  wordWrapWidth: 100\n};\n\n\n//# sourceMappingURL=HTMLTextStyle.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-html/lib/HTMLText.mjs\n\n\n\n\n\nconst _HTMLText = class extends Sprite_Sprite {\n  constructor(text = "", style = {}) {\n    super(Texture_Texture.EMPTY);\n    this._text = null;\n    this._style = null;\n    this._autoResolution = true;\n    this._loading = false;\n    this.localStyleID = -1;\n    this.dirty = false;\n    this.ownsStyle = false;\n    const image = new Image();\n    const texture = Texture_Texture.from(image, {\n      scaleMode: settings_lib/* settings */.Xd.SCALE_MODE,\n      resourceOptions: {\n        autoLoad: false\n      }\n    });\n    texture.orig = new Rectangle_Rectangle();\n    texture.trim = new Rectangle_Rectangle();\n    this.texture = texture;\n    const nssvg = "http://www.w3.org/2000/svg";\n    const nsxhtml = "http://www.w3.org/1999/xhtml";\n    const svgRoot = document.createElementNS(nssvg, "svg");\n    const foreignObject = document.createElementNS(nssvg, "foreignObject");\n    const domElement = document.createElementNS(nsxhtml, "div");\n    const styleElement = document.createElementNS(nsxhtml, "style");\n    foreignObject.setAttribute("width", "10000");\n    foreignObject.setAttribute("height", "10000");\n    foreignObject.style.overflow = "hidden";\n    svgRoot.appendChild(foreignObject);\n    this.maxWidth = _HTMLText.defaultMaxWidth;\n    this.maxHeight = _HTMLText.defaultMaxHeight;\n    this._domElement = domElement;\n    this._styleElement = styleElement;\n    this._svgRoot = svgRoot;\n    this._foreignObject = foreignObject;\n    this._foreignObject.appendChild(styleElement);\n    this._foreignObject.appendChild(domElement);\n    this._image = image;\n    this._loadImage = new Image();\n    this._autoResolution = _HTMLText.defaultAutoResolution;\n    this._resolution = _HTMLText.defaultResolution ?? settings_lib/* settings */.Xd.RESOLUTION;\n    this.text = text;\n    this.style = style;\n  }\n  measureText(overrides) {\n    const { text, style, resolution } = Object.assign({\n      text: this._text,\n      style: this._style,\n      resolution: this._resolution\n    }, overrides);\n    Object.assign(this._domElement, {\n      innerHTML: text,\n      style: style.toCSS(resolution)\n    });\n    this._styleElement.textContent = style.toGlobalCSS();\n    document.body.appendChild(this._svgRoot);\n    const contentBounds = this._domElement.getBoundingClientRect();\n    this._svgRoot.remove();\n    const contentWidth = Math.min(this.maxWidth, Math.ceil(contentBounds.width));\n    const contentHeight = Math.min(this.maxHeight, Math.ceil(contentBounds.height));\n    this._svgRoot.setAttribute("width", contentWidth.toString());\n    this._svgRoot.setAttribute("height", contentHeight.toString());\n    if (text !== this._text) {\n      this._domElement.innerHTML = this._text;\n    }\n    if (style !== this._style) {\n      Object.assign(this._domElement, { style: this._style?.toCSS(resolution) });\n      this._styleElement.textContent = this._style?.toGlobalCSS();\n    }\n    return {\n      width: contentWidth + style.padding * 2,\n      height: contentHeight + style.padding * 2\n    };\n  }\n  async updateText(respectDirty = true) {\n    const { style, _image: image, _loadImage: loadImage } = this;\n    if (this.localStyleID !== style.styleID) {\n      this.dirty = true;\n      this.localStyleID = style.styleID;\n    }\n    if (!this.dirty && respectDirty) {\n      return;\n    }\n    const { width, height } = this.measureText();\n    image.width = loadImage.width = Math.ceil(Math.max(1, width));\n    image.height = loadImage.height = Math.ceil(Math.max(1, height));\n    if (!this._loading) {\n      this._loading = true;\n      await new Promise((resolve) => {\n        loadImage.onload = async () => {\n          await style.onBeforeDraw();\n          this._loading = false;\n          image.src = loadImage.src;\n          loadImage.onload = null;\n          loadImage.src = "";\n          this.updateTexture();\n          resolve();\n        };\n        const svgURL = new XMLSerializer().serializeToString(this._svgRoot);\n        loadImage.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(svgURL)}`;\n      });\n    }\n  }\n  get source() {\n    return this._image;\n  }\n  updateTexture() {\n    const { style, texture, _image: image, resolution } = this;\n    const { padding } = style;\n    const { baseTexture } = texture;\n    texture.trim.width = texture._frame.width = image.width / resolution;\n    texture.trim.height = texture._frame.height = image.height / resolution;\n    texture.trim.x = -padding;\n    texture.trim.y = -padding;\n    texture.orig.width = texture._frame.width - padding * 2;\n    texture.orig.height = texture._frame.height - padding * 2;\n    this._onTextureUpdate();\n    baseTexture.setRealSize(image.width, image.height, resolution);\n    this.dirty = false;\n  }\n  _render(renderer) {\n    if (this._autoResolution && this._resolution !== renderer.resolution) {\n      this._resolution = renderer.resolution;\n      this.dirty = true;\n    }\n    this.updateText(true);\n    super._render(renderer);\n  }\n  _renderCanvas(renderer) {\n    if (this._autoResolution && this._resolution !== renderer.resolution) {\n      this._resolution = renderer.resolution;\n      this.dirty = true;\n    }\n    this.updateText(true);\n    super._renderCanvas(renderer);\n  }\n  getLocalBounds(rect) {\n    this.updateText(true);\n    return super.getLocalBounds(rect);\n  }\n  _calculateBounds() {\n    this.updateText(true);\n    this.calculateVertices();\n    this._bounds.addQuad(this.vertexData);\n  }\n  _onStyleChange() {\n    this.dirty = true;\n  }\n  destroy(options) {\n    if (typeof options === "boolean") {\n      options = { children: options };\n    }\n    options = Object.assign({}, _HTMLText.defaultDestroyOptions, options);\n    super.destroy(options);\n    const forceClear = null;\n    if (this.ownsStyle) {\n      this._style?.cleanFonts();\n    }\n    this._style = forceClear;\n    this._svgRoot?.remove();\n    this._svgRoot = forceClear;\n    this._domElement?.remove();\n    this._domElement = forceClear;\n    this._foreignObject?.remove();\n    this._foreignObject = forceClear;\n    this._styleElement?.remove();\n    this._styleElement = forceClear;\n    this._loadImage.src = "";\n    this._loadImage.onload = null;\n    this._loadImage = forceClear;\n    this._image.src = "";\n    this._image = forceClear;\n  }\n  get width() {\n    this.updateText(true);\n    return Math.abs(this.scale.x) * this._image.width / this.resolution;\n  }\n  set width(value) {\n    this.updateText(true);\n    const s = utils_lib.sign(this.scale.x) || 1;\n    this.scale.x = s * value / this._image.width / this.resolution;\n    this._width = value;\n  }\n  get height() {\n    this.updateText(true);\n    return Math.abs(this.scale.y) * this._image.height / this.resolution;\n  }\n  set height(value) {\n    this.updateText(true);\n    const s = utils_lib.sign(this.scale.y) || 1;\n    this.scale.y = s * value / this._image.height / this.resolution;\n    this._height = value;\n  }\n  get style() {\n    return this._style;\n  }\n  set style(style) {\n    if (this._style === style) {\n      return;\n    }\n    style = style || {};\n    if (style instanceof HTMLTextStyle) {\n      this.ownsStyle = false;\n      this._style = style;\n    } else if (style instanceof TextStyle) {\n      console.warn("[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle");\n      this.ownsStyle = true;\n      this._style = HTMLTextStyle.from(style);\n    } else {\n      this.ownsStyle = true;\n      this._style = new HTMLTextStyle(style);\n    }\n    this.localStyleID = -1;\n    this.dirty = true;\n  }\n  get text() {\n    return this._text;\n  }\n  set text(text) {\n    text = String(text === "" || text === null || text === void 0 ? " " : text);\n    text = this.sanitiseText(text);\n    if (this._text === text) {\n      return;\n    }\n    this._text = text;\n    this.dirty = true;\n  }\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(value) {\n    this._autoResolution = false;\n    if (this._resolution === value) {\n      return;\n    }\n    this._resolution = value;\n    this.dirty = true;\n  }\n  sanitiseText(text) {\n    return text.replace(/<br>/gi, "<br/>").replace(/<hr>/gi, "<hr/>").replace(/&nbsp;/gi, "&#160;");\n  }\n};\nlet HTMLText = _HTMLText;\nHTMLText.defaultDestroyOptions = {\n  texture: true,\n  children: false,\n  baseTexture: true\n};\nHTMLText.defaultMaxWidth = 2024;\nHTMLText.defaultMaxHeight = 2024;\nHTMLText.defaultAutoResolution = true;\n\n\n//# sourceMappingURL=HTMLText.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@pixi/text-html/lib/index.mjs\n\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/pixi.js/lib/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSTtBQUNyQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRLElBQUksUUFBUSxJQUFJLFFBQVEsSUFBSSxRQUFRLEtBQUssU0FBUyxLQUFLLFFBQVE7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFCQUFlO0FBQzdDLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0Esa0NBQWtDLHFCQUFlO0FBQ2pELGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGFBQU07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Q0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtCO0FBQ2xCOzs7QUM1T2lGO0FBQzNDOztBQUV0Qyw0QkFBNEIsc0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsTUFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE1BQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFVBQVU7QUFDL0M7QUFDQTtBQUNBLHNDQUFzQyxVQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpRDtBQUNqRDs7O0FDdFN1RDtBQUNIOztBQUVwRCxNQUFNLG9CQUFV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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsS0FBSztBQUNqQztBQUNBLHdGQUF3RixLQUFLO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0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T0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFlBQVk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxZQUFZO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxZQUFZO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsUUFBUTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBCO0FBQzFCOzs7QUNsSHFDO0FBQ3lCOztBQUU5RCx5QkFBeUIsb0RBQUk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0I7QUFDdEI7OztBQzFCd0M7QUFDUTtBQUNXOztBQUUzRCx5QkFBeUIsb0RBQUk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzQjtBQUN0Qjs7O0FDekI2RDtBQUNGO0FBQ0w7QUFDUjtBQUNFO0FBQ0Y7QUFDOUM7OztBQ05nRDtBQUNOOztBQUUxQyxnQ0FBZ0MseURBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkI7QUFDN0I7OztBQ25GNEQ7O0FBRTVEO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE1BQU0sQ0FBQywrQkFBMkI7QUFDN0Q7QUFDQTtBQUNBLG9CQUFvQixtQ0FBbUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQWtDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQyxvQkFBb0IsbUNBQW1DO0FBQ3ZEO0FBQ0EsNkZBQTZGLGlCQUFLO0FBQ2xHO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RDtBQUNBLDRGQUE0RixpQkFBSztBQUNqRztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUNBQW1DO0FBQ3ZEO0FBQ0EsOEVBQThFLGlCQUFLO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RDtBQUNBLDhFQUE4RSxpQkFBSztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEI7QUFDMUI7OztBQ3JHQSxJQUFJLGtCQUFRLCtCQUErQixzQkFBc0IsK0JBQStCLG9CQUFvQiwrREFBK0QsMkJBQTJCLEdBQUc7O0FBRWxMO0FBQy9COzs7QUNIQSxJQUFJLGlCQUFNLG1DQUFtQywrQkFBK0Isd0JBQXdCLGtDQUFrQyw0QkFBNEIsbUNBQW1DLHNCQUFzQiwrQkFBK0Isc0JBQXNCLG9CQUFvQiw0RkFBNEYsNEZBQTRGLDRCQUE0Qiw2QkFBNkIsNEVBQTRFLHNDQUFzQywrQkFBK0IsR0FBRzs7QUFFNW9CO0FBQzdCOzs7QUNIbUg7QUFDN0Q7QUFDZjtBQUNEOztBQUV0QywrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQU0sTUFBTSxpQkFBTSxFQUFFLGtCQUFRLElBQUk7QUFDbEQsaUJBQWlCLEtBQUs7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0JBQUs7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5Qix1QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQSxxQkFBcUIsc0JBQUs7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxhQUFhO0FBQ3JCO0FBQ0EsVUFBVTs7QUFFa0I7QUFDNUI7OztBQzVONEQ7QUFDRjtBQUMxRDs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjs7QUFFRztBQUN6Qjs7O0FDUHNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2QkFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pELHVDQUF1QyxjQUFjO0FBQ3JEO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUIsc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkMsc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2QkFBUTtBQUN6QixRQUFRO0FBQ1IsaUJBQWlCLDZCQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdUI7QUFDdkI7OztBQ2xZNEM7QUFDVDs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxjQUFjO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCLEVBQUUsa0JBQWtCLEVBQUUsaUJBQWlCLEVBQUUsZ0JBQWdCLEVBQUUsdUJBQXVCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBSztBQUNwQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFcUI7QUFDckI7OztBQ2xYd0U7QUFDbEM7QUFDTTtBQUNJO0FBQ0o7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxlQUFlLDZCQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQU87QUFDM0IsdUJBQXVCLG1CQUFTO0FBQ2hDLHVCQUF1QixtQkFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtEQUFrRCw2QkFBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0EsSUFBSSxxQkFBaUI7QUFDckIsSUFBSSxXQUFXO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzQkFBSztBQUNuQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVc7QUFDbkIsVUFBVSxXQUFXO0FBQ3JCLHdDQUF3QyxjQUFjO0FBQ3RELDRDQUE0QyxjQUFjO0FBQzFEO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsYUFBYTtBQUNoRDtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxjQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBLE1BQU07QUFDTix3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnQjtBQUNoQjs7O0FDdFc0QztBQUNWO0FBQ2M7QUFDSjtBQUM1Qzs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3QjtBQUN4Qjs7O0FDZDJFO0FBQ2pDO0FBQ2dCO0FBQ1I7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsdUNBQXVDLGVBQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxXQUFXO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxlQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixJQUFJO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0EsSUFBSSxXQUFXO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixJQUFJO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsYUFBTSxpQ0FBaUMscUJBQWU7QUFDaEU7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxTQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTSxhQUFNLGlDQUFpQyxxQkFBZTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBUztBQUNqQyw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sYUFBTTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1QjtBQUN2Qjs7O0FDbk02QztBQUNQO0FBQ1U7O0FBRWhELHdCQUF3Qiw2QkFBUTtBQUNoQztBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLEtBQUs7QUFDTDtBQUNBLE1BQU0scUJBQWlCO0FBQ3ZCLE1BQU0sV0FBVztBQUNqQjtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUNmb0U7QUFDMUI7QUFDTTs7QUFFaEQ7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCLGtCQUFrQixvQkFBb0I7QUFDdEMsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxhQUFhO0FBQ3JCO0FBQ0EsVUFBVTs7QUFFUztBQUNuQjs7O0FDdkR3QjtBQUN3QjtBQUNFO0FBQ1Y7QUFDUTtBQUNoRDs7O0FDTDhEO0FBQ3hCOztBQUV0Qyw2QkFBNkIsc0RBQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxNQUFNLDZDQUE2QyxpQkFBaUI7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwQjtBQUMxQjs7O0FDOUxzRDtBQUN0RDs7O0FDRGlGO0FBQzNDOztBQUV0QyxNQUFNLHNCQUFTLE9BQU8sS0FBSztBQUMzQiwyQkFBMkIsc0RBQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxzQkFBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNCQUFTLFlBQVksc0JBQVM7QUFDdEM7QUFDQSxVQUFVLHNCQUFTLFlBQVksc0JBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3QjtBQUN4Qjs7O0FDN0dBLHFHQUFxRywwQkFBMEIsMkJBQTJCLCtCQUErQixzQkFBc0IseUJBQXlCLDJCQUEyQiw0QkFBNEIsc0JBQXNCLHNFQUFzRSxnREFBZ0QsNkJBQTZCLDJEQUEyRCxzRkFBc0YsbUZBQW1GLEdBQUc7O0FBRTFvQjtBQUNyQzs7O0FDSEEsbUdBQW1HLDRCQUE0Qix3QkFBd0Isa0NBQWtDLGlDQUFpQywwQkFBMEIsMkJBQTJCLHNCQUFzQiwyR0FBMkcsbUVBQW1FLEdBQUc7O0FBRW5iO0FBQ25DOzs7QUNIQSwrTEFBK0wsK0JBQStCLCtCQUErQixzQkFBc0IseUJBQXlCLDJCQUEyQiw0QkFBNEIsc0JBQXNCLHNFQUFzRSxnREFBZ0QsNkJBQTZCLDJEQUEyRCxvTEFBb0wsaUVBQWlFLHNEQUFzRCxHQUFHOztBQUVoMUI7QUFDckM7OztBQ0hBLGdHQUFnRyxtQ0FBbUMsK0JBQStCLGtDQUFrQyxpQ0FBaUMsMEJBQTBCLCtCQUErQixzQkFBc0IsMkdBQTJHLG1FQUFtRSxHQUFHOztBQUVsYztBQUNuQzs7O0FDSEEsNEdBQTRHLCtCQUErQiwrQkFBK0Isc0JBQXNCLHNCQUFzQiwwREFBMEQsd0NBQXdDLEdBQUc7O0FBRW5SO0FBQ3hDOzs7QUNIZ0k7QUFDL0U7QUFDRDtBQUNVO0FBQ0Q7QUFDRTs7QUFFM0QsTUFBTSw0QkFBTyxPQUFPLE1BQU07QUFDMUIsbUNBQW1DLGNBQWM7QUFDakQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUIsaUJBQWlCLEtBQUs7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHdCQUF3QixNQUFNLE1BQU0sWUFBWSxFQUFFLGlCQUFpQjtBQUNuRSxzREFBc0QsTUFBTSxNQUFNLFlBQVksRUFBRSxjQUFjLGNBQWMsTUFBTSxNQUFNLFlBQVksRUFBRSxjQUFjO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHNCQUFVO0FBQzNDLDZCQUE2QixzQkFBVTtBQUN2QztBQUNBLFFBQVE7QUFDUix3Q0FBd0Msc0JBQVU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUFPO0FBQ1gsSUFBSSw0QkFBTztBQUNYO0FBQ0EsTUFBTSw0QkFBTztBQUNiLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw0QkFBTztBQUN4Qyw2QkFBNkIsc0JBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsYUFBYTtBQUNyQjtBQUNBLFVBQVU7O0FBRXNCO0FBQ2hDOzs7QUNwRmtEO0FBQ2dCO0FBQ2xFOzs7QUNGb0U7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxlQUFPO0FBQzlDLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIscUJBQXFCLDRCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBUztBQUNsQztBQUNBLHNCQUFzQixtQkFBUztBQUMvQixVQUFVO0FBQ1Ysc0JBQXNCLG1CQUFTO0FBQy9CO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQVM7QUFDOUI7QUFDQSwrQkFBK0IsZUFBTztBQUN0QyxRQUFRLGVBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlDQUFpQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1QjtBQUN2Qjs7O0FDcEhzRTtBQUNFO0FBQ3hCOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQkFBcUIsY0FBVTtBQUMvQjtBQUNBLDBDQUEwQyxTQUFTLEdBQUcsdUNBQXVDO0FBQzdGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0Esc0NBQXNDLFdBQVc7QUFDakQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZCQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QixnQkFBZ0Isb0JBQW9CO0FBQ3BDLEtBQUs7QUFDTDtBQUNBLGFBQWEsY0FBVTtBQUN2QixLQUFLO0FBQ0w7QUFDQSxxQkFBcUIsY0FBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRWtCO0FBQzVCOzs7QUNwR2dEO0FBQ1U7QUFDMUQ7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwQjtBQUMxQjs7O0FDWnVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFc0I7QUFDdEI7OztBQ3JFdUQ7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRXFCO0FBQ3JCOzs7QUNoRXNDO0FBQ007O0FBRTVDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUyxNQUFNLDZCQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTLE9BQU8sNkJBQVE7QUFDbkM7QUFDQTs7QUFFMkI7QUFDM0I7OztBQ2hCOEM7QUFDQTtBQUNGO0FBQ0E7QUFDWTtBQUNBOztBQUV4RDtBQUNBLEVBQUUsVUFBVTtBQUNaLEVBQUUsU0FBUztBQUNYLEVBQUUsZUFBZTtBQUNqQjtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTRCO0FBQzVCOzs7QUN0QjJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU2QjtBQUM3Qjs7O0FDbEVtQztBQUN5Qjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxQjtBQUNyQjs7O0FDMUM0QztBQUNZO0FBQ0k7QUFDQTtBQUNRO0FBQ3BFOzs7QUNMQTtBQUNBO0FBQ0E7O0FBRWlDO0FBQ2pDOzs7QUNMb0U7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsWUFBWTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsVUFBVTtBQUN2RDtBQUNBO0FBQ0EsTUFBTTtBQUNOLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZCO0FBQzdCOzs7QUNoQ0E7QUFDQTtBQUNBOztBQUUyQjtBQUMzQjs7O0FDTHlHO0FBQ3JEO0FBQ0U7QUFDQztBQUM1QjtBQUN1QztBQUNoQjtBQUNZOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQyxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBLGlEQUFpRCx1QkFBVztBQUM1RCw4Q0FBOEMsd0JBQVk7QUFDMUQ7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUMsY0FBYyxrQkFBa0I7QUFDaEMsWUFBWSxrREFBa0Q7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIscUJBQXFCLGVBQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QyxZQUFZLHdCQUF3QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQSxNQUFNO0FBQ04scUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrQkFBa0I7QUFDeEIsc0JBQXNCLGlCQUFpQjtBQUN2Qyx1Q0FBdUMsU0FBUyxtQkFBbUIsU0FBUztBQUM1RTtBQUNBLHlCQUF5QixjQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQSxpQkFBaUIsNkJBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVcsV0FBVyw0QkFBNEI7QUFDNUU7QUFDQSwwQkFBMEIsZUFBTztBQUNqQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsY0FBYyxnQ0FBZ0MsaUJBQWlCLGVBQWUsZUFBZSxhQUFhLFVBQVU7QUFDNUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsYUFBYSxnQ0FBZ0MsaUJBQWlCLGVBQWUsZUFBZSxhQUFhLFVBQVU7QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sU0FBUztBQUNmLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQyxvQkFBb0IsZUFBZTtBQUNuQztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXNCO0FBQ3RCOzs7QUMxT0EsbUVBQW1FLCtCQUErQix1Q0FBdUMsb0hBQW9ILHlCQUF5Qix1SUFBdUksbU5BQW1OLG1EQUFtRCw0REFBNEQsNERBQTRELDBCQUEwQixvQkFBb0IsUUFBUSx5QkFBeUIsb0JBQW9CLE9BQU8sbUhBQW1ILDhDQUE4QyxzREFBc0Qsc0ZBQXNGLEtBQUs7O0FBRXhwQztBQUMvQjs7O0FDSEEsb0ZBQW9GLGlDQUFpQyxzQ0FBc0MsbUNBQW1DLGdDQUFnQyxtQ0FBbUMsNEJBQTRCLDZHQUE2RywyRUFBMkUsS0FBSzs7QUFFM2I7QUFDL0I7OztBQ0gyRztBQUNqRTtBQUNvQjtBQUNoQjtBQUNMO0FBQ0M7QUFDZjtBQUMrQztBQUNaOztBQUU5RDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbUJBQVM7QUFDM0MsOEJBQThCO0FBQzlCO0FBQ0EsWUFBWSwyREFBMkQsa0JBQWtCO0FBQ3pGLFNBQVMsVUFBVTtBQUNuQiw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQSxLQUFLO0FBQ0wsd0JBQXdCLDZCQUFRO0FBQ2hDO0FBQ0EsdUJBQXVCLDZCQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscUJBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IseUJBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUFZLENBQUMsZUFBTztBQUMvQyw0QkFBNEIsdUJBQVc7QUFDdkMsWUFBWTtBQUNaLDJCQUEyQix5QkFBWSxDQUFDLGVBQU8sVUFBVSxTQUFTLE9BQU8sTUFBTSxRQUFRLEVBQUUsUUFBUSxlQUFlLGNBQWM7QUFDOUgsNEJBQTRCLHVCQUFXO0FBQ3ZDO0FBQ0EsMkJBQTJCLFNBQUk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQyw2RUFBNkUsZUFBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsU0FBSTtBQUM1RjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlCQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhDQUE4QyxFQUFFLFVBQVU7QUFDdEU7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBLDZDQUE2QyxlQUFlO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQ0FBc0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFVBQVU7QUFDbkIsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFPO0FBQ2pDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXNCO0FBQ3RCOzs7QUMzZHNFO0FBQ0U7QUFDMUI7QUFDakI7QUFDeUI7QUFDVTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCLGNBQWMsb0JBQW9CO0FBQ2xDLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0NBQW9DLGNBQVU7QUFDOUMsR0FBRztBQUNIO0FBQ0EsV0FBVyxVQUFVLGVBQWUsZUFBZTtBQUNuRCxHQUFHO0FBQ0g7QUFDQSxxQkFBcUIsVUFBVSxlQUFlLFVBQVUsZ0JBQWdCLGVBQWU7QUFDdkYsWUFBWSxNQUFNO0FBQ2xCLFlBQVksY0FBYztBQUMxQjtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQSxzQkFBc0IsY0FBVSxNQUFNLGNBQVU7QUFDaEQsa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixHQUFHO0FBQ0g7QUFDQSwyQkFBMkIsNkJBQVE7QUFDbkM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVnQjtBQUMxQjs7O0FDOUM4QztBQUNRO0FBQ1I7QUFDZjtBQUN3QjtBQUNEO0FBQ0E7QUFDRjtBQUNZO0FBQ2hFOzs7QUNUNkM7QUFDTjs7QUFFdkMscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRyxxQ0FBcUMsS0FBSztBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZCQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsY0FBVSxlQUFlLGNBQVU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFNBQVM7QUFDakU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNO0FBQ2hDO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DLG9CQUFvQixjQUFjO0FBQ2xDLHNCQUFzQixnQkFBZ0I7QUFDdEMsc0JBQXNCLGdCQUFnQjtBQUN0QyxxQkFBcUIsZUFBZTtBQUNwQyx1QkFBdUIsaUJBQWlCO0FBQ3hDLHlCQUF5QixtQkFBbUI7QUFDNUMscUJBQXFCLFdBQVc7QUFDaEMsa0JBQWtCLGFBQWE7QUFDL0Isc0JBQXNCLGdCQUFnQjtBQUN0Qyw0Q0FBNEMsZ0JBQWdCO0FBQzVEO0FBQ0Esc0JBQXNCLDZDQUE2QztBQUNuRSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCO0FBQzNELHNDQUFzQyxpQ0FBaUM7QUFDdkUsOEJBQThCLHFCQUFxQjtBQUNuRCw4QkFBOEIsaUNBQWlDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1Qyw0QkFBNEIsYUFBYTtBQUN6QywrQkFBK0I7QUFDL0IsOEJBQThCO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFhO0FBQzNCO0FBQ0E7QUFDQSxhQUFhLG9CQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEVBQUUsS0FBSyxFQUFFO0FBQ2pDO0FBQ0EsNkJBQTZCLFVBQVUsRUFBRSxvQkFBb0IsS0FBSyxNQUFNO0FBQ3hFO0FBQ0EsMkJBQTJCLFVBQVUsRUFBRSxNQUFNO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWSxFQUFFLDZCQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlCO0FBQ3pCOzs7QUN0UGlFO0FBQzNCO0FBQ0M7QUFDYTs7QUFFcEQsZ0NBQWdDLGFBQU07QUFDdEMsbUNBQW1DO0FBQ25DLFVBQVUsZUFBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQU87QUFDM0IsaUJBQWlCLDZCQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx1QkFBdUIsbUJBQVM7QUFDaEMsdUJBQXVCLG1CQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDZCQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsdUNBQXVDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhDQUE4QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxlQUFlLDJCQUEyQjtBQUN0RixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBNEM7QUFDeEQsWUFBWSxVQUFVO0FBQ3RCLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxjQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBLE1BQU0sMEJBQTBCLFNBQVM7QUFDekM7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDLE1BQU07QUFDTjtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLFlBQVk7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0I7QUFDcEI7OztBQ25RMEM7QUFDVTtBQUNwRDs7O0FDRnFDO0FBQ0U7QUFDRTtBQUNEO0FBQ0o7QUFDVjtBQUNHO0FBQ2E7QUFDZjtBQUNHO0FBQ0Q7QUFDQztBQUNLO0FBQ0Q7QUFDUTtBQUNBO0FBQ1I7QUFDQztBQUNKO0FBQ0o7QUFDTztBQUNPO0FBQ1g7QUFDRDtBQUNTO0FBQ0Y7QUFDRjtBQUNQO0FBQ087QUFDRjtBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9leHRlbnNpb25zL2xpYi9pbmRleC5tanM/YTIyYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZ2VvbWV0cnkvVmlld2FibGVCdWZmZXIubWpzPzkwZTMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9jaGVja01heElmU3RhdGVtZW50c0luU2hhZGVyLm1qcz9hMTAxIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zdGF0ZS9TdGF0ZS5tanM/YTEwNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL2F1dG9EZXRlY3RSZXNvdXJjZS5tanM/NDlmYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvcnVubmVyL2xpYi9SdW5uZXIubWpzPzI1MGYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3J1bm5lci9saWIvaW5kZXgubWpzP2RiZDciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9SZXNvdXJjZS5tanM/YmFjMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL0J1ZmZlclJlc291cmNlLm1qcz9iNGJlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9CYXNlVGV4dHVyZS5tanM/NDk0MSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvYmF0Y2gvQmF0Y2hEcmF3Q2FsbC5tanM/NTBmMCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZ2VvbWV0cnkvQnVmZmVyLm1qcz9lNjkyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9nZW9tZXRyeS9BdHRyaWJ1dGUubWpzPzVlZDYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2dlb21ldHJ5L3V0aWxzL2ludGVybGVhdmVUeXBlZEFycmF5cy5tanM/MzZlYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZ2VvbWV0cnkvR2VvbWV0cnkubWpzP2U2ZmYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2JhdGNoL0JhdGNoR2VvbWV0cnkubWpzPzRiYmMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21hdGgvbGliL2NvbnN0Lm1qcz81NjAyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9Qb2ludC5tanM/MzQ0ZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvbWF0aC9saWIvc2hhcGVzL1JlY3RhbmdsZS5tanM/MGQ1YyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvbWF0aC9saWIvc2hhcGVzL0NpcmNsZS5tanM/Y2E4NiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvbWF0aC9saWIvc2hhcGVzL0VsbGlwc2UubWpzP2I2ZDciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21hdGgvbGliL3NoYXBlcy9Qb2x5Z29uLm1qcz9lMDI5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9zaGFwZXMvUm91bmRlZFJlY3RhbmdsZS5tanM/OWRlMCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvbWF0aC9saWIvTWF0cml4Lm1qcz9iNTNiIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9ncm91cEQ4Lm1qcz9iYTQzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9tYXRoL2xpYi9PYnNlcnZhYmxlUG9pbnQubWpzPzc0ZjEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21hdGgvbGliL1RyYW5zZm9ybS5tanM/ZjhjYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvbWF0aC9saWIvaW5kZXgubWpzPzJmYTQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci9kZWZhdWx0UHJvZ3JhbS5tanM/ODJmMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL2RlZmF1bHRQcm9ncmFtMi5tanM/NGVhNyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL3VuaWZvcm1QYXJzZXJzLm1qcz8yMzY0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvdXRpbHMvZ2VuZXJhdGVVbmlmb3Jtc1N5bmMubWpzPzBmN2YiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9nZXRUZXN0Q29udGV4dC5tanM/MTY3NyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL2dldE1heEZyYWdtZW50UHJlY2lzaW9uLm1qcz8xYmExIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvdXRpbHMvbWFwU2l6ZS5tanM/MjQ0MSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL21hcFR5cGUubWpzPzE0OTYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9zZXRQcmVjaXNpb24ubWpzPzg2OWQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9pbmRleC5tanM/NDNiMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL1Byb2dyYW0ubWpzPzNhMzIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci9Vbmlmb3JtR3JvdXAubWpzPzIzZDEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci9TaGFkZXIubWpzPzRlMzYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2JhdGNoL0JhdGNoU2hhZGVyR2VuZXJhdG9yLm1qcz8zODkzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9iYXRjaC9CYXRjaFRleHR1cmVBcnJheS5tanM/ZjE5ZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvYmF0Y2gvY2FuVXBsb2FkU2FtZUJ1ZmZlci5tanM/MjgxMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvYmF0Y2gvbWF4UmVjb21tZW5kZWRUZXh0dXJlcy5tanM/NTQwOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvYmF0Y2gvT2JqZWN0UmVuZGVyZXIubWpzP2RjYjYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2JhdGNoL3RleHR1cmUubWpzPzdkNzgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2JhdGNoL3RleHR1cmUyLm1qcz81ZWVjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9iYXRjaC9CYXRjaFJlbmRlcmVyLm1qcz85ODc3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9maWx0ZXJzL2RlZmF1bHRGaWx0ZXIubWpzPzI3ZDciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZpbHRlcnMvZGVmYXVsdEZpbHRlcjIubWpzPzA0NDciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZpbHRlcnMvRmlsdGVyLm1qcz85OTA2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9iYWNrZ3JvdW5kL0JhY2tncm91bmRTeXN0ZW0ubWpzPzYwYzkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2JhdGNoL0JhdGNoU3lzdGVtLm1qcz9hM2M5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9jb250ZXh0L0NvbnRleHRTeXN0ZW0ubWpzP2RmODMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9EZXB0aFJlc291cmNlLm1qcz9mZjUzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9mcmFtZWJ1ZmZlci9GcmFtZWJ1ZmZlci5tanM/ZTdjOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvcmVuZGVyVGV4dHVyZS9CYXNlUmVuZGVyVGV4dHVyZS5tanM/MzlmOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL0Jhc2VJbWFnZVJlc291cmNlLm1qcz8zZjY1Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9yZXNvdXJjZXMvSW1hZ2VSZXNvdXJjZS5tanM/Y2Q5YyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvVGV4dHVyZVV2cy5tanM/NDViYiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvVGV4dHVyZS5tanM/NWMyZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvcmVuZGVyVGV4dHVyZS9SZW5kZXJUZXh0dXJlLm1qcz9mMDJjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9yZW5kZXJUZXh0dXJlL1JlbmRlclRleHR1cmVQb29sLm1qcz81ODAxIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi91dGlscy9RdWFkLm1qcz8yMDZiIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi91dGlscy9RdWFkVXYubWpzP2E0MDQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZpbHRlcnMvRmlsdGVyU3RhdGUubWpzPzJmOWIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZpbHRlcnMvRmlsdGVyU3lzdGVtLm1qcz9mMWNmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9mcmFtZWJ1ZmZlci9HTEZyYW1lYnVmZmVyLm1qcz80NDljIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9mcmFtZWJ1ZmZlci9GcmFtZWJ1ZmZlclN5c3RlbS5tanM/ZjUwMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZ2VvbWV0cnkvR2VvbWV0cnlTeXN0ZW0ubWpzPzQ2YmYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL1RleHR1cmVNYXRyaXgubWpzP2ZkNGEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZpbHRlcnMvc3ByaXRlTWFzay9zcHJpdGVNYXNrRmlsdGVyMi5tanM/YTYzNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZmlsdGVycy9zcHJpdGVNYXNrL3Nwcml0ZU1hc2tGaWx0ZXIzLm1qcz8yY2IyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9maWx0ZXJzL3Nwcml0ZU1hc2svU3ByaXRlTWFza0ZpbHRlci5tanM/YmM5MSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvbWFzay9NYXNrRGF0YS5tanM/MTA3MyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvbWFzay9NYXNrU3lzdGVtLm1qcz8xNGE0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9tYXNrL0Fic3RyYWN0TWFza1N5c3RlbS5tanM/OGE5MCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvbWFzay9TY2lzc29yU3lzdGVtLm1qcz8wY2Q3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9tYXNrL1N0ZW5jaWxTeXN0ZW0ubWpzP2JkMGIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3BsdWdpbi9QbHVnaW5TeXN0ZW0ubWpzPzI2MTYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3Byb2plY3Rpb24vUHJvamVjdGlvblN5c3RlbS5tanM/Yjc3MiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvcmVuZGVyVGV4dHVyZS9HZW5lcmF0ZVRleHR1cmVTeXN0ZW0ubWpzP2E0OGEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3JlbmRlclRleHR1cmUvUmVuZGVyVGV4dHVyZVN5c3RlbS5tanM/YmM5MiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL0dMUHJvZ3JhbS5tanM/ZTA1ZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL3V0aWxzL2NvbXBpbGVTaGFkZXIubWpzPzQ4ZDciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9kZWZhdWx0VmFsdWUubWpzP2NhOGMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9nZXRBdHRyaWJ1dGVEYXRhLm1qcz8yYzc0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvdXRpbHMvZ2V0VW5pZm9ybURhdGEubWpzPzA5NzEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9sb2dQcm9ncmFtRXJyb3IubWpzP2IyMDAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9nZW5lcmF0ZVByb2dyYW0ubWpzPzk3MDQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3NoYWRlci91dGlscy9nZW5lcmF0ZVVuaWZvcm1CdWZmZXJTeW5jLm1qcz9kZjEyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zaGFkZXIvdXRpbHMvdW5zYWZlRXZhbFN1cHBvcnRlZC5tanM/M2NhYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc2hhZGVyL1NoYWRlclN5c3RlbS5tanM/OTFlMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvc3RhcnR1cC9TdGFydHVwU3lzdGVtLm1qcz81YWUzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zdGF0ZS91dGlscy9tYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkubWpzPzY4YmEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3N0YXRlL1N0YXRlU3lzdGVtLm1qcz82MjY4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zeXN0ZW0vU3lzdGVtTWFuYWdlci5tanM/ODkzOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvVGV4dHVyZUdDU3lzdGVtLm1qcz9iZDJhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9HTFRleHR1cmUubWpzP2NkYzAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3V0aWxzL21hcFR5cGVBbmRGb3JtYXRUb0ludGVybmFsRm9ybWF0Lm1qcz81NDU2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90ZXh0dXJlcy9UZXh0dXJlU3lzdGVtLm1qcz81ZTk3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi90cmFuc2Zvcm1GZWVkYmFjay9UcmFuc2Zvcm1GZWVkYmFja1N5c3RlbS5tanM/OGMyMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdmlldy9WaWV3U3lzdGVtLm1qcz82YmE0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zeXN0ZW1zLm1qcz80YjQwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9zZXR0aW5ncy5tanM/MmU0NyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvdGlja2VyL2xpYi9jb25zdC5tanM/MTkzNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvdGlja2VyL2xpYi9UaWNrZXJMaXN0ZW5lci5tanM/YjkzOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvdGlja2VyL2xpYi9UaWNrZXIubWpzPzA1ZTIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RpY2tlci9saWIvc2V0dGluZ3MubWpzPzdiNjYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RpY2tlci9saWIvVGlja2VyUGx1Z2luLm1qcz82YmUzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS90aWNrZXIvbGliL2luZGV4Lm1qcz9jMTQzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9hdXRvRGV0ZWN0UmVuZGVyZXIubWpzPzcwYWQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2ZyYWdtZW50cy9kZWZhdWx0Lm1qcz9mZTJkIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9mcmFnbWVudHMvZGVmYXVsdEZpbHRlci5tanM/ZWVlOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZnJhZ21lbnRzL2luZGV4Lm1qcz8zNzZiIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9mcmFtZWJ1ZmZlci9NdWx0aXNhbXBsZVN5c3RlbS5tanM/YmM5ZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvZ2VvbWV0cnkvR0xCdWZmZXIubWpzPzMxMDciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2dlb21ldHJ5L0J1ZmZlclN5c3RlbS5tanM/MTdhZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvcmVuZGVyL09iamVjdFJlbmRlcmVyU3lzdGVtLm1qcz8zNzIyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb3JlL2xpYi9SZW5kZXJlci5tanM/NTk0ZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL0Fic3RyYWN0TXVsdGlSZXNvdXJjZS5tanM/ZWVjYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL0FycmF5UmVzb3VyY2UubWpzP2MxNWUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9DYW52YXNSZXNvdXJjZS5tanM/ZDk4MiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL0N1YmVSZXNvdXJjZS5tanM/MDc0MCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL0ltYWdlQml0bWFwUmVzb3VyY2UubWpzPzE5NjUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9TVkdSZXNvdXJjZS5tanM/NWY0YSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdGV4dHVyZXMvcmVzb3VyY2VzL1ZpZGVvUmVzb3VyY2UubWpzPzdlYTgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL3RleHR1cmVzL3Jlc291cmNlcy9pbmRleC5tanM/OTYxYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29yZS9saWIvdHJhbnNmb3JtRmVlZGJhY2svVHJhbnNmb3JtRmVlZGJhY2subWpzPzA2NDIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvcmUvbGliL2luZGV4Lm1qcz9lNTEzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9kaXNwbGF5L2xpYi9Cb3VuZHMubWpzP2Q3ZjYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Rpc3BsYXkvbGliL0Rpc3BsYXlPYmplY3QubWpzP2I2N2UiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Rpc3BsYXkvbGliL0NvbnRhaW5lci5tanM/NzhhOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvZGlzcGxheS9saWIvc2V0dGluZ3MubWpzP2Q0MzMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Rpc3BsYXkvbGliL2luZGV4Lm1qcz9mMGUzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9zcHJpdGUvbGliL1Nwcml0ZS5tanM/M2Y1NSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlL2xpYi9pbmRleC5tanM/ZDdiMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvbWl4aW4tY2FjaGUtYXMtYml0bWFwL2xpYi9pbmRleC5tanM/NzAxOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvbWl4aW4tZ2V0LWNoaWxkLWJ5LW5hbWUvbGliL2luZGV4Lm1qcz8xYWEwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9taXhpbi1nZXQtZ2xvYmFsLXBvc2l0aW9uL2xpYi9pbmRleC5tanM/ZjgyZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWFscGhhL2xpYi9hbHBoYS5tanM/YzNmNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWFscGhhL2xpYi9BbHBoYUZpbHRlci5tanM/NzJiNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWFscGhhL2xpYi9pbmRleC5tanM/MGIwNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWJsdXIvbGliL2dlbmVyYXRlQmx1ckZyYWdTb3VyY2UubWpzPzNiNzIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1ibHVyL2xpYi9nZW5lcmF0ZUJsdXJWZXJ0U291cmNlLm1qcz8yODVlIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItYmx1ci9saWIvQmx1ckZpbHRlclBhc3MubWpzP2QyOWYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1ibHVyL2xpYi9CbHVyRmlsdGVyLm1qcz80NjZjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItYmx1ci9saWIvaW5kZXgubWpzP2Q1NGUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1jb2xvci1tYXRyaXgvbGliL2NvbG9yTWF0cml4Lm1qcz80YTgxIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItY29sb3ItbWF0cml4L2xpYi9Db2xvck1hdHJpeEZpbHRlci5tanM/YTZjNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWNvbG9yLW1hdHJpeC9saWIvaW5kZXgubWpzP2JmZDMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1kaXNwbGFjZW1lbnQvbGliL2Rpc3BsYWNlbWVudC5tanM/MWU3MSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWRpc3BsYWNlbWVudC9saWIvZGlzcGxhY2VtZW50Mi5tanM/MmI3ZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWRpc3BsYWNlbWVudC9saWIvRGlzcGxhY2VtZW50RmlsdGVyLm1qcz85Yzg0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9maWx0ZXItZGlzcGxhY2VtZW50L2xpYi9pbmRleC5tanM/N2Q3ZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWZ4YWEvbGliL2Z4YWEubWpzP2ExMTMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1meGFhL2xpYi9meGFhMi5tanM/YzcwNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLWZ4YWEvbGliL0ZYQUFGaWx0ZXIubWpzP2VhNjkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2ZpbHRlci1meGFhL2xpYi9pbmRleC5tanM/MTAwNyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLW5vaXNlL2xpYi9ub2lzZS5tanM/NjQ3NCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLW5vaXNlL2xpYi9Ob2lzZUZpbHRlci5tanM/ODIzOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvZmlsdGVyLW5vaXNlL2xpYi9pbmRleC5tanM/M2JlNyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvcGl4aS5qcy9saWIvZmlsdGVycy5tanM/MTA2MCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvZXZlbnRzL2xpYi9FdmVudFRpY2tlci5tanM/NDNiOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvZXZlbnRzL2xpYi9GZWRlcmF0ZWRFdmVudC5tanM/YTNhNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvZXZlbnRzL2xpYi9GZWRlcmF0ZWRNb3VzZUV2ZW50Lm1qcz84NTA2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9ldmVudHMvbGliL0ZlZGVyYXRlZFBvaW50ZXJFdmVudC5tanM/OWJmOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvZXZlbnRzL2xpYi9GZWRlcmF0ZWRXaGVlbEV2ZW50Lm1qcz84NzY5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9ldmVudHMvbGliL0V2ZW50Qm91bmRhcnkubWpzPzkxMWYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2V2ZW50cy9saWIvRXZlbnRTeXN0ZW0ubWpzPzk5NWMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2V2ZW50cy9saWIvRmVkZXJhdGVkRXZlbnRUYXJnZXQubWpzP2JjMzIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2V2ZW50cy9saWIvaW5kZXgubWpzPzM2MjEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2FjY2Vzc2liaWxpdHkvbGliL2FjY2Vzc2libGVUYXJnZXQubWpzPzUzYTciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2FjY2Vzc2liaWxpdHkvbGliL0FjY2Vzc2liaWxpdHlNYW5hZ2VyLm1qcz9hOWViIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9hY2Nlc3NpYmlsaXR5L2xpYi9pbmRleC5tanM/YjhmYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvYXBwL2xpYi9BcHBsaWNhdGlvbi5tanM/OWI4OSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvYXBwL2xpYi9SZXNpemVQbHVnaW4ubWpzPzZjZDEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2FwcC9saWIvaW5kZXgubWpzPzE5YWUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvQXNzZXRFeHRlbnNpb24ubWpzPzIyOTIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvQmFja2dyb3VuZExvYWRlci5tanM/NTE5YiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi91dGlscy9jaGVja0V4dGVuc2lvbi5tanM/YzNhOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi91dGlscy9pbmRleC5tanM/ZjEwOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi91dGlscy9jb252ZXJ0VG9MaXN0Lm1qcz83ZmY0Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2NhY2hlL0NhY2hlLm1qcz84NWZmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL3V0aWxzL2lzU2luZ2xlSXRlbS5tanM/MjFjNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvTG9hZGVyLm1qcz9jM2NhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2xvYWRlci9wYXJzZXJzL0xvYWRlclBhcnNlci5tanM/ZGEwZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi91dGlscy9jaGVja0RhdGFVcmwubWpzPzdjNDciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvbG9hZGVyL3BhcnNlcnMvbG9hZEpzb24ubWpzPzQ5NTQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvbG9hZGVyL3BhcnNlcnMvbG9hZFR4dC5tanM/YzgzNiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvcGFyc2Vycy9sb2FkV2ViRm9udC5tanM/YjhkNyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvcGFyc2Vycy9Xb3JrZXJNYW5hZ2VyLm1qcz9jZTBmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL3V0aWxzL2NyZWF0ZVRleHR1cmUubWpzP2MzYzUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvbG9hZFRleHR1cmVzLm1qcz9iYjc5Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL2xvYWRTVkcubWpzPzI2NmEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvdXRpbHMvaW5kZXgubWpzP2E4M2UiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvaW5kZXgubWpzPzhhN2UiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvbG9hZGVyL3BhcnNlcnMvaW5kZXgubWpzPzIxYmIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvdXRpbHMvY3JlYXRlU3RyaW5nVmFyaWF0aW9ucy5tanM/MTg4MSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9yZXNvbHZlci9SZXNvbHZlci5tanM/ZjdjZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9Bc3NldHMubWpzPzlmZDgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvY2FjaGUvcGFyc2Vycy9jYWNoZVRleHR1cmVBcnJheS5tanM/NjAwYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9jYWNoZS9wYXJzZXJzL2luZGV4Lm1qcz9kMzIyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2NhY2hlL2luZGV4Lm1qcz82OGViIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RBdmlmLm1qcz9mZDcyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RXZWJwLm1qcz9mYjk4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3REZWZhdWx0cy5tanM/YzI1ZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9kZXRlY3Rpb25zL3BhcnNlcnMvaW5kZXgubWpzP2U0ZDciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvZGV0ZWN0aW9ucy9pbmRleC5tanM/NmQ3YSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9sb2FkZXIvaW5kZXgubWpzPzg3OTEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvcmVzb2x2ZXIvcGFyc2Vycy9yZXNvbHZlVGV4dHVyZVVybC5tanM/NmY3ZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvYXNzZXRzL2xpYi9yZXNvbHZlci9wYXJzZXJzL2luZGV4Lm1qcz8xZTY2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL3Jlc29sdmVyL2luZGV4Lm1qcz8xNzNjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9hc3NldHMvbGliL3V0aWxzL2NvcHlTZWFyY2hQYXJhbXMubWpzPzVlZTYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2Fzc2V0cy9saWIvaW5kZXgubWpzP2YzMWIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL2NvbnN0Lm1qcz9kN2MyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb21wcmVzc2VkLXRleHR1cmVzL2xpYi9sb2FkZXJzL2NvbXByZXNzZWRUZXh0dXJlRXh0ZW5zaW9ucy5tanM/OWZjYSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29tcHJlc3NlZC10ZXh0dXJlcy9saWIvbG9hZGVycy9kZXRlY3RDb21wcmVzc2VkVGV4dHVyZXMubWpzPzg2MjgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL3Jlc291cmNlcy9CbG9iUmVzb3VyY2UubWpzPzZmMzkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL3Jlc291cmNlcy9Db21wcmVzc2VkVGV4dHVyZVJlc291cmNlLm1qcz85YjhjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb21wcmVzc2VkLXRleHR1cmVzL2xpYi9yZXNvdXJjZXMvaW5kZXgubWpzP2IzNWMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL3BhcnNlcnMvcGFyc2VERFMubWpzPzIzNDgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL3BhcnNlcnMvcGFyc2VLVFgubWpzP2UxYjkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL3BhcnNlcnMvaW5kZXgubWpzP2MxOTEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2NvbXByZXNzZWQtdGV4dHVyZXMvbGliL2xvYWRlcnMvbG9hZEREUy5tanM/NGM0YyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29tcHJlc3NlZC10ZXh0dXJlcy9saWIvbG9hZGVycy9sb2FkS1RYLm1qcz82NmFhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9jb21wcmVzc2VkLXRleHR1cmVzL2xpYi9sb2FkZXJzL3Jlc29sdmVDb21wcmVzc2VkVGV4dHVyZVVybC5tanM/MmZjZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29tcHJlc3NlZC10ZXh0dXJlcy9saWIvbG9hZGVycy9pbmRleC5tanM/NGVkNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvY29tcHJlc3NlZC10ZXh0dXJlcy9saWIvaW5kZXgubWpzP2RmZWYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2V4dHJhY3QvbGliL0V4dHJhY3QubWpzPzVhMmUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2V4dHJhY3QvbGliL2luZGV4Lm1qcz83NjRiIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvdXRpbHMvYnVpbGRDaXJjbGUubWpzPzE1NjkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi91dGlscy9idWlsZFBvbHkubWpzP2MzMDQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi91dGlscy9idWlsZFJlY3RhbmdsZS5tanM/OTE0OSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL3V0aWxzL2J1aWxkUm91bmRlZFJlY3RhbmdsZS5tanM/YTk4YSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL2NvbnN0Lm1qcz8wMDQzIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvdXRpbHMvQXJjVXRpbHMubWpzPzg5YmEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi91dGlscy9CZXppZXJVdGlscy5tanM/YmRlZCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL3V0aWxzL2J1aWxkTGluZS5tanM/NDMzMyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL3V0aWxzL1F1YWRyYXRpY1V0aWxzLm1qcz9lZDNiIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvdXRpbHMvaW5kZXgubWpzP2QxOGMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi9HcmFwaGljc0RhdGEubWpzP2Q0MzAiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi91dGlscy9CYXRjaFBhcnQubWpzPzIyNGQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi9HcmFwaGljc0dlb21ldHJ5Lm1qcz84MTJjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9ncmFwaGljcy9saWIvc3R5bGVzL0ZpbGxTdHlsZS5tanM/OGM4MiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL3N0eWxlcy9MaW5lU3R5bGUubWpzPzJmNDciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL2dyYXBoaWNzL2xpYi9HcmFwaGljcy5tanM/MGEyMSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvZ3JhcGhpY3MvbGliL2luZGV4Lm1qcz9hNDVhIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9tZXNoL2xpYi9NZXNoQmF0Y2hVdnMubWpzPzE4ZTciLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gvbGliL01lc2gubWpzPzZhMWQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gvbGliL01lc2hHZW9tZXRyeS5tanM/OTg3ZiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC9saWIvc2hhZGVyL21lc2gubWpzPzk2MjEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gvbGliL3NoYWRlci9tZXNoMi5tanM/N2I5MyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC9saWIvTWVzaE1hdGVyaWFsLm1qcz85OTg2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9tZXNoL2xpYi9pbmRleC5tanM/N2RhOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC1leHRyYXMvbGliL2dlb21ldHJ5L1BsYW5lR2VvbWV0cnkubWpzPzIzMjkiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gtZXh0cmFzL2xpYi9nZW9tZXRyeS9Sb3BlR2VvbWV0cnkubWpzPzkwYmUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gtZXh0cmFzL2xpYi9TaW1wbGVQbGFuZS5tanM/ZWJlMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC1leHRyYXMvbGliL05pbmVTbGljZVBsYW5lLm1qcz8xZTZjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9tZXNoLWV4dHJhcy9saWIvU2ltcGxlTWVzaC5tanM/NDIwOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvbWVzaC1leHRyYXMvbGliL1NpbXBsZVJvcGUubWpzP2Q5ZGYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL21lc2gtZXh0cmFzL2xpYi9pbmRleC5tanM/ZmJmYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvcGFydGljbGUtY29udGFpbmVyL2xpYi9QYXJ0aWNsZUNvbnRhaW5lci5tanM/OGZkOCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvcGFydGljbGUtY29udGFpbmVyL2xpYi9QYXJ0aWNsZUJ1ZmZlci5tanM/YmYyYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvcGFydGljbGUtY29udGFpbmVyL2xpYi9wYXJ0aWNsZXMubWpzPzcxNzUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3BhcnRpY2xlLWNvbnRhaW5lci9saWIvcGFydGljbGVzMi5tanM/ZTZlMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvcGFydGljbGUtY29udGFpbmVyL2xpYi9QYXJ0aWNsZVJlbmRlcmVyLm1qcz81Y2EyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9wYXJ0aWNsZS1jb250YWluZXIvbGliL2luZGV4Lm1qcz8yNmQ2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0L2xpYi9jb25zdC5tanM/NWJkYiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC9saWIvVGV4dE1ldHJpY3MubWpzP2VlYmIiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQvbGliL1RleHRTdHlsZS5tanM/YTUwOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC9saWIvVGV4dC5tanM/OGQyNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC9saWIvaW5kZXgubWpzPzViNjgiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3ByZXBhcmUvbGliL0NvdW50TGltaXRlci5tanM/MDI2NyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvcHJlcGFyZS9saWIvQmFzZVByZXBhcmUubWpzPzE5OGUiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3ByZXBhcmUvbGliL3NldHRpbmdzLm1qcz85NjIxIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9wcmVwYXJlL2xpYi9QcmVwYXJlLm1qcz85ODc3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9wcmVwYXJlL2xpYi9pbmRleC5tanM/NWZkNCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLWFuaW1hdGVkL2xpYi9BbmltYXRlZFNwcml0ZS5tanM/MDlhYiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLWFuaW1hdGVkL2xpYi9pbmRleC5tanM/MWY4YiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLXRpbGluZy9saWIvVGlsaW5nU3ByaXRlLm1qcz80N2VjIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9zcHJpdGUtdGlsaW5nL2xpYi9zcHJpdGUtdGlsaW5nLm1qcz83YmI2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9zcHJpdGUtdGlsaW5nL2xpYi9zcHJpdGUtdGlsaW5nMi5tanM/N2EzNSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLXRpbGluZy9saWIvc3ByaXRlLXRpbGluZy1mYWxsYmFjay5tanM/ZWIzMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLXRpbGluZy9saWIvc3ByaXRlLXRpbGluZy1mYWxsYmFjazIubWpzPzcwY2EiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3Nwcml0ZS10aWxpbmcvbGliL3Nwcml0ZS10aWxpbmctc2ltcGxlLm1qcz83NmM3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS9zcHJpdGUtdGlsaW5nL2xpYi9UaWxpbmdTcHJpdGVSZW5kZXJlci5tanM/MzdmMSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlLXRpbGluZy9saWIvaW5kZXgubWpzP2VjMjEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3Nwcml0ZXNoZWV0L2xpYi9TcHJpdGVzaGVldC5tanM/YTk1ZSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvc3ByaXRlc2hlZXQvbGliL3Nwcml0ZXNoZWV0QXNzZXQubWpzPzI5NWMiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3Nwcml0ZXNoZWV0L2xpYi9pbmRleC5tanM/NTkzOSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1iaXRtYXAvbGliL0JpdG1hcEZvbnREYXRhLm1qcz8zOGYwIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvZm9ybWF0cy9UZXh0Rm9ybWF0Lm1qcz85N2IyIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvZm9ybWF0cy9YTUxGb3JtYXQubWpzPzVhNWQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi9mb3JtYXRzL1hNTFN0cmluZ0Zvcm1hdC5tanM/Y2E3NCIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1iaXRtYXAvbGliL2Zvcm1hdHMvaW5kZXgubWpzPzY1YWYiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi91dGlscy9nZW5lcmF0ZUZpbGxTdHlsZS5tanM/NWVjMiIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1iaXRtYXAvbGliL3V0aWxzL2RyYXdHbHlwaC5tanM/NzllMSIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1iaXRtYXAvbGliL3V0aWxzL2luZGV4Lm1qcz85NTg3Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvdXRpbHMvc3BsaXRUZXh0VG9DaGFyYWN0ZXJzLm1qcz8zZDNiIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvdXRpbHMvcmVzb2x2ZUNoYXJhY3RlcnMubWpzPzNhMDEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi91dGlscy9leHRyYWN0Q2hhckNvZGUubWpzP2ZmODQiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi9CaXRtYXBGb250Lm1qcz9jOWQxIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvc2hhZGVyL21zZGYubWpzP2E1NTEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi9zaGFkZXIvbXNkZjIubWpzPzQwODEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi9CaXRtYXBUZXh0Lm1qcz9kYzA4Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWJpdG1hcC9saWIvbG9hZEJpdG1hcEZvbnQubWpzPzYwNWEiLCJ3ZWJwYWNrOi8vQG1hc2F0b21ha2luby9waXhpanMtYmFzaWMtYnV0dG9uLy4vbm9kZV9tb2R1bGVzL0BwaXhpL3RleHQtYml0bWFwL2xpYi9pbmRleC5tanM/YjJjYyIsIndlYnBhY2s6Ly9AbWFzYXRvbWFraW5vL3BpeGlqcy1iYXNpYy1idXR0b24vLi9ub2RlX21vZHVsZXMvQHBpeGkvdGV4dC1odG1sL2xpYi9IVE1MVGV4dFN0eWxlLm1qcz8zOTM2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWh0bWwvbGliL0hUTUxUZXh0Lm1qcz9iNjJmIiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9AcGl4aS90ZXh0LWh0bWwvbGliL2luZGV4Lm1qcz83Njg2Iiwid2VicGFjazovL0BtYXNhdG9tYWtpbm8vcGl4aWpzLWJhc2ljLWJ1dHRvbi8uL25vZGVfbW9kdWxlcy9waXhpLmpzL2xpYi9pbmRleC5tanM/M2VhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRXh0ZW5zaW9uVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEV4dGVuc2lvblR5cGUyKSA9PiB7XG4gIEV4dGVuc2lvblR5cGUyW1wiUmVuZGVyZXJcIl0gPSBcInJlbmRlcmVyXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiQXBwbGljYXRpb25cIl0gPSBcImFwcGxpY2F0aW9uXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiUmVuZGVyZXJTeXN0ZW1cIl0gPSBcInJlbmRlcmVyLXdlYmdsLXN5c3RlbVwiO1xuICBFeHRlbnNpb25UeXBlMltcIlJlbmRlcmVyUGx1Z2luXCJdID0gXCJyZW5kZXJlci13ZWJnbC1wbHVnaW5cIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJDYW52YXNSZW5kZXJlclN5c3RlbVwiXSA9IFwicmVuZGVyZXItY2FudmFzLXN5c3RlbVwiO1xuICBFeHRlbnNpb25UeXBlMltcIkNhbnZhc1JlbmRlcmVyUGx1Z2luXCJdID0gXCJyZW5kZXJlci1jYW52YXMtcGx1Z2luXCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiQXNzZXRcIl0gPSBcImFzc2V0XCI7XG4gIEV4dGVuc2lvblR5cGUyW1wiTG9hZFBhcnNlclwiXSA9IFwibG9hZC1wYXJzZXJcIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJSZXNvbHZlUGFyc2VyXCJdID0gXCJyZXNvbHZlLXBhcnNlclwiO1xuICBFeHRlbnNpb25UeXBlMltcIkNhY2hlUGFyc2VyXCJdID0gXCJjYWNoZS1wYXJzZXJcIjtcbiAgRXh0ZW5zaW9uVHlwZTJbXCJEZXRlY3Rpb25QYXJzZXJcIl0gPSBcImRldGVjdGlvbi1wYXJzZXJcIjtcbiAgcmV0dXJuIEV4dGVuc2lvblR5cGUyO1xufSkoRXh0ZW5zaW9uVHlwZSB8fCB7fSk7XG5jb25zdCBub3JtYWxpemVFeHRlbnNpb24gPSAoZXh0KSA9PiB7XG4gIGlmICh0eXBlb2YgZXh0ID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGV4dCA9PT0gXCJvYmplY3RcIiAmJiBleHQuZXh0ZW5zaW9uKSB7XG4gICAgaWYgKCFleHQuZXh0ZW5zaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHRlbnNpb24gY2xhc3MgbXVzdCBoYXZlIGFuIGV4dGVuc2lvbiBvYmplY3RcIik7XG4gICAgfVxuICAgIGNvbnN0IG1ldGFkYXRhID0gdHlwZW9mIGV4dC5leHRlbnNpb24gIT09IFwib2JqZWN0XCIgPyB7IHR5cGU6IGV4dC5leHRlbnNpb24gfSA6IGV4dC5leHRlbnNpb247XG4gICAgZXh0ID0geyAuLi5tZXRhZGF0YSwgcmVmOiBleHQgfTtcbiAgfVxuICBpZiAodHlwZW9mIGV4dCA9PT0gXCJvYmplY3RcIikge1xuICAgIGV4dCA9IHsgLi4uZXh0IH07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBleHRlbnNpb24gdHlwZVwiKTtcbiAgfVxuICBpZiAodHlwZW9mIGV4dC50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgZXh0LnR5cGUgPSBbZXh0LnR5cGVdO1xuICB9XG4gIHJldHVybiBleHQ7XG59O1xuY29uc3Qgbm9ybWFsaXplUHJpb3JpdHkgPSAoZXh0LCBkZWZhdWx0UHJpb3JpdHkpID0+IG5vcm1hbGl6ZUV4dGVuc2lvbihleHQpLnByaW9yaXR5ID8/IGRlZmF1bHRQcmlvcml0eTtcbmNvbnN0IGV4dGVuc2lvbnMgPSB7XG4gIF9hZGRIYW5kbGVyczoge30sXG4gIF9yZW1vdmVIYW5kbGVyczoge30sXG4gIF9xdWV1ZToge30sXG4gIHJlbW92ZSguLi5leHRlbnNpb25zMikge1xuICAgIGV4dGVuc2lvbnMyLm1hcChub3JtYWxpemVFeHRlbnNpb24pLmZvckVhY2goKGV4dCkgPT4ge1xuICAgICAgZXh0LnR5cGUuZm9yRWFjaCgodHlwZSkgPT4gdGhpcy5fcmVtb3ZlSGFuZGxlcnNbdHlwZV0/LihleHQpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkKC4uLmV4dGVuc2lvbnMyKSB7XG4gICAgZXh0ZW5zaW9uczIubWFwKG5vcm1hbGl6ZUV4dGVuc2lvbikuZm9yRWFjaCgoZXh0KSA9PiB7XG4gICAgICBleHQudHlwZS5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy5fYWRkSGFuZGxlcnM7XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5fcXVldWU7XG4gICAgICAgIGlmICghaGFuZGxlcnNbdHlwZV0pIHtcbiAgICAgICAgICBxdWV1ZVt0eXBlXSA9IHF1ZXVlW3R5cGVdIHx8IFtdO1xuICAgICAgICAgIHF1ZXVlW3R5cGVdLnB1c2goZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVyc1t0eXBlXShleHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgaGFuZGxlKHR5cGUsIG9uQWRkLCBvblJlbW92ZSkge1xuICAgIGNvbnN0IGFkZEhhbmRsZXJzID0gdGhpcy5fYWRkSGFuZGxlcnM7XG4gICAgY29uc3QgcmVtb3ZlSGFuZGxlcnMgPSB0aGlzLl9yZW1vdmVIYW5kbGVycztcbiAgICBpZiAoYWRkSGFuZGxlcnNbdHlwZV0gfHwgcmVtb3ZlSGFuZGxlcnNbdHlwZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXh0ZW5zaW9uIHR5cGUgJHt0eXBlfSBhbHJlYWR5IGhhcyBhIGhhbmRsZXJgKTtcbiAgICB9XG4gICAgYWRkSGFuZGxlcnNbdHlwZV0gPSBvbkFkZDtcbiAgICByZW1vdmVIYW5kbGVyc1t0eXBlXSA9IG9uUmVtb3ZlO1xuICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5fcXVldWU7XG4gICAgaWYgKHF1ZXVlW3R5cGVdKSB7XG4gICAgICBxdWV1ZVt0eXBlXS5mb3JFYWNoKChleHQpID0+IG9uQWRkKGV4dCkpO1xuICAgICAgZGVsZXRlIHF1ZXVlW3R5cGVdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgaGFuZGxlQnlNYXAodHlwZSwgbWFwKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlKHR5cGUsIChleHRlbnNpb24pID0+IHtcbiAgICAgIG1hcFtleHRlbnNpb24ubmFtZV0gPSBleHRlbnNpb24ucmVmO1xuICAgIH0sIChleHRlbnNpb24pID0+IHtcbiAgICAgIGRlbGV0ZSBtYXBbZXh0ZW5zaW9uLm5hbWVdO1xuICAgIH0pO1xuICB9LFxuICBoYW5kbGVCeUxpc3QodHlwZSwgbGlzdCwgZGVmYXVsdFByaW9yaXR5ID0gLTEpIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGUodHlwZSwgKGV4dGVuc2lvbikgPT4ge1xuICAgICAgaWYgKGxpc3QuaW5jbHVkZXMoZXh0ZW5zaW9uLnJlZikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGlzdC5wdXNoKGV4dGVuc2lvbi5yZWYpO1xuICAgICAgbGlzdC5zb3J0KChhLCBiKSA9PiBub3JtYWxpemVQcmlvcml0eShiLCBkZWZhdWx0UHJpb3JpdHkpIC0gbm9ybWFsaXplUHJpb3JpdHkoYSwgZGVmYXVsdFByaW9yaXR5KSk7XG4gICAgfSwgKGV4dGVuc2lvbikgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBsaXN0LmluZGV4T2YoZXh0ZW5zaW9uLnJlZik7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuZXhwb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiY2xhc3MgVmlld2FibGVCdWZmZXIge1xuICBjb25zdHJ1Y3RvcihzaXplT3JCdWZmZXIpIHtcbiAgICBpZiAodHlwZW9mIHNpemVPckJ1ZmZlciA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdGhpcy5yYXdCaW5hcnlEYXRhID0gbmV3IEFycmF5QnVmZmVyKHNpemVPckJ1ZmZlcik7XG4gICAgfSBlbHNlIGlmIChzaXplT3JCdWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICB0aGlzLnJhd0JpbmFyeURhdGEgPSBzaXplT3JCdWZmZXIuYnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJhd0JpbmFyeURhdGEgPSBzaXplT3JCdWZmZXI7XG4gICAgfVxuICAgIHRoaXMudWludDMyVmlldyA9IG5ldyBVaW50MzJBcnJheSh0aGlzLnJhd0JpbmFyeURhdGEpO1xuICAgIHRoaXMuZmxvYXQzMlZpZXcgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMucmF3QmluYXJ5RGF0YSk7XG4gIH1cbiAgZ2V0IGludDhWaWV3KCkge1xuICAgIGlmICghdGhpcy5faW50OFZpZXcpIHtcbiAgICAgIHRoaXMuX2ludDhWaWV3ID0gbmV3IEludDhBcnJheSh0aGlzLnJhd0JpbmFyeURhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faW50OFZpZXc7XG4gIH1cbiAgZ2V0IHVpbnQ4VmlldygpIHtcbiAgICBpZiAoIXRoaXMuX3VpbnQ4Vmlldykge1xuICAgICAgdGhpcy5fdWludDhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5yYXdCaW5hcnlEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3VpbnQ4VmlldztcbiAgfVxuICBnZXQgaW50MTZWaWV3KCkge1xuICAgIGlmICghdGhpcy5faW50MTZWaWV3KSB7XG4gICAgICB0aGlzLl9pbnQxNlZpZXcgPSBuZXcgSW50MTZBcnJheSh0aGlzLnJhd0JpbmFyeURhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faW50MTZWaWV3O1xuICB9XG4gIGdldCB1aW50MTZWaWV3KCkge1xuICAgIGlmICghdGhpcy5fdWludDE2Vmlldykge1xuICAgICAgdGhpcy5fdWludDE2VmlldyA9IG5ldyBVaW50MTZBcnJheSh0aGlzLnJhd0JpbmFyeURhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdWludDE2VmlldztcbiAgfVxuICBnZXQgaW50MzJWaWV3KCkge1xuICAgIGlmICghdGhpcy5faW50MzJWaWV3KSB7XG4gICAgICB0aGlzLl9pbnQzMlZpZXcgPSBuZXcgSW50MzJBcnJheSh0aGlzLnJhd0JpbmFyeURhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faW50MzJWaWV3O1xuICB9XG4gIHZpZXcodHlwZSkge1xuICAgIHJldHVybiB0aGlzW2Ake3R5cGV9Vmlld2BdO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yYXdCaW5hcnlEYXRhID0gbnVsbDtcbiAgICB0aGlzLl9pbnQ4VmlldyA9IG51bGw7XG4gICAgdGhpcy5fdWludDhWaWV3ID0gbnVsbDtcbiAgICB0aGlzLl9pbnQxNlZpZXcgPSBudWxsO1xuICAgIHRoaXMuX3VpbnQxNlZpZXcgPSBudWxsO1xuICAgIHRoaXMuX2ludDMyVmlldyA9IG51bGw7XG4gICAgdGhpcy51aW50MzJWaWV3ID0gbnVsbDtcbiAgICB0aGlzLmZsb2F0MzJWaWV3ID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgc2l6ZU9mKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJpbnQ4XCI6XG4gICAgICBjYXNlIFwidWludDhcIjpcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBjYXNlIFwiaW50MTZcIjpcbiAgICAgIGNhc2UgXCJ1aW50MTZcIjpcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgIGNhc2UgXCJmbG9hdDMyXCI6XG4gICAgICAgIHJldHVybiA0O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3R5cGV9IGlzbid0IGEgdmFsaWQgdmlldyB0eXBlYCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IFZpZXdhYmxlQnVmZmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WaWV3YWJsZUJ1ZmZlci5tanMubWFwXG4iLCJjb25zdCBmcmFnVGVtcGxhdGUgPSBbXG4gIFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XCIsXG4gIFwidm9pZCBtYWluKHZvaWQpe1wiLFxuICBcImZsb2F0IHRlc3QgPSAwLjE7XCIsXG4gIFwiJWZvcmxvb3AlXCIsXG4gIFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjApO1wiLFxuICBcIn1cIlxuXS5qb2luKFwiXFxuXCIpO1xuZnVuY3Rpb24gZ2VuZXJhdGVJZlRlc3RTcmMobWF4SWZzKSB7XG4gIGxldCBzcmMgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1heElmczsgKytpKSB7XG4gICAgaWYgKGkgPiAwKSB7XG4gICAgICBzcmMgKz0gXCJcXG5lbHNlIFwiO1xuICAgIH1cbiAgICBpZiAoaSA8IG1heElmcyAtIDEpIHtcbiAgICAgIHNyYyArPSBgaWYodGVzdCA9PSAke2l9LjApe31gO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3JjO1xufVxuZnVuY3Rpb24gY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlcihtYXhJZnMsIGdsKSB7XG4gIGlmIChtYXhJZnMgPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIG9mIGAwYCBwYXNzZWQgdG8gYGNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXJgXCIpO1xuICB9XG4gIGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IGZyYWdtZW50U3JjID0gZnJhZ1RlbXBsYXRlLnJlcGxhY2UoLyVmb3Jsb29wJS9naSwgZ2VuZXJhdGVJZlRlc3RTcmMobWF4SWZzKSk7XG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgZnJhZ21lbnRTcmMpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgbWF4SWZzID0gbWF4SWZzIC8gMiB8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWF4SWZzO1xufVxuXG5leHBvcnQgeyBjaGVja01heElmU3RhdGVtZW50c0luU2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja01heElmU3RhdGVtZW50c0luU2hhZGVyLm1qcy5tYXBcbiIsImltcG9ydCB7IEJMRU5EX01PREVTIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcblxuY29uc3QgQkxFTkQgPSAwO1xuY29uc3QgT0ZGU0VUID0gMTtcbmNvbnN0IENVTExJTkcgPSAyO1xuY29uc3QgREVQVEhfVEVTVCA9IDM7XG5jb25zdCBXSU5ESU5HID0gNDtcbmNvbnN0IERFUFRIX01BU0sgPSA1O1xuY2xhc3MgU3RhdGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRhdGEgPSAwO1xuICAgIHRoaXMuYmxlbmRNb2RlID0gQkxFTkRfTU9ERVMuTk9STUFMO1xuICAgIHRoaXMucG9seWdvbk9mZnNldCA9IDA7XG4gICAgdGhpcy5ibGVuZCA9IHRydWU7XG4gICAgdGhpcy5kZXB0aE1hc2sgPSB0cnVlO1xuICB9XG4gIGdldCBibGVuZCgpIHtcbiAgICByZXR1cm4gISEodGhpcy5kYXRhICYgMSA8PCBCTEVORCk7XG4gIH1cbiAgc2V0IGJsZW5kKHZhbHVlKSB7XG4gICAgaWYgKCEhKHRoaXMuZGF0YSAmIDEgPDwgQkxFTkQpICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5kYXRhIF49IDEgPDwgQkxFTkQ7XG4gICAgfVxuICB9XG4gIGdldCBvZmZzZXRzKCkge1xuICAgIHJldHVybiAhISh0aGlzLmRhdGEgJiAxIDw8IE9GRlNFVCk7XG4gIH1cbiAgc2V0IG9mZnNldHModmFsdWUpIHtcbiAgICBpZiAoISEodGhpcy5kYXRhICYgMSA8PCBPRkZTRVQpICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5kYXRhIF49IDEgPDwgT0ZGU0VUO1xuICAgIH1cbiAgfVxuICBnZXQgY3VsbGluZygpIHtcbiAgICByZXR1cm4gISEodGhpcy5kYXRhICYgMSA8PCBDVUxMSU5HKTtcbiAgfVxuICBzZXQgY3VsbGluZyh2YWx1ZSkge1xuICAgIGlmICghISh0aGlzLmRhdGEgJiAxIDw8IENVTExJTkcpICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5kYXRhIF49IDEgPDwgQ1VMTElORztcbiAgICB9XG4gIH1cbiAgZ2V0IGRlcHRoVGVzdCgpIHtcbiAgICByZXR1cm4gISEodGhpcy5kYXRhICYgMSA8PCBERVBUSF9URVNUKTtcbiAgfVxuICBzZXQgZGVwdGhUZXN0KHZhbHVlKSB7XG4gICAgaWYgKCEhKHRoaXMuZGF0YSAmIDEgPDwgREVQVEhfVEVTVCkgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmRhdGEgXj0gMSA8PCBERVBUSF9URVNUO1xuICAgIH1cbiAgfVxuICBnZXQgZGVwdGhNYXNrKCkge1xuICAgIHJldHVybiAhISh0aGlzLmRhdGEgJiAxIDw8IERFUFRIX01BU0spO1xuICB9XG4gIHNldCBkZXB0aE1hc2sodmFsdWUpIHtcbiAgICBpZiAoISEodGhpcy5kYXRhICYgMSA8PCBERVBUSF9NQVNLKSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuZGF0YSBePSAxIDw8IERFUFRIX01BU0s7XG4gICAgfVxuICB9XG4gIGdldCBjbG9ja3dpc2VGcm9udEZhY2UoKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuZGF0YSAmIDEgPDwgV0lORElORyk7XG4gIH1cbiAgc2V0IGNsb2Nrd2lzZUZyb250RmFjZSh2YWx1ZSkge1xuICAgIGlmICghISh0aGlzLmRhdGEgJiAxIDw8IFdJTkRJTkcpICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5kYXRhIF49IDEgPDwgV0lORElORztcbiAgICB9XG4gIH1cbiAgZ2V0IGJsZW5kTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxlbmRNb2RlO1xuICB9XG4gIHNldCBibGVuZE1vZGUodmFsdWUpIHtcbiAgICB0aGlzLmJsZW5kID0gdmFsdWUgIT09IEJMRU5EX01PREVTLk5PTkU7XG4gICAgdGhpcy5fYmxlbmRNb2RlID0gdmFsdWU7XG4gIH1cbiAgZ2V0IHBvbHlnb25PZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvbHlnb25PZmZzZXQ7XG4gIH1cbiAgc2V0IHBvbHlnb25PZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLm9mZnNldHMgPSAhIXZhbHVlO1xuICAgIHRoaXMuX3BvbHlnb25PZmZzZXQgPSB2YWx1ZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtAcGl4aS9jb3JlOlN0YXRlIGJsZW5kTW9kZT0ke3RoaXMuYmxlbmRNb2RlfSBjbG9ja3dpc2VGcm9udEZhY2U9JHt0aGlzLmNsb2Nrd2lzZUZyb250RmFjZX0gY3VsbGluZz0ke3RoaXMuY3VsbGluZ30gZGVwdGhNYXNrPSR7dGhpcy5kZXB0aE1hc2t9IHBvbHlnb25PZmZzZXQ9JHt0aGlzLnBvbHlnb25PZmZzZXR9XWA7XG4gIH1cbiAgc3RhdGljIGZvcjJkKCkge1xuICAgIGNvbnN0IHN0YXRlID0gbmV3IFN0YXRlKCk7XG4gICAgc3RhdGUuZGVwdGhUZXN0ID0gZmFsc2U7XG4gICAgc3RhdGUuYmxlbmQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5leHBvcnQgeyBTdGF0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RhdGUubWpzLm1hcFxuIiwiY29uc3QgSU5TVEFMTEVEID0gW107XG5mdW5jdGlvbiBhdXRvRGV0ZWN0UmVzb3VyY2Uoc291cmNlLCBvcHRpb25zKSB7XG4gIGlmICghc291cmNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IGV4dGVuc2lvbiA9IFwiXCI7XG4gIGlmICh0eXBlb2Ygc291cmNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gL1xcLihcXHd7Myw0fSkoPzokfFxcP3wjKS9pLmV4ZWMoc291cmNlKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBleHRlbnNpb24gPSByZXN1bHRbMV0udG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IElOU1RBTExFRC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGNvbnN0IFJlc291cmNlUGx1Z2luID0gSU5TVEFMTEVEW2ldO1xuICAgIGlmIChSZXNvdXJjZVBsdWdpbi50ZXN0ICYmIFJlc291cmNlUGx1Z2luLnRlc3Qoc291cmNlLCBleHRlbnNpb24pKSB7XG4gICAgICByZXR1cm4gbmV3IFJlc291cmNlUGx1Z2luKHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBzb3VyY2UgdHlwZSB0byBhdXRvLWRldGVjdCBSZXNvdXJjZVwiKTtcbn1cblxuZXhwb3J0IHsgSU5TVEFMTEVELCBhdXRvRGV0ZWN0UmVzb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dG9EZXRlY3RSZXNvdXJjZS5tanMubWFwXG4iLCJjbGFzcyBSdW5uZXIge1xuICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgIHRoaXMuX2FsaWFzQ291bnQgPSAwO1xuICB9XG4gIGVtaXQoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiA4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXggYXJndW1lbnRzIHJlYWNoZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHsgbmFtZSwgaXRlbXMgfSA9IHRoaXM7XG4gICAgdGhpcy5fYWxpYXNDb3VudCsrO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaXRlbXNbaV1bbmFtZV0oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KTtcbiAgICB9XG4gICAgaWYgKGl0ZW1zID09PSB0aGlzLml0ZW1zKSB7XG4gICAgICB0aGlzLl9hbGlhc0NvdW50LS07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGVuc3VyZU5vbkFsaWFzZWRJdGVtcygpIHtcbiAgICBpZiAodGhpcy5fYWxpYXNDb3VudCA+IDAgJiYgdGhpcy5pdGVtcy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLl9hbGlhc0NvdW50ID0gMDtcbiAgICAgIHRoaXMuaXRlbXMgPSB0aGlzLml0ZW1zLnNsaWNlKDApO1xuICAgIH1cbiAgfVxuICBhZGQoaXRlbSkge1xuICAgIGlmIChpdGVtW3RoaXMuX25hbWVdKSB7XG4gICAgICB0aGlzLmVuc3VyZU5vbkFsaWFzZWRJdGVtcygpO1xuICAgICAgdGhpcy5yZW1vdmUoaXRlbSk7XG4gICAgICB0aGlzLml0ZW1zLnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlbW92ZShpdGVtKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5lbnN1cmVOb25BbGlhc2VkSXRlbXMoKTtcbiAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY29udGFpbnMoaXRlbSkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLmluY2x1ZGVzKGl0ZW0pO1xuICB9XG4gIHJlbW92ZUFsbCgpIHtcbiAgICB0aGlzLmVuc3VyZU5vbkFsaWFzZWRJdGVtcygpO1xuICAgIHRoaXMuaXRlbXMubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVtb3ZlQWxsKCk7XG4gICAgdGhpcy5pdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fbmFtZSA9IG51bGw7XG4gIH1cbiAgZ2V0IGVtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUnVubmVyLnByb3RvdHlwZSwge1xuICBkaXNwYXRjaDogeyB2YWx1ZTogUnVubmVyLnByb3RvdHlwZS5lbWl0IH0sXG4gIHJ1bjogeyB2YWx1ZTogUnVubmVyLnByb3RvdHlwZS5lbWl0IH1cbn0pO1xuXG5leHBvcnQgeyBSdW5uZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJ1bm5lci5tanMubWFwXG4iLCJleHBvcnQgeyBSdW5uZXIgfSBmcm9tICcuL1J1bm5lci5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgUnVubmVyIH0gZnJvbSAnQHBpeGkvcnVubmVyJztcblxuY2xhc3MgUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3Rvcih3aWR0aCA9IDAsIGhlaWdodCA9IDApIHtcbiAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuaW50ZXJuYWwgPSBmYWxzZTtcbiAgICB0aGlzLm9uUmVzaXplID0gbmV3IFJ1bm5lcihcInNldFJlYWxTaXplXCIpO1xuICAgIHRoaXMub25VcGRhdGUgPSBuZXcgUnVubmVyKFwidXBkYXRlXCIpO1xuICAgIHRoaXMub25FcnJvciA9IG5ldyBSdW5uZXIoXCJvbkVycm9yXCIpO1xuICB9XG4gIGJpbmQoYmFzZVRleHR1cmUpIHtcbiAgICB0aGlzLm9uUmVzaXplLmFkZChiYXNlVGV4dHVyZSk7XG4gICAgdGhpcy5vblVwZGF0ZS5hZGQoYmFzZVRleHR1cmUpO1xuICAgIHRoaXMub25FcnJvci5hZGQoYmFzZVRleHR1cmUpO1xuICAgIGlmICh0aGlzLl93aWR0aCB8fCB0aGlzLl9oZWlnaHQpIHtcbiAgICAgIHRoaXMub25SZXNpemUuZW1pdCh0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICB9XG4gIH1cbiAgdW5iaW5kKGJhc2VUZXh0dXJlKSB7XG4gICAgdGhpcy5vblJlc2l6ZS5yZW1vdmUoYmFzZVRleHR1cmUpO1xuICAgIHRoaXMub25VcGRhdGUucmVtb3ZlKGJhc2VUZXh0dXJlKTtcbiAgICB0aGlzLm9uRXJyb3IucmVtb3ZlKGJhc2VUZXh0dXJlKTtcbiAgfVxuICByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICh3aWR0aCAhPT0gdGhpcy5fd2lkdGggfHwgaGVpZ2h0ICE9PSB0aGlzLl9oZWlnaHQpIHtcbiAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB0aGlzLm9uUmVzaXplLmVtaXQod2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICB9XG4gIGdldCB2YWxpZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl93aWR0aCAmJiAhIXRoaXMuX2hlaWdodDtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgdGhpcy5vblVwZGF0ZS5lbWl0KCk7XG4gICAgfVxuICB9XG4gIGxvYWQoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzKTtcbiAgfVxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICB9XG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgfVxuICBzdHlsZShfcmVuZGVyZXIsIF9iYXNlVGV4dHVyZSwgX2dsVGV4dHVyZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKCF0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICB0aGlzLm9uRXJyb3IucmVtb3ZlQWxsKCk7XG4gICAgICB0aGlzLm9uRXJyb3IgPSBudWxsO1xuICAgICAgdGhpcy5vblJlc2l6ZS5yZW1vdmVBbGwoKTtcbiAgICAgIHRoaXMub25SZXNpemUgPSBudWxsO1xuICAgICAgdGhpcy5vblVwZGF0ZS5yZW1vdmVBbGwoKTtcbiAgICAgIHRoaXMub25VcGRhdGUgPSBudWxsO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgdGVzdChfc291cmNlLCBfZXh0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCB7IFJlc291cmNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXNvdXJjZS5tanMubWFwXG4iLCJpbXBvcnQgeyBBTFBIQV9NT0RFUyB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBSZXNvdXJjZSB9IGZyb20gJy4vUmVzb3VyY2UubWpzJztcblxuY2xhc3MgQnVmZmVyUmVzb3VyY2UgZXh0ZW5kcyBSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZmZlclJlc291cmNlIHdpZHRoIG9yIGhlaWdodCBpbnZhbGlkXCIpO1xuICAgIH1cbiAgICBzdXBlcih3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmRhdGEgPSBzb3VyY2U7XG4gIH1cbiAgdXBsb2FkKHJlbmRlcmVyLCBiYXNlVGV4dHVyZSwgZ2xUZXh0dXJlKSB7XG4gICAgY29uc3QgZ2wgPSByZW5kZXJlci5nbDtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGJhc2VUZXh0dXJlLmFscGhhTW9kZSA9PT0gQUxQSEFfTU9ERVMuVU5QQUNLKTtcbiAgICBjb25zdCB3aWR0aCA9IGJhc2VUZXh0dXJlLnJlYWxXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBiYXNlVGV4dHVyZS5yZWFsSGVpZ2h0O1xuICAgIGlmIChnbFRleHR1cmUud2lkdGggPT09IHdpZHRoICYmIGdsVGV4dHVyZS5oZWlnaHQgPT09IGhlaWdodCkge1xuICAgICAgZ2wudGV4U3ViSW1hZ2UyRChiYXNlVGV4dHVyZS50YXJnZXQsIDAsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIGJhc2VUZXh0dXJlLmZvcm1hdCwgZ2xUZXh0dXJlLnR5cGUsIHRoaXMuZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsVGV4dHVyZS53aWR0aCA9IHdpZHRoO1xuICAgICAgZ2xUZXh0dXJlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIGdsLnRleEltYWdlMkQoYmFzZVRleHR1cmUudGFyZ2V0LCAwLCBnbFRleHR1cmUuaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGJhc2VUZXh0dXJlLmZvcm1hdCwgZ2xUZXh0dXJlLnR5cGUsIHRoaXMuZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgdGVzdChzb3VyY2UpIHtcbiAgICByZXR1cm4gc291cmNlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8IHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgc291cmNlIGluc3RhbmNlb2YgVWludDMyQXJyYXk7XG4gIH1cbn1cblxuZXhwb3J0IHsgQnVmZmVyUmVzb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1ZmZlclJlc291cmNlLm1qcy5tYXBcbiIsImltcG9ydCB7IFNDQUxFX01PREVTLCBGT1JNQVRTLCBBTFBIQV9NT0RFUywgVFlQRVMsIE1JUE1BUF9NT0RFUywgV1JBUF9NT0RFUywgVEFSR0VUUyB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gJ0BwaXhpL3NldHRpbmdzJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciwgdWlkLCBpc1BvdzIsIEJhc2VUZXh0dXJlQ2FjaGUsIFRleHR1cmVDYWNoZSB9IGZyb20gJ0BwaXhpL3V0aWxzJztcbmltcG9ydCB7IGF1dG9EZXRlY3RSZXNvdXJjZSB9IGZyb20gJy4vcmVzb3VyY2VzL2F1dG9EZXRlY3RSZXNvdXJjZS5tanMnO1xuaW1wb3J0IHsgQnVmZmVyUmVzb3VyY2UgfSBmcm9tICcuL3Jlc291cmNlcy9CdWZmZXJSZXNvdXJjZS5tanMnO1xuaW1wb3J0IHsgUmVzb3VyY2UgfSBmcm9tICcuL3Jlc291cmNlcy9SZXNvdXJjZS5tanMnO1xuXG5jb25zdCBkZWZhdWx0QnVmZmVyT3B0aW9ucyA9IHtcbiAgc2NhbGVNb2RlOiBTQ0FMRV9NT0RFUy5ORUFSRVNULFxuICBmb3JtYXQ6IEZPUk1BVFMuUkdCQSxcbiAgYWxwaGFNb2RlOiBBTFBIQV9NT0RFUy5OUE1cbn07XG5jb25zdCBfQmFzZVRleHR1cmUgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKHJlc291cmNlID0gbnVsbCwgb3B0aW9ucyA9IG51bGwpIHtcbiAgICBzdXBlcigpO1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBfQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHtcbiAgICAgIGFscGhhTW9kZSxcbiAgICAgIG1pcG1hcCxcbiAgICAgIGFuaXNvdHJvcGljTGV2ZWwsXG4gICAgICBzY2FsZU1vZGUsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHdyYXBNb2RlLFxuICAgICAgZm9ybWF0LFxuICAgICAgdHlwZSxcbiAgICAgIHRhcmdldCxcbiAgICAgIHJlc29sdXRpb24sXG4gICAgICByZXNvdXJjZU9wdGlvbnNcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAocmVzb3VyY2UgJiYgIShyZXNvdXJjZSBpbnN0YW5jZW9mIFJlc291cmNlKSkge1xuICAgICAgcmVzb3VyY2UgPSBhdXRvRGV0ZWN0UmVzb3VyY2UocmVzb3VyY2UsIHJlc291cmNlT3B0aW9ucyk7XG4gICAgICByZXNvdXJjZS5pbnRlcm5hbCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgc2V0dGluZ3MuUkVTT0xVVElPTjtcbiAgICB0aGlzLndpZHRoID0gTWF0aC5yb3VuZCgod2lkdGggfHwgMCkgKiB0aGlzLnJlc29sdXRpb24pIC8gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5yb3VuZCgoaGVpZ2h0IHx8IDApICogdGhpcy5yZXNvbHV0aW9uKSAvIHRoaXMucmVzb2x1dGlvbjtcbiAgICB0aGlzLl9taXBtYXAgPSBtaXBtYXA7XG4gICAgdGhpcy5hbmlzb3Ryb3BpY0xldmVsID0gYW5pc290cm9waWNMZXZlbDtcbiAgICB0aGlzLl93cmFwTW9kZSA9IHdyYXBNb2RlO1xuICAgIHRoaXMuX3NjYWxlTW9kZSA9IHNjYWxlTW9kZTtcbiAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMuYWxwaGFNb2RlID0gYWxwaGFNb2RlO1xuICAgIHRoaXMudWlkID0gdWlkKCk7XG4gICAgdGhpcy50b3VjaGVkID0gMDtcbiAgICB0aGlzLmlzUG93ZXJPZlR3byA9IGZhbHNlO1xuICAgIHRoaXMuX3JlZnJlc2hQT1QoKTtcbiAgICB0aGlzLl9nbFRleHR1cmVzID0ge307XG4gICAgdGhpcy5kaXJ0eUlkID0gMDtcbiAgICB0aGlzLmRpcnR5U3R5bGVJZCA9IDA7XG4gICAgdGhpcy5jYWNoZUlkID0gbnVsbDtcbiAgICB0aGlzLnZhbGlkID0gd2lkdGggPiAwICYmIGhlaWdodCA+IDA7XG4gICAgdGhpcy50ZXh0dXJlQ2FjaGVJZHMgPSBbXTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMucmVzb3VyY2UgPSBudWxsO1xuICAgIHRoaXMuX2JhdGNoRW5hYmxlZCA9IDA7XG4gICAgdGhpcy5fYmF0Y2hMb2NhdGlvbiA9IDA7XG4gICAgdGhpcy5wYXJlbnRUZXh0dXJlQXJyYXkgPSBudWxsO1xuICAgIHRoaXMuc2V0UmVzb3VyY2UocmVzb3VyY2UpO1xuICB9XG4gIGdldCByZWFsV2lkdGgoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy53aWR0aCAqIHRoaXMucmVzb2x1dGlvbik7XG4gIH1cbiAgZ2V0IHJlYWxIZWlnaHQoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy5oZWlnaHQgKiB0aGlzLnJlc29sdXRpb24pO1xuICB9XG4gIGdldCBtaXBtYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pcG1hcDtcbiAgfVxuICBzZXQgbWlwbWFwKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX21pcG1hcCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX21pcG1hcCA9IHZhbHVlO1xuICAgICAgdGhpcy5kaXJ0eVN0eWxlSWQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IHNjYWxlTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2NhbGVNb2RlO1xuICB9XG4gIHNldCBzY2FsZU1vZGUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fc2NhbGVNb2RlICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fc2NhbGVNb2RlID0gdmFsdWU7XG4gICAgICB0aGlzLmRpcnR5U3R5bGVJZCsrO1xuICAgIH1cbiAgfVxuICBnZXQgd3JhcE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyYXBNb2RlO1xuICB9XG4gIHNldCB3cmFwTW9kZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl93cmFwTW9kZSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX3dyYXBNb2RlID0gdmFsdWU7XG4gICAgICB0aGlzLmRpcnR5U3R5bGVJZCsrO1xuICAgIH1cbiAgfVxuICBzZXRTdHlsZShzY2FsZU1vZGUsIG1pcG1hcCkge1xuICAgIGxldCBkaXJ0eTtcbiAgICBpZiAoc2NhbGVNb2RlICE9PSB2b2lkIDAgJiYgc2NhbGVNb2RlICE9PSB0aGlzLnNjYWxlTW9kZSkge1xuICAgICAgdGhpcy5zY2FsZU1vZGUgPSBzY2FsZU1vZGU7XG4gICAgICBkaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChtaXBtYXAgIT09IHZvaWQgMCAmJiBtaXBtYXAgIT09IHRoaXMubWlwbWFwKSB7XG4gICAgICB0aGlzLm1pcG1hcCA9IG1pcG1hcDtcbiAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGRpcnR5KSB7XG4gICAgICB0aGlzLmRpcnR5U3R5bGVJZCsrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRTaXplKGRlc2lyZWRXaWR0aCwgZGVzaXJlZEhlaWdodCwgcmVzb2x1dGlvbikge1xuICAgIHJlc29sdXRpb24gPSByZXNvbHV0aW9uIHx8IHRoaXMucmVzb2x1dGlvbjtcbiAgICByZXR1cm4gdGhpcy5zZXRSZWFsU2l6ZShkZXNpcmVkV2lkdGggKiByZXNvbHV0aW9uLCBkZXNpcmVkSGVpZ2h0ICogcmVzb2x1dGlvbiwgcmVzb2x1dGlvbik7XG4gIH1cbiAgc2V0UmVhbFNpemUocmVhbFdpZHRoLCByZWFsSGVpZ2h0LCByZXNvbHV0aW9uKSB7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCB0aGlzLnJlc29sdXRpb247XG4gICAgdGhpcy53aWR0aCA9IE1hdGgucm91bmQocmVhbFdpZHRoKSAvIHRoaXMucmVzb2x1dGlvbjtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgucm91bmQocmVhbEhlaWdodCkgLyB0aGlzLnJlc29sdXRpb247XG4gICAgdGhpcy5fcmVmcmVzaFBPVCgpO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgX3JlZnJlc2hQT1QoKSB7XG4gICAgdGhpcy5pc1Bvd2VyT2ZUd28gPSBpc1BvdzIodGhpcy5yZWFsV2lkdGgpICYmIGlzUG93Mih0aGlzLnJlYWxIZWlnaHQpO1xuICB9XG4gIHNldFJlc29sdXRpb24ocmVzb2x1dGlvbikge1xuICAgIGNvbnN0IG9sZFJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG4gICAgaWYgKG9sZFJlc29sdXRpb24gPT09IHJlc29sdXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgIGlmICh0aGlzLnZhbGlkKSB7XG4gICAgICB0aGlzLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLndpZHRoICogb2xkUmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xuICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLnJvdW5kKHRoaXMuaGVpZ2h0ICogb2xkUmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xuICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl9yZWZyZXNoUE9UKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0UmVzb3VyY2UocmVzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5yZXNvdXJjZSA9PT0gcmVzb3VyY2UpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZXNvdXJjZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVzb3VyY2UgY2FuIGJlIHNldCBvbmx5IG9uY2VcIik7XG4gICAgfVxuICAgIHJlc291cmNlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5yZXNvdXJjZSA9IHJlc291cmNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMudmFsaWQpIHtcbiAgICAgIGlmICh0aGlzLndpZHRoID4gMCAmJiB0aGlzLmhlaWdodCA+IDApIHtcbiAgICAgICAgdGhpcy52YWxpZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdChcImxvYWRlZFwiLCB0aGlzKTtcbiAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpcnR5SWQrKztcbiAgICAgIHRoaXMuZGlydHlTdHlsZUlkKys7XG4gICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgdGhpcyk7XG4gICAgfVxuICB9XG4gIG9uRXJyb3IoZXZlbnQpIHtcbiAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCB0aGlzLCBldmVudCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5yZXNvdXJjZSkge1xuICAgICAgdGhpcy5yZXNvdXJjZS51bmJpbmQodGhpcyk7XG4gICAgICBpZiAodGhpcy5yZXNvdXJjZS5pbnRlcm5hbCkge1xuICAgICAgICB0aGlzLnJlc291cmNlLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzb3VyY2UgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5jYWNoZUlkKSB7XG4gICAgICBkZWxldGUgQmFzZVRleHR1cmVDYWNoZVt0aGlzLmNhY2hlSWRdO1xuICAgICAgZGVsZXRlIFRleHR1cmVDYWNoZVt0aGlzLmNhY2hlSWRdO1xuICAgICAgdGhpcy5jYWNoZUlkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgX0Jhc2VUZXh0dXJlLnJlbW92ZUZyb21DYWNoZSh0aGlzKTtcbiAgICB0aGlzLnRleHR1cmVDYWNoZUlkcyA9IG51bGw7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5lbWl0KFwiZGlzcG9zZVwiLCB0aGlzKTtcbiAgfVxuICBjYXN0VG9CYXNlVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdGF0aWMgZnJvbShzb3VyY2UsIG9wdGlvbnMsIHN0cmljdCA9IHNldHRpbmdzLlNUUklDVF9URVhUVVJFX0NBQ0hFKSB7XG4gICAgY29uc3QgaXNGcmFtZSA9IHR5cGVvZiBzb3VyY2UgPT09IFwic3RyaW5nXCI7XG4gICAgbGV0IGNhY2hlSWQgPSBudWxsO1xuICAgIGlmIChpc0ZyYW1lKSB7XG4gICAgICBjYWNoZUlkID0gc291cmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXNvdXJjZS5fcGl4aUlkKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IG9wdGlvbnM/LnBpeGlJZFByZWZpeCB8fCBcInBpeGlpZFwiO1xuICAgICAgICBzb3VyY2UuX3BpeGlJZCA9IGAke3ByZWZpeH1fJHt1aWQoKX1gO1xuICAgICAgfVxuICAgICAgY2FjaGVJZCA9IHNvdXJjZS5fcGl4aUlkO1xuICAgIH1cbiAgICBsZXQgYmFzZVRleHR1cmUgPSBCYXNlVGV4dHVyZUNhY2hlW2NhY2hlSWRdO1xuICAgIGlmIChpc0ZyYW1lICYmIHN0cmljdCAmJiAhYmFzZVRleHR1cmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGNhY2hlSWQgXCIke2NhY2hlSWR9XCIgZG9lcyBub3QgZXhpc3QgaW4gQmFzZVRleHR1cmVDYWNoZS5gKTtcbiAgICB9XG4gICAgaWYgKCFiYXNlVGV4dHVyZSkge1xuICAgICAgYmFzZVRleHR1cmUgPSBuZXcgX0Jhc2VUZXh0dXJlKHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgICBiYXNlVGV4dHVyZS5jYWNoZUlkID0gY2FjaGVJZDtcbiAgICAgIF9CYXNlVGV4dHVyZS5hZGRUb0NhY2hlKGJhc2VUZXh0dXJlLCBjYWNoZUlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2VUZXh0dXJlO1xuICB9XG4gIHN0YXRpYyBmcm9tQnVmZmVyKGJ1ZmZlciwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuICAgIGJ1ZmZlciA9IGJ1ZmZlciB8fCBuZXcgRmxvYXQzMkFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgY29uc3QgcmVzb3VyY2UgPSBuZXcgQnVmZmVyUmVzb3VyY2UoYnVmZmVyLCB7IHdpZHRoLCBoZWlnaHQgfSk7XG4gICAgY29uc3QgdHlwZSA9IGJ1ZmZlciBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSA/IFRZUEVTLkZMT0FUIDogVFlQRVMuVU5TSUdORURfQllURTtcbiAgICByZXR1cm4gbmV3IF9CYXNlVGV4dHVyZShyZXNvdXJjZSwgT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdEJ1ZmZlck9wdGlvbnMsIHsgdHlwZSB9LCBvcHRpb25zKSk7XG4gIH1cbiAgc3RhdGljIGFkZFRvQ2FjaGUoYmFzZVRleHR1cmUsIGlkKSB7XG4gICAgaWYgKGlkKSB7XG4gICAgICBpZiAoIWJhc2VUZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5pbmNsdWRlcyhpZCkpIHtcbiAgICAgICAgYmFzZVRleHR1cmUudGV4dHVyZUNhY2hlSWRzLnB1c2goaWQpO1xuICAgICAgfVxuICAgICAgaWYgKEJhc2VUZXh0dXJlQ2FjaGVbaWRdICYmIEJhc2VUZXh0dXJlQ2FjaGVbaWRdICE9PSBiYXNlVGV4dHVyZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYEJhc2VUZXh0dXJlIGFkZGVkIHRvIHRoZSBjYWNoZSB3aXRoIGFuIGlkIFske2lkfV0gdGhhdCBhbHJlYWR5IGhhZCBhbiBlbnRyeWApO1xuICAgICAgfVxuICAgICAgQmFzZVRleHR1cmVDYWNoZVtpZF0gPSBiYXNlVGV4dHVyZTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHJlbW92ZUZyb21DYWNoZShiYXNlVGV4dHVyZSkge1xuICAgIGlmICh0eXBlb2YgYmFzZVRleHR1cmUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IGJhc2VUZXh0dXJlRnJvbUNhY2hlID0gQmFzZVRleHR1cmVDYWNoZVtiYXNlVGV4dHVyZV07XG4gICAgICBpZiAoYmFzZVRleHR1cmVGcm9tQ2FjaGUpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBiYXNlVGV4dHVyZUZyb21DYWNoZS50ZXh0dXJlQ2FjaGVJZHMuaW5kZXhPZihiYXNlVGV4dHVyZSk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgYmFzZVRleHR1cmVGcm9tQ2FjaGUudGV4dHVyZUNhY2hlSWRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIEJhc2VUZXh0dXJlQ2FjaGVbYmFzZVRleHR1cmVdO1xuICAgICAgICByZXR1cm4gYmFzZVRleHR1cmVGcm9tQ2FjaGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChiYXNlVGV4dHVyZT8udGV4dHVyZUNhY2hlSWRzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2VUZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBkZWxldGUgQmFzZVRleHR1cmVDYWNoZVtiYXNlVGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHNbaV1dO1xuICAgICAgfVxuICAgICAgYmFzZVRleHR1cmUudGV4dHVyZUNhY2hlSWRzLmxlbmd0aCA9IDA7XG4gICAgICByZXR1cm4gYmFzZVRleHR1cmU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xubGV0IEJhc2VUZXh0dXJlID0gX0Jhc2VUZXh0dXJlO1xuQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMgPSB7XG4gIG1pcG1hcDogTUlQTUFQX01PREVTLlBPVzIsXG4gIGFuaXNvdHJvcGljTGV2ZWw6IDAsXG4gIHNjYWxlTW9kZTogU0NBTEVfTU9ERVMuTElORUFSLFxuICB3cmFwTW9kZTogV1JBUF9NT0RFUy5DTEFNUCxcbiAgYWxwaGFNb2RlOiBBTFBIQV9NT0RFUy5VTlBBQ0ssXG4gIHRhcmdldDogVEFSR0VUUy5URVhUVVJFXzJELFxuICBmb3JtYXQ6IEZPUk1BVFMuUkdCQSxcbiAgdHlwZTogVFlQRVMuVU5TSUdORURfQllURVxufTtcbkJhc2VUZXh0dXJlLl9nbG9iYWxCYXRjaCA9IDA7XG5cbmV4cG9ydCB7IEJhc2VUZXh0dXJlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlVGV4dHVyZS5tanMubWFwXG4iLCJpbXBvcnQgeyBEUkFXX01PREVTIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcblxuY2xhc3MgQmF0Y2hEcmF3Q2FsbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudGV4QXJyYXkgPSBudWxsO1xuICAgIHRoaXMuYmxlbmQgPSAwO1xuICAgIHRoaXMudHlwZSA9IERSQVdfTU9ERVMuVFJJQU5HTEVTO1xuICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgeyBCYXRjaERyYXdDYWxsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXRjaERyYXdDYWxsLm1qcy5tYXBcbiIsImltcG9ydCB7IEJVRkZFUl9UWVBFIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcbmltcG9ydCB7IFJ1bm5lciB9IGZyb20gJ0BwaXhpL3J1bm5lcic7XG5cbmxldCBVSUQgPSAwO1xuY2xhc3MgQnVmZmVyIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgX3N0YXRpYyA9IHRydWUsIGluZGV4ID0gZmFsc2UpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IG5ldyBGbG9hdDMyQXJyYXkoMSk7XG4gICAgdGhpcy5fZ2xCdWZmZXJzID0ge307XG4gICAgdGhpcy5fdXBkYXRlSUQgPSAwO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLnN0YXRpYyA9IF9zdGF0aWM7XG4gICAgdGhpcy5pZCA9IFVJRCsrO1xuICAgIHRoaXMuZGlzcG9zZVJ1bm5lciA9IG5ldyBSdW5uZXIoXCJkaXNwb3NlQnVmZmVyXCIpO1xuICB9XG4gIHVwZGF0ZShkYXRhKSB7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSk7XG4gICAgfVxuICAgIHRoaXMuZGF0YSA9IGRhdGEgfHwgdGhpcy5kYXRhO1xuICAgIHRoaXMuX3VwZGF0ZUlEKys7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmRpc3Bvc2VSdW5uZXIuZW1pdCh0aGlzLCBmYWxzZSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICB9XG4gIHNldCBpbmRleCh2YWx1ZSkge1xuICAgIHRoaXMudHlwZSA9IHZhbHVlID8gQlVGRkVSX1RZUEUuRUxFTUVOVF9BUlJBWV9CVUZGRVIgOiBCVUZGRVJfVFlQRS5BUlJBWV9CVUZGRVI7XG4gIH1cbiAgZ2V0IGluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IEJVRkZFUl9UWVBFLkVMRU1FTlRfQVJSQVlfQlVGRkVSO1xuICB9XG4gIHN0YXRpYyBmcm9tKGRhdGEpIHtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoZGF0YSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgQnVmZmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CdWZmZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgVFlQRVMgfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuXG5jbGFzcyBBdHRyaWJ1dGUge1xuICBjb25zdHJ1Y3RvcihidWZmZXIsIHNpemUgPSAwLCBub3JtYWxpemVkID0gZmFsc2UsIHR5cGUgPSBUWVBFUy5GTE9BVCwgc3RyaWRlLCBzdGFydCwgaW5zdGFuY2UsIGRpdmlzb3IgPSAxKSB7XG4gICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5zdHJpZGUgPSBzdHJpZGU7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICB0aGlzLmRpdmlzb3IgPSBkaXZpc29yO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICB9XG4gIHN0YXRpYyBmcm9tKGJ1ZmZlciwgc2l6ZSwgbm9ybWFsaXplZCwgdHlwZSwgc3RyaWRlKSB7XG4gICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGUoYnVmZmVyLCBzaXplLCBub3JtYWxpemVkLCB0eXBlLCBzdHJpZGUpO1xuICB9XG59XG5cbmV4cG9ydCB7IEF0dHJpYnV0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXR0cmlidXRlLm1qcy5tYXBcbiIsImltcG9ydCB7IGdldEJ1ZmZlclR5cGUgfSBmcm9tICdAcGl4aS91dGlscyc7XG5cbmNvbnN0IG1hcCA9IHtcbiAgRmxvYXQzMkFycmF5LFxuICBVaW50MzJBcnJheSxcbiAgSW50MzJBcnJheSxcbiAgVWludDhBcnJheVxufTtcbmZ1bmN0aW9uIGludGVybGVhdmVUeXBlZEFycmF5cyhhcnJheXMsIHNpemVzKSB7XG4gIGxldCBvdXRTaXplID0gMDtcbiAgbGV0IHN0cmlkZSA9IDA7XG4gIGNvbnN0IHZpZXdzID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3RyaWRlICs9IHNpemVzW2ldO1xuICAgIG91dFNpemUgKz0gYXJyYXlzW2ldLmxlbmd0aDtcbiAgfVxuICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIob3V0U2l6ZSAqIDQpO1xuICBsZXQgb3V0ID0gbnVsbDtcbiAgbGV0IGxpdHRsZU9mZnNldCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHNpemVzW2ldO1xuICAgIGNvbnN0IGFycmF5ID0gYXJyYXlzW2ldO1xuICAgIGNvbnN0IHR5cGUgPSBnZXRCdWZmZXJUeXBlKGFycmF5KTtcbiAgICBpZiAoIXZpZXdzW3R5cGVdKSB7XG4gICAgICB2aWV3c1t0eXBlXSA9IG5ldyBtYXBbdHlwZV0oYnVmZmVyKTtcbiAgICB9XG4gICAgb3V0ID0gdmlld3NbdHlwZV07XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBhcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3QgaW5kZXhTdGFydCA9IChqIC8gc2l6ZSB8IDApICogc3RyaWRlICsgbGl0dGxlT2Zmc2V0O1xuICAgICAgY29uc3QgaW5kZXggPSBqICUgc2l6ZTtcbiAgICAgIG91dFtpbmRleFN0YXJ0ICsgaW5kZXhdID0gYXJyYXlbal07XG4gICAgfVxuICAgIGxpdHRsZU9mZnNldCArPSBzaXplO1xuICB9XG4gIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XG59XG5cbmV4cG9ydCB7IGludGVybGVhdmVUeXBlZEFycmF5cyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJsZWF2ZVR5cGVkQXJyYXlzLm1qcy5tYXBcbiIsImltcG9ydCB7IEJVRkZFUl9UWVBFIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcbmltcG9ydCB7IFJ1bm5lciB9IGZyb20gJ0BwaXhpL3J1bm5lcic7XG5pbXBvcnQgeyBnZXRCdWZmZXJUeXBlIH0gZnJvbSAnQHBpeGkvdXRpbHMnO1xuaW1wb3J0IHsgQXR0cmlidXRlIH0gZnJvbSAnLi9BdHRyaWJ1dGUubWpzJztcbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJy4vQnVmZmVyLm1qcyc7XG5pbXBvcnQgeyBpbnRlcmxlYXZlVHlwZWRBcnJheXMgfSBmcm9tICcuL3V0aWxzL2ludGVybGVhdmVUeXBlZEFycmF5cy5tanMnO1xuXG5jb25zdCBieXRlU2l6ZU1hcCA9IHsgNTEyNjogNCwgNTEyMzogMiwgNTEyMTogMSB9O1xubGV0IFVJRCA9IDA7XG5jb25zdCBtYXAgPSB7XG4gIEZsb2F0MzJBcnJheSxcbiAgVWludDMyQXJyYXksXG4gIEludDMyQXJyYXksXG4gIFVpbnQ4QXJyYXksXG4gIFVpbnQxNkFycmF5XG59O1xuY2xhc3MgR2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvcihidWZmZXJzID0gW10sIGF0dHJpYnV0ZXMgPSB7fSkge1xuICAgIHRoaXMuYnVmZmVycyA9IGJ1ZmZlcnM7XG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICB0aGlzLmdsVmVydGV4QXJyYXlPYmplY3RzID0ge307XG4gICAgdGhpcy5pZCA9IFVJRCsrO1xuICAgIHRoaXMuaW5zdGFuY2VkID0gZmFsc2U7XG4gICAgdGhpcy5pbnN0YW5jZUNvdW50ID0gMTtcbiAgICB0aGlzLmRpc3Bvc2VSdW5uZXIgPSBuZXcgUnVubmVyKFwiZGlzcG9zZUdlb21ldHJ5XCIpO1xuICAgIHRoaXMucmVmQ291bnQgPSAwO1xuICB9XG4gIGFkZEF0dHJpYnV0ZShpZCwgYnVmZmVyLCBzaXplID0gMCwgbm9ybWFsaXplZCA9IGZhbHNlLCB0eXBlLCBzdHJpZGUsIHN0YXJ0LCBpbnN0YW5jZSA9IGZhbHNlKSB7XG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgYSBidWZmZXIgd2hlbiBjcmVhdGluZyBhbiBhdHRyaWJ1dGVcIik7XG4gICAgfVxuICAgIGlmICghKGJ1ZmZlciBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBidWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XG4gICAgICB9XG4gICAgICBidWZmZXIgPSBuZXcgQnVmZmVyKGJ1ZmZlcik7XG4gICAgfVxuICAgIGNvbnN0IGlkcyA9IGlkLnNwbGl0KFwifFwiKTtcbiAgICBpZiAoaWRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKGlkc1tpXSwgYnVmZmVyLCBzaXplLCBub3JtYWxpemVkLCB0eXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBsZXQgYnVmZmVySW5kZXggPSB0aGlzLmJ1ZmZlcnMuaW5kZXhPZihidWZmZXIpO1xuICAgIGlmIChidWZmZXJJbmRleCA9PT0gLTEpIHtcbiAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGJ1ZmZlcik7XG4gICAgICBidWZmZXJJbmRleCA9IHRoaXMuYnVmZmVycy5sZW5ndGggLSAxO1xuICAgIH1cbiAgICB0aGlzLmF0dHJpYnV0ZXNbaWRdID0gbmV3IEF0dHJpYnV0ZShidWZmZXJJbmRleCwgc2l6ZSwgbm9ybWFsaXplZCwgdHlwZSwgc3RyaWRlLCBzdGFydCwgaW5zdGFuY2UpO1xuICAgIHRoaXMuaW5zdGFuY2VkID0gdGhpcy5pbnN0YW5jZWQgfHwgaW5zdGFuY2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0QXR0cmlidXRlKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1tpZF07XG4gIH1cbiAgZ2V0QnVmZmVyKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyc1t0aGlzLmdldEF0dHJpYnV0ZShpZCkuYnVmZmVyXTtcbiAgfVxuICBhZGRJbmRleChidWZmZXIpIHtcbiAgICBpZiAoIShidWZmZXIgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlcik7XG4gICAgICB9XG4gICAgICBidWZmZXIgPSBuZXcgQnVmZmVyKGJ1ZmZlcik7XG4gICAgfVxuICAgIGJ1ZmZlci50eXBlID0gQlVGRkVSX1RZUEUuRUxFTUVOVF9BUlJBWV9CVUZGRVI7XG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICBpZiAoIXRoaXMuYnVmZmVycy5pbmNsdWRlcyhidWZmZXIpKSB7XG4gICAgICB0aGlzLmJ1ZmZlcnMucHVzaChidWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXRJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleEJ1ZmZlcjtcbiAgfVxuICBpbnRlcmxlYXZlKCkge1xuICAgIGlmICh0aGlzLmJ1ZmZlcnMubGVuZ3RoID09PSAxIHx8IHRoaXMuYnVmZmVycy5sZW5ndGggPT09IDIgJiYgdGhpcy5pbmRleEJ1ZmZlcilcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IGFycmF5cyA9IFtdO1xuICAgIGNvbnN0IHNpemVzID0gW107XG4gICAgY29uc3QgaW50ZXJsZWF2ZWRCdWZmZXIgPSBuZXcgQnVmZmVyKCk7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzW2ldO1xuICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXJzW2F0dHJpYnV0ZS5idWZmZXJdO1xuICAgICAgYXJyYXlzLnB1c2goYnVmZmVyLmRhdGEpO1xuICAgICAgc2l6ZXMucHVzaChhdHRyaWJ1dGUuc2l6ZSAqIGJ5dGVTaXplTWFwW2F0dHJpYnV0ZS50eXBlXSAvIDQpO1xuICAgICAgYXR0cmlidXRlLmJ1ZmZlciA9IDA7XG4gICAgfVxuICAgIGludGVybGVhdmVkQnVmZmVyLmRhdGEgPSBpbnRlcmxlYXZlVHlwZWRBcnJheXMoYXJyYXlzLCBzaXplcyk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuYnVmZmVyc1tpXSAhPT0gdGhpcy5pbmRleEJ1ZmZlcikge1xuICAgICAgICB0aGlzLmJ1ZmZlcnNbaV0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmJ1ZmZlcnMgPSBbaW50ZXJsZWF2ZWRCdWZmZXJdO1xuICAgIGlmICh0aGlzLmluZGV4QnVmZmVyKSB7XG4gICAgICB0aGlzLmJ1ZmZlcnMucHVzaCh0aGlzLmluZGV4QnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0U2l6ZSgpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXNbaV07XG4gICAgICBjb25zdCBidWZmZXIgPSB0aGlzLmJ1ZmZlcnNbYXR0cmlidXRlLmJ1ZmZlcl07XG4gICAgICByZXR1cm4gYnVmZmVyLmRhdGEubGVuZ3RoIC8gKGF0dHJpYnV0ZS5zdHJpZGUgLyA0IHx8IGF0dHJpYnV0ZS5zaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmRpc3Bvc2VSdW5uZXIuZW1pdCh0aGlzLCBmYWxzZSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB0aGlzLmJ1ZmZlcnMgPSBudWxsO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IG51bGw7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgR2VvbWV0cnkoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZ2VvbWV0cnkuYnVmZmVyc1tpXSA9IG5ldyBCdWZmZXIodGhpcy5idWZmZXJzW2ldLmRhdGEuc2xpY2UoMCkpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWIgPSB0aGlzLmF0dHJpYnV0ZXNbaV07XG4gICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzW2ldID0gbmV3IEF0dHJpYnV0ZShhdHRyaWIuYnVmZmVyLCBhdHRyaWIuc2l6ZSwgYXR0cmliLm5vcm1hbGl6ZWQsIGF0dHJpYi50eXBlLCBhdHRyaWIuc3RyaWRlLCBhdHRyaWIuc3RhcnQsIGF0dHJpYi5pbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmluZGV4QnVmZmVyKSB7XG4gICAgICBnZW9tZXRyeS5pbmRleEJ1ZmZlciA9IGdlb21ldHJ5LmJ1ZmZlcnNbdGhpcy5idWZmZXJzLmluZGV4T2YodGhpcy5pbmRleEJ1ZmZlcildO1xuICAgICAgZ2VvbWV0cnkuaW5kZXhCdWZmZXIudHlwZSA9IEJVRkZFUl9UWVBFLkVMRU1FTlRfQVJSQVlfQlVGRkVSO1xuICAgIH1cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbiAgc3RhdGljIG1lcmdlKGdlb21ldHJpZXMpIHtcbiAgICBjb25zdCBnZW9tZXRyeU91dCA9IG5ldyBHZW9tZXRyeSgpO1xuICAgIGNvbnN0IGFycmF5cyA9IFtdO1xuICAgIGNvbnN0IHNpemVzID0gW107XG4gICAgY29uc3Qgb2Zmc2V0cyA9IFtdO1xuICAgIGxldCBnZW9tZXRyeTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGdlb21ldHJ5ID0gZ2VvbWV0cmllc1tpXTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZ2VvbWV0cnkuYnVmZmVycy5sZW5ndGg7IGorKykge1xuICAgICAgICBzaXplc1tqXSA9IHNpemVzW2pdIHx8IDA7XG4gICAgICAgIHNpemVzW2pdICs9IGdlb21ldHJ5LmJ1ZmZlcnNbal0uZGF0YS5sZW5ndGg7XG4gICAgICAgIG9mZnNldHNbal0gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdlb21ldHJ5LmJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycmF5c1tpXSA9IG5ldyBtYXBbZ2V0QnVmZmVyVHlwZShnZW9tZXRyeS5idWZmZXJzW2ldLmRhdGEpXShzaXplc1tpXSk7XG4gICAgICBnZW9tZXRyeU91dC5idWZmZXJzW2ldID0gbmV3IEJ1ZmZlcihhcnJheXNbaV0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGdlb21ldHJ5ID0gZ2VvbWV0cmllc1tpXTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZ2VvbWV0cnkuYnVmZmVycy5sZW5ndGg7IGorKykge1xuICAgICAgICBhcnJheXNbal0uc2V0KGdlb21ldHJ5LmJ1ZmZlcnNbal0uZGF0YSwgb2Zmc2V0c1tqXSk7XG4gICAgICAgIG9mZnNldHNbal0gKz0gZ2VvbWV0cnkuYnVmZmVyc1tqXS5kYXRhLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VvbWV0cnlPdXQuYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgaWYgKGdlb21ldHJ5LmluZGV4QnVmZmVyKSB7XG4gICAgICBnZW9tZXRyeU91dC5pbmRleEJ1ZmZlciA9IGdlb21ldHJ5T3V0LmJ1ZmZlcnNbZ2VvbWV0cnkuYnVmZmVycy5pbmRleE9mKGdlb21ldHJ5LmluZGV4QnVmZmVyKV07XG4gICAgICBnZW9tZXRyeU91dC5pbmRleEJ1ZmZlci50eXBlID0gQlVGRkVSX1RZUEUuRUxFTUVOVF9BUlJBWV9CVUZGRVI7XG4gICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgIGxldCBzdHJpZGUgPSAwO1xuICAgICAgbGV0IG9mZnNldDIgPSAwO1xuICAgICAgbGV0IGJ1ZmZlckluZGV4VG9Db3VudCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdlb21ldHJ5LmJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGdlb21ldHJ5LmJ1ZmZlcnNbaV0gIT09IGdlb21ldHJ5LmluZGV4QnVmZmVyKSB7XG4gICAgICAgICAgYnVmZmVySW5kZXhUb0NvdW50ID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBpIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlc1tpXTtcbiAgICAgICAgaWYgKChhdHRyaWJ1dGUuYnVmZmVyIHwgMCkgPT09IGJ1ZmZlckluZGV4VG9Db3VudCkge1xuICAgICAgICAgIHN0cmlkZSArPSBhdHRyaWJ1dGUuc2l6ZSAqIGJ5dGVTaXplTWFwW2F0dHJpYnV0ZS50eXBlXSAvIDQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpbmRleEJ1ZmZlckRhdGEgPSBnZW9tZXRyaWVzW2ldLmluZGV4QnVmZmVyLmRhdGE7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5kZXhCdWZmZXJEYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgZ2VvbWV0cnlPdXQuaW5kZXhCdWZmZXIuZGF0YVtqICsgb2Zmc2V0Ml0gKz0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSBnZW9tZXRyaWVzW2ldLmJ1ZmZlcnNbYnVmZmVySW5kZXhUb0NvdW50XS5kYXRhLmxlbmd0aCAvIHN0cmlkZTtcbiAgICAgICAgb2Zmc2V0MiArPSBpbmRleEJ1ZmZlckRhdGEubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2VvbWV0cnlPdXQ7XG4gIH1cbn1cblxuZXhwb3J0IHsgR2VvbWV0cnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdlb21ldHJ5Lm1qcy5tYXBcbiIsImltcG9ydCB7IFRZUEVTIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJy4uL2dlb21ldHJ5L0J1ZmZlci5tanMnO1xuaW1wb3J0IHsgR2VvbWV0cnkgfSBmcm9tICcuLi9nZW9tZXRyeS9HZW9tZXRyeS5tanMnO1xuXG5jbGFzcyBCYXRjaEdlb21ldHJ5IGV4dGVuZHMgR2VvbWV0cnkge1xuICBjb25zdHJ1Y3Rvcihfc3RhdGljID0gZmFsc2UpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2J1ZmZlciA9IG5ldyBCdWZmZXIobnVsbCwgX3N0YXRpYywgZmFsc2UpO1xuICAgIHRoaXMuX2luZGV4QnVmZmVyID0gbmV3IEJ1ZmZlcihudWxsLCBfc3RhdGljLCB0cnVlKTtcbiAgICB0aGlzLmFkZEF0dHJpYnV0ZShcImFWZXJ0ZXhQb3NpdGlvblwiLCB0aGlzLl9idWZmZXIsIDIsIGZhbHNlLCBUWVBFUy5GTE9BVCkuYWRkQXR0cmlidXRlKFwiYVRleHR1cmVDb29yZFwiLCB0aGlzLl9idWZmZXIsIDIsIGZhbHNlLCBUWVBFUy5GTE9BVCkuYWRkQXR0cmlidXRlKFwiYUNvbG9yXCIsIHRoaXMuX2J1ZmZlciwgNCwgdHJ1ZSwgVFlQRVMuVU5TSUdORURfQllURSkuYWRkQXR0cmlidXRlKFwiYVRleHR1cmVJZFwiLCB0aGlzLl9idWZmZXIsIDEsIHRydWUsIFRZUEVTLkZMT0FUKS5hZGRJbmRleCh0aGlzLl9pbmRleEJ1ZmZlcik7XG4gIH1cbn1cblxuZXhwb3J0IHsgQmF0Y2hHZW9tZXRyeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hHZW9tZXRyeS5tanMubWFwXG4iLCJjb25zdCBQSV8yID0gTWF0aC5QSSAqIDI7XG5jb25zdCBSQURfVE9fREVHID0gMTgwIC8gTWF0aC5QSTtcbmNvbnN0IERFR19UT19SQUQgPSBNYXRoLlBJIC8gMTgwO1xudmFyIFNIQVBFUyA9IC8qIEBfX1BVUkVfXyAqLyAoKFNIQVBFUzIpID0+IHtcbiAgU0hBUEVTMltTSEFQRVMyW1wiUE9MWVwiXSA9IDBdID0gXCJQT0xZXCI7XG4gIFNIQVBFUzJbU0hBUEVTMltcIlJFQ1RcIl0gPSAxXSA9IFwiUkVDVFwiO1xuICBTSEFQRVMyW1NIQVBFUzJbXCJDSVJDXCJdID0gMl0gPSBcIkNJUkNcIjtcbiAgU0hBUEVTMltTSEFQRVMyW1wiRUxJUFwiXSA9IDNdID0gXCJFTElQXCI7XG4gIFNIQVBFUzJbU0hBUEVTMltcIlJSRUNcIl0gPSA0XSA9IFwiUlJFQ1wiO1xuICByZXR1cm4gU0hBUEVTMjtcbn0pKFNIQVBFUyB8fCB7fSk7XG5cbmV4cG9ydCB7IERFR19UT19SQUQsIFBJXzIsIFJBRF9UT19ERUcsIFNIQVBFUyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3QubWpzLm1hcFxuIiwiY2xhc3MgUG9pbnQge1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDApIHtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xuICB9XG4gIGNvcHlGcm9tKHApIHtcbiAgICB0aGlzLnNldChwLngsIHAueSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY29weVRvKHApIHtcbiAgICBwLnNldCh0aGlzLngsIHRoaXMueSk7XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgZXF1YWxzKHApIHtcbiAgICByZXR1cm4gcC54ID09PSB0aGlzLnggJiYgcC55ID09PSB0aGlzLnk7XG4gIH1cbiAgc2V0KHggPSAwLCB5ID0geCkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtAcGl4aS9tYXRoOlBvaW50IHg9JHt0aGlzLnh9IHk9JHt0aGlzLnl9XWA7XG4gIH1cbn1cblxuZXhwb3J0IHsgUG9pbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvaW50Lm1qcy5tYXBcbiIsImltcG9ydCB7IFNIQVBFUyB9IGZyb20gJy4uL2NvbnN0Lm1qcyc7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uL1BvaW50Lm1qcyc7XG5cbmNvbnN0IHRlbXBQb2ludHMgPSBbbmV3IFBvaW50KCksIG5ldyBQb2ludCgpLCBuZXcgUG9pbnQoKSwgbmV3IFBvaW50KCldO1xuY2xhc3MgUmVjdGFuZ2xlIHtcbiAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB3aWR0aCA9IDAsIGhlaWdodCA9IDApIHtcbiAgICB0aGlzLnggPSBOdW1iZXIoeCk7XG4gICAgdGhpcy55ID0gTnVtYmVyKHkpO1xuICAgIHRoaXMud2lkdGggPSBOdW1iZXIod2lkdGgpO1xuICAgIHRoaXMuaGVpZ2h0ID0gTnVtYmVyKGhlaWdodCk7XG4gICAgdGhpcy50eXBlID0gU0hBUEVTLlJFQ1Q7XG4gIH1cbiAgZ2V0IGxlZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMueDtcbiAgfVxuICBnZXQgcmlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XG4gIH1cbiAgZ2V0IHRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy55O1xuICB9XG4gIGdldCBib3R0b20oKSB7XG4gICAgcmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuICB9XG4gIHN0YXRpYyBnZXQgRU1QVFkoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoMCwgMCwgMCwgMCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgfVxuICBjb3B5RnJvbShyZWN0YW5nbGUpIHtcbiAgICB0aGlzLnggPSByZWN0YW5nbGUueDtcbiAgICB0aGlzLnkgPSByZWN0YW5nbGUueTtcbiAgICB0aGlzLndpZHRoID0gcmVjdGFuZ2xlLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gcmVjdGFuZ2xlLmhlaWdodDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb3B5VG8ocmVjdGFuZ2xlKSB7XG4gICAgcmVjdGFuZ2xlLnggPSB0aGlzLng7XG4gICAgcmVjdGFuZ2xlLnkgPSB0aGlzLnk7XG4gICAgcmVjdGFuZ2xlLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICByZWN0YW5nbGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgcmV0dXJuIHJlY3RhbmdsZTtcbiAgfVxuICBjb250YWlucyh4LCB5KSB7XG4gICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh4ID49IHRoaXMueCAmJiB4IDwgdGhpcy54ICsgdGhpcy53aWR0aCkge1xuICAgICAgaWYgKHkgPj0gdGhpcy55ICYmIHkgPCB0aGlzLnkgKyB0aGlzLmhlaWdodCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGludGVyc2VjdHMob3RoZXIsIHRyYW5zZm9ybSkge1xuICAgIGlmICghdHJhbnNmb3JtKSB7XG4gICAgICBjb25zdCB4MDIgPSB0aGlzLnggPCBvdGhlci54ID8gb3RoZXIueCA6IHRoaXMueDtcbiAgICAgIGNvbnN0IHgxMiA9IHRoaXMucmlnaHQgPiBvdGhlci5yaWdodCA/IG90aGVyLnJpZ2h0IDogdGhpcy5yaWdodDtcbiAgICAgIGlmICh4MTIgPD0geDAyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHkwMiA9IHRoaXMueSA8IG90aGVyLnkgPyBvdGhlci55IDogdGhpcy55O1xuICAgICAgY29uc3QgeTEyID0gdGhpcy5ib3R0b20gPiBvdGhlci5ib3R0b20gPyBvdGhlci5ib3R0b20gOiB0aGlzLmJvdHRvbTtcbiAgICAgIHJldHVybiB5MTIgPiB5MDI7XG4gICAgfVxuICAgIGNvbnN0IHgwID0gdGhpcy5sZWZ0O1xuICAgIGNvbnN0IHgxID0gdGhpcy5yaWdodDtcbiAgICBjb25zdCB5MCA9IHRoaXMudG9wO1xuICAgIGNvbnN0IHkxID0gdGhpcy5ib3R0b207XG4gICAgaWYgKHgxIDw9IHgwIHx8IHkxIDw9IHkwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGx0ID0gdGVtcFBvaW50c1swXS5zZXQob3RoZXIubGVmdCwgb3RoZXIudG9wKTtcbiAgICBjb25zdCBsYiA9IHRlbXBQb2ludHNbMV0uc2V0KG90aGVyLmxlZnQsIG90aGVyLmJvdHRvbSk7XG4gICAgY29uc3QgcnQgPSB0ZW1wUG9pbnRzWzJdLnNldChvdGhlci5yaWdodCwgb3RoZXIudG9wKTtcbiAgICBjb25zdCByYiA9IHRlbXBQb2ludHNbM10uc2V0KG90aGVyLnJpZ2h0LCBvdGhlci5ib3R0b20pO1xuICAgIGlmIChydC54IDw9IGx0LnggfHwgbGIueSA8PSBsdC55KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHMgPSBNYXRoLnNpZ24odHJhbnNmb3JtLmEgKiB0cmFuc2Zvcm0uZCAtIHRyYW5zZm9ybS5iICogdHJhbnNmb3JtLmMpO1xuICAgIGlmIChzID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyYW5zZm9ybS5hcHBseShsdCwgbHQpO1xuICAgIHRyYW5zZm9ybS5hcHBseShsYiwgbGIpO1xuICAgIHRyYW5zZm9ybS5hcHBseShydCwgcnQpO1xuICAgIHRyYW5zZm9ybS5hcHBseShyYiwgcmIpO1xuICAgIGlmIChNYXRoLm1heChsdC54LCBsYi54LCBydC54LCByYi54KSA8PSB4MCB8fCBNYXRoLm1pbihsdC54LCBsYi54LCBydC54LCByYi54KSA+PSB4MSB8fCBNYXRoLm1heChsdC55LCBsYi55LCBydC55LCByYi55KSA8PSB5MCB8fCBNYXRoLm1pbihsdC55LCBsYi55LCBydC55LCByYi55KSA+PSB5MSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBueCA9IHMgKiAobGIueSAtIGx0LnkpO1xuICAgIGNvbnN0IG55ID0gcyAqIChsdC54IC0gbGIueCk7XG4gICAgY29uc3QgbjAwID0gbnggKiB4MCArIG55ICogeTA7XG4gICAgY29uc3QgbjEwID0gbnggKiB4MSArIG55ICogeTA7XG4gICAgY29uc3QgbjAxID0gbnggKiB4MCArIG55ICogeTE7XG4gICAgY29uc3QgbjExID0gbnggKiB4MSArIG55ICogeTE7XG4gICAgaWYgKE1hdGgubWF4KG4wMCwgbjEwLCBuMDEsIG4xMSkgPD0gbnggKiBsdC54ICsgbnkgKiBsdC55IHx8IE1hdGgubWluKG4wMCwgbjEwLCBuMDEsIG4xMSkgPj0gbnggKiByYi54ICsgbnkgKiByYi55KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG14ID0gcyAqIChsdC55IC0gcnQueSk7XG4gICAgY29uc3QgbXkgPSBzICogKHJ0LnggLSBsdC54KTtcbiAgICBjb25zdCBtMDAgPSBteCAqIHgwICsgbXkgKiB5MDtcbiAgICBjb25zdCBtMTAgPSBteCAqIHgxICsgbXkgKiB5MDtcbiAgICBjb25zdCBtMDEgPSBteCAqIHgwICsgbXkgKiB5MTtcbiAgICBjb25zdCBtMTEgPSBteCAqIHgxICsgbXkgKiB5MTtcbiAgICBpZiAoTWF0aC5tYXgobTAwLCBtMTAsIG0wMSwgbTExKSA8PSBteCAqIGx0LnggKyBteSAqIGx0LnkgfHwgTWF0aC5taW4obTAwLCBtMTAsIG0wMSwgbTExKSA+PSBteCAqIHJiLnggKyBteSAqIHJiLnkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcGFkKHBhZGRpbmdYID0gMCwgcGFkZGluZ1kgPSBwYWRkaW5nWCkge1xuICAgIHRoaXMueCAtPSBwYWRkaW5nWDtcbiAgICB0aGlzLnkgLT0gcGFkZGluZ1k7XG4gICAgdGhpcy53aWR0aCArPSBwYWRkaW5nWCAqIDI7XG4gICAgdGhpcy5oZWlnaHQgKz0gcGFkZGluZ1kgKiAyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZpdChyZWN0YW5nbGUpIHtcbiAgICBjb25zdCB4MSA9IE1hdGgubWF4KHRoaXMueCwgcmVjdGFuZ2xlLngpO1xuICAgIGNvbnN0IHgyID0gTWF0aC5taW4odGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdGFuZ2xlLnggKyByZWN0YW5nbGUud2lkdGgpO1xuICAgIGNvbnN0IHkxID0gTWF0aC5tYXgodGhpcy55LCByZWN0YW5nbGUueSk7XG4gICAgY29uc3QgeTIgPSBNYXRoLm1pbih0aGlzLnkgKyB0aGlzLmhlaWdodCwgcmVjdGFuZ2xlLnkgKyByZWN0YW5nbGUuaGVpZ2h0KTtcbiAgICB0aGlzLnggPSB4MTtcbiAgICB0aGlzLndpZHRoID0gTWF0aC5tYXgoeDIgLSB4MSwgMCk7XG4gICAgdGhpcy55ID0geTE7XG4gICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1heCh5MiAtIHkxLCAwKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjZWlsKHJlc29sdXRpb24gPSAxLCBlcHMgPSAxZS0zKSB7XG4gICAgY29uc3QgeDIgPSBNYXRoLmNlaWwoKHRoaXMueCArIHRoaXMud2lkdGggLSBlcHMpICogcmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xuICAgIGNvbnN0IHkyID0gTWF0aC5jZWlsKCh0aGlzLnkgKyB0aGlzLmhlaWdodCAtIGVwcykgKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb247XG4gICAgdGhpcy54ID0gTWF0aC5mbG9vcigodGhpcy54ICsgZXBzKSAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgICB0aGlzLnkgPSBNYXRoLmZsb29yKCh0aGlzLnkgKyBlcHMpICogcmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xuICAgIHRoaXMud2lkdGggPSB4MiAtIHRoaXMueDtcbiAgICB0aGlzLmhlaWdodCA9IHkyIC0gdGhpcy55O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGVubGFyZ2UocmVjdGFuZ2xlKSB7XG4gICAgY29uc3QgeDEgPSBNYXRoLm1pbih0aGlzLngsIHJlY3RhbmdsZS54KTtcbiAgICBjb25zdCB4MiA9IE1hdGgubWF4KHRoaXMueCArIHRoaXMud2lkdGgsIHJlY3RhbmdsZS54ICsgcmVjdGFuZ2xlLndpZHRoKTtcbiAgICBjb25zdCB5MSA9IE1hdGgubWluKHRoaXMueSwgcmVjdGFuZ2xlLnkpO1xuICAgIGNvbnN0IHkyID0gTWF0aC5tYXgodGhpcy55ICsgdGhpcy5oZWlnaHQsIHJlY3RhbmdsZS55ICsgcmVjdGFuZ2xlLmhlaWdodCk7XG4gICAgdGhpcy54ID0geDE7XG4gICAgdGhpcy53aWR0aCA9IHgyIC0geDE7XG4gICAgdGhpcy55ID0geTE7XG4gICAgdGhpcy5oZWlnaHQgPSB5MiAtIHkxO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgW0BwaXhpL21hdGg6UmVjdGFuZ2xlIHg9JHt0aGlzLnh9IHk9JHt0aGlzLnl9IHdpZHRoPSR7dGhpcy53aWR0aH0gaGVpZ2h0PSR7dGhpcy5oZWlnaHR9XWA7XG4gIH1cbn1cblxuZXhwb3J0IHsgUmVjdGFuZ2xlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWN0YW5nbGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgU0hBUEVTIH0gZnJvbSAnLi4vY29uc3QubWpzJztcbmltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gJy4vUmVjdGFuZ2xlLm1qcyc7XG5cbmNsYXNzIENpcmNsZSB7XG4gIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgcmFkaXVzID0gMCkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcbiAgICB0aGlzLnR5cGUgPSBTSEFQRVMuQ0lSQztcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IENpcmNsZSh0aGlzLngsIHRoaXMueSwgdGhpcy5yYWRpdXMpO1xuICB9XG4gIGNvbnRhaW5zKHgsIHkpIHtcbiAgICBpZiAodGhpcy5yYWRpdXMgPD0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCByMiA9IHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXM7XG4gICAgbGV0IGR4ID0gdGhpcy54IC0geDtcbiAgICBsZXQgZHkgPSB0aGlzLnkgLSB5O1xuICAgIGR4ICo9IGR4O1xuICAgIGR5ICo9IGR5O1xuICAgIHJldHVybiBkeCArIGR5IDw9IHIyO1xuICB9XG4gIGdldEJvdW5kcygpIHtcbiAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLnggLSB0aGlzLnJhZGl1cywgdGhpcy55IC0gdGhpcy5yYWRpdXMsIHRoaXMucmFkaXVzICogMiwgdGhpcy5yYWRpdXMgKiAyKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtAcGl4aS9tYXRoOkNpcmNsZSB4PSR7dGhpcy54fSB5PSR7dGhpcy55fSByYWRpdXM9JHt0aGlzLnJhZGl1c31dYDtcbiAgfVxufVxuXG5leHBvcnQgeyBDaXJjbGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNpcmNsZS5tanMubWFwXG4iLCJpbXBvcnQgeyBTSEFQRVMgfSBmcm9tICcuLi9jb25zdC5tanMnO1xuaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi9SZWN0YW5nbGUubWpzJztcblxuY2xhc3MgRWxsaXBzZSB7XG4gIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgaGFsZldpZHRoID0gMCwgaGFsZkhlaWdodCA9IDApIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy53aWR0aCA9IGhhbGZXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhhbGZIZWlnaHQ7XG4gICAgdGhpcy50eXBlID0gU0hBUEVTLkVMSVA7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBFbGxpcHNlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gIH1cbiAgY29udGFpbnMoeCwgeSkge1xuICAgIGlmICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgbm9ybXggPSAoeCAtIHRoaXMueCkgLyB0aGlzLndpZHRoO1xuICAgIGxldCBub3JteSA9ICh5IC0gdGhpcy55KSAvIHRoaXMuaGVpZ2h0O1xuICAgIG5vcm14ICo9IG5vcm14O1xuICAgIG5vcm15ICo9IG5vcm15O1xuICAgIHJldHVybiBub3JteCArIG5vcm15IDw9IDE7XG4gIH1cbiAgZ2V0Qm91bmRzKCkge1xuICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCAtIHRoaXMud2lkdGgsIHRoaXMueSAtIHRoaXMuaGVpZ2h0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBbQHBpeGkvbWF0aDpFbGxpcHNlIHg9JHt0aGlzLnh9IHk9JHt0aGlzLnl9IHdpZHRoPSR7dGhpcy53aWR0aH0gaGVpZ2h0PSR7dGhpcy5oZWlnaHR9XWA7XG4gIH1cbn1cblxuZXhwb3J0IHsgRWxsaXBzZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RWxsaXBzZS5tanMubWFwXG4iLCJpbXBvcnQgeyBTSEFQRVMgfSBmcm9tICcuLi9jb25zdC5tanMnO1xuXG5jbGFzcyBQb2x5Z29uIHtcbiAgY29uc3RydWN0b3IoLi4ucG9pbnRzKSB7XG4gICAgbGV0IGZsYXQgPSBBcnJheS5pc0FycmF5KHBvaW50c1swXSkgPyBwb2ludHNbMF0gOiBwb2ludHM7XG4gICAgaWYgKHR5cGVvZiBmbGF0WzBdICE9PSBcIm51bWJlclwiKSB7XG4gICAgICBjb25zdCBwID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBmbGF0Lmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgcC5wdXNoKGZsYXRbaV0ueCwgZmxhdFtpXS55KTtcbiAgICAgIH1cbiAgICAgIGZsYXQgPSBwO1xuICAgIH1cbiAgICB0aGlzLnBvaW50cyA9IGZsYXQ7XG4gICAgdGhpcy50eXBlID0gU0hBUEVTLlBPTFk7XG4gICAgdGhpcy5jbG9zZVN0cm9rZSA9IHRydWU7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHMuc2xpY2UoKTtcbiAgICBjb25zdCBwb2x5Z29uID0gbmV3IFBvbHlnb24ocG9pbnRzKTtcbiAgICBwb2x5Z29uLmNsb3NlU3Ryb2tlID0gdGhpcy5jbG9zZVN0cm9rZTtcbiAgICByZXR1cm4gcG9seWdvbjtcbiAgfVxuICBjb250YWlucyh4LCB5KSB7XG4gICAgbGV0IGluc2lkZSA9IGZhbHNlO1xuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMucG9pbnRzLmxlbmd0aCAvIDI7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSBsZW5ndGggLSAxOyBpIDwgbGVuZ3RoOyBqID0gaSsrKSB7XG4gICAgICBjb25zdCB4aSA9IHRoaXMucG9pbnRzW2kgKiAyXTtcbiAgICAgIGNvbnN0IHlpID0gdGhpcy5wb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgIGNvbnN0IHhqID0gdGhpcy5wb2ludHNbaiAqIDJdO1xuICAgICAgY29uc3QgeWogPSB0aGlzLnBvaW50c1tqICogMiArIDFdO1xuICAgICAgY29uc3QgaW50ZXJzZWN0ID0geWkgPiB5ICE9PSB5aiA+IHkgJiYgeCA8ICh4aiAtIHhpKSAqICgoeSAtIHlpKSAvICh5aiAtIHlpKSkgKyB4aTtcbiAgICAgIGlmIChpbnRlcnNlY3QpIHtcbiAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluc2lkZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtAcGl4aS9tYXRoOlBvbHlnb25jbG9zZVN0cm9rZT0ke3RoaXMuY2xvc2VTdHJva2V9cG9pbnRzPSR7dGhpcy5wb2ludHMucmVkdWNlKChwb2ludHNEZXNjLCBjdXJyZW50UG9pbnQpID0+IGAke3BvaW50c0Rlc2N9LCAke2N1cnJlbnRQb2ludH1gLCBcIlwiKX1dYDtcbiAgfVxufVxuXG5leHBvcnQgeyBQb2x5Z29uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb2x5Z29uLm1qcy5tYXBcbiIsImltcG9ydCB7IFNIQVBFUyB9IGZyb20gJy4uL2NvbnN0Lm1qcyc7XG5cbmNsYXNzIFJvdW5kZWRSZWN0YW5nbGUge1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHdpZHRoID0gMCwgaGVpZ2h0ID0gMCwgcmFkaXVzID0gMjApIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xuICAgIHRoaXMudHlwZSA9IFNIQVBFUy5SUkVDO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgUm91bmRlZFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMucmFkaXVzKTtcbiAgfVxuICBjb250YWlucyh4LCB5KSB7XG4gICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh4ID49IHRoaXMueCAmJiB4IDw9IHRoaXMueCArIHRoaXMud2lkdGgpIHtcbiAgICAgIGlmICh5ID49IHRoaXMueSAmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMucmFkaXVzLCBNYXRoLm1pbih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkgLyAyKSk7XG4gICAgICAgIGlmICh5ID49IHRoaXMueSArIHJhZGl1cyAmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0IC0gcmFkaXVzIHx8IHggPj0gdGhpcy54ICsgcmFkaXVzICYmIHggPD0gdGhpcy54ICsgdGhpcy53aWR0aCAtIHJhZGl1cykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkeCA9IHggLSAodGhpcy54ICsgcmFkaXVzKTtcbiAgICAgICAgbGV0IGR5ID0geSAtICh0aGlzLnkgKyByYWRpdXMpO1xuICAgICAgICBjb25zdCByYWRpdXMyID0gcmFkaXVzICogcmFkaXVzO1xuICAgICAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPD0gcmFkaXVzMikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGR4ID0geCAtICh0aGlzLnggKyB0aGlzLndpZHRoIC0gcmFkaXVzKTtcbiAgICAgICAgaWYgKGR4ICogZHggKyBkeSAqIGR5IDw9IHJhZGl1czIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBkeSA9IHkgLSAodGhpcy55ICsgdGhpcy5oZWlnaHQgLSByYWRpdXMpO1xuICAgICAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPD0gcmFkaXVzMikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGR4ID0geCAtICh0aGlzLnggKyByYWRpdXMpO1xuICAgICAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPD0gcmFkaXVzMikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtAcGl4aS9tYXRoOlJvdW5kZWRSZWN0YW5nbGUgeD0ke3RoaXMueH0geT0ke3RoaXMueX13aWR0aD0ke3RoaXMud2lkdGh9IGhlaWdodD0ke3RoaXMuaGVpZ2h0fSByYWRpdXM9JHt0aGlzLnJhZGl1c31dYDtcbiAgfVxufVxuXG5leHBvcnQgeyBSb3VuZGVkUmVjdGFuZ2xlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Sb3VuZGVkUmVjdGFuZ2xlLm1qcy5tYXBcbiIsImltcG9ydCB7IFBJXzIgfSBmcm9tICcuL2NvbnN0Lm1qcyc7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4vUG9pbnQubWpzJztcblxuY2xhc3MgTWF0cml4IHtcbiAgY29uc3RydWN0b3IoYSA9IDEsIGIgPSAwLCBjID0gMCwgZCA9IDEsIHR4ID0gMCwgdHkgPSAwKSB7XG4gICAgdGhpcy5hcnJheSA9IG51bGw7XG4gICAgdGhpcy5hID0gYTtcbiAgICB0aGlzLmIgPSBiO1xuICAgIHRoaXMuYyA9IGM7XG4gICAgdGhpcy5kID0gZDtcbiAgICB0aGlzLnR4ID0gdHg7XG4gICAgdGhpcy50eSA9IHR5O1xuICB9XG4gIGZyb21BcnJheShhcnJheSkge1xuICAgIHRoaXMuYSA9IGFycmF5WzBdO1xuICAgIHRoaXMuYiA9IGFycmF5WzFdO1xuICAgIHRoaXMuYyA9IGFycmF5WzNdO1xuICAgIHRoaXMuZCA9IGFycmF5WzRdO1xuICAgIHRoaXMudHggPSBhcnJheVsyXTtcbiAgICB0aGlzLnR5ID0gYXJyYXlbNV07XG4gIH1cbiAgc2V0KGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICAgIHRoaXMuYSA9IGE7XG4gICAgdGhpcy5iID0gYjtcbiAgICB0aGlzLmMgPSBjO1xuICAgIHRoaXMuZCA9IGQ7XG4gICAgdGhpcy50eCA9IHR4O1xuICAgIHRoaXMudHkgPSB0eTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0b0FycmF5KHRyYW5zcG9zZSwgb3V0KSB7XG4gICAgaWYgKCF0aGlzLmFycmF5KSB7XG4gICAgICB0aGlzLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSg5KTtcbiAgICB9XG4gICAgY29uc3QgYXJyYXkgPSBvdXQgfHwgdGhpcy5hcnJheTtcbiAgICBpZiAodHJhbnNwb3NlKSB7XG4gICAgICBhcnJheVswXSA9IHRoaXMuYTtcbiAgICAgIGFycmF5WzFdID0gdGhpcy5iO1xuICAgICAgYXJyYXlbMl0gPSAwO1xuICAgICAgYXJyYXlbM10gPSB0aGlzLmM7XG4gICAgICBhcnJheVs0XSA9IHRoaXMuZDtcbiAgICAgIGFycmF5WzVdID0gMDtcbiAgICAgIGFycmF5WzZdID0gdGhpcy50eDtcbiAgICAgIGFycmF5WzddID0gdGhpcy50eTtcbiAgICAgIGFycmF5WzhdID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJyYXlbMF0gPSB0aGlzLmE7XG4gICAgICBhcnJheVsxXSA9IHRoaXMuYztcbiAgICAgIGFycmF5WzJdID0gdGhpcy50eDtcbiAgICAgIGFycmF5WzNdID0gdGhpcy5iO1xuICAgICAgYXJyYXlbNF0gPSB0aGlzLmQ7XG4gICAgICBhcnJheVs1XSA9IHRoaXMudHk7XG4gICAgICBhcnJheVs2XSA9IDA7XG4gICAgICBhcnJheVs3XSA9IDA7XG4gICAgICBhcnJheVs4XSA9IDE7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuICBhcHBseShwb3MsIG5ld1Bvcykge1xuICAgIG5ld1BvcyA9IG5ld1BvcyB8fCBuZXcgUG9pbnQoKTtcbiAgICBjb25zdCB4ID0gcG9zLng7XG4gICAgY29uc3QgeSA9IHBvcy55O1xuICAgIG5ld1Bvcy54ID0gdGhpcy5hICogeCArIHRoaXMuYyAqIHkgKyB0aGlzLnR4O1xuICAgIG5ld1Bvcy55ID0gdGhpcy5iICogeCArIHRoaXMuZCAqIHkgKyB0aGlzLnR5O1xuICAgIHJldHVybiBuZXdQb3M7XG4gIH1cbiAgYXBwbHlJbnZlcnNlKHBvcywgbmV3UG9zKSB7XG4gICAgbmV3UG9zID0gbmV3UG9zIHx8IG5ldyBQb2ludCgpO1xuICAgIGNvbnN0IGlkID0gMSAvICh0aGlzLmEgKiB0aGlzLmQgKyB0aGlzLmMgKiAtdGhpcy5iKTtcbiAgICBjb25zdCB4ID0gcG9zLng7XG4gICAgY29uc3QgeSA9IHBvcy55O1xuICAgIG5ld1Bvcy54ID0gdGhpcy5kICogaWQgKiB4ICsgLXRoaXMuYyAqIGlkICogeSArICh0aGlzLnR5ICogdGhpcy5jIC0gdGhpcy50eCAqIHRoaXMuZCkgKiBpZDtcbiAgICBuZXdQb3MueSA9IHRoaXMuYSAqIGlkICogeSArIC10aGlzLmIgKiBpZCAqIHggKyAoLXRoaXMudHkgKiB0aGlzLmEgKyB0aGlzLnR4ICogdGhpcy5iKSAqIGlkO1xuICAgIHJldHVybiBuZXdQb3M7XG4gIH1cbiAgdHJhbnNsYXRlKHgsIHkpIHtcbiAgICB0aGlzLnR4ICs9IHg7XG4gICAgdGhpcy50eSArPSB5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNjYWxlKHgsIHkpIHtcbiAgICB0aGlzLmEgKj0geDtcbiAgICB0aGlzLmQgKj0geTtcbiAgICB0aGlzLmMgKj0geDtcbiAgICB0aGlzLmIgKj0geTtcbiAgICB0aGlzLnR4ICo9IHg7XG4gICAgdGhpcy50eSAqPSB5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJvdGF0ZShhbmdsZSkge1xuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgY29uc3QgYTEgPSB0aGlzLmE7XG4gICAgY29uc3QgYzEgPSB0aGlzLmM7XG4gICAgY29uc3QgdHgxID0gdGhpcy50eDtcbiAgICB0aGlzLmEgPSBhMSAqIGNvcyAtIHRoaXMuYiAqIHNpbjtcbiAgICB0aGlzLmIgPSBhMSAqIHNpbiArIHRoaXMuYiAqIGNvcztcbiAgICB0aGlzLmMgPSBjMSAqIGNvcyAtIHRoaXMuZCAqIHNpbjtcbiAgICB0aGlzLmQgPSBjMSAqIHNpbiArIHRoaXMuZCAqIGNvcztcbiAgICB0aGlzLnR4ID0gdHgxICogY29zIC0gdGhpcy50eSAqIHNpbjtcbiAgICB0aGlzLnR5ID0gdHgxICogc2luICsgdGhpcy50eSAqIGNvcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhcHBlbmQobWF0cml4KSB7XG4gICAgY29uc3QgYTEgPSB0aGlzLmE7XG4gICAgY29uc3QgYjEgPSB0aGlzLmI7XG4gICAgY29uc3QgYzEgPSB0aGlzLmM7XG4gICAgY29uc3QgZDEgPSB0aGlzLmQ7XG4gICAgdGhpcy5hID0gbWF0cml4LmEgKiBhMSArIG1hdHJpeC5iICogYzE7XG4gICAgdGhpcy5iID0gbWF0cml4LmEgKiBiMSArIG1hdHJpeC5iICogZDE7XG4gICAgdGhpcy5jID0gbWF0cml4LmMgKiBhMSArIG1hdHJpeC5kICogYzE7XG4gICAgdGhpcy5kID0gbWF0cml4LmMgKiBiMSArIG1hdHJpeC5kICogZDE7XG4gICAgdGhpcy50eCA9IG1hdHJpeC50eCAqIGExICsgbWF0cml4LnR5ICogYzEgKyB0aGlzLnR4O1xuICAgIHRoaXMudHkgPSBtYXRyaXgudHggKiBiMSArIG1hdHJpeC50eSAqIGQxICsgdGhpcy50eTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRUcmFuc2Zvcm0oeCwgeSwgcGl2b3RYLCBwaXZvdFksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgc2tld1gsIHNrZXdZKSB7XG4gICAgdGhpcy5hID0gTWF0aC5jb3Mocm90YXRpb24gKyBza2V3WSkgKiBzY2FsZVg7XG4gICAgdGhpcy5iID0gTWF0aC5zaW4ocm90YXRpb24gKyBza2V3WSkgKiBzY2FsZVg7XG4gICAgdGhpcy5jID0gLU1hdGguc2luKHJvdGF0aW9uIC0gc2tld1gpICogc2NhbGVZO1xuICAgIHRoaXMuZCA9IE1hdGguY29zKHJvdGF0aW9uIC0gc2tld1gpICogc2NhbGVZO1xuICAgIHRoaXMudHggPSB4IC0gKHBpdm90WCAqIHRoaXMuYSArIHBpdm90WSAqIHRoaXMuYyk7XG4gICAgdGhpcy50eSA9IHkgLSAocGl2b3RYICogdGhpcy5iICsgcGl2b3RZICogdGhpcy5kKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwcmVwZW5kKG1hdHJpeCkge1xuICAgIGNvbnN0IHR4MSA9IHRoaXMudHg7XG4gICAgaWYgKG1hdHJpeC5hICE9PSAxIHx8IG1hdHJpeC5iICE9PSAwIHx8IG1hdHJpeC5jICE9PSAwIHx8IG1hdHJpeC5kICE9PSAxKSB7XG4gICAgICBjb25zdCBhMSA9IHRoaXMuYTtcbiAgICAgIGNvbnN0IGMxID0gdGhpcy5jO1xuICAgICAgdGhpcy5hID0gYTEgKiBtYXRyaXguYSArIHRoaXMuYiAqIG1hdHJpeC5jO1xuICAgICAgdGhpcy5iID0gYTEgKiBtYXRyaXguYiArIHRoaXMuYiAqIG1hdHJpeC5kO1xuICAgICAgdGhpcy5jID0gYzEgKiBtYXRyaXguYSArIHRoaXMuZCAqIG1hdHJpeC5jO1xuICAgICAgdGhpcy5kID0gYzEgKiBtYXRyaXguYiArIHRoaXMuZCAqIG1hdHJpeC5kO1xuICAgIH1cbiAgICB0aGlzLnR4ID0gdHgxICogbWF0cml4LmEgKyB0aGlzLnR5ICogbWF0cml4LmMgKyBtYXRyaXgudHg7XG4gICAgdGhpcy50eSA9IHR4MSAqIG1hdHJpeC5iICsgdGhpcy50eSAqIG1hdHJpeC5kICsgbWF0cml4LnR5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRlY29tcG9zZSh0cmFuc2Zvcm0pIHtcbiAgICBjb25zdCBhID0gdGhpcy5hO1xuICAgIGNvbnN0IGIgPSB0aGlzLmI7XG4gICAgY29uc3QgYyA9IHRoaXMuYztcbiAgICBjb25zdCBkID0gdGhpcy5kO1xuICAgIGNvbnN0IHBpdm90ID0gdHJhbnNmb3JtLnBpdm90O1xuICAgIGNvbnN0IHNrZXdYID0gLU1hdGguYXRhbjIoLWMsIGQpO1xuICAgIGNvbnN0IHNrZXdZID0gTWF0aC5hdGFuMihiLCBhKTtcbiAgICBjb25zdCBkZWx0YSA9IE1hdGguYWJzKHNrZXdYICsgc2tld1kpO1xuICAgIGlmIChkZWx0YSA8IDFlLTUgfHwgTWF0aC5hYnMoUElfMiAtIGRlbHRhKSA8IDFlLTUpIHtcbiAgICAgIHRyYW5zZm9ybS5yb3RhdGlvbiA9IHNrZXdZO1xuICAgICAgdHJhbnNmb3JtLnNrZXcueCA9IHRyYW5zZm9ybS5za2V3LnkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2Zvcm0ucm90YXRpb24gPSAwO1xuICAgICAgdHJhbnNmb3JtLnNrZXcueCA9IHNrZXdYO1xuICAgICAgdHJhbnNmb3JtLnNrZXcueSA9IHNrZXdZO1xuICAgIH1cbiAgICB0cmFuc2Zvcm0uc2NhbGUueCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgICB0cmFuc2Zvcm0uc2NhbGUueSA9IE1hdGguc3FydChjICogYyArIGQgKiBkKTtcbiAgICB0cmFuc2Zvcm0ucG9zaXRpb24ueCA9IHRoaXMudHggKyAocGl2b3QueCAqIGEgKyBwaXZvdC55ICogYyk7XG4gICAgdHJhbnNmb3JtLnBvc2l0aW9uLnkgPSB0aGlzLnR5ICsgKHBpdm90LnggKiBiICsgcGl2b3QueSAqIGQpO1xuICAgIHJldHVybiB0cmFuc2Zvcm07XG4gIH1cbiAgaW52ZXJ0KCkge1xuICAgIGNvbnN0IGExID0gdGhpcy5hO1xuICAgIGNvbnN0IGIxID0gdGhpcy5iO1xuICAgIGNvbnN0IGMxID0gdGhpcy5jO1xuICAgIGNvbnN0IGQxID0gdGhpcy5kO1xuICAgIGNvbnN0IHR4MSA9IHRoaXMudHg7XG4gICAgY29uc3QgbiA9IGExICogZDEgLSBiMSAqIGMxO1xuICAgIHRoaXMuYSA9IGQxIC8gbjtcbiAgICB0aGlzLmIgPSAtYjEgLyBuO1xuICAgIHRoaXMuYyA9IC1jMSAvIG47XG4gICAgdGhpcy5kID0gYTEgLyBuO1xuICAgIHRoaXMudHggPSAoYzEgKiB0aGlzLnR5IC0gZDEgKiB0eDEpIC8gbjtcbiAgICB0aGlzLnR5ID0gLShhMSAqIHRoaXMudHkgLSBiMSAqIHR4MSkgLyBuO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlkZW50aXR5KCkge1xuICAgIHRoaXMuYSA9IDE7XG4gICAgdGhpcy5iID0gMDtcbiAgICB0aGlzLmMgPSAwO1xuICAgIHRoaXMuZCA9IDE7XG4gICAgdGhpcy50eCA9IDA7XG4gICAgdGhpcy50eSA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgIG1hdHJpeC5hID0gdGhpcy5hO1xuICAgIG1hdHJpeC5iID0gdGhpcy5iO1xuICAgIG1hdHJpeC5jID0gdGhpcy5jO1xuICAgIG1hdHJpeC5kID0gdGhpcy5kO1xuICAgIG1hdHJpeC50eCA9IHRoaXMudHg7XG4gICAgbWF0cml4LnR5ID0gdGhpcy50eTtcbiAgICByZXR1cm4gbWF0cml4O1xuICB9XG4gIGNvcHlUbyhtYXRyaXgpIHtcbiAgICBtYXRyaXguYSA9IHRoaXMuYTtcbiAgICBtYXRyaXguYiA9IHRoaXMuYjtcbiAgICBtYXRyaXguYyA9IHRoaXMuYztcbiAgICBtYXRyaXguZCA9IHRoaXMuZDtcbiAgICBtYXRyaXgudHggPSB0aGlzLnR4O1xuICAgIG1hdHJpeC50eSA9IHRoaXMudHk7XG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfVxuICBjb3B5RnJvbShtYXRyaXgpIHtcbiAgICB0aGlzLmEgPSBtYXRyaXguYTtcbiAgICB0aGlzLmIgPSBtYXRyaXguYjtcbiAgICB0aGlzLmMgPSBtYXRyaXguYztcbiAgICB0aGlzLmQgPSBtYXRyaXguZDtcbiAgICB0aGlzLnR4ID0gbWF0cml4LnR4O1xuICAgIHRoaXMudHkgPSBtYXRyaXgudHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBbQHBpeGkvbWF0aDpNYXRyaXggYT0ke3RoaXMuYX0gYj0ke3RoaXMuYn0gYz0ke3RoaXMuY30gZD0ke3RoaXMuZH0gdHg9JHt0aGlzLnR4fSB0eT0ke3RoaXMudHl9XWA7XG4gIH1cbiAgc3RhdGljIGdldCBJREVOVElUWSgpIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeCgpO1xuICB9XG4gIHN0YXRpYyBnZXQgVEVNUF9NQVRSSVgoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXRyaXgoKTtcbiAgfVxufVxuXG5leHBvcnQgeyBNYXRyaXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hdHJpeC5tanMubWFwXG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuL01hdHJpeC5tanMnO1xuXG5jb25zdCB1eCA9IFsxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxXTtcbmNvbnN0IHV5ID0gWzAsIDEsIDEsIDEsIDAsIC0xLCAtMSwgLTEsIDAsIDEsIDEsIDEsIDAsIC0xLCAtMSwgLTFdO1xuY29uc3QgdnggPSBbMCwgLTEsIC0xLCAtMSwgMCwgMSwgMSwgMSwgMCwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMV07XG5jb25zdCB2eSA9IFsxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxLCAtMSwgLTEsIDAsIDEsIDEsIDEsIDAsIC0xXTtcbmNvbnN0IHJvdGF0aW9uQ2F5bGV5ID0gW107XG5jb25zdCByb3RhdGlvbk1hdHJpY2VzID0gW107XG5jb25zdCBzaWdudW0gPSBNYXRoLnNpZ247XG5mdW5jdGlvbiBpbml0KCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBjb25zdCByb3cgPSBbXTtcbiAgICByb3RhdGlvbkNheWxleS5wdXNoKHJvdyk7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgaisrKSB7XG4gICAgICBjb25zdCBfdXggPSBzaWdudW0odXhbaV0gKiB1eFtqXSArIHZ4W2ldICogdXlbal0pO1xuICAgICAgY29uc3QgX3V5ID0gc2lnbnVtKHV5W2ldICogdXhbal0gKyB2eVtpXSAqIHV5W2pdKTtcbiAgICAgIGNvbnN0IF92eCA9IHNpZ251bSh1eFtpXSAqIHZ4W2pdICsgdnhbaV0gKiB2eVtqXSk7XG4gICAgICBjb25zdCBfdnkgPSBzaWdudW0odXlbaV0gKiB2eFtqXSArIHZ5W2ldICogdnlbal0pO1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCAxNjsgaysrKSB7XG4gICAgICAgIGlmICh1eFtrXSA9PT0gX3V4ICYmIHV5W2tdID09PSBfdXkgJiYgdnhba10gPT09IF92eCAmJiB2eVtrXSA9PT0gX3Z5KSB7XG4gICAgICAgICAgcm93LnB1c2goayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgY29uc3QgbWF0ID0gbmV3IE1hdHJpeCgpO1xuICAgIG1hdC5zZXQodXhbaV0sIHV5W2ldLCB2eFtpXSwgdnlbaV0sIDAsIDApO1xuICAgIHJvdGF0aW9uTWF0cmljZXMucHVzaChtYXQpO1xuICB9XG59XG5pbml0KCk7XG5jb25zdCBncm91cEQ4ID0ge1xuICBFOiAwLFxuICBTRTogMSxcbiAgUzogMixcbiAgU1c6IDMsXG4gIFc6IDQsXG4gIE5XOiA1LFxuICBOOiA2LFxuICBORTogNyxcbiAgTUlSUk9SX1ZFUlRJQ0FMOiA4LFxuICBNQUlOX0RJQUdPTkFMOiAxMCxcbiAgTUlSUk9SX0hPUklaT05UQUw6IDEyLFxuICBSRVZFUlNFX0RJQUdPTkFMOiAxNCxcbiAgdVg6IChpbmQpID0+IHV4W2luZF0sXG4gIHVZOiAoaW5kKSA9PiB1eVtpbmRdLFxuICB2WDogKGluZCkgPT4gdnhbaW5kXSxcbiAgdlk6IChpbmQpID0+IHZ5W2luZF0sXG4gIGludjogKHJvdGF0aW9uKSA9PiB7XG4gICAgaWYgKHJvdGF0aW9uICYgOCkge1xuICAgICAgcmV0dXJuIHJvdGF0aW9uICYgMTU7XG4gICAgfVxuICAgIHJldHVybiAtcm90YXRpb24gJiA3O1xuICB9LFxuICBhZGQ6IChyb3RhdGlvblNlY29uZCwgcm90YXRpb25GaXJzdCkgPT4gcm90YXRpb25DYXlsZXlbcm90YXRpb25TZWNvbmRdW3JvdGF0aW9uRmlyc3RdLFxuICBzdWI6IChyb3RhdGlvblNlY29uZCwgcm90YXRpb25GaXJzdCkgPT4gcm90YXRpb25DYXlsZXlbcm90YXRpb25TZWNvbmRdW2dyb3VwRDguaW52KHJvdGF0aW9uRmlyc3QpXSxcbiAgcm90YXRlMTgwOiAocm90YXRpb24pID0+IHJvdGF0aW9uIF4gNCxcbiAgaXNWZXJ0aWNhbDogKHJvdGF0aW9uKSA9PiAocm90YXRpb24gJiAzKSA9PT0gMixcbiAgYnlEaXJlY3Rpb246IChkeCwgZHkpID0+IHtcbiAgICBpZiAoTWF0aC5hYnMoZHgpICogMiA8PSBNYXRoLmFicyhkeSkpIHtcbiAgICAgIGlmIChkeSA+PSAwKSB7XG4gICAgICAgIHJldHVybiBncm91cEQ4LlM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXBEOC5OO1xuICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoZHkpICogMiA8PSBNYXRoLmFicyhkeCkpIHtcbiAgICAgIGlmIChkeCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwRDguRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncm91cEQ4Llc7XG4gICAgfSBlbHNlIGlmIChkeSA+IDApIHtcbiAgICAgIGlmIChkeCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwRDguU0U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXBEOC5TVztcbiAgICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgICAgcmV0dXJuIGdyb3VwRDguTkU7XG4gICAgfVxuICAgIHJldHVybiBncm91cEQ4Lk5XO1xuICB9LFxuICBtYXRyaXhBcHBlbmRSb3RhdGlvbkludjogKG1hdHJpeCwgcm90YXRpb24sIHR4ID0gMCwgdHkgPSAwKSA9PiB7XG4gICAgY29uc3QgbWF0ID0gcm90YXRpb25NYXRyaWNlc1tncm91cEQ4Lmludihyb3RhdGlvbildO1xuICAgIG1hdC50eCA9IHR4O1xuICAgIG1hdC50eSA9IHR5O1xuICAgIG1hdHJpeC5hcHBlbmQobWF0KTtcbiAgfVxufTtcblxuZXhwb3J0IHsgZ3JvdXBEOCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JvdXBEOC5tanMubWFwXG4iLCJjbGFzcyBPYnNlcnZhYmxlUG9pbnQge1xuICBjb25zdHJ1Y3RvcihjYiwgc2NvcGUsIHggPSAwLCB5ID0gMCkge1xuICAgIHRoaXMuX3ggPSB4O1xuICAgIHRoaXMuX3kgPSB5O1xuICAgIHRoaXMuY2IgPSBjYjtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gIH1cbiAgY2xvbmUoY2IgPSB0aGlzLmNiLCBzY29wZSA9IHRoaXMuc2NvcGUpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVQb2ludChjYiwgc2NvcGUsIHRoaXMuX3gsIHRoaXMuX3kpO1xuICB9XG4gIHNldCh4ID0gMCwgeSA9IHgpIHtcbiAgICBpZiAodGhpcy5feCAhPT0geCB8fCB0aGlzLl95ICE9PSB5KSB7XG4gICAgICB0aGlzLl94ID0geDtcbiAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgdGhpcy5jYi5jYWxsKHRoaXMuc2NvcGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb3B5RnJvbShwKSB7XG4gICAgaWYgKHRoaXMuX3ggIT09IHAueCB8fCB0aGlzLl95ICE9PSBwLnkpIHtcbiAgICAgIHRoaXMuX3ggPSBwLng7XG4gICAgICB0aGlzLl95ID0gcC55O1xuICAgICAgdGhpcy5jYi5jYWxsKHRoaXMuc2NvcGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb3B5VG8ocCkge1xuICAgIHAuc2V0KHRoaXMuX3gsIHRoaXMuX3kpO1xuICAgIHJldHVybiBwO1xuICB9XG4gIGVxdWFscyhwKSB7XG4gICAgcmV0dXJuIHAueCA9PT0gdGhpcy5feCAmJiBwLnkgPT09IHRoaXMuX3k7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBbQHBpeGkvbWF0aDpPYnNlcnZhYmxlUG9pbnQgeD0kezB9IHk9JHswfSBzY29wZT0ke3RoaXMuc2NvcGV9XWA7XG4gIH1cbiAgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3g7XG4gIH1cbiAgc2V0IHgodmFsdWUpIHtcbiAgICBpZiAodGhpcy5feCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX3ggPSB2YWx1ZTtcbiAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3k7XG4gIH1cbiAgc2V0IHkodmFsdWUpIHtcbiAgICBpZiAodGhpcy5feSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX3kgPSB2YWx1ZTtcbiAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgT2JzZXJ2YWJsZVBvaW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYnNlcnZhYmxlUG9pbnQubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnLi9NYXRyaXgubWpzJztcbmltcG9ydCB7IE9ic2VydmFibGVQb2ludCB9IGZyb20gJy4vT2JzZXJ2YWJsZVBvaW50Lm1qcyc7XG5cbmNvbnN0IF9UcmFuc2Zvcm0gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy5sb2NhbFRyYW5zZm9ybSA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IE9ic2VydmFibGVQb2ludCh0aGlzLm9uQ2hhbmdlLCB0aGlzLCAwLCAwKTtcbiAgICB0aGlzLnNjYWxlID0gbmV3IE9ic2VydmFibGVQb2ludCh0aGlzLm9uQ2hhbmdlLCB0aGlzLCAxLCAxKTtcbiAgICB0aGlzLnBpdm90ID0gbmV3IE9ic2VydmFibGVQb2ludCh0aGlzLm9uQ2hhbmdlLCB0aGlzLCAwLCAwKTtcbiAgICB0aGlzLnNrZXcgPSBuZXcgT2JzZXJ2YWJsZVBvaW50KHRoaXMudXBkYXRlU2tldywgdGhpcywgMCwgMCk7XG4gICAgdGhpcy5fcm90YXRpb24gPSAwO1xuICAgIHRoaXMuX2N4ID0gMTtcbiAgICB0aGlzLl9zeCA9IDA7XG4gICAgdGhpcy5fY3kgPSAwO1xuICAgIHRoaXMuX3N5ID0gMTtcbiAgICB0aGlzLl9sb2NhbElEID0gMDtcbiAgICB0aGlzLl9jdXJyZW50TG9jYWxJRCA9IDA7XG4gICAgdGhpcy5fd29ybGRJRCA9IDA7XG4gICAgdGhpcy5fcGFyZW50SUQgPSAwO1xuICB9XG4gIG9uQ2hhbmdlKCkge1xuICAgIHRoaXMuX2xvY2FsSUQrKztcbiAgfVxuICB1cGRhdGVTa2V3KCkge1xuICAgIHRoaXMuX2N4ID0gTWF0aC5jb3ModGhpcy5fcm90YXRpb24gKyB0aGlzLnNrZXcueSk7XG4gICAgdGhpcy5fc3ggPSBNYXRoLnNpbih0aGlzLl9yb3RhdGlvbiArIHRoaXMuc2tldy55KTtcbiAgICB0aGlzLl9jeSA9IC1NYXRoLnNpbih0aGlzLl9yb3RhdGlvbiAtIHRoaXMuc2tldy54KTtcbiAgICB0aGlzLl9zeSA9IE1hdGguY29zKHRoaXMuX3JvdGF0aW9uIC0gdGhpcy5za2V3LngpO1xuICAgIHRoaXMuX2xvY2FsSUQrKztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtAcGl4aS9tYXRoOlRyYW5zZm9ybSBwb3NpdGlvbj0oJHt0aGlzLnBvc2l0aW9uLnh9LCAke3RoaXMucG9zaXRpb24ueX0pIHJvdGF0aW9uPSR7dGhpcy5yb3RhdGlvbn0gc2NhbGU9KCR7dGhpcy5zY2FsZS54fSwgJHt0aGlzLnNjYWxlLnl9KSBza2V3PSgke3RoaXMuc2tldy54fSwgJHt0aGlzLnNrZXcueX0pIF1gO1xuICB9XG4gIHVwZGF0ZUxvY2FsVHJhbnNmb3JtKCkge1xuICAgIGNvbnN0IGx0ID0gdGhpcy5sb2NhbFRyYW5zZm9ybTtcbiAgICBpZiAodGhpcy5fbG9jYWxJRCAhPT0gdGhpcy5fY3VycmVudExvY2FsSUQpIHtcbiAgICAgIGx0LmEgPSB0aGlzLl9jeCAqIHRoaXMuc2NhbGUueDtcbiAgICAgIGx0LmIgPSB0aGlzLl9zeCAqIHRoaXMuc2NhbGUueDtcbiAgICAgIGx0LmMgPSB0aGlzLl9jeSAqIHRoaXMuc2NhbGUueTtcbiAgICAgIGx0LmQgPSB0aGlzLl9zeSAqIHRoaXMuc2NhbGUueTtcbiAgICAgIGx0LnR4ID0gdGhpcy5wb3NpdGlvbi54IC0gKHRoaXMucGl2b3QueCAqIGx0LmEgKyB0aGlzLnBpdm90LnkgKiBsdC5jKTtcbiAgICAgIGx0LnR5ID0gdGhpcy5wb3NpdGlvbi55IC0gKHRoaXMucGl2b3QueCAqIGx0LmIgKyB0aGlzLnBpdm90LnkgKiBsdC5kKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRMb2NhbElEID0gdGhpcy5fbG9jYWxJRDtcbiAgICAgIHRoaXMuX3BhcmVudElEID0gLTE7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVRyYW5zZm9ybShwYXJlbnRUcmFuc2Zvcm0pIHtcbiAgICBjb25zdCBsdCA9IHRoaXMubG9jYWxUcmFuc2Zvcm07XG4gICAgaWYgKHRoaXMuX2xvY2FsSUQgIT09IHRoaXMuX2N1cnJlbnRMb2NhbElEKSB7XG4gICAgICBsdC5hID0gdGhpcy5fY3ggKiB0aGlzLnNjYWxlLng7XG4gICAgICBsdC5iID0gdGhpcy5fc3ggKiB0aGlzLnNjYWxlLng7XG4gICAgICBsdC5jID0gdGhpcy5fY3kgKiB0aGlzLnNjYWxlLnk7XG4gICAgICBsdC5kID0gdGhpcy5fc3kgKiB0aGlzLnNjYWxlLnk7XG4gICAgICBsdC50eCA9IHRoaXMucG9zaXRpb24ueCAtICh0aGlzLnBpdm90LnggKiBsdC5hICsgdGhpcy5waXZvdC55ICogbHQuYyk7XG4gICAgICBsdC50eSA9IHRoaXMucG9zaXRpb24ueSAtICh0aGlzLnBpdm90LnggKiBsdC5iICsgdGhpcy5waXZvdC55ICogbHQuZCk7XG4gICAgICB0aGlzLl9jdXJyZW50TG9jYWxJRCA9IHRoaXMuX2xvY2FsSUQ7XG4gICAgICB0aGlzLl9wYXJlbnRJRCA9IC0xO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcGFyZW50SUQgIT09IHBhcmVudFRyYW5zZm9ybS5fd29ybGRJRCkge1xuICAgICAgY29uc3QgcHQgPSBwYXJlbnRUcmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gICAgICBjb25zdCB3dCA9IHRoaXMud29ybGRUcmFuc2Zvcm07XG4gICAgICB3dC5hID0gbHQuYSAqIHB0LmEgKyBsdC5iICogcHQuYztcbiAgICAgIHd0LmIgPSBsdC5hICogcHQuYiArIGx0LmIgKiBwdC5kO1xuICAgICAgd3QuYyA9IGx0LmMgKiBwdC5hICsgbHQuZCAqIHB0LmM7XG4gICAgICB3dC5kID0gbHQuYyAqIHB0LmIgKyBsdC5kICogcHQuZDtcbiAgICAgIHd0LnR4ID0gbHQudHggKiBwdC5hICsgbHQudHkgKiBwdC5jICsgcHQudHg7XG4gICAgICB3dC50eSA9IGx0LnR4ICogcHQuYiArIGx0LnR5ICogcHQuZCArIHB0LnR5O1xuICAgICAgdGhpcy5fcGFyZW50SUQgPSBwYXJlbnRUcmFuc2Zvcm0uX3dvcmxkSUQ7XG4gICAgICB0aGlzLl93b3JsZElEKys7XG4gICAgfVxuICB9XG4gIHNldEZyb21NYXRyaXgobWF0cml4KSB7XG4gICAgbWF0cml4LmRlY29tcG9zZSh0aGlzKTtcbiAgICB0aGlzLl9sb2NhbElEKys7XG4gIH1cbiAgZ2V0IHJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yb3RhdGlvbjtcbiAgfVxuICBzZXQgcm90YXRpb24odmFsdWUpIHtcbiAgICBpZiAodGhpcy5fcm90YXRpb24gIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9yb3RhdGlvbiA9IHZhbHVlO1xuICAgICAgdGhpcy51cGRhdGVTa2V3KCk7XG4gICAgfVxuICB9XG59O1xubGV0IFRyYW5zZm9ybSA9IF9UcmFuc2Zvcm07XG5UcmFuc2Zvcm0uSURFTlRJVFkgPSBuZXcgX1RyYW5zZm9ybSgpO1xuXG5leHBvcnQgeyBUcmFuc2Zvcm0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyYW5zZm9ybS5tanMubWFwXG4iLCJleHBvcnQgeyBDaXJjbGUgfSBmcm9tICcuL3NoYXBlcy9DaXJjbGUubWpzJztcbmV4cG9ydCB7IEVsbGlwc2UgfSBmcm9tICcuL3NoYXBlcy9FbGxpcHNlLm1qcyc7XG5leHBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi9zaGFwZXMvUG9seWdvbi5tanMnO1xuZXhwb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi9zaGFwZXMvUmVjdGFuZ2xlLm1qcyc7XG5leHBvcnQgeyBSb3VuZGVkUmVjdGFuZ2xlIH0gZnJvbSAnLi9zaGFwZXMvUm91bmRlZFJlY3RhbmdsZS5tanMnO1xuZXhwb3J0IHsgZ3JvdXBEOCB9IGZyb20gJy4vZ3JvdXBEOC5tanMnO1xuaW1wb3J0ICcuL0lQb2ludC5tanMnO1xuaW1wb3J0ICcuL0lQb2ludERhdGEubWpzJztcbmV4cG9ydCB7IE1hdHJpeCB9IGZyb20gJy4vTWF0cml4Lm1qcyc7XG5leHBvcnQgeyBPYnNlcnZhYmxlUG9pbnQgfSBmcm9tICcuL09ic2VydmFibGVQb2ludC5tanMnO1xuZXhwb3J0IHsgUG9pbnQgfSBmcm9tICcuL1BvaW50Lm1qcyc7XG5leHBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICcuL1RyYW5zZm9ybS5tanMnO1xuZXhwb3J0IHsgREVHX1RPX1JBRCwgUElfMiwgUkFEX1RPX0RFRywgU0hBUEVTIH0gZnJvbSAnLi9jb25zdC5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwidmFyIGRlZmF1bHRGcmFnbWVudCA9IFwidmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxuXFxudm9pZCBtYWluKHZvaWQpe1xcbiAgIGdsX0ZyYWdDb2xvciAqPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcbn1cIjtcblxuZXhwb3J0IHsgZGVmYXVsdEZyYWdtZW50IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRQcm9ncmFtLm1qcy5tYXBcbiIsInZhciBkZWZhdWx0VmVydGV4ID0gXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG52b2lkIG1haW4odm9pZCl7XFxuICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxuICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxufVxcblwiO1xuXG5leHBvcnQgeyBkZWZhdWx0VmVydGV4IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRQcm9ncmFtMi5tanMubWFwXG4iLCJjb25zdCB1bmlmb3JtUGFyc2VycyA9IFtcbiAge1xuICAgIHRlc3Q6IChkYXRhKSA9PiBkYXRhLnR5cGUgPT09IFwiZmxvYXRcIiAmJiBkYXRhLnNpemUgPT09IDEgJiYgIWRhdGEuaXNBcnJheSxcbiAgICBjb2RlOiAobmFtZSkgPT4gYFxuICAgICAgICAgICAgaWYodXZbXCIke25hbWV9XCJdICE9PSB1ZFtcIiR7bmFtZX1cIl0udmFsdWUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdWRbXCIke25hbWV9XCJdLnZhbHVlID0gdXZbXCIke25hbWV9XCJdXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHVkW1wiJHtuYW1lfVwiXS5sb2NhdGlvbiwgdXZbXCIke25hbWV9XCJdKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYFxuICB9LFxuICB7XG4gICAgdGVzdDogKGRhdGEsIHVuaWZvcm0pID0+IChkYXRhLnR5cGUgPT09IFwic2FtcGxlcjJEXCIgfHwgZGF0YS50eXBlID09PSBcInNhbXBsZXJDdWJlXCIgfHwgZGF0YS50eXBlID09PSBcInNhbXBsZXIyREFycmF5XCIpICYmIGRhdGEuc2l6ZSA9PT0gMSAmJiAhZGF0YS5pc0FycmF5ICYmICh1bmlmb3JtID09IG51bGwgfHwgdW5pZm9ybS5jYXN0VG9CYXNlVGV4dHVyZSAhPT0gdm9pZCAwKSxcbiAgICBjb2RlOiAobmFtZSkgPT4gYHQgPSBzeW5jRGF0YS50ZXh0dXJlQ291bnQrKztcblxuICAgICAgICAgICAgcmVuZGVyZXIudGV4dHVyZS5iaW5kKHV2W1wiJHtuYW1lfVwiXSwgdCk7XG5cbiAgICAgICAgICAgIGlmKHVkW1wiJHtuYW1lfVwiXS52YWx1ZSAhPT0gdClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1ZFtcIiR7bmFtZX1cIl0udmFsdWUgPSB0O1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaSh1ZFtcIiR7bmFtZX1cIl0ubG9jYXRpb24sIHQpO1xuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cbiAgICAgICAgICAgIH1gXG4gIH0sXG4gIHtcbiAgICB0ZXN0OiAoZGF0YSwgdW5pZm9ybSkgPT4gZGF0YS50eXBlID09PSBcIm1hdDNcIiAmJiBkYXRhLnNpemUgPT09IDEgJiYgIWRhdGEuaXNBcnJheSAmJiB1bmlmb3JtLmEgIT09IHZvaWQgMCxcbiAgICBjb2RlOiAobmFtZSkgPT4gYFxuICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih1ZFtcIiR7bmFtZX1cIl0ubG9jYXRpb24sIGZhbHNlLCB1dltcIiR7bmFtZX1cIl0udG9BcnJheSh0cnVlKSk7XG4gICAgICAgICAgICBgLFxuICAgIGNvZGVVYm86IChuYW1lKSA9PiBgXG4gICAgICAgICAgICAgICAgdmFyICR7bmFtZX1fbWF0cml4ID0gdXYuJHtuYW1lfS50b0FycmF5KHRydWUpO1xuXG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gJHtuYW1lfV9tYXRyaXhbMF07XG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrMV0gPSAke25hbWV9X21hdHJpeFsxXTtcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCsyXSA9ICR7bmFtZX1fbWF0cml4WzJdO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCArIDRdID0gJHtuYW1lfV9tYXRyaXhbM107XG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyA1XSA9ICR7bmFtZX1fbWF0cml4WzRdO1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgNl0gPSAke25hbWV9X21hdHJpeFs1XTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyA4XSA9ICR7bmFtZX1fbWF0cml4WzZdO1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgOV0gPSAke25hbWV9X21hdHJpeFs3XTtcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCArIDEwXSA9ICR7bmFtZX1fbWF0cml4WzhdO1xuICAgICAgICAgICAgYFxuICB9LFxuICB7XG4gICAgdGVzdDogKGRhdGEsIHVuaWZvcm0pID0+IGRhdGEudHlwZSA9PT0gXCJ2ZWMyXCIgJiYgZGF0YS5zaXplID09PSAxICYmICFkYXRhLmlzQXJyYXkgJiYgdW5pZm9ybS54ICE9PSB2b2lkIDAsXG4gICAgY29kZTogKG5hbWUpID0+IGBcbiAgICAgICAgICAgICAgICBjdiA9IHVkW1wiJHtuYW1lfVwiXS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2ID0gdXZbXCIke25hbWV9XCJdO1xuXG4gICAgICAgICAgICAgICAgaWYoY3ZbMF0gIT09IHYueCB8fCBjdlsxXSAhPT0gdi55KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY3ZbMF0gPSB2Lng7XG4gICAgICAgICAgICAgICAgICAgIGN2WzFdID0gdi55O1xuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMmYodWRbXCIke25hbWV9XCJdLmxvY2F0aW9uLCB2LngsIHYueSk7XG4gICAgICAgICAgICAgICAgfWAsXG4gICAgY29kZVVibzogKG5hbWUpID0+IGBcbiAgICAgICAgICAgICAgICB2ID0gdXYuJHtuYW1lfTtcblxuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IHYueDtcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCsxXSA9IHYueTtcbiAgICAgICAgICAgIGBcbiAgfSxcbiAge1xuICAgIHRlc3Q6IChkYXRhKSA9PiBkYXRhLnR5cGUgPT09IFwidmVjMlwiICYmIGRhdGEuc2l6ZSA9PT0gMSAmJiAhZGF0YS5pc0FycmF5LFxuICAgIGNvZGU6IChuYW1lKSA9PiBgXG4gICAgICAgICAgICAgICAgY3YgPSB1ZFtcIiR7bmFtZX1cIl0udmFsdWU7XG4gICAgICAgICAgICAgICAgdiA9IHV2W1wiJHtuYW1lfVwiXTtcblxuICAgICAgICAgICAgICAgIGlmKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICAgICAgICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0yZih1ZFtcIiR7bmFtZX1cIl0ubG9jYXRpb24sIHZbMF0sIHZbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGBcbiAgfSxcbiAge1xuICAgIHRlc3Q6IChkYXRhLCB1bmlmb3JtKSA9PiBkYXRhLnR5cGUgPT09IFwidmVjNFwiICYmIGRhdGEuc2l6ZSA9PT0gMSAmJiAhZGF0YS5pc0FycmF5ICYmIHVuaWZvcm0ud2lkdGggIT09IHZvaWQgMCxcbiAgICBjb2RlOiAobmFtZSkgPT4gYFxuICAgICAgICAgICAgICAgIGN2ID0gdWRbXCIke25hbWV9XCJdLnZhbHVlO1xuICAgICAgICAgICAgICAgIHYgPSB1dltcIiR7bmFtZX1cIl07XG5cbiAgICAgICAgICAgICAgICBpZihjdlswXSAhPT0gdi54IHx8IGN2WzFdICE9PSB2LnkgfHwgY3ZbMl0gIT09IHYud2lkdGggfHwgY3ZbM10gIT09IHYuaGVpZ2h0KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY3ZbMF0gPSB2Lng7XG4gICAgICAgICAgICAgICAgICAgIGN2WzFdID0gdi55O1xuICAgICAgICAgICAgICAgICAgICBjdlsyXSA9IHYud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGN2WzNdID0gdi5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm00Zih1ZFtcIiR7bmFtZX1cIl0ubG9jYXRpb24sIHYueCwgdi55LCB2LndpZHRoLCB2LmhlaWdodClcbiAgICAgICAgICAgICAgICB9YCxcbiAgICBjb2RlVWJvOiAobmFtZSkgPT4gYFxuICAgICAgICAgICAgICAgICAgICB2ID0gdXYuJHtuYW1lfTtcblxuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldF0gPSB2Lng7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KzFdID0gdi55O1xuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldCsyXSA9IHYud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KzNdID0gdi5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgYFxuICB9LFxuICB7XG4gICAgdGVzdDogKGRhdGEsIHVuaWZvcm0pID0+IGRhdGEudHlwZSA9PT0gXCJ2ZWM0XCIgJiYgZGF0YS5zaXplID09PSAxICYmICFkYXRhLmlzQXJyYXkgJiYgdW5pZm9ybS5yZWQgIT09IHZvaWQgMCxcbiAgICBjb2RlOiAobmFtZSkgPT4gYFxuICAgICAgICAgICAgICAgIGN2ID0gdWRbXCIke25hbWV9XCJdLnZhbHVlO1xuICAgICAgICAgICAgICAgIHYgPSB1dltcIiR7bmFtZX1cIl07XG5cbiAgICAgICAgICAgICAgICBpZihjdlswXSAhPT0gdi5yZWQgfHwgY3ZbMV0gIT09IHYuZ3JlZW4gfHwgY3ZbMl0gIT09IHYuYmx1ZSB8fCBjdlszXSAhPT0gdi5hbHBoYSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGN2WzBdID0gdi5yZWQ7XG4gICAgICAgICAgICAgICAgICAgIGN2WzFdID0gdi5ncmVlbjtcbiAgICAgICAgICAgICAgICAgICAgY3ZbMl0gPSB2LmJsdWU7XG4gICAgICAgICAgICAgICAgICAgIGN2WzNdID0gdi5hbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTRmKHVkW1wiJHtuYW1lfVwiXS5sb2NhdGlvbiwgdi5yZWQsIHYuZ3JlZW4sIHYuYmx1ZSwgdi5hbHBoYSlcbiAgICAgICAgICAgICAgICB9YCxcbiAgICBjb2RlVWJvOiAobmFtZSkgPT4gYFxuICAgICAgICAgICAgICAgICAgICB2ID0gdXYuJHtuYW1lfTtcblxuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldF0gPSB2LnJlZDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrMV0gPSB2LmdyZWVuO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldCsyXSA9IHYuYmx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrM10gPSB2LmFscGhhO1xuICAgICAgICAgICAgICAgIGBcbiAgfSxcbiAge1xuICAgIHRlc3Q6IChkYXRhLCB1bmlmb3JtKSA9PiBkYXRhLnR5cGUgPT09IFwidmVjM1wiICYmIGRhdGEuc2l6ZSA9PT0gMSAmJiAhZGF0YS5pc0FycmF5ICYmIHVuaWZvcm0ucmVkICE9PSB2b2lkIDAsXG4gICAgY29kZTogKG5hbWUpID0+IGBcbiAgICAgICAgICAgICAgICBjdiA9IHVkW1wiJHtuYW1lfVwiXS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2ID0gdXZbXCIke25hbWV9XCJdO1xuXG4gICAgICAgICAgICAgICAgaWYoY3ZbMF0gIT09IHYucmVkIHx8IGN2WzFdICE9PSB2LmdyZWVuIHx8IGN2WzJdICE9PSB2LmJsdWUgfHwgY3ZbM10gIT09IHYuYSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGN2WzBdID0gdi5yZWQ7XG4gICAgICAgICAgICAgICAgICAgIGN2WzFdID0gdi5ncmVlbjtcbiAgICAgICAgICAgICAgICAgICAgY3ZbMl0gPSB2LmJsdWU7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0zZih1ZFtcIiR7bmFtZX1cIl0ubG9jYXRpb24sIHYucmVkLCB2LmdyZWVuLCB2LmJsdWUpXG4gICAgICAgICAgICAgICAgfWAsXG4gICAgY29kZVVibzogKG5hbWUpID0+IGBcbiAgICAgICAgICAgICAgICAgICAgdiA9IHV2LiR7bmFtZX07XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gdi5yZWQ7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KzFdID0gdi5ncmVlbjtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQrMl0gPSB2LmJsdWU7XG4gICAgICAgICAgICAgICAgYFxuICB9LFxuICB7XG4gICAgdGVzdDogKGRhdGEpID0+IGRhdGEudHlwZSA9PT0gXCJ2ZWM0XCIgJiYgZGF0YS5zaXplID09PSAxICYmICFkYXRhLmlzQXJyYXksXG4gICAgY29kZTogKG5hbWUpID0+IGBcbiAgICAgICAgICAgICAgICBjdiA9IHVkW1wiJHtuYW1lfVwiXS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2ID0gdXZbXCIke25hbWV9XCJdO1xuXG4gICAgICAgICAgICAgICAgaWYoY3ZbMF0gIT09IHZbMF0gfHwgY3ZbMV0gIT09IHZbMV0gfHwgY3ZbMl0gIT09IHZbMl0gfHwgY3ZbM10gIT09IHZbM10pXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjdlswXSA9IHZbMF07XG4gICAgICAgICAgICAgICAgICAgIGN2WzFdID0gdlsxXTtcbiAgICAgICAgICAgICAgICAgICAgY3ZbMl0gPSB2WzJdO1xuICAgICAgICAgICAgICAgICAgICBjdlszXSA9IHZbM107XG5cbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTRmKHVkW1wiJHtuYW1lfVwiXS5sb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSwgdlszXSlcbiAgICAgICAgICAgICAgICB9YFxuICB9XG5dO1xuXG5leHBvcnQgeyB1bmlmb3JtUGFyc2VycyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5pZm9ybVBhcnNlcnMubWpzLm1hcFxuIiwiaW1wb3J0IHsgdW5pZm9ybVBhcnNlcnMgfSBmcm9tICcuL3VuaWZvcm1QYXJzZXJzLm1qcyc7XG5cbmNvbnN0IEdMU0xfVE9fU0lOR0xFX1NFVFRFUlNfQ0FDSEVEID0ge1xuICBmbG9hdDogYFxuICAgIGlmIChjdiAhPT0gdilcbiAgICB7XG4gICAgICAgIGN1LnZhbHVlID0gdjtcbiAgICAgICAgZ2wudW5pZm9ybTFmKGxvY2F0aW9uLCB2KTtcbiAgICB9YCxcbiAgdmVjMjogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuXG4gICAgICAgIGdsLnVuaWZvcm0yZihsb2NhdGlvbiwgdlswXSwgdlsxXSlcbiAgICB9YCxcbiAgdmVjMzogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSB8fCBjdlsyXSAhPT0gdlsyXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuICAgICAgICBjdlsyXSA9IHZbMl07XG5cbiAgICAgICAgZ2wudW5pZm9ybTNmKGxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdKVxuICAgIH1gLFxuICB2ZWM0OiBgXG4gICAgaWYgKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdIHx8IGN2WzJdICE9PSB2WzJdIHx8IGN2WzNdICE9PSB2WzNdKVxuICAgIHtcbiAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgIGN2WzJdID0gdlsyXTtcbiAgICAgICAgY3ZbM10gPSB2WzNdO1xuXG4gICAgICAgIGdsLnVuaWZvcm00Zihsb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSwgdlszXSk7XG4gICAgfWAsXG4gIGludDogYFxuICAgIGlmIChjdiAhPT0gdilcbiAgICB7XG4gICAgICAgIGN1LnZhbHVlID0gdjtcblxuICAgICAgICBnbC51bmlmb3JtMWkobG9jYXRpb24sIHYpO1xuICAgIH1gLFxuICBpdmVjMjogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuXG4gICAgICAgIGdsLnVuaWZvcm0yaShsb2NhdGlvbiwgdlswXSwgdlsxXSk7XG4gICAgfWAsXG4gIGl2ZWMzOiBgXG4gICAgaWYgKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdIHx8IGN2WzJdICE9PSB2WzJdKVxuICAgIHtcbiAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgIGN2WzJdID0gdlsyXTtcblxuICAgICAgICBnbC51bmlmb3JtM2kobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0pO1xuICAgIH1gLFxuICBpdmVjNDogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSB8fCBjdlsyXSAhPT0gdlsyXSB8fCBjdlszXSAhPT0gdlszXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuICAgICAgICBjdlsyXSA9IHZbMl07XG4gICAgICAgIGN2WzNdID0gdlszXTtcblxuICAgICAgICBnbC51bmlmb3JtNGkobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0sIHZbM10pO1xuICAgIH1gLFxuICB1aW50OiBgXG4gICAgaWYgKGN2ICE9PSB2KVxuICAgIHtcbiAgICAgICAgY3UudmFsdWUgPSB2O1xuXG4gICAgICAgIGdsLnVuaWZvcm0xdWkobG9jYXRpb24sIHYpO1xuICAgIH1gLFxuICB1dmVjMjogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuXG4gICAgICAgIGdsLnVuaWZvcm0ydWkobG9jYXRpb24sIHZbMF0sIHZbMV0pO1xuICAgIH1gLFxuICB1dmVjMzogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSB8fCBjdlsyXSAhPT0gdlsyXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuICAgICAgICBjdlsyXSA9IHZbMl07XG5cbiAgICAgICAgZ2wudW5pZm9ybTN1aShsb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSk7XG4gICAgfWAsXG4gIHV2ZWM0OiBgXG4gICAgaWYgKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdIHx8IGN2WzJdICE9PSB2WzJdIHx8IGN2WzNdICE9PSB2WzNdKVxuICAgIHtcbiAgICAgICAgY3ZbMF0gPSB2WzBdO1xuICAgICAgICBjdlsxXSA9IHZbMV07XG4gICAgICAgIGN2WzJdID0gdlsyXTtcbiAgICAgICAgY3ZbM10gPSB2WzNdO1xuXG4gICAgICAgIGdsLnVuaWZvcm00dWkobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0sIHZbM10pO1xuICAgIH1gLFxuICBib29sOiBgXG4gICAgaWYgKGN2ICE9PSB2KVxuICAgIHtcbiAgICAgICAgY3UudmFsdWUgPSB2O1xuICAgICAgICBnbC51bmlmb3JtMWkobG9jYXRpb24sIHYpO1xuICAgIH1gLFxuICBidmVjMjogYFxuICAgIGlmIChjdlswXSAhPSB2WzBdIHx8IGN2WzFdICE9IHZbMV0pXG4gICAge1xuICAgICAgICBjdlswXSA9IHZbMF07XG4gICAgICAgIGN2WzFdID0gdlsxXTtcblxuICAgICAgICBnbC51bmlmb3JtMmkobG9jYXRpb24sIHZbMF0sIHZbMV0pO1xuICAgIH1gLFxuICBidmVjMzogYFxuICAgIGlmIChjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSB8fCBjdlsyXSAhPT0gdlsyXSlcbiAgICB7XG4gICAgICAgIGN2WzBdID0gdlswXTtcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xuICAgICAgICBjdlsyXSA9IHZbMl07XG5cbiAgICAgICAgZ2wudW5pZm9ybTNpKGxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdKTtcbiAgICB9YCxcbiAgYnZlYzQ6IGBcbiAgICBpZiAoY3ZbMF0gIT09IHZbMF0gfHwgY3ZbMV0gIT09IHZbMV0gfHwgY3ZbMl0gIT09IHZbMl0gfHwgY3ZbM10gIT09IHZbM10pXG4gICAge1xuICAgICAgICBjdlswXSA9IHZbMF07XG4gICAgICAgIGN2WzFdID0gdlsxXTtcbiAgICAgICAgY3ZbMl0gPSB2WzJdO1xuICAgICAgICBjdlszXSA9IHZbM107XG5cbiAgICAgICAgZ2wudW5pZm9ybTRpKGxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdLCB2WzNdKTtcbiAgICB9YCxcbiAgbWF0MjogXCJnbC51bmlmb3JtTWF0cml4MmZ2KGxvY2F0aW9uLCBmYWxzZSwgdilcIixcbiAgbWF0MzogXCJnbC51bmlmb3JtTWF0cml4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgdilcIixcbiAgbWF0NDogXCJnbC51bmlmb3JtTWF0cml4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgdilcIixcbiAgc2FtcGxlcjJEOiBgXG4gICAgaWYgKGN2ICE9PSB2KVxuICAgIHtcbiAgICAgICAgY3UudmFsdWUgPSB2O1xuXG4gICAgICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdik7XG4gICAgfWAsXG4gIHNhbXBsZXJDdWJlOiBgXG4gICAgaWYgKGN2ICE9PSB2KVxuICAgIHtcbiAgICAgICAgY3UudmFsdWUgPSB2O1xuXG4gICAgICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdik7XG4gICAgfWAsXG4gIHNhbXBsZXIyREFycmF5OiBgXG4gICAgaWYgKGN2ICE9PSB2KVxuICAgIHtcbiAgICAgICAgY3UudmFsdWUgPSB2O1xuXG4gICAgICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdik7XG4gICAgfWBcbn07XG5jb25zdCBHTFNMX1RPX0FSUkFZX1NFVFRFUlMgPSB7XG4gIGZsb2F0OiBgZ2wudW5pZm9ybTFmdihsb2NhdGlvbiwgdilgLFxuICB2ZWMyOiBgZ2wudW5pZm9ybTJmdihsb2NhdGlvbiwgdilgLFxuICB2ZWMzOiBgZ2wudW5pZm9ybTNmdihsb2NhdGlvbiwgdilgLFxuICB2ZWM0OiBcImdsLnVuaWZvcm00ZnYobG9jYXRpb24sIHYpXCIsXG4gIG1hdDQ6IFwiZ2wudW5pZm9ybU1hdHJpeDRmdihsb2NhdGlvbiwgZmFsc2UsIHYpXCIsXG4gIG1hdDM6IFwiZ2wudW5pZm9ybU1hdHJpeDNmdihsb2NhdGlvbiwgZmFsc2UsIHYpXCIsXG4gIG1hdDI6IFwiZ2wudW5pZm9ybU1hdHJpeDJmdihsb2NhdGlvbiwgZmFsc2UsIHYpXCIsXG4gIGludDogXCJnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB2KVwiLFxuICBpdmVjMjogXCJnbC51bmlmb3JtMml2KGxvY2F0aW9uLCB2KVwiLFxuICBpdmVjMzogXCJnbC51bmlmb3JtM2l2KGxvY2F0aW9uLCB2KVwiLFxuICBpdmVjNDogXCJnbC51bmlmb3JtNGl2KGxvY2F0aW9uLCB2KVwiLFxuICB1aW50OiBcImdsLnVuaWZvcm0xdWl2KGxvY2F0aW9uLCB2KVwiLFxuICB1dmVjMjogXCJnbC51bmlmb3JtMnVpdihsb2NhdGlvbiwgdilcIixcbiAgdXZlYzM6IFwiZ2wudW5pZm9ybTN1aXYobG9jYXRpb24sIHYpXCIsXG4gIHV2ZWM0OiBcImdsLnVuaWZvcm00dWl2KGxvY2F0aW9uLCB2KVwiLFxuICBib29sOiBcImdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHYpXCIsXG4gIGJ2ZWMyOiBcImdsLnVuaWZvcm0yaXYobG9jYXRpb24sIHYpXCIsXG4gIGJ2ZWMzOiBcImdsLnVuaWZvcm0zaXYobG9jYXRpb24sIHYpXCIsXG4gIGJ2ZWM0OiBcImdsLnVuaWZvcm00aXYobG9jYXRpb24sIHYpXCIsXG4gIHNhbXBsZXIyRDogXCJnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB2KVwiLFxuICBzYW1wbGVyQ3ViZTogXCJnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB2KVwiLFxuICBzYW1wbGVyMkRBcnJheTogXCJnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB2KVwiXG59O1xuZnVuY3Rpb24gZ2VuZXJhdGVVbmlmb3Jtc1N5bmMoZ3JvdXAsIHVuaWZvcm1EYXRhKSB7XG4gIGNvbnN0IGZ1bmNGcmFnbWVudHMgPSBbYFxuICAgICAgICB2YXIgdiA9IG51bGw7XG4gICAgICAgIHZhciBjdiA9IG51bGw7XG4gICAgICAgIHZhciBjdSA9IG51bGw7XG4gICAgICAgIHZhciB0ID0gMDtcbiAgICAgICAgdmFyIGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgYF07XG4gIGZvciAoY29uc3QgaSBpbiBncm91cC51bmlmb3Jtcykge1xuICAgIGNvbnN0IGRhdGEgPSB1bmlmb3JtRGF0YVtpXTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIGlmIChncm91cC51bmlmb3Jtc1tpXT8uZ3JvdXApIHtcbiAgICAgICAgaWYgKGdyb3VwLnVuaWZvcm1zW2ldLnVibykge1xuICAgICAgICAgIGZ1bmNGcmFnbWVudHMucHVzaChgXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlci5zaGFkZXIuc3luY1VuaWZvcm1CdWZmZXJHcm91cCh1di4ke2l9LCAnJHtpfScpO1xuICAgICAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmdW5jRnJhZ21lbnRzLnB1c2goYFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIuc2hhZGVyLnN5bmNVbmlmb3JtR3JvdXAodXYuJHtpfSwgc3luY0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHVuaWZvcm0gPSBncm91cC51bmlmb3Jtc1tpXTtcbiAgICBsZXQgcGFyc2VkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB1bmlmb3JtUGFyc2Vycy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKHVuaWZvcm1QYXJzZXJzW2pdLnRlc3QoZGF0YSwgdW5pZm9ybSkpIHtcbiAgICAgICAgZnVuY0ZyYWdtZW50cy5wdXNoKHVuaWZvcm1QYXJzZXJzW2pdLmNvZGUoaSwgdW5pZm9ybSkpO1xuICAgICAgICBwYXJzZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlVHlwZSA9IGRhdGEuc2l6ZSA9PT0gMSAmJiAhZGF0YS5pc0FycmF5ID8gR0xTTF9UT19TSU5HTEVfU0VUVEVSU19DQUNIRUQgOiBHTFNMX1RPX0FSUkFZX1NFVFRFUlM7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlVHlwZVtkYXRhLnR5cGVdLnJlcGxhY2UoXCJsb2NhdGlvblwiLCBgdWRbXCIke2l9XCJdLmxvY2F0aW9uYCk7XG4gICAgICBmdW5jRnJhZ21lbnRzLnB1c2goYFxuICAgICAgICAgICAgY3UgPSB1ZFtcIiR7aX1cIl07XG4gICAgICAgICAgICBjdiA9IGN1LnZhbHVlO1xuICAgICAgICAgICAgdiA9IHV2W1wiJHtpfVwiXTtcbiAgICAgICAgICAgICR7dGVtcGxhdGV9O2ApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwidWRcIiwgXCJ1dlwiLCBcInJlbmRlcmVyXCIsIFwic3luY0RhdGFcIiwgZnVuY0ZyYWdtZW50cy5qb2luKFwiXFxuXCIpKTtcbn1cblxuZXhwb3J0IHsgZ2VuZXJhdGVVbmlmb3Jtc1N5bmMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbmVyYXRlVW5pZm9ybXNTeW5jLm1qcy5tYXBcbiIsImltcG9ydCB7IEVOViB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gJ0BwaXhpL3NldHRpbmdzJztcblxuY29uc3QgdW5rbm93bkNvbnRleHQgPSB7fTtcbmxldCBjb250ZXh0ID0gdW5rbm93bkNvbnRleHQ7XG5mdW5jdGlvbiBnZXRUZXN0Q29udGV4dCgpIHtcbiAgaWYgKGNvbnRleHQgPT09IHVua25vd25Db250ZXh0IHx8IGNvbnRleHQ/LmlzQ29udGV4dExvc3QoKSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IHNldHRpbmdzLkFEQVBURVIuY3JlYXRlQ2FudmFzKCk7XG4gICAgbGV0IGdsO1xuICAgIGlmIChzZXR0aW5ncy5QUkVGRVJfRU5WID49IEVOVi5XRUJHTDIpIHtcbiAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbDJcIiwge30pO1xuICAgIH1cbiAgICBpZiAoIWdsKSB7XG4gICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIiwge30pIHx8IGNhbnZhcy5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsIHt9KTtcbiAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgZ2wgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfZHJhd19idWZmZXJzXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb250ZXh0ID0gZ2w7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmV4cG9ydCB7IGdldFRlc3RDb250ZXh0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRUZXN0Q29udGV4dC5tanMubWFwXG4iLCJpbXBvcnQgeyBQUkVDSVNJT04gfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuaW1wb3J0IHsgZ2V0VGVzdENvbnRleHQgfSBmcm9tICcuL2dldFRlc3RDb250ZXh0Lm1qcyc7XG5cbmxldCBtYXhGcmFnbWVudFByZWNpc2lvbjtcbmZ1bmN0aW9uIGdldE1heEZyYWdtZW50UHJlY2lzaW9uKCkge1xuICBpZiAoIW1heEZyYWdtZW50UHJlY2lzaW9uKSB7XG4gICAgbWF4RnJhZ21lbnRQcmVjaXNpb24gPSBQUkVDSVNJT04uTUVESVVNO1xuICAgIGNvbnN0IGdsID0gZ2V0VGVzdENvbnRleHQoKTtcbiAgICBpZiAoZ2wpIHtcbiAgICAgIGlmIChnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQpIHtcbiAgICAgICAgY29uc3Qgc2hhZGVyRnJhZ21lbnQgPSBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5ISUdIX0ZMT0FUKTtcbiAgICAgICAgbWF4RnJhZ21lbnRQcmVjaXNpb24gPSBzaGFkZXJGcmFnbWVudC5wcmVjaXNpb24gPyBQUkVDSVNJT04uSElHSCA6IFBSRUNJU0lPTi5NRURJVU07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXhGcmFnbWVudFByZWNpc2lvbjtcbn1cblxuZXhwb3J0IHsgZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldE1heEZyYWdtZW50UHJlY2lzaW9uLm1qcy5tYXBcbiIsImNvbnN0IEdMU0xfVE9fU0laRSA9IHtcbiAgZmxvYXQ6IDEsXG4gIHZlYzI6IDIsXG4gIHZlYzM6IDMsXG4gIHZlYzQ6IDQsXG4gIGludDogMSxcbiAgaXZlYzI6IDIsXG4gIGl2ZWMzOiAzLFxuICBpdmVjNDogNCxcbiAgdWludDogMSxcbiAgdXZlYzI6IDIsXG4gIHV2ZWMzOiAzLFxuICB1dmVjNDogNCxcbiAgYm9vbDogMSxcbiAgYnZlYzI6IDIsXG4gIGJ2ZWMzOiAzLFxuICBidmVjNDogNCxcbiAgbWF0MjogNCxcbiAgbWF0MzogOSxcbiAgbWF0NDogMTYsXG4gIHNhbXBsZXIyRDogMVxufTtcbmZ1bmN0aW9uIG1hcFNpemUodHlwZSkge1xuICByZXR1cm4gR0xTTF9UT19TSVpFW3R5cGVdO1xufVxuXG5leHBvcnQgeyBtYXBTaXplIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXBTaXplLm1qcy5tYXBcbiIsImxldCBHTF9UQUJMRSA9IG51bGw7XG5jb25zdCBHTF9UT19HTFNMX1RZUEVTID0ge1xuICBGTE9BVDogXCJmbG9hdFwiLFxuICBGTE9BVF9WRUMyOiBcInZlYzJcIixcbiAgRkxPQVRfVkVDMzogXCJ2ZWMzXCIsXG4gIEZMT0FUX1ZFQzQ6IFwidmVjNFwiLFxuICBJTlQ6IFwiaW50XCIsXG4gIElOVF9WRUMyOiBcIml2ZWMyXCIsXG4gIElOVF9WRUMzOiBcIml2ZWMzXCIsXG4gIElOVF9WRUM0OiBcIml2ZWM0XCIsXG4gIFVOU0lHTkVEX0lOVDogXCJ1aW50XCIsXG4gIFVOU0lHTkVEX0lOVF9WRUMyOiBcInV2ZWMyXCIsXG4gIFVOU0lHTkVEX0lOVF9WRUMzOiBcInV2ZWMzXCIsXG4gIFVOU0lHTkVEX0lOVF9WRUM0OiBcInV2ZWM0XCIsXG4gIEJPT0w6IFwiYm9vbFwiLFxuICBCT09MX1ZFQzI6IFwiYnZlYzJcIixcbiAgQk9PTF9WRUMzOiBcImJ2ZWMzXCIsXG4gIEJPT0xfVkVDNDogXCJidmVjNFwiLFxuICBGTE9BVF9NQVQyOiBcIm1hdDJcIixcbiAgRkxPQVRfTUFUMzogXCJtYXQzXCIsXG4gIEZMT0FUX01BVDQ6IFwibWF0NFwiLFxuICBTQU1QTEVSXzJEOiBcInNhbXBsZXIyRFwiLFxuICBJTlRfU0FNUExFUl8yRDogXCJzYW1wbGVyMkRcIixcbiAgVU5TSUdORURfSU5UX1NBTVBMRVJfMkQ6IFwic2FtcGxlcjJEXCIsXG4gIFNBTVBMRVJfQ1VCRTogXCJzYW1wbGVyQ3ViZVwiLFxuICBJTlRfU0FNUExFUl9DVUJFOiBcInNhbXBsZXJDdWJlXCIsXG4gIFVOU0lHTkVEX0lOVF9TQU1QTEVSX0NVQkU6IFwic2FtcGxlckN1YmVcIixcbiAgU0FNUExFUl8yRF9BUlJBWTogXCJzYW1wbGVyMkRBcnJheVwiLFxuICBJTlRfU0FNUExFUl8yRF9BUlJBWTogXCJzYW1wbGVyMkRBcnJheVwiLFxuICBVTlNJR05FRF9JTlRfU0FNUExFUl8yRF9BUlJBWTogXCJzYW1wbGVyMkRBcnJheVwiXG59O1xuZnVuY3Rpb24gbWFwVHlwZShnbCwgdHlwZSkge1xuICBpZiAoIUdMX1RBQkxFKSB7XG4gICAgY29uc3QgdHlwZU5hbWVzID0gT2JqZWN0LmtleXMoR0xfVE9fR0xTTF9UWVBFUyk7XG4gICAgR0xfVEFCTEUgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVOYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgdG4gPSB0eXBlTmFtZXNbaV07XG4gICAgICBHTF9UQUJMRVtnbFt0bl1dID0gR0xfVE9fR0xTTF9UWVBFU1t0bl07XG4gICAgfVxuICB9XG4gIHJldHVybiBHTF9UQUJMRVt0eXBlXTtcbn1cblxuZXhwb3J0IHsgbWFwVHlwZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwVHlwZS5tanMubWFwXG4iLCJpbXBvcnQgeyBQUkVDSVNJT04gfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuXG5mdW5jdGlvbiBzZXRQcmVjaXNpb24oc3JjLCByZXF1ZXN0ZWRQcmVjaXNpb24sIG1heFN1cHBvcnRlZFByZWNpc2lvbikge1xuICBpZiAoc3JjLnN1YnN0cmluZygwLCA5KSAhPT0gXCJwcmVjaXNpb25cIikge1xuICAgIGxldCBwcmVjaXNpb24gPSByZXF1ZXN0ZWRQcmVjaXNpb247XG4gICAgaWYgKHJlcXVlc3RlZFByZWNpc2lvbiA9PT0gUFJFQ0lTSU9OLkhJR0ggJiYgbWF4U3VwcG9ydGVkUHJlY2lzaW9uICE9PSBQUkVDSVNJT04uSElHSCkge1xuICAgICAgcHJlY2lzaW9uID0gUFJFQ0lTSU9OLk1FRElVTTtcbiAgICB9XG4gICAgcmV0dXJuIGBwcmVjaXNpb24gJHtwcmVjaXNpb259IGZsb2F0O1xuJHtzcmN9YDtcbiAgfSBlbHNlIGlmIChtYXhTdXBwb3J0ZWRQcmVjaXNpb24gIT09IFBSRUNJU0lPTi5ISUdIICYmIHNyYy5zdWJzdHJpbmcoMCwgMTUpID09PSBcInByZWNpc2lvbiBoaWdocFwiKSB7XG4gICAgcmV0dXJuIHNyYy5yZXBsYWNlKFwicHJlY2lzaW9uIGhpZ2hwXCIsIFwicHJlY2lzaW9uIG1lZGl1bXBcIik7XG4gIH1cbiAgcmV0dXJuIHNyYztcbn1cblxuZXhwb3J0IHsgc2V0UHJlY2lzaW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXRQcmVjaXNpb24ubWpzLm1hcFxuIiwiZXhwb3J0IHsgY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlciB9IGZyb20gJy4vY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlci5tanMnO1xuZXhwb3J0IHsgY29tcGlsZVNoYWRlciB9IGZyb20gJy4vY29tcGlsZVNoYWRlci5tanMnO1xuZXhwb3J0IHsgZGVmYXVsdFZhbHVlIH0gZnJvbSAnLi9kZWZhdWx0VmFsdWUubWpzJztcbmV4cG9ydCB7IGdlbmVyYXRlVW5pZm9ybXNTeW5jIH0gZnJvbSAnLi9nZW5lcmF0ZVVuaWZvcm1zU3luYy5tanMnO1xuZXhwb3J0IHsgZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb24gfSBmcm9tICcuL2dldE1heEZyYWdtZW50UHJlY2lzaW9uLm1qcyc7XG5leHBvcnQgeyBnZXRUZXN0Q29udGV4dCB9IGZyb20gJy4vZ2V0VGVzdENvbnRleHQubWpzJztcbmV4cG9ydCB7IGxvZ1Byb2dyYW1FcnJvciB9IGZyb20gJy4vbG9nUHJvZ3JhbUVycm9yLm1qcyc7XG5leHBvcnQgeyBtYXBTaXplIH0gZnJvbSAnLi9tYXBTaXplLm1qcyc7XG5leHBvcnQgeyBtYXBUeXBlIH0gZnJvbSAnLi9tYXBUeXBlLm1qcyc7XG5leHBvcnQgeyBzZXRQcmVjaXNpb24gfSBmcm9tICcuL3NldFByZWNpc2lvbi5tanMnO1xuZXhwb3J0IHsgdW5pZm9ybVBhcnNlcnMgfSBmcm9tICcuL3VuaWZvcm1QYXJzZXJzLm1qcyc7XG5leHBvcnQgeyB1bnNhZmVFdmFsU3VwcG9ydGVkIH0gZnJvbSAnLi91bnNhZmVFdmFsU3VwcG9ydGVkLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBQUkVDSVNJT04gfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuaW1wb3J0IHsgUHJvZ3JhbUNhY2hlLCBpc01vYmlsZSB9IGZyb20gJ0BwaXhpL3V0aWxzJztcbmltcG9ydCBkZWZhdWx0RnJhZ21lbnQgZnJvbSAnLi9kZWZhdWx0UHJvZ3JhbS5tanMnO1xuaW1wb3J0IGRlZmF1bHRWZXJ0ZXggZnJvbSAnLi9kZWZhdWx0UHJvZ3JhbTIubWpzJztcbmltcG9ydCAnLi91dGlscy9pbmRleC5tanMnO1xuaW1wb3J0IHsgc2V0UHJlY2lzaW9uIH0gZnJvbSAnLi91dGlscy9zZXRQcmVjaXNpb24ubWpzJztcbmltcG9ydCB7IGdldE1heEZyYWdtZW50UHJlY2lzaW9uIH0gZnJvbSAnLi91dGlscy9nZXRNYXhGcmFnbWVudFByZWNpc2lvbi5tanMnO1xuXG5sZXQgVUlEID0gMDtcbmNvbnN0IG5hbWVDYWNoZSA9IHt9O1xuY29uc3QgX1Byb2dyYW0gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIG5hbWUgPSBcInBpeGktc2hhZGVyXCIsIGV4dHJhID0ge30pIHtcbiAgICB0aGlzLmV4dHJhID0ge307XG4gICAgdGhpcy5pZCA9IFVJRCsrO1xuICAgIHRoaXMudmVydGV4U3JjID0gdmVydGV4U3JjIHx8IF9Qcm9ncmFtLmRlZmF1bHRWZXJ0ZXhTcmM7XG4gICAgdGhpcy5mcmFnbWVudFNyYyA9IGZyYWdtZW50U3JjIHx8IF9Qcm9ncmFtLmRlZmF1bHRGcmFnbWVudFNyYztcbiAgICB0aGlzLnZlcnRleFNyYyA9IHRoaXMudmVydGV4U3JjLnRyaW0oKTtcbiAgICB0aGlzLmZyYWdtZW50U3JjID0gdGhpcy5mcmFnbWVudFNyYy50cmltKCk7XG4gICAgdGhpcy5leHRyYSA9IGV4dHJhO1xuICAgIGlmICh0aGlzLnZlcnRleFNyYy5zdWJzdHJpbmcoMCwgOCkgIT09IFwiI3ZlcnNpb25cIikge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvXFxzKy9nLCBcIi1cIik7XG4gICAgICBpZiAobmFtZUNhY2hlW25hbWVdKSB7XG4gICAgICAgIG5hbWVDYWNoZVtuYW1lXSsrO1xuICAgICAgICBuYW1lICs9IGAtJHtuYW1lQ2FjaGVbbmFtZV19YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWVDYWNoZVtuYW1lXSA9IDE7XG4gICAgICB9XG4gICAgICB0aGlzLnZlcnRleFNyYyA9IGAjZGVmaW5lIFNIQURFUl9OQU1FICR7bmFtZX1cbiR7dGhpcy52ZXJ0ZXhTcmN9YDtcbiAgICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBgI2RlZmluZSBTSEFERVJfTkFNRSAke25hbWV9XG4ke3RoaXMuZnJhZ21lbnRTcmN9YDtcbiAgICAgIHRoaXMudmVydGV4U3JjID0gc2V0UHJlY2lzaW9uKHRoaXMudmVydGV4U3JjLCBfUHJvZ3JhbS5kZWZhdWx0VmVydGV4UHJlY2lzaW9uLCBQUkVDSVNJT04uSElHSCk7XG4gICAgICB0aGlzLmZyYWdtZW50U3JjID0gc2V0UHJlY2lzaW9uKHRoaXMuZnJhZ21lbnRTcmMsIF9Qcm9ncmFtLmRlZmF1bHRGcmFnbWVudFByZWNpc2lvbiwgZ2V0TWF4RnJhZ21lbnRQcmVjaXNpb24oKSk7XG4gICAgfVxuICAgIHRoaXMuZ2xQcm9ncmFtcyA9IHt9O1xuICAgIHRoaXMuc3luY1VuaWZvcm1zID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRWZXJ0ZXhTcmMoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRWZXJ0ZXg7XG4gIH1cbiAgc3RhdGljIGdldCBkZWZhdWx0RnJhZ21lbnRTcmMoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRGcmFnbWVudDtcbiAgfVxuICBzdGF0aWMgZnJvbSh2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBuYW1lKSB7XG4gICAgY29uc3Qga2V5ID0gdmVydGV4U3JjICsgZnJhZ21lbnRTcmM7XG4gICAgbGV0IHByb2dyYW0gPSBQcm9ncmFtQ2FjaGVba2V5XTtcbiAgICBpZiAoIXByb2dyYW0pIHtcbiAgICAgIFByb2dyYW1DYWNoZVtrZXldID0gcHJvZ3JhbSA9IG5ldyBfUHJvZ3JhbSh2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2dyYW07XG4gIH1cbn07XG5sZXQgUHJvZ3JhbSA9IF9Qcm9ncmFtO1xuUHJvZ3JhbS5kZWZhdWx0VmVydGV4UHJlY2lzaW9uID0gUFJFQ0lTSU9OLkhJR0g7XG5Qcm9ncmFtLmRlZmF1bHRGcmFnbWVudFByZWNpc2lvbiA9IGlzTW9iaWxlLmFwcGxlLmRldmljZSA/IFBSRUNJU0lPTi5ISUdIIDogUFJFQ0lTSU9OLk1FRElVTTtcblxuZXhwb3J0IHsgUHJvZ3JhbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJvZ3JhbS5tanMubWFwXG4iLCJpbXBvcnQgeyBCVUZGRVJfVFlQRSB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICcuLi9nZW9tZXRyeS9CdWZmZXIubWpzJztcblxubGV0IFVJRCA9IDA7XG5jbGFzcyBVbmlmb3JtR3JvdXAge1xuICBjb25zdHJ1Y3Rvcih1bmlmb3JtcywgaXNTdGF0aWMsIGlzVWJvKSB7XG4gICAgdGhpcy5ncm91cCA9IHRydWU7XG4gICAgdGhpcy5zeW5jVW5pZm9ybXMgPSB7fTtcbiAgICB0aGlzLmRpcnR5SWQgPSAwO1xuICAgIHRoaXMuaWQgPSBVSUQrKztcbiAgICB0aGlzLnN0YXRpYyA9ICEhaXNTdGF0aWM7XG4gICAgdGhpcy51Ym8gPSAhIWlzVWJvO1xuICAgIGlmICh1bmlmb3JtcyBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgdGhpcy5idWZmZXIgPSB1bmlmb3JtcztcbiAgICAgIHRoaXMuYnVmZmVyLnR5cGUgPSBCVUZGRVJfVFlQRS5VTklGT1JNX0JVRkZFUjtcbiAgICAgIHRoaXMuYXV0b01hbmFnZSA9IGZhbHNlO1xuICAgICAgdGhpcy51Ym8gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuaWZvcm1zID0gdW5pZm9ybXM7XG4gICAgICBpZiAodGhpcy51Ym8pIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyKG5ldyBGbG9hdDMyQXJyYXkoMSkpO1xuICAgICAgICB0aGlzLmJ1ZmZlci50eXBlID0gQlVGRkVSX1RZUEUuVU5JRk9STV9CVUZGRVI7XG4gICAgICAgIHRoaXMuYXV0b01hbmFnZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLmRpcnR5SWQrKztcbiAgICBpZiAoIXRoaXMuYXV0b01hbmFnZSAmJiB0aGlzLmJ1ZmZlcikge1xuICAgICAgdGhpcy5idWZmZXIudXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIGFkZChuYW1lLCB1bmlmb3JtcywgX3N0YXRpYykge1xuICAgIGlmICghdGhpcy51Ym8pIHtcbiAgICAgIHRoaXMudW5pZm9ybXNbbmFtZV0gPSBuZXcgVW5pZm9ybUdyb3VwKHVuaWZvcm1zLCBfc3RhdGljKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW1VuaWZvcm1Hcm91cF0gdW5pZm9ybSBncm91cHMgaW4gdWJvIG1vZGUgY2Fubm90IGJlIG1vZGlmaWVkLCBvciBoYXZlIHVuaWZvcm0gZ3JvdXBzIG5lc3RlZCBpbiB0aGVtXCIpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZnJvbSh1bmlmb3JtcywgX3N0YXRpYywgX3Vibykge1xuICAgIHJldHVybiBuZXcgVW5pZm9ybUdyb3VwKHVuaWZvcm1zLCBfc3RhdGljLCBfdWJvKTtcbiAgfVxuICBzdGF0aWMgdWJvRnJvbSh1bmlmb3JtcywgX3N0YXRpYykge1xuICAgIHJldHVybiBuZXcgVW5pZm9ybUdyb3VwKHVuaWZvcm1zLCBfc3RhdGljID8/IHRydWUsIHRydWUpO1xuICB9XG59XG5cbmV4cG9ydCB7IFVuaWZvcm1Hcm91cCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VW5pZm9ybUdyb3VwLm1qcy5tYXBcbiIsImltcG9ydCB7IFJ1bm5lciB9IGZyb20gJ0BwaXhpL3J1bm5lcic7XG5pbXBvcnQgeyBQcm9ncmFtIH0gZnJvbSAnLi9Qcm9ncmFtLm1qcyc7XG5pbXBvcnQgeyBVbmlmb3JtR3JvdXAgfSBmcm9tICcuL1VuaWZvcm1Hcm91cC5tanMnO1xuXG5jbGFzcyBTaGFkZXIge1xuICBjb25zdHJ1Y3Rvcihwcm9ncmFtLCB1bmlmb3Jtcykge1xuICAgIHRoaXMudW5pZm9ybUJpbmRDb3VudCA9IDA7XG4gICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICBpZiAodW5pZm9ybXMpIHtcbiAgICAgIGlmICh1bmlmb3JtcyBpbnN0YW5jZW9mIFVuaWZvcm1Hcm91cCkge1xuICAgICAgICB0aGlzLnVuaWZvcm1Hcm91cCA9IHVuaWZvcm1zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51bmlmb3JtR3JvdXAgPSBuZXcgVW5pZm9ybUdyb3VwKHVuaWZvcm1zKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmlmb3JtR3JvdXAgPSBuZXcgVW5pZm9ybUdyb3VwKHt9KTtcbiAgICB9XG4gICAgdGhpcy5kaXNwb3NlUnVubmVyID0gbmV3IFJ1bm5lcihcImRpc3Bvc2VTaGFkZXJcIik7XG4gIH1cbiAgY2hlY2tVbmlmb3JtRXhpc3RzKG5hbWUsIGdyb3VwKSB7XG4gICAgaWYgKGdyb3VwLnVuaWZvcm1zW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBpIGluIGdyb3VwLnVuaWZvcm1zKSB7XG4gICAgICBjb25zdCB1bmlmb3JtID0gZ3JvdXAudW5pZm9ybXNbaV07XG4gICAgICBpZiAodW5pZm9ybS5ncm91cCkge1xuICAgICAgICBpZiAodGhpcy5jaGVja1VuaWZvcm1FeGlzdHMobmFtZSwgdW5pZm9ybSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVuaWZvcm1Hcm91cCA9IG51bGw7XG4gICAgdGhpcy5kaXNwb3NlUnVubmVyLmVtaXQodGhpcyk7XG4gICAgdGhpcy5kaXNwb3NlUnVubmVyLmRlc3Ryb3koKTtcbiAgfVxuICBnZXQgdW5pZm9ybXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybUdyb3VwLnVuaWZvcm1zO1xuICB9XG4gIHN0YXRpYyBmcm9tKHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIHVuaWZvcm1zKSB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IFByb2dyYW0uZnJvbSh2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjKTtcbiAgICByZXR1cm4gbmV3IFNoYWRlcihwcm9ncmFtLCB1bmlmb3Jtcyk7XG4gIH1cbn1cblxuZXhwb3J0IHsgU2hhZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaGFkZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSAnQHBpeGkvbWF0aCc7XG5pbXBvcnQgeyBQcm9ncmFtIH0gZnJvbSAnLi4vc2hhZGVyL1Byb2dyYW0ubWpzJztcbmltcG9ydCB7IFNoYWRlciB9IGZyb20gJy4uL3NoYWRlci9TaGFkZXIubWpzJztcbmltcG9ydCB7IFVuaWZvcm1Hcm91cCB9IGZyb20gJy4uL3NoYWRlci9Vbmlmb3JtR3JvdXAubWpzJztcblxuY2xhc3MgQmF0Y2hTaGFkZXJHZW5lcmF0b3Ige1xuICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhTcmMsIGZyYWdUZW1wbGF0ZSkge1xuICAgIHRoaXMudmVydGV4U3JjID0gdmVydGV4U3JjO1xuICAgIHRoaXMuZnJhZ1RlbXBsYXRlID0gZnJhZ1RlbXBsYXRlO1xuICAgIHRoaXMucHJvZ3JhbUNhY2hlID0ge307XG4gICAgdGhpcy5kZWZhdWx0R3JvdXBDYWNoZSA9IHt9O1xuICAgIGlmICghZnJhZ1RlbXBsYXRlLmluY2x1ZGVzKFwiJWNvdW50JVwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGcmFnbWVudCB0ZW1wbGF0ZSBtdXN0IGNvbnRhaW4gXCIlY291bnQlXCIuJyk7XG4gICAgfVxuICAgIGlmICghZnJhZ1RlbXBsYXRlLmluY2x1ZGVzKFwiJWZvcmxvb3AlXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZyYWdtZW50IHRlbXBsYXRlIG11c3QgY29udGFpbiBcIiVmb3Jsb29wJVwiLicpO1xuICAgIH1cbiAgfVxuICBnZW5lcmF0ZVNoYWRlcihtYXhUZXh0dXJlcykge1xuICAgIGlmICghdGhpcy5wcm9ncmFtQ2FjaGVbbWF4VGV4dHVyZXNdKSB7XG4gICAgICBjb25zdCBzYW1wbGVWYWx1ZXMgPSBuZXcgSW50MzJBcnJheShtYXhUZXh0dXJlcyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heFRleHR1cmVzOyBpKyspIHtcbiAgICAgICAgc2FtcGxlVmFsdWVzW2ldID0gaTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVmYXVsdEdyb3VwQ2FjaGVbbWF4VGV4dHVyZXNdID0gVW5pZm9ybUdyb3VwLmZyb20oeyB1U2FtcGxlcnM6IHNhbXBsZVZhbHVlcyB9LCB0cnVlKTtcbiAgICAgIGxldCBmcmFnbWVudFNyYyA9IHRoaXMuZnJhZ1RlbXBsYXRlO1xuICAgICAgZnJhZ21lbnRTcmMgPSBmcmFnbWVudFNyYy5yZXBsYWNlKC8lY291bnQlL2dpLCBgJHttYXhUZXh0dXJlc31gKTtcbiAgICAgIGZyYWdtZW50U3JjID0gZnJhZ21lbnRTcmMucmVwbGFjZSgvJWZvcmxvb3AlL2dpLCB0aGlzLmdlbmVyYXRlU2FtcGxlU3JjKG1heFRleHR1cmVzKSk7XG4gICAgICB0aGlzLnByb2dyYW1DYWNoZVttYXhUZXh0dXJlc10gPSBuZXcgUHJvZ3JhbSh0aGlzLnZlcnRleFNyYywgZnJhZ21lbnRTcmMpO1xuICAgIH1cbiAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAgICAgIHRpbnQ6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDFdKSxcbiAgICAgIHRyYW5zbGF0aW9uTWF0cml4OiBuZXcgTWF0cml4KCksXG4gICAgICBkZWZhdWx0OiB0aGlzLmRlZmF1bHRHcm91cENhY2hlW21heFRleHR1cmVzXVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBTaGFkZXIodGhpcy5wcm9ncmFtQ2FjaGVbbWF4VGV4dHVyZXNdLCB1bmlmb3Jtcyk7XG4gIH1cbiAgZ2VuZXJhdGVTYW1wbGVTcmMobWF4VGV4dHVyZXMpIHtcbiAgICBsZXQgc3JjID0gXCJcIjtcbiAgICBzcmMgKz0gXCJcXG5cIjtcbiAgICBzcmMgKz0gXCJcXG5cIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heFRleHR1cmVzOyBpKyspIHtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBzcmMgKz0gXCJcXG5lbHNlIFwiO1xuICAgICAgfVxuICAgICAgaWYgKGkgPCBtYXhUZXh0dXJlcyAtIDEpIHtcbiAgICAgICAgc3JjICs9IGBpZih2VGV4dHVyZUlkIDwgJHtpfS41KWA7XG4gICAgICB9XG4gICAgICBzcmMgKz0gXCJcXG57XCI7XG4gICAgICBzcmMgKz0gYFxuXHRjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlcnNbJHtpfV0sIHZUZXh0dXJlQ29vcmQpO2A7XG4gICAgICBzcmMgKz0gXCJcXG59XCI7XG4gICAgfVxuICAgIHNyYyArPSBcIlxcblwiO1xuICAgIHNyYyArPSBcIlxcblwiO1xuICAgIHJldHVybiBzcmM7XG4gIH1cbn1cblxuZXhwb3J0IHsgQmF0Y2hTaGFkZXJHZW5lcmF0b3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhdGNoU2hhZGVyR2VuZXJhdG9yLm1qcy5tYXBcbiIsImNsYXNzIEJhdGNoVGV4dHVyZUFycmF5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuaWRzID0gW107XG4gICAgdGhpcy5jb3VudCA9IDA7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvdW50OyBpKyspIHtcbiAgICAgIHRoaXMuZWxlbWVudHNbaV0gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmNvdW50ID0gMDtcbiAgfVxufVxuXG5leHBvcnQgeyBCYXRjaFRleHR1cmVBcnJheSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hUZXh0dXJlQXJyYXkubWpzLm1hcFxuIiwiaW1wb3J0IHsgaXNNb2JpbGUgfSBmcm9tICdAcGl4aS9zZXR0aW5ncyc7XG5cbmZ1bmN0aW9uIGNhblVwbG9hZFNhbWVCdWZmZXIoKSB7XG4gIHJldHVybiAhaXNNb2JpbGUuYXBwbGUuZGV2aWNlO1xufVxuXG5leHBvcnQgeyBjYW5VcGxvYWRTYW1lQnVmZmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYW5VcGxvYWRTYW1lQnVmZmVyLm1qcy5tYXBcbiIsImltcG9ydCB7IHNldHRpbmdzLCBpc01vYmlsZSB9IGZyb20gJ0BwaXhpL3NldHRpbmdzJztcblxuZnVuY3Rpb24gbWF4UmVjb21tZW5kZWRUZXh0dXJlcyhtYXgpIHtcbiAgbGV0IGFsbG93TWF4ID0gdHJ1ZTtcbiAgY29uc3QgbmF2aWdhdG9yID0gc2V0dGluZ3MuQURBUFRFUi5nZXROYXZpZ2F0b3IoKTtcbiAgaWYgKGlzTW9iaWxlLnRhYmxldCB8fCBpc01vYmlsZS5waG9uZSkge1xuICAgIGlmIChpc01vYmlsZS5hcHBsZS5kZXZpY2UpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvT1MgKFxcZCspXyhcXGQrKT8vKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBjb25zdCBtYWpvclZlcnNpb24gPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgICBpZiAobWFqb3JWZXJzaW9uIDwgMTEpIHtcbiAgICAgICAgICBhbGxvd01heCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc01vYmlsZS5hbmRyb2lkLmRldmljZSkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BbmRyb2lkXFxzKFswLTkuXSopLyk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgY29uc3QgbWFqb3JWZXJzaW9uID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgICAgaWYgKG1ham9yVmVyc2lvbiA8IDcpIHtcbiAgICAgICAgICBhbGxvd01heCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhbGxvd01heCA/IG1heCA6IDQ7XG59XG5cbmV4cG9ydCB7IG1heFJlY29tbWVuZGVkVGV4dHVyZXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1heFJlY29tbWVuZGVkVGV4dHVyZXMubWpzLm1hcFxuIiwiY2xhc3MgT2JqZWN0UmVuZGVyZXIge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICBmbHVzaCgpIHtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG4gIHN0YXJ0KCkge1xuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5mbHVzaCgpO1xuICB9XG4gIHJlbmRlcihfb2JqZWN0KSB7XG4gIH1cbn1cblxuZXhwb3J0IHsgT2JqZWN0UmVuZGVyZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9iamVjdFJlbmRlcmVyLm1qcy5tYXBcbiIsInZhciBkZWZhdWx0RnJhZ21lbnQgPSBcInZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxudmFyeWluZyBmbG9hdCB2VGV4dHVyZUlkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyc1slY291bnQlXTtcXG5cXG52b2lkIG1haW4odm9pZCl7XFxuICAgIHZlYzQgY29sb3I7XFxuICAgICVmb3Jsb29wJVxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvciAqIHZDb2xvcjtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHRGcmFnbWVudCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXh0dXJlLm1qcy5tYXBcbiIsInZhciBkZWZhdWx0VmVydGV4ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xcbmF0dHJpYnV0ZSBmbG9hdCBhVGV4dHVyZUlkO1xcblxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcXG51bmlmb3JtIHZlYzQgdGludDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbnZhcnlpbmcgZmxvYXQgdlRleHR1cmVJZDtcXG5cXG52b2lkIG1haW4odm9pZCl7XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxuXFxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcbiAgICB2VGV4dHVyZUlkID0gYVRleHR1cmVJZDtcXG4gICAgdkNvbG9yID0gYUNvbG9yICogdGludDtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGRlZmF1bHRWZXJ0ZXggYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dHVyZTIubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICdAcGl4aS9jb2xvcic7XG5pbXBvcnQgeyBFTlYgfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2V4dGVuc2lvbnMnO1xuaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tICdAcGl4aS9zZXR0aW5ncyc7XG5pbXBvcnQgeyBkZXByZWNhdGlvbiwgcHJlbXVsdGlwbHlCbGVuZE1vZGUsIG5leHRQb3cyLCBsb2cyIH0gZnJvbSAnQHBpeGkvdXRpbHMnO1xuaW1wb3J0IHsgVmlld2FibGVCdWZmZXIgfSBmcm9tICcuLi9nZW9tZXRyeS9WaWV3YWJsZUJ1ZmZlci5tanMnO1xuaW1wb3J0IHsgY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlciB9IGZyb20gJy4uL3NoYWRlci91dGlscy9jaGVja01heElmU3RhdGVtZW50c0luU2hhZGVyLm1qcyc7XG5pbXBvcnQgeyBTdGF0ZSB9IGZyb20gJy4uL3N0YXRlL1N0YXRlLm1qcyc7XG5pbXBvcnQgeyBCYXNlVGV4dHVyZSB9IGZyb20gJy4uL3RleHR1cmVzL0Jhc2VUZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyBCYXRjaERyYXdDYWxsIH0gZnJvbSAnLi9CYXRjaERyYXdDYWxsLm1qcyc7XG5pbXBvcnQgeyBCYXRjaEdlb21ldHJ5IH0gZnJvbSAnLi9CYXRjaEdlb21ldHJ5Lm1qcyc7XG5pbXBvcnQgeyBCYXRjaFNoYWRlckdlbmVyYXRvciB9IGZyb20gJy4vQmF0Y2hTaGFkZXJHZW5lcmF0b3IubWpzJztcbmltcG9ydCB7IEJhdGNoVGV4dHVyZUFycmF5IH0gZnJvbSAnLi9CYXRjaFRleHR1cmVBcnJheS5tanMnO1xuaW1wb3J0IHsgY2FuVXBsb2FkU2FtZUJ1ZmZlciB9IGZyb20gJy4vY2FuVXBsb2FkU2FtZUJ1ZmZlci5tanMnO1xuaW1wb3J0IHsgbWF4UmVjb21tZW5kZWRUZXh0dXJlcyB9IGZyb20gJy4vbWF4UmVjb21tZW5kZWRUZXh0dXJlcy5tanMnO1xuaW1wb3J0IHsgT2JqZWN0UmVuZGVyZXIgfSBmcm9tICcuL09iamVjdFJlbmRlcmVyLm1qcyc7XG5pbXBvcnQgZGVmYXVsdEZyYWdtZW50IGZyb20gJy4vdGV4dHVyZS5tanMnO1xuaW1wb3J0IGRlZmF1bHRWZXJ0ZXggZnJvbSAnLi90ZXh0dXJlMi5tanMnO1xuXG5jb25zdCBfQmF0Y2hSZW5kZXJlciA9IGNsYXNzIGV4dGVuZHMgT2JqZWN0UmVuZGVyZXIge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHN1cGVyKHJlbmRlcmVyKTtcbiAgICB0aGlzLnNldFNoYWRlckdlbmVyYXRvcigpO1xuICAgIHRoaXMuZ2VvbWV0cnlDbGFzcyA9IEJhdGNoR2VvbWV0cnk7XG4gICAgdGhpcy52ZXJ0ZXhTaXplID0gNjtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuZm9yMmQoKTtcbiAgICB0aGlzLnNpemUgPSBfQmF0Y2hSZW5kZXJlci5kZWZhdWx0QmF0Y2hTaXplICogNDtcbiAgICB0aGlzLl92ZXJ0ZXhDb3VudCA9IDA7XG4gICAgdGhpcy5faW5kZXhDb3VudCA9IDA7XG4gICAgdGhpcy5fYnVmZmVyZWRFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuX2J1ZmZlcmVkVGV4dHVyZXMgPSBbXTtcbiAgICB0aGlzLl9idWZmZXJTaXplID0gMDtcbiAgICB0aGlzLl9zaGFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3BhY2tlZEdlb21ldHJpZXMgPSBbXTtcbiAgICB0aGlzLl9wYWNrZWRHZW9tZXRyeVBvb2xTaXplID0gMjtcbiAgICB0aGlzLl9mbHVzaElkID0gMDtcbiAgICB0aGlzLl9hQnVmZmVycyA9IHt9O1xuICAgIHRoaXMuX2lCdWZmZXJzID0ge307XG4gICAgdGhpcy5tYXhUZXh0dXJlcyA9IDE7XG4gICAgdGhpcy5yZW5kZXJlci5vbihcInByZXJlbmRlclwiLCB0aGlzLm9uUHJlcmVuZGVyLCB0aGlzKTtcbiAgICByZW5kZXJlci5ydW5uZXJzLmNvbnRleHRDaGFuZ2UuYWRkKHRoaXMpO1xuICAgIHRoaXMuX2RjSW5kZXggPSAwO1xuICAgIHRoaXMuX2FJbmRleCA9IDA7XG4gICAgdGhpcy5faUluZGV4ID0gMDtcbiAgICB0aGlzLl9hdHRyaWJ1dGVCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuX2luZGV4QnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLl90ZW1wQm91bmRUZXh0dXJlcyA9IFtdO1xuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdE1heFRleHR1cmVzKCkge1xuICAgIHRoaXMuX2RlZmF1bHRNYXhUZXh0dXJlcyA9IHRoaXMuX2RlZmF1bHRNYXhUZXh0dXJlcyA/PyBtYXhSZWNvbW1lbmRlZFRleHR1cmVzKDMyKTtcbiAgICByZXR1cm4gdGhpcy5fZGVmYXVsdE1heFRleHR1cmVzO1xuICB9XG4gIHN0YXRpYyBzZXQgZGVmYXVsdE1heFRleHR1cmVzKHZhbHVlKSB7XG4gICAgdGhpcy5fZGVmYXVsdE1heFRleHR1cmVzID0gdmFsdWU7XG4gIH1cbiAgc3RhdGljIGdldCBjYW5VcGxvYWRTYW1lQnVmZmVyKCkge1xuICAgIHRoaXMuX2NhblVwbG9hZFNhbWVCdWZmZXIgPSB0aGlzLl9jYW5VcGxvYWRTYW1lQnVmZmVyID8/IGNhblVwbG9hZFNhbWVCdWZmZXIoKTtcbiAgICByZXR1cm4gdGhpcy5fY2FuVXBsb2FkU2FtZUJ1ZmZlcjtcbiAgfVxuICBzdGF0aWMgc2V0IGNhblVwbG9hZFNhbWVCdWZmZXIodmFsdWUpIHtcbiAgICB0aGlzLl9jYW5VcGxvYWRTYW1lQnVmZmVyID0gdmFsdWU7XG4gIH1cbiAgZ2V0IE1BWF9URVhUVVJFUygpIHtcbiAgICBkZXByZWNhdGlvbihcIjcuMS4wXCIsIFwiQmF0Y2hSZW5kZXJlciNNQVhfVEVYVFVSRVMgcmVuYW1lZCB0byBCYXRjaFJlbmRlcmVyI21heFRleHR1cmVzXCIpO1xuICAgIHJldHVybiB0aGlzLm1heFRleHR1cmVzO1xuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdFZlcnRleFNyYygpIHtcbiAgICByZXR1cm4gZGVmYXVsdFZlcnRleDtcbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRGcmFnbWVudFRlbXBsYXRlKCkge1xuICAgIHJldHVybiBkZWZhdWx0RnJhZ21lbnQ7XG4gIH1cbiAgc2V0U2hhZGVyR2VuZXJhdG9yKHtcbiAgICB2ZXJ0ZXggPSBfQmF0Y2hSZW5kZXJlci5kZWZhdWx0VmVydGV4U3JjLFxuICAgIGZyYWdtZW50ID0gX0JhdGNoUmVuZGVyZXIuZGVmYXVsdEZyYWdtZW50VGVtcGxhdGVcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5zaGFkZXJHZW5lcmF0b3IgPSBuZXcgQmF0Y2hTaGFkZXJHZW5lcmF0b3IodmVydGV4LCBmcmFnbWVudCk7XG4gIH1cbiAgY29udGV4dENoYW5nZSgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgaWYgKHNldHRpbmdzLlBSRUZFUl9FTlYgPT09IEVOVi5XRUJHTF9MRUdBQ1kpIHtcbiAgICAgIHRoaXMubWF4VGV4dHVyZXMgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1heFRleHR1cmVzID0gTWF0aC5taW4oZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKSwgX0JhdGNoUmVuZGVyZXIuZGVmYXVsdE1heFRleHR1cmVzKTtcbiAgICAgIHRoaXMubWF4VGV4dHVyZXMgPSBjaGVja01heElmU3RhdGVtZW50c0luU2hhZGVyKHRoaXMubWF4VGV4dHVyZXMsIGdsKTtcbiAgICB9XG4gICAgdGhpcy5fc2hhZGVyID0gdGhpcy5zaGFkZXJHZW5lcmF0b3IuZ2VuZXJhdGVTaGFkZXIodGhpcy5tYXhUZXh0dXJlcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9wYWNrZWRHZW9tZXRyeVBvb2xTaXplOyBpKyspIHtcbiAgICAgIHRoaXMuX3BhY2tlZEdlb21ldHJpZXNbaV0gPSBuZXcgdGhpcy5nZW9tZXRyeUNsYXNzKCk7XG4gICAgfVxuICAgIHRoaXMuaW5pdEZsdXNoQnVmZmVycygpO1xuICB9XG4gIGluaXRGbHVzaEJ1ZmZlcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgX2RyYXdDYWxsUG9vbCxcbiAgICAgIF90ZXh0dXJlQXJyYXlQb29sXG4gICAgfSA9IF9CYXRjaFJlbmRlcmVyO1xuICAgIGNvbnN0IE1BWF9TUFJJVEVTID0gdGhpcy5zaXplIC8gNDtcbiAgICBjb25zdCBNQVhfVEEgPSBNYXRoLmZsb29yKE1BWF9TUFJJVEVTIC8gdGhpcy5tYXhUZXh0dXJlcykgKyAxO1xuICAgIHdoaWxlIChfZHJhd0NhbGxQb29sLmxlbmd0aCA8IE1BWF9TUFJJVEVTKSB7XG4gICAgICBfZHJhd0NhbGxQb29sLnB1c2gobmV3IEJhdGNoRHJhd0NhbGwoKSk7XG4gICAgfVxuICAgIHdoaWxlIChfdGV4dHVyZUFycmF5UG9vbC5sZW5ndGggPCBNQVhfVEEpIHtcbiAgICAgIF90ZXh0dXJlQXJyYXlQb29sLnB1c2gobmV3IEJhdGNoVGV4dHVyZUFycmF5KCkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWF4VGV4dHVyZXM7IGkrKykge1xuICAgICAgdGhpcy5fdGVtcEJvdW5kVGV4dHVyZXNbaV0gPSBudWxsO1xuICAgIH1cbiAgfVxuICBvblByZXJlbmRlcigpIHtcbiAgICB0aGlzLl9mbHVzaElkID0gMDtcbiAgfVxuICByZW5kZXIoZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudC5fdGV4dHVyZS52YWxpZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fdmVydGV4Q291bnQgKyBlbGVtZW50LnZlcnRleERhdGEubGVuZ3RoIC8gMiA+IHRoaXMuc2l6ZSkge1xuICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbiAgICB0aGlzLl92ZXJ0ZXhDb3VudCArPSBlbGVtZW50LnZlcnRleERhdGEubGVuZ3RoIC8gMjtcbiAgICB0aGlzLl9pbmRleENvdW50ICs9IGVsZW1lbnQuaW5kaWNlcy5sZW5ndGg7XG4gICAgdGhpcy5fYnVmZmVyZWRUZXh0dXJlc1t0aGlzLl9idWZmZXJTaXplXSA9IGVsZW1lbnQuX3RleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgdGhpcy5fYnVmZmVyZWRFbGVtZW50c1t0aGlzLl9idWZmZXJTaXplKytdID0gZWxlbWVudDtcbiAgfVxuICBidWlsZFRleHR1cmVzQW5kRHJhd0NhbGxzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIF9idWZmZXJlZFRleHR1cmVzOiB0ZXh0dXJlcyxcbiAgICAgIG1heFRleHR1cmVzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgdGV4dHVyZUFycmF5cyA9IF9CYXRjaFJlbmRlcmVyLl90ZXh0dXJlQXJyYXlQb29sO1xuICAgIGNvbnN0IGJhdGNoID0gdGhpcy5yZW5kZXJlci5iYXRjaDtcbiAgICBjb25zdCBib3VuZFRleHR1cmVzID0gdGhpcy5fdGVtcEJvdW5kVGV4dHVyZXM7XG4gICAgY29uc3QgdG91Y2ggPSB0aGlzLnJlbmRlcmVyLnRleHR1cmVHQy5jb3VudDtcbiAgICBsZXQgVElDSyA9ICsrQmFzZVRleHR1cmUuX2dsb2JhbEJhdGNoO1xuICAgIGxldCBjb3VudFRleEFycmF5cyA9IDA7XG4gICAgbGV0IHRleEFycmF5ID0gdGV4dHVyZUFycmF5c1swXTtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGJhdGNoLmNvcHlCb3VuZFRleHR1cmVzKGJvdW5kVGV4dHVyZXMsIG1heFRleHR1cmVzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2J1ZmZlclNpemU7ICsraSkge1xuICAgICAgY29uc3QgdGV4ID0gdGV4dHVyZXNbaV07XG4gICAgICB0ZXh0dXJlc1tpXSA9IG51bGw7XG4gICAgICBpZiAodGV4Ll9iYXRjaEVuYWJsZWQgPT09IFRJQ0spIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodGV4QXJyYXkuY291bnQgPj0gbWF4VGV4dHVyZXMpIHtcbiAgICAgICAgYmF0Y2guYm91bmRBcnJheSh0ZXhBcnJheSwgYm91bmRUZXh0dXJlcywgVElDSywgbWF4VGV4dHVyZXMpO1xuICAgICAgICB0aGlzLmJ1aWxkRHJhd0NhbGxzKHRleEFycmF5LCBzdGFydCwgaSk7XG4gICAgICAgIHN0YXJ0ID0gaTtcbiAgICAgICAgdGV4QXJyYXkgPSB0ZXh0dXJlQXJyYXlzWysrY291bnRUZXhBcnJheXNdO1xuICAgICAgICArK1RJQ0s7XG4gICAgICB9XG4gICAgICB0ZXguX2JhdGNoRW5hYmxlZCA9IFRJQ0s7XG4gICAgICB0ZXgudG91Y2hlZCA9IHRvdWNoO1xuICAgICAgdGV4QXJyYXkuZWxlbWVudHNbdGV4QXJyYXkuY291bnQrK10gPSB0ZXg7XG4gICAgfVxuICAgIGlmICh0ZXhBcnJheS5jb3VudCA+IDApIHtcbiAgICAgIGJhdGNoLmJvdW5kQXJyYXkodGV4QXJyYXksIGJvdW5kVGV4dHVyZXMsIFRJQ0ssIG1heFRleHR1cmVzKTtcbiAgICAgIHRoaXMuYnVpbGREcmF3Q2FsbHModGV4QXJyYXksIHN0YXJ0LCB0aGlzLl9idWZmZXJTaXplKTtcbiAgICAgICsrY291bnRUZXhBcnJheXM7XG4gICAgICArK1RJQ0s7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm91bmRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgYm91bmRUZXh0dXJlc1tpXSA9IG51bGw7XG4gICAgfVxuICAgIEJhc2VUZXh0dXJlLl9nbG9iYWxCYXRjaCA9IFRJQ0s7XG4gIH1cbiAgYnVpbGREcmF3Q2FsbHModGV4QXJyYXksIHN0YXJ0LCBmaW5pc2gpIHtcbiAgICBjb25zdCB7XG4gICAgICBfYnVmZmVyZWRFbGVtZW50czogZWxlbWVudHMsXG4gICAgICBfYXR0cmlidXRlQnVmZmVyLFxuICAgICAgX2luZGV4QnVmZmVyLFxuICAgICAgdmVydGV4U2l6ZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGRyYXdDYWxscyA9IF9CYXRjaFJlbmRlcmVyLl9kcmF3Q2FsbFBvb2w7XG4gICAgbGV0IGRjSW5kZXggPSB0aGlzLl9kY0luZGV4O1xuICAgIGxldCBhSW5kZXggPSB0aGlzLl9hSW5kZXg7XG4gICAgbGV0IGlJbmRleCA9IHRoaXMuX2lJbmRleDtcbiAgICBsZXQgZHJhd0NhbGwgPSBkcmF3Q2FsbHNbZGNJbmRleF07XG4gICAgZHJhd0NhbGwuc3RhcnQgPSB0aGlzLl9pSW5kZXg7XG4gICAgZHJhd0NhbGwudGV4QXJyYXkgPSB0ZXhBcnJheTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBmaW5pc2g7ICsraSkge1xuICAgICAgY29uc3Qgc3ByaXRlID0gZWxlbWVudHNbaV07XG4gICAgICBjb25zdCB0ZXggPSBzcHJpdGUuX3RleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgICBjb25zdCBzcHJpdGVCbGVuZE1vZGUgPSBwcmVtdWx0aXBseUJsZW5kTW9kZVt0ZXguYWxwaGFNb2RlID8gMSA6IDBdW3Nwcml0ZS5ibGVuZE1vZGVdO1xuICAgICAgZWxlbWVudHNbaV0gPSBudWxsO1xuICAgICAgaWYgKHN0YXJ0IDwgaSAmJiBkcmF3Q2FsbC5ibGVuZCAhPT0gc3ByaXRlQmxlbmRNb2RlKSB7XG4gICAgICAgIGRyYXdDYWxsLnNpemUgPSBpSW5kZXggLSBkcmF3Q2FsbC5zdGFydDtcbiAgICAgICAgc3RhcnQgPSBpO1xuICAgICAgICBkcmF3Q2FsbCA9IGRyYXdDYWxsc1srK2RjSW5kZXhdO1xuICAgICAgICBkcmF3Q2FsbC50ZXhBcnJheSA9IHRleEFycmF5O1xuICAgICAgICBkcmF3Q2FsbC5zdGFydCA9IGlJbmRleDtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFja0ludGVybGVhdmVkR2VvbWV0cnkoc3ByaXRlLCBfYXR0cmlidXRlQnVmZmVyLCBfaW5kZXhCdWZmZXIsIGFJbmRleCwgaUluZGV4KTtcbiAgICAgIGFJbmRleCArPSBzcHJpdGUudmVydGV4RGF0YS5sZW5ndGggLyAyICogdmVydGV4U2l6ZTtcbiAgICAgIGlJbmRleCArPSBzcHJpdGUuaW5kaWNlcy5sZW5ndGg7XG4gICAgICBkcmF3Q2FsbC5ibGVuZCA9IHNwcml0ZUJsZW5kTW9kZTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0IDwgZmluaXNoKSB7XG4gICAgICBkcmF3Q2FsbC5zaXplID0gaUluZGV4IC0gZHJhd0NhbGwuc3RhcnQ7XG4gICAgICArK2RjSW5kZXg7XG4gICAgfVxuICAgIHRoaXMuX2RjSW5kZXggPSBkY0luZGV4O1xuICAgIHRoaXMuX2FJbmRleCA9IGFJbmRleDtcbiAgICB0aGlzLl9pSW5kZXggPSBpSW5kZXg7XG4gIH1cbiAgYmluZEFuZENsZWFyVGV4QXJyYXkodGV4QXJyYXkpIHtcbiAgICBjb25zdCB0ZXh0dXJlU3lzdGVtID0gdGhpcy5yZW5kZXJlci50ZXh0dXJlO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGV4QXJyYXkuY291bnQ7IGorKykge1xuICAgICAgdGV4dHVyZVN5c3RlbS5iaW5kKHRleEFycmF5LmVsZW1lbnRzW2pdLCB0ZXhBcnJheS5pZHNbal0pO1xuICAgICAgdGV4QXJyYXkuZWxlbWVudHNbal0gPSBudWxsO1xuICAgIH1cbiAgICB0ZXhBcnJheS5jb3VudCA9IDA7XG4gIH1cbiAgdXBkYXRlR2VvbWV0cnkoKSB7XG4gICAgY29uc3Qge1xuICAgICAgX3BhY2tlZEdlb21ldHJpZXM6IHBhY2tlZEdlb21ldHJpZXMsXG4gICAgICBfYXR0cmlidXRlQnVmZmVyOiBhdHRyaWJ1dGVCdWZmZXIsXG4gICAgICBfaW5kZXhCdWZmZXI6IGluZGV4QnVmZmVyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFfQmF0Y2hSZW5kZXJlci5jYW5VcGxvYWRTYW1lQnVmZmVyKSB7XG4gICAgICBpZiAodGhpcy5fcGFja2VkR2VvbWV0cnlQb29sU2l6ZSA8PSB0aGlzLl9mbHVzaElkKSB7XG4gICAgICAgIHRoaXMuX3BhY2tlZEdlb21ldHJ5UG9vbFNpemUrKztcbiAgICAgICAgcGFja2VkR2VvbWV0cmllc1t0aGlzLl9mbHVzaElkXSA9IG5ldyB0aGlzLmdlb21ldHJ5Q2xhc3MoKTtcbiAgICAgIH1cbiAgICAgIHBhY2tlZEdlb21ldHJpZXNbdGhpcy5fZmx1c2hJZF0uX2J1ZmZlci51cGRhdGUoYXR0cmlidXRlQnVmZmVyLnJhd0JpbmFyeURhdGEpO1xuICAgICAgcGFja2VkR2VvbWV0cmllc1t0aGlzLl9mbHVzaElkXS5faW5kZXhCdWZmZXIudXBkYXRlKGluZGV4QnVmZmVyKTtcbiAgICAgIHRoaXMucmVuZGVyZXIuZ2VvbWV0cnkuYmluZChwYWNrZWRHZW9tZXRyaWVzW3RoaXMuX2ZsdXNoSWRdKTtcbiAgICAgIHRoaXMucmVuZGVyZXIuZ2VvbWV0cnkudXBkYXRlQnVmZmVycygpO1xuICAgICAgdGhpcy5fZmx1c2hJZCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNrZWRHZW9tZXRyaWVzW3RoaXMuX2ZsdXNoSWRdLl9idWZmZXIudXBkYXRlKGF0dHJpYnV0ZUJ1ZmZlci5yYXdCaW5hcnlEYXRhKTtcbiAgICAgIHBhY2tlZEdlb21ldHJpZXNbdGhpcy5fZmx1c2hJZF0uX2luZGV4QnVmZmVyLnVwZGF0ZShpbmRleEJ1ZmZlcik7XG4gICAgICB0aGlzLnJlbmRlcmVyLmdlb21ldHJ5LnVwZGF0ZUJ1ZmZlcnMoKTtcbiAgICB9XG4gIH1cbiAgZHJhd0JhdGNoZXMoKSB7XG4gICAgY29uc3QgZGNDb3VudCA9IHRoaXMuX2RjSW5kZXg7XG4gICAgY29uc3QgeyBnbCwgc3RhdGU6IHN0YXRlU3lzdGVtIH0gPSB0aGlzLnJlbmRlcmVyO1xuICAgIGNvbnN0IGRyYXdDYWxscyA9IF9CYXRjaFJlbmRlcmVyLl9kcmF3Q2FsbFBvb2w7XG4gICAgbGV0IGN1clRleEFycmF5ID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRjQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgeyB0ZXhBcnJheSwgdHlwZSwgc2l6ZSwgc3RhcnQsIGJsZW5kIH0gPSBkcmF3Q2FsbHNbaV07XG4gICAgICBpZiAoY3VyVGV4QXJyYXkgIT09IHRleEFycmF5KSB7XG4gICAgICAgIGN1clRleEFycmF5ID0gdGV4QXJyYXk7XG4gICAgICAgIHRoaXMuYmluZEFuZENsZWFyVGV4QXJyYXkodGV4QXJyYXkpO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZS5ibGVuZE1vZGUgPSBibGVuZDtcbiAgICAgIHN0YXRlU3lzdGVtLnNldCh0aGlzLnN0YXRlKTtcbiAgICAgIGdsLmRyYXdFbGVtZW50cyh0eXBlLCBzaXplLCBnbC5VTlNJR05FRF9TSE9SVCwgc3RhcnQgKiAyKTtcbiAgICB9XG4gIH1cbiAgZmx1c2goKSB7XG4gICAgaWYgKHRoaXMuX3ZlcnRleENvdW50ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2F0dHJpYnV0ZUJ1ZmZlciA9IHRoaXMuZ2V0QXR0cmlidXRlQnVmZmVyKHRoaXMuX3ZlcnRleENvdW50KTtcbiAgICB0aGlzLl9pbmRleEJ1ZmZlciA9IHRoaXMuZ2V0SW5kZXhCdWZmZXIodGhpcy5faW5kZXhDb3VudCk7XG4gICAgdGhpcy5fYUluZGV4ID0gMDtcbiAgICB0aGlzLl9pSW5kZXggPSAwO1xuICAgIHRoaXMuX2RjSW5kZXggPSAwO1xuICAgIHRoaXMuYnVpbGRUZXh0dXJlc0FuZERyYXdDYWxscygpO1xuICAgIHRoaXMudXBkYXRlR2VvbWV0cnkoKTtcbiAgICB0aGlzLmRyYXdCYXRjaGVzKCk7XG4gICAgdGhpcy5fYnVmZmVyU2l6ZSA9IDA7XG4gICAgdGhpcy5fdmVydGV4Q291bnQgPSAwO1xuICAgIHRoaXMuX2luZGV4Q291bnQgPSAwO1xuICB9XG4gIHN0YXJ0KCkge1xuICAgIHRoaXMucmVuZGVyZXIuc3RhdGUuc2V0KHRoaXMuc3RhdGUpO1xuICAgIHRoaXMucmVuZGVyZXIudGV4dHVyZS5lbnN1cmVTYW1wbGVyVHlwZSh0aGlzLm1heFRleHR1cmVzKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNoYWRlci5iaW5kKHRoaXMuX3NoYWRlcik7XG4gICAgaWYgKF9CYXRjaFJlbmRlcmVyLmNhblVwbG9hZFNhbWVCdWZmZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuZ2VvbWV0cnkuYmluZCh0aGlzLl9wYWNrZWRHZW9tZXRyaWVzW3RoaXMuX2ZsdXNoSWRdKTtcbiAgICB9XG4gIH1cbiAgc3RvcCgpIHtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3BhY2tlZEdlb21ldHJ5UG9vbFNpemU7IGkrKykge1xuICAgICAgaWYgKHRoaXMuX3BhY2tlZEdlb21ldHJpZXNbaV0pIHtcbiAgICAgICAgdGhpcy5fcGFja2VkR2VvbWV0cmllc1tpXS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVuZGVyZXIub2ZmKFwicHJlcmVuZGVyXCIsIHRoaXMub25QcmVyZW5kZXIsIHRoaXMpO1xuICAgIHRoaXMuX2FCdWZmZXJzID0gbnVsbDtcbiAgICB0aGlzLl9pQnVmZmVycyA9IG51bGw7XG4gICAgdGhpcy5fcGFja2VkR2VvbWV0cmllcyA9IG51bGw7XG4gICAgdGhpcy5fYXR0cmlidXRlQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLl9pbmRleEJ1ZmZlciA9IG51bGw7XG4gICAgaWYgKHRoaXMuX3NoYWRlcikge1xuICAgICAgdGhpcy5fc2hhZGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX3NoYWRlciA9IG51bGw7XG4gICAgfVxuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuICBnZXRBdHRyaWJ1dGVCdWZmZXIoc2l6ZSkge1xuICAgIGNvbnN0IHJvdW5kZWRQMiA9IG5leHRQb3cyKE1hdGguY2VpbChzaXplIC8gOCkpO1xuICAgIGNvbnN0IHJvdW5kZWRTaXplSW5kZXggPSBsb2cyKHJvdW5kZWRQMik7XG4gICAgY29uc3Qgcm91bmRlZFNpemUgPSByb3VuZGVkUDIgKiA4O1xuICAgIGlmICh0aGlzLl9hQnVmZmVycy5sZW5ndGggPD0gcm91bmRlZFNpemVJbmRleCkge1xuICAgICAgdGhpcy5faUJ1ZmZlcnMubGVuZ3RoID0gcm91bmRlZFNpemVJbmRleCArIDE7XG4gICAgfVxuICAgIGxldCBidWZmZXIgPSB0aGlzLl9hQnVmZmVyc1tyb3VuZGVkU2l6ZV07XG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgIHRoaXMuX2FCdWZmZXJzW3JvdW5kZWRTaXplXSA9IGJ1ZmZlciA9IG5ldyBWaWV3YWJsZUJ1ZmZlcihyb3VuZGVkU2l6ZSAqIHRoaXMudmVydGV4U2l6ZSAqIDQpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG4gIGdldEluZGV4QnVmZmVyKHNpemUpIHtcbiAgICBjb25zdCByb3VuZGVkUDIgPSBuZXh0UG93MihNYXRoLmNlaWwoc2l6ZSAvIDEyKSk7XG4gICAgY29uc3Qgcm91bmRlZFNpemVJbmRleCA9IGxvZzIocm91bmRlZFAyKTtcbiAgICBjb25zdCByb3VuZGVkU2l6ZSA9IHJvdW5kZWRQMiAqIDEyO1xuICAgIGlmICh0aGlzLl9pQnVmZmVycy5sZW5ndGggPD0gcm91bmRlZFNpemVJbmRleCkge1xuICAgICAgdGhpcy5faUJ1ZmZlcnMubGVuZ3RoID0gcm91bmRlZFNpemVJbmRleCArIDE7XG4gICAgfVxuICAgIGxldCBidWZmZXIgPSB0aGlzLl9pQnVmZmVyc1tyb3VuZGVkU2l6ZUluZGV4XTtcbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgdGhpcy5faUJ1ZmZlcnNbcm91bmRlZFNpemVJbmRleF0gPSBidWZmZXIgPSBuZXcgVWludDE2QXJyYXkocm91bmRlZFNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG4gIHBhY2tJbnRlcmxlYXZlZEdlb21ldHJ5KGVsZW1lbnQsIGF0dHJpYnV0ZUJ1ZmZlciwgaW5kZXhCdWZmZXIsIGFJbmRleCwgaUluZGV4KSB7XG4gICAgY29uc3Qge1xuICAgICAgdWludDMyVmlldyxcbiAgICAgIGZsb2F0MzJWaWV3XG4gICAgfSA9IGF0dHJpYnV0ZUJ1ZmZlcjtcbiAgICBjb25zdCBwYWNrZWRWZXJ0aWNlcyA9IGFJbmRleCAvIHRoaXMudmVydGV4U2l6ZTtcbiAgICBjb25zdCB1dnMgPSBlbGVtZW50LnV2cztcbiAgICBjb25zdCBpbmRpY2llcyA9IGVsZW1lbnQuaW5kaWNlcztcbiAgICBjb25zdCB2ZXJ0ZXhEYXRhID0gZWxlbWVudC52ZXJ0ZXhEYXRhO1xuICAgIGNvbnN0IHRleHR1cmVJZCA9IGVsZW1lbnQuX3RleHR1cmUuYmFzZVRleHR1cmUuX2JhdGNoTG9jYXRpb247XG4gICAgY29uc3QgYWxwaGEgPSBNYXRoLm1pbihlbGVtZW50LndvcmxkQWxwaGEsIDEpO1xuICAgIGNvbnN0IGFyZ2IgPSBDb2xvci5zaGFyZWQuc2V0VmFsdWUoZWxlbWVudC5fdGludFJHQikudG9QcmVtdWx0aXBsaWVkKGFscGhhLCBlbGVtZW50Ll90ZXh0dXJlLmJhc2VUZXh0dXJlLmFscGhhTW9kZSA+IDApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGV4RGF0YS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgZmxvYXQzMlZpZXdbYUluZGV4KytdID0gdmVydGV4RGF0YVtpXTtcbiAgICAgIGZsb2F0MzJWaWV3W2FJbmRleCsrXSA9IHZlcnRleERhdGFbaSArIDFdO1xuICAgICAgZmxvYXQzMlZpZXdbYUluZGV4KytdID0gdXZzW2ldO1xuICAgICAgZmxvYXQzMlZpZXdbYUluZGV4KytdID0gdXZzW2kgKyAxXTtcbiAgICAgIHVpbnQzMlZpZXdbYUluZGV4KytdID0gYXJnYjtcbiAgICAgIGZsb2F0MzJWaWV3W2FJbmRleCsrXSA9IHRleHR1cmVJZDtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRpY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgaW5kZXhCdWZmZXJbaUluZGV4KytdID0gcGFja2VkVmVydGljZXMgKyBpbmRpY2llc1tpXTtcbiAgICB9XG4gIH1cbn07XG5sZXQgQmF0Y2hSZW5kZXJlciA9IF9CYXRjaFJlbmRlcmVyO1xuQmF0Y2hSZW5kZXJlci5kZWZhdWx0QmF0Y2hTaXplID0gNDA5NjtcbkJhdGNoUmVuZGVyZXIuZXh0ZW5zaW9uID0ge1xuICBuYW1lOiBcImJhdGNoXCIsXG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJQbHVnaW5cbn07XG5CYXRjaFJlbmRlcmVyLl9kcmF3Q2FsbFBvb2wgPSBbXTtcbkJhdGNoUmVuZGVyZXIuX3RleHR1cmVBcnJheVBvb2wgPSBbXTtcbmV4dGVuc2lvbnMuYWRkKEJhdGNoUmVuZGVyZXIpO1xuXG5leHBvcnQgeyBCYXRjaFJlbmRlcmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXRjaFJlbmRlcmVyLm1qcy5tYXBcbiIsInZhciBkZWZhdWx0RnJhZ21lbnQgPSBcInZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcblxcbnZvaWQgbWFpbih2b2lkKXtcXG4gICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgZGVmYXVsdEZyYWdtZW50IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRGaWx0ZXIubWpzLm1hcFxuIiwidmFyIGRlZmF1bHRWZXJ0ZXggPSBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXG5cXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIHZlYzQgaW5wdXRTaXplO1xcbnVuaWZvcm0gdmVjNCBvdXRwdXRGcmFtZTtcXG5cXG52ZWM0IGZpbHRlclZlcnRleFBvc2l0aW9uKCB2b2lkIClcXG57XFxuICAgIHZlYzIgcG9zaXRpb24gPSBhVmVydGV4UG9zaXRpb24gKiBtYXgob3V0cHV0RnJhbWUuencsIHZlYzIoMC4pKSArIG91dHB1dEZyYW1lLnh5O1xcblxcbiAgICByZXR1cm4gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMocG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxufVxcblxcbnZlYzIgZmlsdGVyVGV4dHVyZUNvb3JkKCB2b2lkIClcXG57XFxuICAgIHJldHVybiBhVmVydGV4UG9zaXRpb24gKiAob3V0cHV0RnJhbWUuencgKiBpbnB1dFNpemUuencpO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX1Bvc2l0aW9uID0gZmlsdGVyVmVydGV4UG9zaXRpb24oKTtcXG4gICAgdlRleHR1cmVDb29yZCA9IGZpbHRlclRleHR1cmVDb29yZCgpO1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgZGVmYXVsdFZlcnRleCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0RmlsdGVyMi5tanMubWFwXG4iLCJpbXBvcnQgeyBNU0FBX1FVQUxJVFkgfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuaW1wb3J0IHsgUHJvZ3JhbSB9IGZyb20gJy4uL3NoYWRlci9Qcm9ncmFtLm1qcyc7XG5pbXBvcnQgeyBTaGFkZXIgfSBmcm9tICcuLi9zaGFkZXIvU2hhZGVyLm1qcyc7XG5pbXBvcnQgeyBTdGF0ZSB9IGZyb20gJy4uL3N0YXRlL1N0YXRlLm1qcyc7XG5pbXBvcnQgZGVmYXVsdEZyYWdtZW50IGZyb20gJy4vZGVmYXVsdEZpbHRlci5tanMnO1xuaW1wb3J0IGRlZmF1bHRWZXJ0ZXggZnJvbSAnLi9kZWZhdWx0RmlsdGVyMi5tanMnO1xuXG5jb25zdCBfRmlsdGVyID0gY2xhc3MgZXh0ZW5kcyBTaGFkZXIge1xuICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCB1bmlmb3Jtcykge1xuICAgIGNvbnN0IHByb2dyYW0gPSBQcm9ncmFtLmZyb20odmVydGV4U3JjIHx8IF9GaWx0ZXIuZGVmYXVsdFZlcnRleFNyYywgZnJhZ21lbnRTcmMgfHwgX0ZpbHRlci5kZWZhdWx0RnJhZ21lbnRTcmMpO1xuICAgIHN1cGVyKHByb2dyYW0sIHVuaWZvcm1zKTtcbiAgICB0aGlzLnBhZGRpbmcgPSAwO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IF9GaWx0ZXIuZGVmYXVsdFJlc29sdXRpb247XG4gICAgdGhpcy5tdWx0aXNhbXBsZSA9IF9GaWx0ZXIuZGVmYXVsdE11bHRpc2FtcGxlO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5hdXRvRml0ID0gdHJ1ZTtcbiAgICB0aGlzLnN0YXRlID0gbmV3IFN0YXRlKCk7XG4gIH1cbiAgYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlLCBfY3VycmVudFN0YXRlKSB7XG4gICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpO1xuICB9XG4gIGdldCBibGVuZE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuYmxlbmRNb2RlO1xuICB9XG4gIHNldCBibGVuZE1vZGUodmFsdWUpIHtcbiAgICB0aGlzLnN0YXRlLmJsZW5kTW9kZSA9IHZhbHVlO1xuICB9XG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHV0aW9uO1xuICB9XG4gIHNldCByZXNvbHV0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fcmVzb2x1dGlvbiA9IHZhbHVlO1xuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdFZlcnRleFNyYygpIHtcbiAgICByZXR1cm4gZGVmYXVsdFZlcnRleDtcbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRGcmFnbWVudFNyYygpIHtcbiAgICByZXR1cm4gZGVmYXVsdEZyYWdtZW50O1xuICB9XG59O1xubGV0IEZpbHRlciA9IF9GaWx0ZXI7XG5GaWx0ZXIuZGVmYXVsdFJlc29sdXRpb24gPSAxO1xuRmlsdGVyLmRlZmF1bHRNdWx0aXNhbXBsZSA9IE1TQUFfUVVBTElUWS5OT05FO1xuXG5leHBvcnQgeyBGaWx0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbHRlci5tanMubWFwXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJ0BwaXhpL2NvbG9yJztcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tICdAcGl4aS9leHRlbnNpb25zJztcblxuY2xhc3MgQmFja2dyb3VuZFN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIgPSB0cnVlO1xuICAgIHRoaXMuX2JhY2tncm91bmRDb2xvciA9IG5ldyBDb2xvcigwKTtcbiAgICB0aGlzLmFscGhhID0gMTtcbiAgfVxuICBpbml0KG9wdGlvbnMpIHtcbiAgICB0aGlzLmNsZWFyQmVmb3JlUmVuZGVyID0gb3B0aW9ucy5jbGVhckJlZm9yZVJlbmRlcjtcbiAgICBjb25zdCB7IGJhY2tncm91bmRDb2xvciwgYmFja2dyb3VuZCwgYmFja2dyb3VuZEFscGhhIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGNvbG9yID0gYmFja2dyb3VuZCA/PyBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgaWYgKGNvbG9yICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICB9XG4gICAgdGhpcy5hbHBoYSA9IGJhY2tncm91bmRBbHBoYTtcbiAgfVxuICBnZXQgY29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tncm91bmRDb2xvci52YWx1ZTtcbiAgfVxuICBzZXQgY29sb3IodmFsdWUpIHtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3Iuc2V0VmFsdWUodmFsdWUpO1xuICB9XG4gIGdldCBhbHBoYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFja2dyb3VuZENvbG9yLmFscGhhO1xuICB9XG4gIHNldCBhbHBoYSh2YWx1ZSkge1xuICAgIHRoaXMuX2JhY2tncm91bmRDb2xvci5zZXRBbHBoYSh2YWx1ZSk7XG4gIH1cbiAgZ2V0IGJhY2tncm91bmRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFja2dyb3VuZENvbG9yO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gIH1cbn1cbkJhY2tncm91bmRTeXN0ZW0uZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGJhY2tncm91bmRBbHBoYTogMSxcbiAgYmFja2dyb3VuZENvbG9yOiAwLFxuICBjbGVhckJlZm9yZVJlbmRlcjogdHJ1ZVxufTtcbkJhY2tncm91bmRTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1JlbmRlcmVyU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwiYmFja2dyb3VuZFwiXG59O1xuZXh0ZW5zaW9ucy5hZGQoQmFja2dyb3VuZFN5c3RlbSk7XG5cbmV4cG9ydCB7IEJhY2tncm91bmRTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhY2tncm91bmRTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2V4dGVuc2lvbnMnO1xuaW1wb3J0IHsgT2JqZWN0UmVuZGVyZXIgfSBmcm9tICcuL09iamVjdFJlbmRlcmVyLm1qcyc7XG5cbmNsYXNzIEJhdGNoU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5lbXB0eVJlbmRlcmVyID0gbmV3IE9iamVjdFJlbmRlcmVyKHJlbmRlcmVyKTtcbiAgICB0aGlzLmN1cnJlbnRSZW5kZXJlciA9IHRoaXMuZW1wdHlSZW5kZXJlcjtcbiAgfVxuICBzZXRPYmplY3RSZW5kZXJlcihvYmplY3RSZW5kZXJlcikge1xuICAgIGlmICh0aGlzLmN1cnJlbnRSZW5kZXJlciA9PT0gb2JqZWN0UmVuZGVyZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50UmVuZGVyZXIuc3RvcCgpO1xuICAgIHRoaXMuY3VycmVudFJlbmRlcmVyID0gb2JqZWN0UmVuZGVyZXI7XG4gICAgdGhpcy5jdXJyZW50UmVuZGVyZXIuc3RhcnQoKTtcbiAgfVxuICBmbHVzaCgpIHtcbiAgICB0aGlzLnNldE9iamVjdFJlbmRlcmVyKHRoaXMuZW1wdHlSZW5kZXJlcik7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zZXRPYmplY3RSZW5kZXJlcih0aGlzLmVtcHR5UmVuZGVyZXIpO1xuICB9XG4gIGNvcHlCb3VuZFRleHR1cmVzKGFyciwgbWF4VGV4dHVyZXMpIHtcbiAgICBjb25zdCB7IGJvdW5kVGV4dHVyZXMgfSA9IHRoaXMucmVuZGVyZXIudGV4dHVyZTtcbiAgICBmb3IgKGxldCBpID0gbWF4VGV4dHVyZXMgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgYXJyW2ldID0gYm91bmRUZXh0dXJlc1tpXSB8fCBudWxsO1xuICAgICAgaWYgKGFycltpXSkge1xuICAgICAgICBhcnJbaV0uX2JhdGNoTG9jYXRpb24gPSBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBib3VuZEFycmF5KHRleEFycmF5LCBib3VuZFRleHR1cmVzLCBiYXRjaElkLCBtYXhUZXh0dXJlcykge1xuICAgIGNvbnN0IHsgZWxlbWVudHMsIGlkcywgY291bnQgfSA9IHRleEFycmF5O1xuICAgIGxldCBqID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHRleCA9IGVsZW1lbnRzW2ldO1xuICAgICAgY29uc3QgbG9jID0gdGV4Ll9iYXRjaExvY2F0aW9uO1xuICAgICAgaWYgKGxvYyA+PSAwICYmIGxvYyA8IG1heFRleHR1cmVzICYmIGJvdW5kVGV4dHVyZXNbbG9jXSA9PT0gdGV4KSB7XG4gICAgICAgIGlkc1tpXSA9IGxvYztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB3aGlsZSAoaiA8IG1heFRleHR1cmVzKSB7XG4gICAgICAgIGNvbnN0IGJvdW5kID0gYm91bmRUZXh0dXJlc1tqXTtcbiAgICAgICAgaWYgKGJvdW5kICYmIGJvdW5kLl9iYXRjaEVuYWJsZWQgPT09IGJhdGNoSWQgJiYgYm91bmQuX2JhdGNoTG9jYXRpb24gPT09IGopIHtcbiAgICAgICAgICBqKys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWRzW2ldID0gajtcbiAgICAgICAgdGV4Ll9iYXRjaExvY2F0aW9uID0gajtcbiAgICAgICAgYm91bmRUZXh0dXJlc1tqXSA9IHRleDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbkJhdGNoU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJiYXRjaFwiXG59O1xuZXh0ZW5zaW9ucy5hZGQoQmF0Y2hTeXN0ZW0pO1xuXG5leHBvcnQgeyBCYXRjaFN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRU5WIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tICdAcGl4aS9leHRlbnNpb25zJztcbmltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSAnQHBpeGkvc2V0dGluZ3MnO1xuXG5sZXQgQ09OVEVYVF9VSURfQ09VTlRFUiA9IDA7XG5jbGFzcyBDb250ZXh0U3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy53ZWJHTFZlcnNpb24gPSAxO1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHt9O1xuICAgIHRoaXMuc3VwcG9ydHMgPSB7XG4gICAgICB1aW50MzJJbmRpY2VzOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVDb250ZXh0TG9zdCA9IHRoaXMuaGFuZGxlQ29udGV4dExvc3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZCA9IHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkLmJpbmQodGhpcyk7XG4gIH1cbiAgZ2V0IGlzTG9zdCgpIHtcbiAgICByZXR1cm4gIXRoaXMuZ2wgfHwgdGhpcy5nbC5pc0NvbnRleHRMb3N0KCk7XG4gIH1cbiAgY29udGV4dENoYW5nZShnbCkge1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLnJlbmRlcmVyLmdsID0gZ2w7XG4gICAgdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRCA9IENPTlRFWFRfVUlEX0NPVU5URVIrKztcbiAgfVxuICBpbml0KG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5jb250ZXh0KSB7XG4gICAgICB0aGlzLmluaXRGcm9tQ29udGV4dChvcHRpb25zLmNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhbHBoYSA9IHRoaXMucmVuZGVyZXIuYmFja2dyb3VuZC5hbHBoYSA8IDE7XG4gICAgICBjb25zdCBwcmVtdWx0aXBsaWVkQWxwaGEgPSBvcHRpb25zLnByZW11bHRpcGxpZWRBbHBoYTtcbiAgICAgIHRoaXMucHJlc2VydmVEcmF3aW5nQnVmZmVyID0gb3B0aW9ucy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXI7XG4gICAgICB0aGlzLnVzZUNvbnRleHRBbHBoYSA9IG9wdGlvbnMudXNlQ29udGV4dEFscGhhO1xuICAgICAgdGhpcy5wb3dlclByZWZlcmVuY2UgPSBvcHRpb25zLnBvd2VyUHJlZmVyZW5jZTtcbiAgICAgIHRoaXMuaW5pdEZyb21PcHRpb25zKHtcbiAgICAgICAgYWxwaGEsXG4gICAgICAgIHByZW11bHRpcGxpZWRBbHBoYSxcbiAgICAgICAgYW50aWFsaWFzOiBvcHRpb25zLmFudGlhbGlhcyxcbiAgICAgICAgc3RlbmNpbDogdHJ1ZSxcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBvcHRpb25zLnByZXNlcnZlRHJhd2luZ0J1ZmZlcixcbiAgICAgICAgcG93ZXJQcmVmZXJlbmNlOiBvcHRpb25zLnBvd2VyUHJlZmVyZW5jZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGluaXRGcm9tQ29udGV4dChnbCkge1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLnZhbGlkYXRlQ29udGV4dChnbCk7XG4gICAgdGhpcy5yZW5kZXJlci5nbCA9IGdsO1xuICAgIHRoaXMucmVuZGVyZXIuQ09OVEVYVF9VSUQgPSBDT05URVhUX1VJRF9DT1VOVEVSKys7XG4gICAgdGhpcy5yZW5kZXJlci5ydW5uZXJzLmNvbnRleHRDaGFuZ2UuZW1pdChnbCk7XG4gICAgY29uc3QgdmlldyA9IHRoaXMucmVuZGVyZXIudmlldztcbiAgICBpZiAodmlldy5hZGRFdmVudExpc3RlbmVyICE9PSB2b2lkIDApIHtcbiAgICAgIHZpZXcuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dGxvc3RcIiwgdGhpcy5oYW5kbGVDb250ZXh0TG9zdCwgZmFsc2UpO1xuICAgICAgdmlldy5hZGRFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0cmVzdG9yZWRcIiwgdGhpcy5oYW5kbGVDb250ZXh0UmVzdG9yZWQsIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgaW5pdEZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuY3JlYXRlQ29udGV4dCh0aGlzLnJlbmRlcmVyLnZpZXcsIG9wdGlvbnMpO1xuICAgIHRoaXMuaW5pdEZyb21Db250ZXh0KGdsKTtcbiAgfVxuICBjcmVhdGVDb250ZXh0KGNhbnZhcywgb3B0aW9ucykge1xuICAgIGxldCBnbDtcbiAgICBpZiAoc2V0dGluZ3MuUFJFRkVSX0VOViA+PSBFTlYuV0VCR0wyKSB7XG4gICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2wyXCIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoZ2wpIHtcbiAgICAgIHRoaXMud2ViR0xWZXJzaW9uID0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53ZWJHTFZlcnNpb24gPSAxO1xuICAgICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIsIG9wdGlvbnMpIHx8IGNhbnZhcy5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsIG9wdGlvbnMpO1xuICAgICAgaWYgKCFnbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBXZWJHTC4gVHJ5IHVzaW5nIHRoZSBjYW52YXMgcmVuZGVyZXJcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLmdldEV4dGVuc2lvbnMoKTtcbiAgICByZXR1cm4gdGhpcy5nbDtcbiAgfVxuICBnZXRFeHRlbnNpb25zKCkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgY29uc3QgY29tbW9uID0ge1xuICAgICAgbG9zZUNvbnRleHQ6IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2xvc2VfY29udGV4dFwiKSxcbiAgICAgIGFuaXNvdHJvcGljRmlsdGVyaW5nOiBnbC5nZXRFeHRlbnNpb24oXCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIiksXG4gICAgICBmbG9hdFRleHR1cmVMaW5lYXI6IGdsLmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhclwiKSxcbiAgICAgIHMzdGM6IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXCIpLFxuICAgICAgczN0Y19zUkdCOiBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y19zcmdiXCIpLFxuICAgICAgZXRjOiBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjXCIpLFxuICAgICAgZXRjMTogZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzFcIiksXG4gICAgICBwdnJ0YzogZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjXCIpIHx8IGdsLmdldEV4dGVuc2lvbihcIldFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcIiksXG4gICAgICBhdGM6IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hdGNcIiksXG4gICAgICBhc3RjOiBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfYXN0Y1wiKVxuICAgIH07XG4gICAgaWYgKHRoaXMud2ViR0xWZXJzaW9uID09PSAxKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMuZXh0ZW5zaW9ucywgY29tbW9uLCB7XG4gICAgICAgIGRyYXdCdWZmZXJzOiBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9kcmF3X2J1ZmZlcnNcIiksXG4gICAgICAgIGRlcHRoVGV4dHVyZTogZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfZGVwdGhfdGV4dHVyZVwiKSxcbiAgICAgICAgdmVydGV4QXJyYXlPYmplY3Q6IGdsLmdldEV4dGVuc2lvbihcIk9FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0XCIpIHx8IGdsLmdldEV4dGVuc2lvbihcIk1PWl9PRVNfdmVydGV4X2FycmF5X29iamVjdFwiKSB8fCBnbC5nZXRFeHRlbnNpb24oXCJXRUJLSVRfT0VTX3ZlcnRleF9hcnJheV9vYmplY3RcIiksXG4gICAgICAgIHVpbnQzMkVsZW1lbnRJbmRleDogZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX2VsZW1lbnRfaW5kZXhfdWludFwiKSxcbiAgICAgICAgZmxvYXRUZXh0dXJlOiBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9mbG9hdFwiKSxcbiAgICAgICAgZmxvYXRUZXh0dXJlTGluZWFyOiBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXJcIiksXG4gICAgICAgIHRleHR1cmVIYWxmRmxvYXQ6IGdsLmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRcIiksXG4gICAgICAgIHRleHR1cmVIYWxmRmxvYXRMaW5lYXI6IGdsLmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyXCIpXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMud2ViR0xWZXJzaW9uID09PSAyKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMuZXh0ZW5zaW9ucywgY29tbW9uLCB7XG4gICAgICAgIGNvbG9yQnVmZmVyRmxvYXQ6IGdsLmdldEV4dGVuc2lvbihcIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIilcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBoYW5kbGVDb250ZXh0TG9zdChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5nbC5pc0NvbnRleHRMb3N0KCkgJiYgdGhpcy5leHRlbnNpb25zLmxvc2VDb250ZXh0KSB7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucy5sb3NlQ29udGV4dC5yZXN0b3JlQ29udGV4dCgpO1xuICAgICAgfVxuICAgIH0sIDApO1xuICB9XG4gIGhhbmRsZUNvbnRleHRSZXN0b3JlZCgpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnJ1bm5lcnMuY29udGV4dENoYW5nZS5lbWl0KHRoaXMuZ2wpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3QgdmlldyA9IHRoaXMucmVuZGVyZXIudmlldztcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICBpZiAodmlldy5yZW1vdmVFdmVudExpc3RlbmVyICE9PSB2b2lkIDApIHtcbiAgICAgIHZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dGxvc3RcIiwgdGhpcy5oYW5kbGVDb250ZXh0TG9zdCk7XG4gICAgICB2aWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRyZXN0b3JlZFwiLCB0aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZCk7XG4gICAgfVxuICAgIHRoaXMuZ2wudXNlUHJvZ3JhbShudWxsKTtcbiAgICBpZiAodGhpcy5leHRlbnNpb25zLmxvc2VDb250ZXh0KSB7XG4gICAgICB0aGlzLmV4dGVuc2lvbnMubG9zZUNvbnRleHQubG9zZUNvbnRleHQoKTtcbiAgICB9XG4gIH1cbiAgcG9zdHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJlci5vYmplY3RSZW5kZXJlci5yZW5kZXJpbmdUb1NjcmVlbikge1xuICAgICAgdGhpcy5nbC5mbHVzaCgpO1xuICAgIH1cbiAgfVxuICB2YWxpZGF0ZUNvbnRleHQoZ2wpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gZ2wuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKTtcbiAgICBjb25zdCBpc1dlYkdsMiA9IFwiV2ViR0wyUmVuZGVyaW5nQ29udGV4dFwiIGluIGdsb2JhbFRoaXMgJiYgZ2wgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLldlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XG4gICAgaWYgKGlzV2ViR2wyKSB7XG4gICAgICB0aGlzLndlYkdMVmVyc2lvbiA9IDI7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGVzICYmICFhdHRyaWJ1dGVzLnN0ZW5jaWwpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlByb3ZpZGVkIFdlYkdMIGNvbnRleHQgZG9lcyBub3QgaGF2ZSBhIHN0ZW5jaWwgYnVmZmVyLCBtYXNrcyBtYXkgbm90IHJlbmRlciBjb3JyZWN0bHlcIik7XG4gICAgfVxuICAgIGNvbnN0IGhhc3VpbnQzMiA9IGlzV2ViR2wyIHx8ICEhZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX2VsZW1lbnRfaW5kZXhfdWludFwiKTtcbiAgICB0aGlzLnN1cHBvcnRzLnVpbnQzMkluZGljZXMgPSBoYXN1aW50MzI7XG4gICAgaWYgKCFoYXN1aW50MzIpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlByb3ZpZGVkIFdlYkdMIGNvbnRleHQgZG9lcyBub3Qgc3VwcG9ydCAzMiBpbmRleCBidWZmZXIsIGNvbXBsZXggZ3JhcGhpY3MgbWF5IG5vdCByZW5kZXIgY29ycmVjdGx5XCIpO1xuICAgIH1cbiAgfVxufVxuQ29udGV4dFN5c3RlbS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgY29udGV4dDogbnVsbCxcbiAgYW50aWFsaWFzOiBmYWxzZSxcbiAgcHJlbXVsdGlwbGllZEFscGhhOiB0cnVlLFxuICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxuICBwb3dlclByZWZlcmVuY2U6IFwiZGVmYXVsdFwiXG59O1xuQ29udGV4dFN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwiY29udGV4dFwiXG59O1xuZXh0ZW5zaW9ucy5hZGQoQ29udGV4dFN5c3RlbSk7XG5cbmV4cG9ydCB7IENvbnRleHRTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbnRleHRTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgQUxQSEFfTU9ERVMgfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuaW1wb3J0IHsgQnVmZmVyUmVzb3VyY2UgfSBmcm9tICcuL0J1ZmZlclJlc291cmNlLm1qcyc7XG5cbmNsYXNzIERlcHRoUmVzb3VyY2UgZXh0ZW5kcyBCdWZmZXJSZXNvdXJjZSB7XG4gIHVwbG9hZChyZW5kZXJlciwgYmFzZVRleHR1cmUsIGdsVGV4dHVyZSkge1xuICAgIGNvbnN0IGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBiYXNlVGV4dHVyZS5hbHBoYU1vZGUgPT09IEFMUEhBX01PREVTLlVOUEFDSyk7XG4gICAgY29uc3Qgd2lkdGggPSBiYXNlVGV4dHVyZS5yZWFsV2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gYmFzZVRleHR1cmUucmVhbEhlaWdodDtcbiAgICBpZiAoZ2xUZXh0dXJlLndpZHRoID09PSB3aWR0aCAmJiBnbFRleHR1cmUuaGVpZ2h0ID09PSBoZWlnaHQpIHtcbiAgICAgIGdsLnRleFN1YkltYWdlMkQoYmFzZVRleHR1cmUudGFyZ2V0LCAwLCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCBiYXNlVGV4dHVyZS5mb3JtYXQsIGdsVGV4dHVyZS50eXBlLCB0aGlzLmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbFRleHR1cmUud2lkdGggPSB3aWR0aDtcbiAgICAgIGdsVGV4dHVyZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBnbC50ZXhJbWFnZTJEKGJhc2VUZXh0dXJlLnRhcmdldCwgMCwgZ2xUZXh0dXJlLmludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBiYXNlVGV4dHVyZS5mb3JtYXQsIGdsVGV4dHVyZS50eXBlLCB0aGlzLmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnQgeyBEZXB0aFJlc291cmNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZXB0aFJlc291cmNlLm1qcy5tYXBcbiIsImltcG9ydCB7IE1TQUFfUVVBTElUWSwgU0NBTEVfTU9ERVMsIE1JUE1BUF9NT0RFUywgRk9STUFUUywgVFlQRVMgfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuaW1wb3J0IHsgUnVubmVyIH0gZnJvbSAnQHBpeGkvcnVubmVyJztcbmltcG9ydCB7IEJhc2VUZXh0dXJlIH0gZnJvbSAnLi4vdGV4dHVyZXMvQmFzZVRleHR1cmUubWpzJztcbmltcG9ydCB7IERlcHRoUmVzb3VyY2UgfSBmcm9tICcuLi90ZXh0dXJlcy9yZXNvdXJjZXMvRGVwdGhSZXNvdXJjZS5tanMnO1xuXG5jbGFzcyBGcmFtZWJ1ZmZlciB7XG4gIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLndpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCB8fCAxMDApO1xuICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQgfHwgMTAwKTtcbiAgICB0aGlzLnN0ZW5jaWwgPSBmYWxzZTtcbiAgICB0aGlzLmRlcHRoID0gZmFsc2U7XG4gICAgdGhpcy5kaXJ0eUlkID0gMDtcbiAgICB0aGlzLmRpcnR5Rm9ybWF0ID0gMDtcbiAgICB0aGlzLmRpcnR5U2l6ZSA9IDA7XG4gICAgdGhpcy5kZXB0aFRleHR1cmUgPSBudWxsO1xuICAgIHRoaXMuY29sb3JUZXh0dXJlcyA9IFtdO1xuICAgIHRoaXMuZ2xGcmFtZWJ1ZmZlcnMgPSB7fTtcbiAgICB0aGlzLmRpc3Bvc2VSdW5uZXIgPSBuZXcgUnVubmVyKFwiZGlzcG9zZUZyYW1lYnVmZmVyXCIpO1xuICAgIHRoaXMubXVsdGlzYW1wbGUgPSBNU0FBX1FVQUxJVFkuTk9ORTtcbiAgfVxuICBnZXQgY29sb3JUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbG9yVGV4dHVyZXNbMF07XG4gIH1cbiAgYWRkQ29sb3JUZXh0dXJlKGluZGV4ID0gMCwgdGV4dHVyZSkge1xuICAgIHRoaXMuY29sb3JUZXh0dXJlc1tpbmRleF0gPSB0ZXh0dXJlIHx8IG5ldyBCYXNlVGV4dHVyZShudWxsLCB7XG4gICAgICBzY2FsZU1vZGU6IFNDQUxFX01PREVTLk5FQVJFU1QsXG4gICAgICByZXNvbHV0aW9uOiAxLFxuICAgICAgbWlwbWFwOiBNSVBNQVBfTU9ERVMuT0ZGLFxuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgfSk7XG4gICAgdGhpcy5kaXJ0eUlkKys7XG4gICAgdGhpcy5kaXJ0eUZvcm1hdCsrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFkZERlcHRoVGV4dHVyZSh0ZXh0dXJlKSB7XG4gICAgdGhpcy5kZXB0aFRleHR1cmUgPSB0ZXh0dXJlIHx8IG5ldyBCYXNlVGV4dHVyZShuZXcgRGVwdGhSZXNvdXJjZShudWxsLCB7IHdpZHRoOiB0aGlzLndpZHRoLCBoZWlnaHQ6IHRoaXMuaGVpZ2h0IH0pLCB7XG4gICAgICBzY2FsZU1vZGU6IFNDQUxFX01PREVTLk5FQVJFU1QsXG4gICAgICByZXNvbHV0aW9uOiAxLFxuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgbWlwbWFwOiBNSVBNQVBfTU9ERVMuT0ZGLFxuICAgICAgZm9ybWF0OiBGT1JNQVRTLkRFUFRIX0NPTVBPTkVOVCxcbiAgICAgIHR5cGU6IFRZUEVTLlVOU0lHTkVEX1NIT1JUXG4gICAgfSk7XG4gICAgdGhpcy5kaXJ0eUlkKys7XG4gICAgdGhpcy5kaXJ0eUZvcm1hdCsrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGVuYWJsZURlcHRoKCkge1xuICAgIHRoaXMuZGVwdGggPSB0cnVlO1xuICAgIHRoaXMuZGlydHlJZCsrO1xuICAgIHRoaXMuZGlydHlGb3JtYXQrKztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBlbmFibGVTdGVuY2lsKCkge1xuICAgIHRoaXMuc3RlbmNpbCA9IHRydWU7XG4gICAgdGhpcy5kaXJ0eUlkKys7XG4gICAgdGhpcy5kaXJ0eUZvcm1hdCsrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgd2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoKTtcbiAgICBoZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCk7XG4gICAgaWYgKHdpZHRoID09PSB0aGlzLndpZHRoICYmIGhlaWdodCA9PT0gdGhpcy5oZWlnaHQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuZGlydHlJZCsrO1xuICAgIHRoaXMuZGlydHlTaXplKys7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbG9yVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmNvbG9yVGV4dHVyZXNbaV07XG4gICAgICBjb25zdCByZXNvbHV0aW9uID0gdGV4dHVyZS5yZXNvbHV0aW9uO1xuICAgICAgdGV4dHVyZS5zZXRTaXplKHdpZHRoIC8gcmVzb2x1dGlvbiwgaGVpZ2h0IC8gcmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlcHRoVGV4dHVyZSkge1xuICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuZGVwdGhUZXh0dXJlLnJlc29sdXRpb247XG4gICAgICB0aGlzLmRlcHRoVGV4dHVyZS5zZXRTaXplKHdpZHRoIC8gcmVzb2x1dGlvbiwgaGVpZ2h0IC8gcmVzb2x1dGlvbik7XG4gICAgfVxuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5kaXNwb3NlUnVubmVyLmVtaXQodGhpcywgZmFsc2UpO1xuICB9XG4gIGRlc3Ryb3lEZXB0aFRleHR1cmUoKSB7XG4gICAgaWYgKHRoaXMuZGVwdGhUZXh0dXJlKSB7XG4gICAgICB0aGlzLmRlcHRoVGV4dHVyZS5kZXN0cm95KCk7XG4gICAgICB0aGlzLmRlcHRoVGV4dHVyZSA9IG51bGw7XG4gICAgICArK3RoaXMuZGlydHlJZDtcbiAgICAgICsrdGhpcy5kaXJ0eUZvcm1hdDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgRnJhbWVidWZmZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZyYW1lYnVmZmVyLm1qcy5tYXBcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAnQHBpeGkvY29sb3InO1xuaW1wb3J0IHsgTVNBQV9RVUFMSVRZLCBNSVBNQVBfTU9ERVMgfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuaW1wb3J0IHsgRnJhbWVidWZmZXIgfSBmcm9tICcuLi9mcmFtZWJ1ZmZlci9GcmFtZWJ1ZmZlci5tanMnO1xuaW1wb3J0IHsgQmFzZVRleHR1cmUgfSBmcm9tICcuLi90ZXh0dXJlcy9CYXNlVGV4dHVyZS5tanMnO1xuXG5jbGFzcyBCYXNlUmVuZGVyVGV4dHVyZSBleHRlbmRzIEJhc2VUZXh0dXJlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGNvbnN0IHNjYWxlTW9kZSA9IGFyZ3VtZW50c1syXTtcbiAgICAgIGNvbnN0IHJlc29sdXRpb24gPSBhcmd1bWVudHNbM107XG4gICAgICBvcHRpb25zID0geyB3aWR0aCwgaGVpZ2h0LCBzY2FsZU1vZGUsIHJlc29sdXRpb24gfTtcbiAgICB9XG4gICAgb3B0aW9ucy53aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgMTAwO1xuICAgIG9wdGlvbnMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgfHwgMTAwO1xuICAgIG9wdGlvbnMubXVsdGlzYW1wbGUgPz8gKG9wdGlvbnMubXVsdGlzYW1wbGUgPSBNU0FBX1FVQUxJVFkuTk9ORSk7XG4gICAgc3VwZXIobnVsbCwgb3B0aW9ucyk7XG4gICAgdGhpcy5taXBtYXAgPSBNSVBNQVBfTU9ERVMuT0ZGO1xuICAgIHRoaXMudmFsaWQgPSB0cnVlO1xuICAgIHRoaXMuX2NsZWFyID0gbmV3IENvbG9yKFswLCAwLCAwLCAwXSk7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlciA9IG5ldyBGcmFtZWJ1ZmZlcih0aGlzLnJlYWxXaWR0aCwgdGhpcy5yZWFsSGVpZ2h0KS5hZGRDb2xvclRleHR1cmUoMCwgdGhpcyk7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlci5tdWx0aXNhbXBsZSA9IG9wdGlvbnMubXVsdGlzYW1wbGU7XG4gICAgdGhpcy5tYXNrU3RhY2sgPSBbXTtcbiAgICB0aGlzLmZpbHRlclN0YWNrID0gW3t9XTtcbiAgfVxuICBzZXQgY2xlYXJDb2xvcih2YWx1ZSkge1xuICAgIHRoaXMuX2NsZWFyLnNldFZhbHVlKHZhbHVlKTtcbiAgfVxuICBnZXQgY2xlYXJDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xlYXIudmFsdWU7XG4gIH1cbiAgZ2V0IGNsZWFyKCkge1xuICAgIHJldHVybiB0aGlzLl9jbGVhcjtcbiAgfVxuICByZXNpemUoZGVzaXJlZFdpZHRoLCBkZXNpcmVkSGVpZ2h0KSB7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlci5yZXNpemUoZGVzaXJlZFdpZHRoICogdGhpcy5yZXNvbHV0aW9uLCBkZXNpcmVkSGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uKTtcbiAgICB0aGlzLnNldFJlYWxTaXplKHRoaXMuZnJhbWVidWZmZXIud2lkdGgsIHRoaXMuZnJhbWVidWZmZXIuaGVpZ2h0KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuZnJhbWVidWZmZXIuZGlzcG9zZSgpO1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmZyYW1lYnVmZmVyLmRlc3Ryb3lEZXB0aFRleHR1cmUoKTtcbiAgICB0aGlzLmZyYW1lYnVmZmVyID0gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgeyBCYXNlUmVuZGVyVGV4dHVyZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZVJlbmRlclRleHR1cmUubWpzLm1hcFxuIiwiaW1wb3J0IHsgQUxQSEFfTU9ERVMgfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuaW1wb3J0IHsgZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4gfSBmcm9tICdAcGl4aS91dGlscyc7XG5pbXBvcnQgeyBSZXNvdXJjZSB9IGZyb20gJy4vUmVzb3VyY2UubWpzJztcblxuY2xhc3MgQmFzZUltYWdlUmVzb3VyY2UgZXh0ZW5kcyBSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIGNvbnN0IHNvdXJjZUFueSA9IHNvdXJjZTtcbiAgICBjb25zdCB3aWR0aCA9IHNvdXJjZUFueS5uYXR1cmFsV2lkdGggfHwgc291cmNlQW55LnZpZGVvV2lkdGggfHwgc291cmNlQW55LndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHNvdXJjZUFueS5uYXR1cmFsSGVpZ2h0IHx8IHNvdXJjZUFueS52aWRlb0hlaWdodCB8fCBzb3VyY2VBbnkuaGVpZ2h0O1xuICAgIHN1cGVyKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMubm9TdWJJbWFnZSA9IGZhbHNlO1xuICB9XG4gIHN0YXRpYyBjcm9zc09yaWdpbihlbGVtZW50LCB1cmwsIGNyb3Nzb3JpZ2luKSB7XG4gICAgaWYgKGNyb3Nzb3JpZ2luID09PSB2b2lkIDAgJiYgIXVybC5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICAgIGVsZW1lbnQuY3Jvc3NPcmlnaW4gPSBkZXRlcm1pbmVDcm9zc09yaWdpbih1cmwpO1xuICAgIH0gZWxzZSBpZiAoY3Jvc3NvcmlnaW4gIT09IGZhbHNlKSB7XG4gICAgICBlbGVtZW50LmNyb3NzT3JpZ2luID0gdHlwZW9mIGNyb3Nzb3JpZ2luID09PSBcInN0cmluZ1wiID8gY3Jvc3NvcmlnaW4gOiBcImFub255bW91c1wiO1xuICAgIH1cbiAgfVxuICB1cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUsIHNvdXJjZSkge1xuICAgIGNvbnN0IGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgY29uc3Qgd2lkdGggPSBiYXNlVGV4dHVyZS5yZWFsV2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gYmFzZVRleHR1cmUucmVhbEhlaWdodDtcbiAgICBzb3VyY2UgPSBzb3VyY2UgfHwgdGhpcy5zb3VyY2U7XG4gICAgaWYgKHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgIGlmICghc291cmNlLmNvbXBsZXRlIHx8IHNvdXJjZS5uYXR1cmFsV2lkdGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIEhUTUxWaWRlb0VsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgc291cmNlIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgICAgaWYgKHNvdXJjZS5yZWFkeVN0YXRlIDw9IDEgJiYgc291cmNlLmJ1ZmZlcmVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgYmFzZVRleHR1cmUuYWxwaGFNb2RlID09PSBBTFBIQV9NT0RFUy5VTlBBQ0spO1xuICAgIGlmICghdGhpcy5ub1N1YkltYWdlICYmIGJhc2VUZXh0dXJlLnRhcmdldCA9PT0gZ2wuVEVYVFVSRV8yRCAmJiBnbFRleHR1cmUud2lkdGggPT09IHdpZHRoICYmIGdsVGV4dHVyZS5oZWlnaHQgPT09IGhlaWdodCkge1xuICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCBiYXNlVGV4dHVyZS5mb3JtYXQsIGdsVGV4dHVyZS50eXBlLCBzb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbFRleHR1cmUud2lkdGggPSB3aWR0aDtcbiAgICAgIGdsVGV4dHVyZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBnbC50ZXhJbWFnZTJEKGJhc2VUZXh0dXJlLnRhcmdldCwgMCwgZ2xUZXh0dXJlLmludGVybmFsRm9ybWF0LCBiYXNlVGV4dHVyZS5mb3JtYXQsIGdsVGV4dHVyZS50eXBlLCBzb3VyY2UpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgIGNvbnN0IHdpZHRoID0gc291cmNlLm5hdHVyYWxXaWR0aCB8fCBzb3VyY2UudmlkZW9XaWR0aCB8fCBzb3VyY2Uud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gc291cmNlLm5hdHVyYWxIZWlnaHQgfHwgc291cmNlLnZpZGVvSGVpZ2h0IHx8IHNvdXJjZS5oZWlnaHQ7XG4gICAgdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgc3VwZXIudXBkYXRlKCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHsgQmFzZUltYWdlUmVzb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhc2VJbWFnZVJlc291cmNlLm1qcy5tYXBcbiIsImltcG9ydCB7IEFMUEhBX01PREVTIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcbmltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSAnQHBpeGkvc2V0dGluZ3MnO1xuaW1wb3J0IHsgQmFzZUltYWdlUmVzb3VyY2UgfSBmcm9tICcuL0Jhc2VJbWFnZVJlc291cmNlLm1qcyc7XG5cbmNsYXNzIEltYWdlUmVzb3VyY2UgZXh0ZW5kcyBCYXNlSW1hZ2VSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBpbWFnZUVsZW1lbnQgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIEJhc2VJbWFnZVJlc291cmNlLmNyb3NzT3JpZ2luKGltYWdlRWxlbWVudCwgc291cmNlLCBvcHRpb25zLmNyb3Nzb3JpZ2luKTtcbiAgICAgIGltYWdlRWxlbWVudC5zcmMgPSBzb3VyY2U7XG4gICAgICBzb3VyY2UgPSBpbWFnZUVsZW1lbnQ7XG4gICAgfVxuICAgIHN1cGVyKHNvdXJjZSk7XG4gICAgaWYgKCFzb3VyY2UuY29tcGxldGUgJiYgISF0aGlzLl93aWR0aCAmJiAhIXRoaXMuX2hlaWdodCkge1xuICAgICAgdGhpcy5fd2lkdGggPSAwO1xuICAgICAgdGhpcy5faGVpZ2h0ID0gMDtcbiAgICB9XG4gICAgdGhpcy51cmwgPSBzb3VyY2Uuc3JjO1xuICAgIHRoaXMuX3Byb2Nlc3MgPSBudWxsO1xuICAgIHRoaXMucHJlc2VydmVCaXRtYXAgPSBmYWxzZTtcbiAgICB0aGlzLmNyZWF0ZUJpdG1hcCA9IChvcHRpb25zLmNyZWF0ZUJpdG1hcCA/PyBzZXR0aW5ncy5DUkVBVEVfSU1BR0VfQklUTUFQKSAmJiAhIWdsb2JhbFRoaXMuY3JlYXRlSW1hZ2VCaXRtYXA7XG4gICAgdGhpcy5hbHBoYU1vZGUgPSB0eXBlb2Ygb3B0aW9ucy5hbHBoYU1vZGUgPT09IFwibnVtYmVyXCIgPyBvcHRpb25zLmFscGhhTW9kZSA6IG51bGw7XG4gICAgdGhpcy5iaXRtYXAgPSBudWxsO1xuICAgIHRoaXMuX2xvYWQgPSBudWxsO1xuICAgIGlmIChvcHRpb25zLmF1dG9Mb2FkICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5sb2FkKCk7XG4gICAgfVxuICB9XG4gIGxvYWQoY3JlYXRlQml0bWFwKSB7XG4gICAgaWYgKHRoaXMuX2xvYWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2FkO1xuICAgIH1cbiAgICBpZiAoY3JlYXRlQml0bWFwICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuY3JlYXRlQml0bWFwID0gY3JlYXRlQml0bWFwO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgICB0aGlzLnVybCA9IHNvdXJjZS5zcmM7XG4gICAgICBjb25zdCBjb21wbGV0ZWQgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2Uub25sb2FkID0gbnVsbDtcbiAgICAgICAgc291cmNlLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLnJlc2l6ZShzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xuICAgICAgICB0aGlzLl9sb2FkID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuY3JlYXRlQml0bWFwKSB7XG4gICAgICAgICAgcmVzb2x2ZSh0aGlzLnByb2Nlc3MoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChzb3VyY2UuY29tcGxldGUgJiYgc291cmNlLnNyYykge1xuICAgICAgICBjb21wbGV0ZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZS5vbmxvYWQgPSBjb21wbGV0ZWQ7XG4gICAgICAgIHNvdXJjZS5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgcmVqZWN0KGV2ZW50KTtcbiAgICAgICAgICB0aGlzLm9uRXJyb3IuZW1pdChldmVudCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX2xvYWQ7XG4gIH1cbiAgcHJvY2VzcygpIHtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICBpZiAodGhpcy5fcHJvY2VzcyAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3M7XG4gICAgfVxuICAgIGlmICh0aGlzLmJpdG1hcCAhPT0gbnVsbCB8fCAhZ2xvYmFsVGhpcy5jcmVhdGVJbWFnZUJpdG1hcCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzKTtcbiAgICB9XG4gICAgY29uc3QgY3JlYXRlSW1hZ2VCaXRtYXAgPSBnbG9iYWxUaGlzLmNyZWF0ZUltYWdlQml0bWFwO1xuICAgIGNvbnN0IGNvcnMgPSAhc291cmNlLmNyb3NzT3JpZ2luIHx8IHNvdXJjZS5jcm9zc09yaWdpbiA9PT0gXCJhbm9ueW1vdXNcIjtcbiAgICB0aGlzLl9wcm9jZXNzID0gZmV0Y2goc291cmNlLnNyYywge1xuICAgICAgbW9kZTogY29ycyA/IFwiY29yc1wiIDogXCJuby1jb3JzXCJcbiAgICB9KS50aGVuKChyKSA9PiByLmJsb2IoKSkudGhlbigoYmxvYikgPT4gY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYiwgMCwgMCwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0LCB7XG4gICAgICBwcmVtdWx0aXBseUFscGhhOiB0aGlzLmFscGhhTW9kZSA9PT0gbnVsbCB8fCB0aGlzLmFscGhhTW9kZSA9PT0gQUxQSEFfTU9ERVMuVU5QQUNLID8gXCJwcmVtdWx0aXBseVwiIDogXCJub25lXCJcbiAgICB9KSkudGhlbigoYml0bWFwKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmJpdG1hcCA9IGJpdG1hcDtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICB0aGlzLl9wcm9jZXNzID0gbnVsbDtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3M7XG4gIH1cbiAgdXBsb2FkKHJlbmRlcmVyLCBiYXNlVGV4dHVyZSwgZ2xUZXh0dXJlKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmFscGhhTW9kZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgYmFzZVRleHR1cmUuYWxwaGFNb2RlID0gdGhpcy5hbHBoYU1vZGU7XG4gICAgfVxuICAgIGlmICghdGhpcy5jcmVhdGVCaXRtYXApIHtcbiAgICAgIHJldHVybiBzdXBlci51cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuYml0bWFwKSB7XG4gICAgICB0aGlzLnByb2Nlc3MoKTtcbiAgICAgIGlmICghdGhpcy5iaXRtYXApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlci51cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUsIHRoaXMuYml0bWFwKTtcbiAgICBpZiAoIXRoaXMucHJlc2VydmVCaXRtYXApIHtcbiAgICAgIGxldCBmbGFnID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGdsVGV4dHVyZXMgPSBiYXNlVGV4dHVyZS5fZ2xUZXh0dXJlcztcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGdsVGV4dHVyZXMpIHtcbiAgICAgICAgY29uc3Qgb3RoZXJUZXggPSBnbFRleHR1cmVzW2tleV07XG4gICAgICAgIGlmIChvdGhlclRleCAhPT0gZ2xUZXh0dXJlICYmIG90aGVyVGV4LmRpcnR5SWQgIT09IGJhc2VUZXh0dXJlLmRpcnR5SWQpIHtcbiAgICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmbGFnKSB7XG4gICAgICAgIGlmICh0aGlzLmJpdG1hcC5jbG9zZSkge1xuICAgICAgICAgIHRoaXMuYml0bWFwLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaXRtYXAgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuc291cmNlLm9ubG9hZCA9IG51bGw7XG4gICAgdGhpcy5zb3VyY2Uub25lcnJvciA9IG51bGw7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIGlmICh0aGlzLmJpdG1hcCkge1xuICAgICAgdGhpcy5iaXRtYXAuY2xvc2UoKTtcbiAgICAgIHRoaXMuYml0bWFwID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fcHJvY2VzcyA9IG51bGw7XG4gICAgdGhpcy5fbG9hZCA9IG51bGw7XG4gIH1cbiAgc3RhdGljIHRlc3Qoc291cmNlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmICh0eXBlb2Ygc291cmNlID09PSBcInN0cmluZ1wiIHx8IHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpO1xuICB9XG59XG5cbmV4cG9ydCB7IEltYWdlUmVzb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUltYWdlUmVzb3VyY2UubWpzLm1hcFxuIiwiaW1wb3J0IHsgZ3JvdXBEOCB9IGZyb20gJ0BwaXhpL21hdGgnO1xuXG5jbGFzcyBUZXh0dXJlVXZzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy54MCA9IDA7XG4gICAgdGhpcy55MCA9IDA7XG4gICAgdGhpcy54MSA9IDE7XG4gICAgdGhpcy55MSA9IDA7XG4gICAgdGhpcy54MiA9IDE7XG4gICAgdGhpcy55MiA9IDE7XG4gICAgdGhpcy54MyA9IDA7XG4gICAgdGhpcy55MyA9IDE7XG4gICAgdGhpcy51dnNGbG9hdDMyID0gbmV3IEZsb2F0MzJBcnJheSg4KTtcbiAgfVxuICBzZXQoZnJhbWUsIGJhc2VGcmFtZSwgcm90YXRlKSB7XG4gICAgY29uc3QgdHcgPSBiYXNlRnJhbWUud2lkdGg7XG4gICAgY29uc3QgdGggPSBiYXNlRnJhbWUuaGVpZ2h0O1xuICAgIGlmIChyb3RhdGUpIHtcbiAgICAgIGNvbnN0IHcyID0gZnJhbWUud2lkdGggLyAyIC8gdHc7XG4gICAgICBjb25zdCBoMiA9IGZyYW1lLmhlaWdodCAvIDIgLyB0aDtcbiAgICAgIGNvbnN0IGNYID0gZnJhbWUueCAvIHR3ICsgdzI7XG4gICAgICBjb25zdCBjWSA9IGZyYW1lLnkgLyB0aCArIGgyO1xuICAgICAgcm90YXRlID0gZ3JvdXBEOC5hZGQocm90YXRlLCBncm91cEQ4Lk5XKTtcbiAgICAgIHRoaXMueDAgPSBjWCArIHcyICogZ3JvdXBEOC51WChyb3RhdGUpO1xuICAgICAgdGhpcy55MCA9IGNZICsgaDIgKiBncm91cEQ4LnVZKHJvdGF0ZSk7XG4gICAgICByb3RhdGUgPSBncm91cEQ4LmFkZChyb3RhdGUsIDIpO1xuICAgICAgdGhpcy54MSA9IGNYICsgdzIgKiBncm91cEQ4LnVYKHJvdGF0ZSk7XG4gICAgICB0aGlzLnkxID0gY1kgKyBoMiAqIGdyb3VwRDgudVkocm90YXRlKTtcbiAgICAgIHJvdGF0ZSA9IGdyb3VwRDguYWRkKHJvdGF0ZSwgMik7XG4gICAgICB0aGlzLngyID0gY1ggKyB3MiAqIGdyb3VwRDgudVgocm90YXRlKTtcbiAgICAgIHRoaXMueTIgPSBjWSArIGgyICogZ3JvdXBEOC51WShyb3RhdGUpO1xuICAgICAgcm90YXRlID0gZ3JvdXBEOC5hZGQocm90YXRlLCAyKTtcbiAgICAgIHRoaXMueDMgPSBjWCArIHcyICogZ3JvdXBEOC51WChyb3RhdGUpO1xuICAgICAgdGhpcy55MyA9IGNZICsgaDIgKiBncm91cEQ4LnVZKHJvdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMueDAgPSBmcmFtZS54IC8gdHc7XG4gICAgICB0aGlzLnkwID0gZnJhbWUueSAvIHRoO1xuICAgICAgdGhpcy54MSA9IChmcmFtZS54ICsgZnJhbWUud2lkdGgpIC8gdHc7XG4gICAgICB0aGlzLnkxID0gZnJhbWUueSAvIHRoO1xuICAgICAgdGhpcy54MiA9IChmcmFtZS54ICsgZnJhbWUud2lkdGgpIC8gdHc7XG4gICAgICB0aGlzLnkyID0gKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpIC8gdGg7XG4gICAgICB0aGlzLngzID0gZnJhbWUueCAvIHR3O1xuICAgICAgdGhpcy55MyA9IChmcmFtZS55ICsgZnJhbWUuaGVpZ2h0KSAvIHRoO1xuICAgIH1cbiAgICB0aGlzLnV2c0Zsb2F0MzJbMF0gPSB0aGlzLngwO1xuICAgIHRoaXMudXZzRmxvYXQzMlsxXSA9IHRoaXMueTA7XG4gICAgdGhpcy51dnNGbG9hdDMyWzJdID0gdGhpcy54MTtcbiAgICB0aGlzLnV2c0Zsb2F0MzJbM10gPSB0aGlzLnkxO1xuICAgIHRoaXMudXZzRmxvYXQzMls0XSA9IHRoaXMueDI7XG4gICAgdGhpcy51dnNGbG9hdDMyWzVdID0gdGhpcy55MjtcbiAgICB0aGlzLnV2c0Zsb2F0MzJbNl0gPSB0aGlzLngzO1xuICAgIHRoaXMudXZzRmxvYXQzMls3XSA9IHRoaXMueTM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBbQHBpeGkvY29yZTpUZXh0dXJlVXZzIHgwPSR7dGhpcy54MH0geTA9JHt0aGlzLnkwfSB4MT0ke3RoaXMueDF9IHkxPSR7dGhpcy55MX0geDI9JHt0aGlzLngyfSB5Mj0ke3RoaXMueTJ9IHgzPSR7dGhpcy54M30geTM9JHt0aGlzLnkzfV1gO1xuICB9XG59XG5cbmV4cG9ydCB7IFRleHR1cmVVdnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHR1cmVVdnMubWpzLm1hcFxuIiwiaW1wb3J0IHsgUmVjdGFuZ2xlLCBQb2ludCB9IGZyb20gJ0BwaXhpL21hdGgnO1xuaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tICdAcGl4aS9zZXR0aW5ncyc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIsIFRleHR1cmVDYWNoZSwgdWlkLCBnZXRSZXNvbHV0aW9uT2ZVcmwgfSBmcm9tICdAcGl4aS91dGlscyc7XG5pbXBvcnQgeyBCYXNlVGV4dHVyZSB9IGZyb20gJy4vQmFzZVRleHR1cmUubWpzJztcbmltcG9ydCB7IEltYWdlUmVzb3VyY2UgfSBmcm9tICcuL3Jlc291cmNlcy9JbWFnZVJlc291cmNlLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlVXZzIH0gZnJvbSAnLi9UZXh0dXJlVXZzLm1qcyc7XG5cbmNvbnN0IERFRkFVTFRfVVZTID0gbmV3IFRleHR1cmVVdnMoKTtcbmZ1bmN0aW9uIHJlbW92ZUFsbEhhbmRsZXJzKHRleCkge1xuICB0ZXguZGVzdHJveSA9IGZ1bmN0aW9uIF9lbXB0eURlc3Ryb3koKSB7XG4gIH07XG4gIHRleC5vbiA9IGZ1bmN0aW9uIF9lbXB0eU9uKCkge1xuICB9O1xuICB0ZXgub25jZSA9IGZ1bmN0aW9uIF9lbXB0eU9uY2UoKSB7XG4gIH07XG4gIHRleC5lbWl0ID0gZnVuY3Rpb24gX2VtcHR5RW1pdCgpIHtcbiAgfTtcbn1cbmNsYXNzIFRleHR1cmUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihiYXNlVGV4dHVyZSwgZnJhbWUsIG9yaWcsIHRyaW0sIHJvdGF0ZSwgYW5jaG9yLCBib3JkZXJzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5vRnJhbWUgPSBmYWxzZTtcbiAgICBpZiAoIWZyYW1lKSB7XG4gICAgICB0aGlzLm5vRnJhbWUgPSB0cnVlO1xuICAgICAgZnJhbWUgPSBuZXcgUmVjdGFuZ2xlKDAsIDAsIDEsIDEpO1xuICAgIH1cbiAgICBpZiAoYmFzZVRleHR1cmUgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG4gICAgICBiYXNlVGV4dHVyZSA9IGJhc2VUZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgIH1cbiAgICB0aGlzLmJhc2VUZXh0dXJlID0gYmFzZVRleHR1cmU7XG4gICAgdGhpcy5fZnJhbWUgPSBmcmFtZTtcbiAgICB0aGlzLnRyaW0gPSB0cmltO1xuICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcbiAgICB0aGlzLl91dnMgPSBERUZBVUxUX1VWUztcbiAgICB0aGlzLnV2TWF0cml4ID0gbnVsbDtcbiAgICB0aGlzLm9yaWcgPSBvcmlnIHx8IGZyYW1lO1xuICAgIHRoaXMuX3JvdGF0ZSA9IE51bWJlcihyb3RhdGUgfHwgMCk7XG4gICAgaWYgKHJvdGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5fcm90YXRlID0gMjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3JvdGF0ZSAlIDIgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImF0dGVtcHQgdG8gdXNlIGRpYW1vbmQtc2hhcGVkIFVWcy4gSWYgeW91IGFyZSBzdXJlLCBzZXQgcm90YXRpb24gbWFudWFsbHlcIik7XG4gICAgfVxuICAgIHRoaXMuZGVmYXVsdEFuY2hvciA9IGFuY2hvciA/IG5ldyBQb2ludChhbmNob3IueCwgYW5jaG9yLnkpIDogbmV3IFBvaW50KDAsIDApO1xuICAgIHRoaXMuZGVmYXVsdEJvcmRlcnMgPSBib3JkZXJzO1xuICAgIHRoaXMuX3VwZGF0ZUlEID0gMDtcbiAgICB0aGlzLnRleHR1cmVDYWNoZUlkcyA9IFtdO1xuICAgIGlmICghYmFzZVRleHR1cmUudmFsaWQpIHtcbiAgICAgIGJhc2VUZXh0dXJlLm9uY2UoXCJsb2FkZWRcIiwgdGhpcy5vbkJhc2VUZXh0dXJlVXBkYXRlZCwgdGhpcyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm5vRnJhbWUpIHtcbiAgICAgIGlmIChiYXNlVGV4dHVyZS52YWxpZCkge1xuICAgICAgICB0aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkKGJhc2VUZXh0dXJlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mcmFtZSA9IGZyYW1lO1xuICAgIH1cbiAgICBpZiAodGhpcy5ub0ZyYW1lKSB7XG4gICAgICBiYXNlVGV4dHVyZS5vbihcInVwZGF0ZVwiLCB0aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGlmICh0aGlzLmJhc2VUZXh0dXJlLnJlc291cmNlKSB7XG4gICAgICB0aGlzLmJhc2VUZXh0dXJlLnJlc291cmNlLnVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuICBvbkJhc2VUZXh0dXJlVXBkYXRlZChiYXNlVGV4dHVyZSkge1xuICAgIGlmICh0aGlzLm5vRnJhbWUpIHtcbiAgICAgIGlmICghdGhpcy5iYXNlVGV4dHVyZS52YWxpZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9mcmFtZS53aWR0aCA9IGJhc2VUZXh0dXJlLndpZHRoO1xuICAgICAgdGhpcy5fZnJhbWUuaGVpZ2h0ID0gYmFzZVRleHR1cmUuaGVpZ2h0O1xuICAgICAgdGhpcy52YWxpZCA9IHRydWU7XG4gICAgICB0aGlzLnVwZGF0ZVV2cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZyYW1lID0gdGhpcy5fZnJhbWU7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCB0aGlzKTtcbiAgfVxuICBkZXN0cm95KGRlc3Ryb3lCYXNlKSB7XG4gICAgaWYgKHRoaXMuYmFzZVRleHR1cmUpIHtcbiAgICAgIGlmIChkZXN0cm95QmFzZSkge1xuICAgICAgICBjb25zdCB7IHJlc291cmNlIH0gPSB0aGlzLmJhc2VUZXh0dXJlO1xuICAgICAgICBpZiAocmVzb3VyY2U/LnVybCAmJiBUZXh0dXJlQ2FjaGVbcmVzb3VyY2UudXJsXSkge1xuICAgICAgICAgIFRleHR1cmUucmVtb3ZlRnJvbUNhY2hlKHJlc291cmNlLnVybCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmJhc2VUZXh0dXJlLm9mZihcImxvYWRlZFwiLCB0aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkLCB0aGlzKTtcbiAgICAgIHRoaXMuYmFzZVRleHR1cmUub2ZmKFwidXBkYXRlXCIsIHRoaXMub25CYXNlVGV4dHVyZVVwZGF0ZWQsIHRoaXMpO1xuICAgICAgdGhpcy5iYXNlVGV4dHVyZSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX2ZyYW1lID0gbnVsbDtcbiAgICB0aGlzLl91dnMgPSBudWxsO1xuICAgIHRoaXMudHJpbSA9IG51bGw7XG4gICAgdGhpcy5vcmlnID0gbnVsbDtcbiAgICB0aGlzLnZhbGlkID0gZmFsc2U7XG4gICAgVGV4dHVyZS5yZW1vdmVGcm9tQ2FjaGUodGhpcyk7XG4gICAgdGhpcy50ZXh0dXJlQ2FjaGVJZHMgPSBudWxsO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lZEZyYW1lID0gdGhpcy5fZnJhbWUuY2xvbmUoKTtcbiAgICBjb25zdCBjbG9uZWRPcmlnID0gdGhpcy5fZnJhbWUgPT09IHRoaXMub3JpZyA/IGNsb25lZEZyYW1lIDogdGhpcy5vcmlnLmNsb25lKCk7XG4gICAgY29uc3QgY2xvbmVkVGV4dHVyZSA9IG5ldyBUZXh0dXJlKHRoaXMuYmFzZVRleHR1cmUsICF0aGlzLm5vRnJhbWUgJiYgY2xvbmVkRnJhbWUsIGNsb25lZE9yaWcsIHRoaXMudHJpbT8uY2xvbmUoKSwgdGhpcy5yb3RhdGUsIHRoaXMuZGVmYXVsdEFuY2hvciwgdGhpcy5kZWZhdWx0Qm9yZGVycyk7XG4gICAgaWYgKHRoaXMubm9GcmFtZSkge1xuICAgICAgY2xvbmVkVGV4dHVyZS5fZnJhbWUgPSBjbG9uZWRGcmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZFRleHR1cmU7XG4gIH1cbiAgdXBkYXRlVXZzKCkge1xuICAgIGlmICh0aGlzLl91dnMgPT09IERFRkFVTFRfVVZTKSB7XG4gICAgICB0aGlzLl91dnMgPSBuZXcgVGV4dHVyZVV2cygpO1xuICAgIH1cbiAgICB0aGlzLl91dnMuc2V0KHRoaXMuX2ZyYW1lLCB0aGlzLmJhc2VUZXh0dXJlLCB0aGlzLnJvdGF0ZSk7XG4gICAgdGhpcy5fdXBkYXRlSUQrKztcbiAgfVxuICBzdGF0aWMgZnJvbShzb3VyY2UsIG9wdGlvbnMgPSB7fSwgc3RyaWN0ID0gc2V0dGluZ3MuU1RSSUNUX1RFWFRVUkVfQ0FDSEUpIHtcbiAgICBjb25zdCBpc0ZyYW1lID0gdHlwZW9mIHNvdXJjZSA9PT0gXCJzdHJpbmdcIjtcbiAgICBsZXQgY2FjaGVJZCA9IG51bGw7XG4gICAgaWYgKGlzRnJhbWUpIHtcbiAgICAgIGNhY2hlSWQgPSBzb3VyY2U7XG4gICAgfSBlbHNlIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBCYXNlVGV4dHVyZSkge1xuICAgICAgaWYgKCFzb3VyY2UuY2FjaGVJZCkge1xuICAgICAgICBjb25zdCBwcmVmaXggPSBvcHRpb25zPy5waXhpSWRQcmVmaXggfHwgXCJwaXhpaWRcIjtcbiAgICAgICAgc291cmNlLmNhY2hlSWQgPSBgJHtwcmVmaXh9LSR7dWlkKCl9YDtcbiAgICAgICAgQmFzZVRleHR1cmUuYWRkVG9DYWNoZShzb3VyY2UsIHNvdXJjZS5jYWNoZUlkKTtcbiAgICAgIH1cbiAgICAgIGNhY2hlSWQgPSBzb3VyY2UuY2FjaGVJZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFzb3VyY2UuX3BpeGlJZCkge1xuICAgICAgICBjb25zdCBwcmVmaXggPSBvcHRpb25zPy5waXhpSWRQcmVmaXggfHwgXCJwaXhpaWRcIjtcbiAgICAgICAgc291cmNlLl9waXhpSWQgPSBgJHtwcmVmaXh9XyR7dWlkKCl9YDtcbiAgICAgIH1cbiAgICAgIGNhY2hlSWQgPSBzb3VyY2UuX3BpeGlJZDtcbiAgICB9XG4gICAgbGV0IHRleHR1cmUgPSBUZXh0dXJlQ2FjaGVbY2FjaGVJZF07XG4gICAgaWYgKGlzRnJhbWUgJiYgc3RyaWN0ICYmICF0ZXh0dXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBjYWNoZUlkIFwiJHtjYWNoZUlkfVwiIGRvZXMgbm90IGV4aXN0IGluIFRleHR1cmVDYWNoZS5gKTtcbiAgICB9XG4gICAgaWYgKCF0ZXh0dXJlICYmICEoc291cmNlIGluc3RhbmNlb2YgQmFzZVRleHR1cmUpKSB7XG4gICAgICBpZiAoIW9wdGlvbnMucmVzb2x1dGlvbikge1xuICAgICAgICBvcHRpb25zLnJlc29sdXRpb24gPSBnZXRSZXNvbHV0aW9uT2ZVcmwoc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHRleHR1cmUgPSBuZXcgVGV4dHVyZShuZXcgQmFzZVRleHR1cmUoc291cmNlLCBvcHRpb25zKSk7XG4gICAgICB0ZXh0dXJlLmJhc2VUZXh0dXJlLmNhY2hlSWQgPSBjYWNoZUlkO1xuICAgICAgQmFzZVRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLCBjYWNoZUlkKTtcbiAgICAgIFRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLCBjYWNoZUlkKTtcbiAgICB9IGVsc2UgaWYgKCF0ZXh0dXJlICYmIHNvdXJjZSBpbnN0YW5jZW9mIEJhc2VUZXh0dXJlKSB7XG4gICAgICB0ZXh0dXJlID0gbmV3IFRleHR1cmUoc291cmNlKTtcbiAgICAgIFRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLCBjYWNoZUlkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH1cbiAgc3RhdGljIGZyb21VUkwodXJsLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzb3VyY2VPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGF1dG9Mb2FkOiBmYWxzZSB9LCBvcHRpb25zPy5yZXNvdXJjZU9wdGlvbnMpO1xuICAgIGNvbnN0IHRleHR1cmUgPSBUZXh0dXJlLmZyb20odXJsLCBPYmplY3QuYXNzaWduKHsgcmVzb3VyY2VPcHRpb25zIH0sIG9wdGlvbnMpLCBmYWxzZSk7XG4gICAgY29uc3QgcmVzb3VyY2UgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlLnJlc291cmNlO1xuICAgIGlmICh0ZXh0dXJlLmJhc2VUZXh0dXJlLnZhbGlkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRleHR1cmUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb3VyY2UubG9hZCgpLnRoZW4oKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHRleHR1cmUpKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJ1ZmZlcihidWZmZXIsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRleHR1cmUoQmFzZVRleHR1cmUuZnJvbUJ1ZmZlcihidWZmZXIsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpKTtcbiAgfVxuICBzdGF0aWMgZnJvbUxvYWRlcihzb3VyY2UsIGltYWdlVXJsLCBuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYmFzZVRleHR1cmUgPSBuZXcgQmFzZVRleHR1cmUoc291cmNlLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIHNjYWxlTW9kZTogQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMuc2NhbGVNb2RlLFxuICAgICAgcmVzb2x1dGlvbjogZ2V0UmVzb2x1dGlvbk9mVXJsKGltYWdlVXJsKVxuICAgIH0sIG9wdGlvbnMpKTtcbiAgICBjb25zdCB7IHJlc291cmNlIH0gPSBiYXNlVGV4dHVyZTtcbiAgICBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBJbWFnZVJlc291cmNlKSB7XG4gICAgICByZXNvdXJjZS51cmwgPSBpbWFnZVVybDtcbiAgICB9XG4gICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGJhc2VUZXh0dXJlKTtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIG5hbWUgPSBpbWFnZVVybDtcbiAgICB9XG4gICAgQmFzZVRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLCBuYW1lKTtcbiAgICBUZXh0dXJlLmFkZFRvQ2FjaGUodGV4dHVyZSwgbmFtZSk7XG4gICAgaWYgKG5hbWUgIT09IGltYWdlVXJsKSB7XG4gICAgICBCYXNlVGV4dHVyZS5hZGRUb0NhY2hlKHRleHR1cmUuYmFzZVRleHR1cmUsIGltYWdlVXJsKTtcbiAgICAgIFRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLCBpbWFnZVVybCk7XG4gICAgfVxuICAgIGlmICh0ZXh0dXJlLmJhc2VUZXh0dXJlLnZhbGlkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRleHR1cmUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRleHR1cmUuYmFzZVRleHR1cmUub25jZShcImxvYWRlZFwiLCAoKSA9PiByZXNvbHZlKHRleHR1cmUpKTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgYWRkVG9DYWNoZSh0ZXh0dXJlLCBpZCkge1xuICAgIGlmIChpZCkge1xuICAgICAgaWYgKCF0ZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5pbmNsdWRlcyhpZCkpIHtcbiAgICAgICAgdGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHMucHVzaChpZCk7XG4gICAgICB9XG4gICAgICBpZiAoVGV4dHVyZUNhY2hlW2lkXSAmJiBUZXh0dXJlQ2FjaGVbaWRdICE9PSB0ZXh0dXJlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgVGV4dHVyZSBhZGRlZCB0byB0aGUgY2FjaGUgd2l0aCBhbiBpZCBbJHtpZH1dIHRoYXQgYWxyZWFkeSBoYWQgYW4gZW50cnlgKTtcbiAgICAgIH1cbiAgICAgIFRleHR1cmVDYWNoZVtpZF0gPSB0ZXh0dXJlO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgcmVtb3ZlRnJvbUNhY2hlKHRleHR1cmUpIHtcbiAgICBpZiAodHlwZW9mIHRleHR1cmUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IHRleHR1cmVGcm9tQ2FjaGUgPSBUZXh0dXJlQ2FjaGVbdGV4dHVyZV07XG4gICAgICBpZiAodGV4dHVyZUZyb21DYWNoZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRleHR1cmVGcm9tQ2FjaGUudGV4dHVyZUNhY2hlSWRzLmluZGV4T2YodGV4dHVyZSk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgdGV4dHVyZUZyb21DYWNoZS50ZXh0dXJlQ2FjaGVJZHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgVGV4dHVyZUNhY2hlW3RleHR1cmVdO1xuICAgICAgICByZXR1cm4gdGV4dHVyZUZyb21DYWNoZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRleHR1cmU/LnRleHR1cmVDYWNoZUlkcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoVGV4dHVyZUNhY2hlW3RleHR1cmUudGV4dHVyZUNhY2hlSWRzW2ldXSA9PT0gdGV4dHVyZSkge1xuICAgICAgICAgIGRlbGV0ZSBUZXh0dXJlQ2FjaGVbdGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHNbaV1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5sZW5ndGggPSAwO1xuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmJhc2VUZXh0dXJlLnJlc29sdXRpb247XG4gIH1cbiAgZ2V0IGZyYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9mcmFtZTtcbiAgfVxuICBzZXQgZnJhbWUoZnJhbWUpIHtcbiAgICB0aGlzLl9mcmFtZSA9IGZyYW1lO1xuICAgIHRoaXMubm9GcmFtZSA9IGZhbHNlO1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gZnJhbWU7XG4gICAgY29uc3QgeE5vdEZpdCA9IHggKyB3aWR0aCA+IHRoaXMuYmFzZVRleHR1cmUud2lkdGg7XG4gICAgY29uc3QgeU5vdEZpdCA9IHkgKyBoZWlnaHQgPiB0aGlzLmJhc2VUZXh0dXJlLmhlaWdodDtcbiAgICBpZiAoeE5vdEZpdCB8fCB5Tm90Rml0KSB7XG4gICAgICBjb25zdCByZWxhdGlvbnNoaXAgPSB4Tm90Rml0ICYmIHlOb3RGaXQgPyBcImFuZFwiIDogXCJvclwiO1xuICAgICAgY29uc3QgZXJyb3JYID0gYFg6ICR7eH0gKyAke3dpZHRofSA9ICR7eCArIHdpZHRofSA+ICR7dGhpcy5iYXNlVGV4dHVyZS53aWR0aH1gO1xuICAgICAgY29uc3QgZXJyb3JZID0gYFk6ICR7eX0gKyAke2hlaWdodH0gPSAke3kgKyBoZWlnaHR9ID4gJHt0aGlzLmJhc2VUZXh0dXJlLmhlaWdodH1gO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZXh0dXJlIEVycm9yOiBmcmFtZSBkb2VzIG5vdCBmaXQgaW5zaWRlIHRoZSBiYXNlIFRleHR1cmUgZGltZW5zaW9uczogJHtlcnJvclh9ICR7cmVsYXRpb25zaGlwfSAke2Vycm9yWX1gKTtcbiAgICB9XG4gICAgdGhpcy52YWxpZCA9IHdpZHRoICYmIGhlaWdodCAmJiB0aGlzLmJhc2VUZXh0dXJlLnZhbGlkO1xuICAgIGlmICghdGhpcy50cmltICYmICF0aGlzLnJvdGF0ZSkge1xuICAgICAgdGhpcy5vcmlnID0gZnJhbWU7XG4gICAgfVxuICAgIGlmICh0aGlzLnZhbGlkKSB7XG4gICAgICB0aGlzLnVwZGF0ZVV2cygpO1xuICAgIH1cbiAgfVxuICBnZXQgcm90YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9yb3RhdGU7XG4gIH1cbiAgc2V0IHJvdGF0ZShyb3RhdGUpIHtcbiAgICB0aGlzLl9yb3RhdGUgPSByb3RhdGU7XG4gICAgaWYgKHRoaXMudmFsaWQpIHtcbiAgICAgIHRoaXMudXBkYXRlVXZzKCk7XG4gICAgfVxuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcmlnLndpZHRoO1xuICB9XG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3JpZy5oZWlnaHQ7XG4gIH1cbiAgY2FzdFRvQmFzZVRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZVRleHR1cmU7XG4gIH1cbiAgc3RhdGljIGdldCBFTVBUWSgpIHtcbiAgICBpZiAoIVRleHR1cmUuX0VNUFRZKSB7XG4gICAgICBUZXh0dXJlLl9FTVBUWSA9IG5ldyBUZXh0dXJlKG5ldyBCYXNlVGV4dHVyZSgpKTtcbiAgICAgIHJlbW92ZUFsbEhhbmRsZXJzKFRleHR1cmUuX0VNUFRZKTtcbiAgICAgIHJlbW92ZUFsbEhhbmRsZXJzKFRleHR1cmUuX0VNUFRZLmJhc2VUZXh0dXJlKTtcbiAgICB9XG4gICAgcmV0dXJuIFRleHR1cmUuX0VNUFRZO1xuICB9XG4gIHN0YXRpYyBnZXQgV0hJVEUoKSB7XG4gICAgaWYgKCFUZXh0dXJlLl9XSElURSkge1xuICAgICAgY29uc3QgY2FudmFzID0gc2V0dGluZ3MuQURBUFRFUi5jcmVhdGVDYW52YXMoMTYsIDE2KTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY2FudmFzLndpZHRoID0gMTY7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gMTY7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcbiAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgMTYsIDE2KTtcbiAgICAgIFRleHR1cmUuX1dISVRFID0gbmV3IFRleHR1cmUoQmFzZVRleHR1cmUuZnJvbShjYW52YXMpKTtcbiAgICAgIHJlbW92ZUFsbEhhbmRsZXJzKFRleHR1cmUuX1dISVRFKTtcbiAgICAgIHJlbW92ZUFsbEhhbmRsZXJzKFRleHR1cmUuX1dISVRFLmJhc2VUZXh0dXJlKTtcbiAgICB9XG4gICAgcmV0dXJuIFRleHR1cmUuX1dISVRFO1xuICB9XG59XG5cbmV4cG9ydCB7IFRleHR1cmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHR1cmUubWpzLm1hcFxuIiwiaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uL3RleHR1cmVzL1RleHR1cmUubWpzJztcbmltcG9ydCB7IEJhc2VSZW5kZXJUZXh0dXJlIH0gZnJvbSAnLi9CYXNlUmVuZGVyVGV4dHVyZS5tanMnO1xuXG5jbGFzcyBSZW5kZXJUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG4gIGNvbnN0cnVjdG9yKGJhc2VSZW5kZXJUZXh0dXJlLCBmcmFtZSkge1xuICAgIHN1cGVyKGJhc2VSZW5kZXJUZXh0dXJlLCBmcmFtZSk7XG4gICAgdGhpcy52YWxpZCA9IHRydWU7XG4gICAgdGhpcy5maWx0ZXJGcmFtZSA9IG51bGw7XG4gICAgdGhpcy5maWx0ZXJQb29sS2V5ID0gbnVsbDtcbiAgICB0aGlzLnVwZGF0ZVV2cygpO1xuICB9XG4gIGdldCBmcmFtZWJ1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlVGV4dHVyZS5mcmFtZWJ1ZmZlcjtcbiAgfVxuICBnZXQgbXVsdGlzYW1wbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJhbWVidWZmZXIubXVsdGlzYW1wbGU7XG4gIH1cbiAgc2V0IG11bHRpc2FtcGxlKHZhbHVlKSB7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlci5tdWx0aXNhbXBsZSA9IHZhbHVlO1xuICB9XG4gIHJlc2l6ZShkZXNpcmVkV2lkdGgsIGRlc2lyZWRIZWlnaHQsIHJlc2l6ZUJhc2VUZXh0dXJlID0gdHJ1ZSkge1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmJhc2VUZXh0dXJlLnJlc29sdXRpb247XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLnJvdW5kKGRlc2lyZWRXaWR0aCAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLnJvdW5kKGRlc2lyZWRIZWlnaHQgKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb247XG4gICAgdGhpcy52YWxpZCA9IHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwO1xuICAgIHRoaXMuX2ZyYW1lLndpZHRoID0gdGhpcy5vcmlnLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5fZnJhbWUuaGVpZ2h0ID0gdGhpcy5vcmlnLmhlaWdodCA9IGhlaWdodDtcbiAgICBpZiAocmVzaXplQmFzZVRleHR1cmUpIHtcbiAgICAgIHRoaXMuYmFzZVRleHR1cmUucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVV2cygpO1xuICB9XG4gIHNldFJlc29sdXRpb24ocmVzb2x1dGlvbikge1xuICAgIGNvbnN0IHsgYmFzZVRleHR1cmUgfSA9IHRoaXM7XG4gICAgaWYgKGJhc2VUZXh0dXJlLnJlc29sdXRpb24gPT09IHJlc29sdXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYmFzZVRleHR1cmUuc2V0UmVzb2x1dGlvbihyZXNvbHV0aW9uKTtcbiAgICB0aGlzLnJlc2l6ZShiYXNlVGV4dHVyZS53aWR0aCwgYmFzZVRleHR1cmUuaGVpZ2h0LCBmYWxzZSk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSZW5kZXJUZXh0dXJlKG5ldyBCYXNlUmVuZGVyVGV4dHVyZShvcHRpb25zKSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgUmVuZGVyVGV4dHVyZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVuZGVyVGV4dHVyZS5tanMubWFwXG4iLCJpbXBvcnQgeyBNU0FBX1FVQUxJVFkgfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuaW1wb3J0IHsgbmV4dFBvdzIgfSBmcm9tICdAcGl4aS91dGlscyc7XG5pbXBvcnQgeyBCYXNlUmVuZGVyVGV4dHVyZSB9IGZyb20gJy4vQmFzZVJlbmRlclRleHR1cmUubWpzJztcbmltcG9ydCB7IFJlbmRlclRleHR1cmUgfSBmcm9tICcuL1JlbmRlclRleHR1cmUubWpzJztcblxuY2xhc3MgUmVuZGVyVGV4dHVyZVBvb2wge1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlT3B0aW9ucykge1xuICAgIHRoaXMudGV4dHVyZVBvb2wgPSB7fTtcbiAgICB0aGlzLnRleHR1cmVPcHRpb25zID0gdGV4dHVyZU9wdGlvbnMgfHwge307XG4gICAgdGhpcy5lbmFibGVGdWxsU2NyZWVuID0gZmFsc2U7XG4gICAgdGhpcy5fcGl4ZWxzV2lkdGggPSAwO1xuICAgIHRoaXMuX3BpeGVsc0hlaWdodCA9IDA7XG4gIH1cbiAgY3JlYXRlVGV4dHVyZShyZWFsV2lkdGgsIHJlYWxIZWlnaHQsIG11bHRpc2FtcGxlID0gTVNBQV9RVUFMSVRZLk5PTkUpIHtcbiAgICBjb25zdCBiYXNlUmVuZGVyVGV4dHVyZSA9IG5ldyBCYXNlUmVuZGVyVGV4dHVyZShPYmplY3QuYXNzaWduKHtcbiAgICAgIHdpZHRoOiByZWFsV2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlYWxIZWlnaHQsXG4gICAgICByZXNvbHV0aW9uOiAxLFxuICAgICAgbXVsdGlzYW1wbGVcbiAgICB9LCB0aGlzLnRleHR1cmVPcHRpb25zKSk7XG4gICAgcmV0dXJuIG5ldyBSZW5kZXJUZXh0dXJlKGJhc2VSZW5kZXJUZXh0dXJlKTtcbiAgfVxuICBnZXRPcHRpbWFsVGV4dHVyZShtaW5XaWR0aCwgbWluSGVpZ2h0LCByZXNvbHV0aW9uID0gMSwgbXVsdGlzYW1wbGUgPSBNU0FBX1FVQUxJVFkuTk9ORSkge1xuICAgIGxldCBrZXk7XG4gICAgbWluV2lkdGggPSBNYXRoLmNlaWwobWluV2lkdGggKiByZXNvbHV0aW9uIC0gMWUtNik7XG4gICAgbWluSGVpZ2h0ID0gTWF0aC5jZWlsKG1pbkhlaWdodCAqIHJlc29sdXRpb24gLSAxZS02KTtcbiAgICBpZiAoIXRoaXMuZW5hYmxlRnVsbFNjcmVlbiB8fCBtaW5XaWR0aCAhPT0gdGhpcy5fcGl4ZWxzV2lkdGggfHwgbWluSGVpZ2h0ICE9PSB0aGlzLl9waXhlbHNIZWlnaHQpIHtcbiAgICAgIG1pbldpZHRoID0gbmV4dFBvdzIobWluV2lkdGgpO1xuICAgICAgbWluSGVpZ2h0ID0gbmV4dFBvdzIobWluSGVpZ2h0KTtcbiAgICAgIGtleSA9ICgobWluV2lkdGggJiA2NTUzNSkgPDwgMTYgfCBtaW5IZWlnaHQgJiA2NTUzNSkgPj4+IDA7XG4gICAgICBpZiAobXVsdGlzYW1wbGUgPiAxKSB7XG4gICAgICAgIGtleSArPSBtdWx0aXNhbXBsZSAqIDQyOTQ5NjcyOTY7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IG11bHRpc2FtcGxlID4gMSA/IC1tdWx0aXNhbXBsZSA6IC0xO1xuICAgIH1cbiAgICBpZiAoIXRoaXMudGV4dHVyZVBvb2xba2V5XSkge1xuICAgICAgdGhpcy50ZXh0dXJlUG9vbFtrZXldID0gW107XG4gICAgfVxuICAgIGxldCByZW5kZXJUZXh0dXJlID0gdGhpcy50ZXh0dXJlUG9vbFtrZXldLnBvcCgpO1xuICAgIGlmICghcmVuZGVyVGV4dHVyZSkge1xuICAgICAgcmVuZGVyVGV4dHVyZSA9IHRoaXMuY3JlYXRlVGV4dHVyZShtaW5XaWR0aCwgbWluSGVpZ2h0LCBtdWx0aXNhbXBsZSk7XG4gICAgfVxuICAgIHJlbmRlclRleHR1cmUuZmlsdGVyUG9vbEtleSA9IGtleTtcbiAgICByZW5kZXJUZXh0dXJlLnNldFJlc29sdXRpb24ocmVzb2x1dGlvbik7XG4gICAgcmV0dXJuIHJlbmRlclRleHR1cmU7XG4gIH1cbiAgZ2V0RmlsdGVyVGV4dHVyZShpbnB1dCwgcmVzb2x1dGlvbiwgbXVsdGlzYW1wbGUpIHtcbiAgICBjb25zdCBmaWx0ZXJUZXh0dXJlID0gdGhpcy5nZXRPcHRpbWFsVGV4dHVyZShpbnB1dC53aWR0aCwgaW5wdXQuaGVpZ2h0LCByZXNvbHV0aW9uIHx8IGlucHV0LnJlc29sdXRpb24sIG11bHRpc2FtcGxlIHx8IE1TQUFfUVVBTElUWS5OT05FKTtcbiAgICBmaWx0ZXJUZXh0dXJlLmZpbHRlckZyYW1lID0gaW5wdXQuZmlsdGVyRnJhbWU7XG4gICAgcmV0dXJuIGZpbHRlclRleHR1cmU7XG4gIH1cbiAgcmV0dXJuVGV4dHVyZShyZW5kZXJUZXh0dXJlKSB7XG4gICAgY29uc3Qga2V5ID0gcmVuZGVyVGV4dHVyZS5maWx0ZXJQb29sS2V5O1xuICAgIHJlbmRlclRleHR1cmUuZmlsdGVyRnJhbWUgPSBudWxsO1xuICAgIHRoaXMudGV4dHVyZVBvb2xba2V5XS5wdXNoKHJlbmRlclRleHR1cmUpO1xuICB9XG4gIHJldHVybkZpbHRlclRleHR1cmUocmVuZGVyVGV4dHVyZSkge1xuICAgIHRoaXMucmV0dXJuVGV4dHVyZShyZW5kZXJUZXh0dXJlKTtcbiAgfVxuICBjbGVhcihkZXN0cm95VGV4dHVyZXMpIHtcbiAgICBkZXN0cm95VGV4dHVyZXMgPSBkZXN0cm95VGV4dHVyZXMgIT09IGZhbHNlO1xuICAgIGlmIChkZXN0cm95VGV4dHVyZXMpIHtcbiAgICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLnRleHR1cmVQb29sKSB7XG4gICAgICAgIGNvbnN0IHRleHR1cmVzID0gdGhpcy50ZXh0dXJlUG9vbFtpXTtcbiAgICAgICAgaWYgKHRleHR1cmVzKSB7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0ZXh0dXJlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdGV4dHVyZXNbal0uZGVzdHJveSh0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50ZXh0dXJlUG9vbCA9IHt9O1xuICB9XG4gIHNldFNjcmVlblNpemUoc2l6ZSkge1xuICAgIGlmIChzaXplLndpZHRoID09PSB0aGlzLl9waXhlbHNXaWR0aCAmJiBzaXplLmhlaWdodCA9PT0gdGhpcy5fcGl4ZWxzSGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW5hYmxlRnVsbFNjcmVlbiA9IHNpemUud2lkdGggPiAwICYmIHNpemUuaGVpZ2h0ID4gMDtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy50ZXh0dXJlUG9vbCkge1xuICAgICAgaWYgKCEoTnVtYmVyKGkpIDwgMCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0ZXh0dXJlcyA9IHRoaXMudGV4dHVyZVBvb2xbaV07XG4gICAgICBpZiAodGV4dHVyZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0ZXh0dXJlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHRleHR1cmVzW2pdLmRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudGV4dHVyZVBvb2xbaV0gPSBbXTtcbiAgICB9XG4gICAgdGhpcy5fcGl4ZWxzV2lkdGggPSBzaXplLndpZHRoO1xuICAgIHRoaXMuX3BpeGVsc0hlaWdodCA9IHNpemUuaGVpZ2h0O1xuICB9XG59XG5SZW5kZXJUZXh0dXJlUG9vbC5TQ1JFRU5fS0VZID0gLTE7XG5cbmV4cG9ydCB7IFJlbmRlclRleHR1cmVQb29sIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZW5kZXJUZXh0dXJlUG9vbC5tanMubWFwXG4iLCJpbXBvcnQgeyBHZW9tZXRyeSB9IGZyb20gJy4uL2dlb21ldHJ5L0dlb21ldHJ5Lm1qcyc7XG5cbmNsYXNzIFF1YWQgZXh0ZW5kcyBHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5hZGRBdHRyaWJ1dGUoXCJhVmVydGV4UG9zaXRpb25cIiwgbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMVxuICAgIF0pKS5hZGRJbmRleChbMCwgMSwgMywgMl0pO1xuICB9XG59XG5cbmV4cG9ydCB7IFF1YWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVF1YWQubWpzLm1hcFxuIiwiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnLi4vZ2VvbWV0cnkvQnVmZmVyLm1qcyc7XG5pbXBvcnQgeyBHZW9tZXRyeSB9IGZyb20gJy4uL2dlb21ldHJ5L0dlb21ldHJ5Lm1qcyc7XG5cbmNsYXNzIFF1YWRVdiBleHRlbmRzIEdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAtMSxcbiAgICAgIC0xLFxuICAgICAgMSxcbiAgICAgIC0xLFxuICAgICAgMSxcbiAgICAgIDEsXG4gICAgICAtMSxcbiAgICAgIDFcbiAgICBdKTtcbiAgICB0aGlzLnV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDFcbiAgICBdKTtcbiAgICB0aGlzLnZlcnRleEJ1ZmZlciA9IG5ldyBCdWZmZXIodGhpcy52ZXJ0aWNlcyk7XG4gICAgdGhpcy51dkJ1ZmZlciA9IG5ldyBCdWZmZXIodGhpcy51dnMpO1xuICAgIHRoaXMuYWRkQXR0cmlidXRlKFwiYVZlcnRleFBvc2l0aW9uXCIsIHRoaXMudmVydGV4QnVmZmVyKS5hZGRBdHRyaWJ1dGUoXCJhVGV4dHVyZUNvb3JkXCIsIHRoaXMudXZCdWZmZXIpLmFkZEluZGV4KFswLCAxLCAyLCAwLCAyLCAzXSk7XG4gIH1cbiAgbWFwKHRhcmdldFRleHR1cmVGcmFtZSwgZGVzdGluYXRpb25GcmFtZSkge1xuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgeSA9IDA7XG4gICAgdGhpcy51dnNbMF0gPSB4O1xuICAgIHRoaXMudXZzWzFdID0geTtcbiAgICB0aGlzLnV2c1syXSA9IHggKyBkZXN0aW5hdGlvbkZyYW1lLndpZHRoIC8gdGFyZ2V0VGV4dHVyZUZyYW1lLndpZHRoO1xuICAgIHRoaXMudXZzWzNdID0geTtcbiAgICB0aGlzLnV2c1s0XSA9IHggKyBkZXN0aW5hdGlvbkZyYW1lLndpZHRoIC8gdGFyZ2V0VGV4dHVyZUZyYW1lLndpZHRoO1xuICAgIHRoaXMudXZzWzVdID0geSArIGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0IC8gdGFyZ2V0VGV4dHVyZUZyYW1lLmhlaWdodDtcbiAgICB0aGlzLnV2c1s2XSA9IHg7XG4gICAgdGhpcy51dnNbN10gPSB5ICsgZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgLyB0YXJnZXRUZXh0dXJlRnJhbWUuaGVpZ2h0O1xuICAgIHggPSBkZXN0aW5hdGlvbkZyYW1lLng7XG4gICAgeSA9IGRlc3RpbmF0aW9uRnJhbWUueTtcbiAgICB0aGlzLnZlcnRpY2VzWzBdID0geDtcbiAgICB0aGlzLnZlcnRpY2VzWzFdID0geTtcbiAgICB0aGlzLnZlcnRpY2VzWzJdID0geCArIGRlc3RpbmF0aW9uRnJhbWUud2lkdGg7XG4gICAgdGhpcy52ZXJ0aWNlc1szXSA9IHk7XG4gICAgdGhpcy52ZXJ0aWNlc1s0XSA9IHggKyBkZXN0aW5hdGlvbkZyYW1lLndpZHRoO1xuICAgIHRoaXMudmVydGljZXNbNV0gPSB5ICsgZGVzdGluYXRpb25GcmFtZS5oZWlnaHQ7XG4gICAgdGhpcy52ZXJ0aWNlc1s2XSA9IHg7XG4gICAgdGhpcy52ZXJ0aWNlc1s3XSA9IHkgKyBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodDtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpbnZhbGlkYXRlKCkge1xuICAgIHRoaXMudmVydGV4QnVmZmVyLl91cGRhdGVJRCsrO1xuICAgIHRoaXMudXZCdWZmZXIuX3VwZGF0ZUlEKys7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZXhwb3J0IHsgUXVhZFV2IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1RdWFkVXYubWpzLm1hcFxuIiwiaW1wb3J0IHsgTVNBQV9RVUFMSVRZIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcbmltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gJ0BwaXhpL21hdGgnO1xuXG5jbGFzcyBGaWx0ZXJTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucmVuZGVyVGV4dHVyZSA9IG51bGw7XG4gICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgIHRoaXMubGVnYWN5ID0gZmFsc2U7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gMTtcbiAgICB0aGlzLm11bHRpc2FtcGxlID0gTVNBQV9RVUFMSVRZLk5PTkU7XG4gICAgdGhpcy5zb3VyY2VGcmFtZSA9IG5ldyBSZWN0YW5nbGUoKTtcbiAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUgPSBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgdGhpcy5iaW5kaW5nU291cmNlRnJhbWUgPSBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgdGhpcy5iaW5kaW5nRGVzdGluYXRpb25GcmFtZSA9IG5ldyBSZWN0YW5nbGUoKTtcbiAgICB0aGlzLmZpbHRlcnMgPSBbXTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG51bGw7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgIHRoaXMuZmlsdGVycyA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJUZXh0dXJlID0gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgeyBGaWx0ZXJTdGF0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmlsdGVyU3RhdGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ0xFQVJfTU9ERVMsIERSQVdfTU9ERVMsIE1TQUFfUVVBTElUWSB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvZXh0ZW5zaW9ucyc7XG5pbXBvcnQgeyBQb2ludCwgTWF0cml4LCBSZWN0YW5nbGUgfSBmcm9tICdAcGl4aS9tYXRoJztcbmltcG9ydCB7IFJlbmRlclRleHR1cmVQb29sIH0gZnJvbSAnLi4vcmVuZGVyVGV4dHVyZS9SZW5kZXJUZXh0dXJlUG9vbC5tanMnO1xuaW1wb3J0IHsgVW5pZm9ybUdyb3VwIH0gZnJvbSAnLi4vc2hhZGVyL1VuaWZvcm1Hcm91cC5tanMnO1xuaW1wb3J0IHsgUXVhZCB9IGZyb20gJy4uL3V0aWxzL1F1YWQubWpzJztcbmltcG9ydCB7IFF1YWRVdiB9IGZyb20gJy4uL3V0aWxzL1F1YWRVdi5tanMnO1xuaW1wb3J0IHsgRmlsdGVyU3RhdGUgfSBmcm9tICcuL0ZpbHRlclN0YXRlLm1qcyc7XG5cbmNvbnN0IHRlbXBQb2ludHMgPSBbbmV3IFBvaW50KCksIG5ldyBQb2ludCgpLCBuZXcgUG9pbnQoKSwgbmV3IFBvaW50KCldO1xuY29uc3QgdGVtcE1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbmNsYXNzIEZpbHRlclN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMuZGVmYXVsdEZpbHRlclN0YWNrID0gW3t9XTtcbiAgICB0aGlzLnRleHR1cmVQb29sID0gbmV3IFJlbmRlclRleHR1cmVQb29sKCk7XG4gICAgdGhpcy5zdGF0ZVBvb2wgPSBbXTtcbiAgICB0aGlzLnF1YWQgPSBuZXcgUXVhZCgpO1xuICAgIHRoaXMucXVhZFV2ID0gbmV3IFF1YWRVdigpO1xuICAgIHRoaXMudGVtcFJlY3QgPSBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgdGhpcy5hY3RpdmVTdGF0ZSA9IHt9O1xuICAgIHRoaXMuZ2xvYmFsVW5pZm9ybXMgPSBuZXcgVW5pZm9ybUdyb3VwKHtcbiAgICAgIG91dHB1dEZyYW1lOiBuZXcgUmVjdGFuZ2xlKCksXG4gICAgICBpbnB1dFNpemU6IG5ldyBGbG9hdDMyQXJyYXkoNCksXG4gICAgICBpbnB1dFBpeGVsOiBuZXcgRmxvYXQzMkFycmF5KDQpLFxuICAgICAgaW5wdXRDbGFtcDogbmV3IEZsb2F0MzJBcnJheSg0KSxcbiAgICAgIHJlc29sdXRpb246IDEsXG4gICAgICBmaWx0ZXJBcmVhOiBuZXcgRmxvYXQzMkFycmF5KDQpLFxuICAgICAgZmlsdGVyQ2xhbXA6IG5ldyBGbG9hdDMyQXJyYXkoNClcbiAgICB9LCB0cnVlKTtcbiAgICB0aGlzLmZvcmNlQ2xlYXIgPSBmYWxzZTtcbiAgICB0aGlzLnVzZU1heFBhZGRpbmcgPSBmYWxzZTtcbiAgfVxuICBpbml0KCkge1xuICAgIHRoaXMudGV4dHVyZVBvb2wuc2V0U2NyZWVuU2l6ZSh0aGlzLnJlbmRlcmVyLnZpZXcpO1xuICB9XG4gIHB1c2godGFyZ2V0LCBmaWx0ZXJzKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIGNvbnN0IGZpbHRlclN0YWNrID0gdGhpcy5kZWZhdWx0RmlsdGVyU3RhY2s7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlUG9vbC5wb3AoKSB8fCBuZXcgRmlsdGVyU3RhdGUoKTtcbiAgICBjb25zdCByZW5kZXJUZXh0dXJlU3lzdGVtID0gdGhpcy5yZW5kZXJlci5yZW5kZXJUZXh0dXJlO1xuICAgIGxldCByZXNvbHV0aW9uID0gZmlsdGVyc1swXS5yZXNvbHV0aW9uO1xuICAgIGxldCBtdWx0aXNhbXBsZSA9IGZpbHRlcnNbMF0ubXVsdGlzYW1wbGU7XG4gICAgbGV0IHBhZGRpbmcgPSBmaWx0ZXJzWzBdLnBhZGRpbmc7XG4gICAgbGV0IGF1dG9GaXQgPSBmaWx0ZXJzWzBdLmF1dG9GaXQ7XG4gICAgbGV0IGxlZ2FjeSA9IGZpbHRlcnNbMF0ubGVnYWN5ID8/IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBmaWx0ZXIgPSBmaWx0ZXJzW2ldO1xuICAgICAgcmVzb2x1dGlvbiA9IE1hdGgubWluKHJlc29sdXRpb24sIGZpbHRlci5yZXNvbHV0aW9uKTtcbiAgICAgIG11bHRpc2FtcGxlID0gTWF0aC5taW4obXVsdGlzYW1wbGUsIGZpbHRlci5tdWx0aXNhbXBsZSk7XG4gICAgICBwYWRkaW5nID0gdGhpcy51c2VNYXhQYWRkaW5nID8gTWF0aC5tYXgocGFkZGluZywgZmlsdGVyLnBhZGRpbmcpIDogcGFkZGluZyArIGZpbHRlci5wYWRkaW5nO1xuICAgICAgYXV0b0ZpdCA9IGF1dG9GaXQgJiYgZmlsdGVyLmF1dG9GaXQ7XG4gICAgICBsZWdhY3kgPSBsZWdhY3kgfHwgKGZpbHRlci5sZWdhY3kgPz8gdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChmaWx0ZXJTdGFjay5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuZGVmYXVsdEZpbHRlclN0YWNrWzBdLnJlbmRlclRleHR1cmUgPSByZW5kZXJUZXh0dXJlU3lzdGVtLmN1cnJlbnQ7XG4gICAgfVxuICAgIGZpbHRlclN0YWNrLnB1c2goc3RhdGUpO1xuICAgIHN0YXRlLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgIHN0YXRlLm11bHRpc2FtcGxlID0gbXVsdGlzYW1wbGU7XG4gICAgc3RhdGUubGVnYWN5ID0gbGVnYWN5O1xuICAgIHN0YXRlLnRhcmdldCA9IHRhcmdldDtcbiAgICBzdGF0ZS5zb3VyY2VGcmFtZS5jb3B5RnJvbSh0YXJnZXQuZmlsdGVyQXJlYSB8fCB0YXJnZXQuZ2V0Qm91bmRzKHRydWUpKTtcbiAgICBzdGF0ZS5zb3VyY2VGcmFtZS5wYWQocGFkZGluZyk7XG4gICAgY29uc3Qgc291cmNlRnJhbWVQcm9qZWN0ZWQgPSB0aGlzLnRlbXBSZWN0LmNvcHlGcm9tKHJlbmRlclRleHR1cmVTeXN0ZW0uc291cmNlRnJhbWUpO1xuICAgIGlmIChyZW5kZXJlci5wcm9qZWN0aW9uLnRyYW5zZm9ybSkge1xuICAgICAgdGhpcy50cmFuc2Zvcm1BQUJCKHRlbXBNYXRyaXguY29weUZyb20ocmVuZGVyZXIucHJvamVjdGlvbi50cmFuc2Zvcm0pLmludmVydCgpLCBzb3VyY2VGcmFtZVByb2plY3RlZCk7XG4gICAgfVxuICAgIGlmIChhdXRvRml0KSB7XG4gICAgICBzdGF0ZS5zb3VyY2VGcmFtZS5maXQoc291cmNlRnJhbWVQcm9qZWN0ZWQpO1xuICAgICAgaWYgKHN0YXRlLnNvdXJjZUZyYW1lLndpZHRoIDw9IDAgfHwgc3RhdGUuc291cmNlRnJhbWUuaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgc3RhdGUuc291cmNlRnJhbWUud2lkdGggPSAwO1xuICAgICAgICBzdGF0ZS5zb3VyY2VGcmFtZS5oZWlnaHQgPSAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXN0YXRlLnNvdXJjZUZyYW1lLmludGVyc2VjdHMoc291cmNlRnJhbWVQcm9qZWN0ZWQpKSB7XG4gICAgICBzdGF0ZS5zb3VyY2VGcmFtZS53aWR0aCA9IDA7XG4gICAgICBzdGF0ZS5zb3VyY2VGcmFtZS5oZWlnaHQgPSAwO1xuICAgIH1cbiAgICB0aGlzLnJvdW5kRnJhbWUoc3RhdGUuc291cmNlRnJhbWUsIHJlbmRlclRleHR1cmVTeXN0ZW0uY3VycmVudCA/IHJlbmRlclRleHR1cmVTeXN0ZW0uY3VycmVudC5yZXNvbHV0aW9uIDogcmVuZGVyZXIucmVzb2x1dGlvbiwgcmVuZGVyVGV4dHVyZVN5c3RlbS5zb3VyY2VGcmFtZSwgcmVuZGVyVGV4dHVyZVN5c3RlbS5kZXN0aW5hdGlvbkZyYW1lLCByZW5kZXJlci5wcm9qZWN0aW9uLnRyYW5zZm9ybSk7XG4gICAgc3RhdGUucmVuZGVyVGV4dHVyZSA9IHRoaXMuZ2V0T3B0aW1hbEZpbHRlclRleHR1cmUoc3RhdGUuc291cmNlRnJhbWUud2lkdGgsIHN0YXRlLnNvdXJjZUZyYW1lLmhlaWdodCwgcmVzb2x1dGlvbiwgbXVsdGlzYW1wbGUpO1xuICAgIHN0YXRlLmZpbHRlcnMgPSBmaWx0ZXJzO1xuICAgIHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUud2lkdGggPSBzdGF0ZS5yZW5kZXJUZXh0dXJlLndpZHRoO1xuICAgIHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0ID0gc3RhdGUucmVuZGVyVGV4dHVyZS5oZWlnaHQ7XG4gICAgY29uc3QgZGVzdGluYXRpb25GcmFtZSA9IHRoaXMudGVtcFJlY3Q7XG4gICAgZGVzdGluYXRpb25GcmFtZS54ID0gMDtcbiAgICBkZXN0aW5hdGlvbkZyYW1lLnkgPSAwO1xuICAgIGRlc3RpbmF0aW9uRnJhbWUud2lkdGggPSBzdGF0ZS5zb3VyY2VGcmFtZS53aWR0aDtcbiAgICBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCA9IHN0YXRlLnNvdXJjZUZyYW1lLmhlaWdodDtcbiAgICBzdGF0ZS5yZW5kZXJUZXh0dXJlLmZpbHRlckZyYW1lID0gc3RhdGUuc291cmNlRnJhbWU7XG4gICAgc3RhdGUuYmluZGluZ1NvdXJjZUZyYW1lLmNvcHlGcm9tKHJlbmRlclRleHR1cmVTeXN0ZW0uc291cmNlRnJhbWUpO1xuICAgIHN0YXRlLmJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLmNvcHlGcm9tKHJlbmRlclRleHR1cmVTeXN0ZW0uZGVzdGluYXRpb25GcmFtZSk7XG4gICAgc3RhdGUudHJhbnNmb3JtID0gcmVuZGVyZXIucHJvamVjdGlvbi50cmFuc2Zvcm07XG4gICAgcmVuZGVyZXIucHJvamVjdGlvbi50cmFuc2Zvcm0gPSBudWxsO1xuICAgIHJlbmRlclRleHR1cmVTeXN0ZW0uYmluZChzdGF0ZS5yZW5kZXJUZXh0dXJlLCBzdGF0ZS5zb3VyY2VGcmFtZSwgZGVzdGluYXRpb25GcmFtZSk7XG4gICAgcmVuZGVyZXIuZnJhbWVidWZmZXIuY2xlYXIoMCwgMCwgMCwgMCk7XG4gIH1cbiAgcG9wKCkge1xuICAgIGNvbnN0IGZpbHRlclN0YWNrID0gdGhpcy5kZWZhdWx0RmlsdGVyU3RhY2s7XG4gICAgY29uc3Qgc3RhdGUgPSBmaWx0ZXJTdGFjay5wb3AoKTtcbiAgICBjb25zdCBmaWx0ZXJzID0gc3RhdGUuZmlsdGVycztcbiAgICB0aGlzLmFjdGl2ZVN0YXRlID0gc3RhdGU7XG4gICAgY29uc3QgZ2xvYmFsVW5pZm9ybXMgPSB0aGlzLmdsb2JhbFVuaWZvcm1zLnVuaWZvcm1zO1xuICAgIGdsb2JhbFVuaWZvcm1zLm91dHB1dEZyYW1lID0gc3RhdGUuc291cmNlRnJhbWU7XG4gICAgZ2xvYmFsVW5pZm9ybXMucmVzb2x1dGlvbiA9IHN0YXRlLnJlc29sdXRpb247XG4gICAgY29uc3QgaW5wdXRTaXplID0gZ2xvYmFsVW5pZm9ybXMuaW5wdXRTaXplO1xuICAgIGNvbnN0IGlucHV0UGl4ZWwgPSBnbG9iYWxVbmlmb3Jtcy5pbnB1dFBpeGVsO1xuICAgIGNvbnN0IGlucHV0Q2xhbXAgPSBnbG9iYWxVbmlmb3Jtcy5pbnB1dENsYW1wO1xuICAgIGlucHV0U2l6ZVswXSA9IHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUud2lkdGg7XG4gICAgaW5wdXRTaXplWzFdID0gc3RhdGUuZGVzdGluYXRpb25GcmFtZS5oZWlnaHQ7XG4gICAgaW5wdXRTaXplWzJdID0gMSAvIGlucHV0U2l6ZVswXTtcbiAgICBpbnB1dFNpemVbM10gPSAxIC8gaW5wdXRTaXplWzFdO1xuICAgIGlucHV0UGl4ZWxbMF0gPSBNYXRoLnJvdW5kKGlucHV0U2l6ZVswXSAqIHN0YXRlLnJlc29sdXRpb24pO1xuICAgIGlucHV0UGl4ZWxbMV0gPSBNYXRoLnJvdW5kKGlucHV0U2l6ZVsxXSAqIHN0YXRlLnJlc29sdXRpb24pO1xuICAgIGlucHV0UGl4ZWxbMl0gPSAxIC8gaW5wdXRQaXhlbFswXTtcbiAgICBpbnB1dFBpeGVsWzNdID0gMSAvIGlucHV0UGl4ZWxbMV07XG4gICAgaW5wdXRDbGFtcFswXSA9IDAuNSAqIGlucHV0UGl4ZWxbMl07XG4gICAgaW5wdXRDbGFtcFsxXSA9IDAuNSAqIGlucHV0UGl4ZWxbM107XG4gICAgaW5wdXRDbGFtcFsyXSA9IHN0YXRlLnNvdXJjZUZyYW1lLndpZHRoICogaW5wdXRTaXplWzJdIC0gMC41ICogaW5wdXRQaXhlbFsyXTtcbiAgICBpbnB1dENsYW1wWzNdID0gc3RhdGUuc291cmNlRnJhbWUuaGVpZ2h0ICogaW5wdXRTaXplWzNdIC0gMC41ICogaW5wdXRQaXhlbFszXTtcbiAgICBpZiAoc3RhdGUubGVnYWN5KSB7XG4gICAgICBjb25zdCBmaWx0ZXJBcmVhID0gZ2xvYmFsVW5pZm9ybXMuZmlsdGVyQXJlYTtcbiAgICAgIGZpbHRlckFyZWFbMF0gPSBzdGF0ZS5kZXN0aW5hdGlvbkZyYW1lLndpZHRoO1xuICAgICAgZmlsdGVyQXJlYVsxXSA9IHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0O1xuICAgICAgZmlsdGVyQXJlYVsyXSA9IHN0YXRlLnNvdXJjZUZyYW1lLng7XG4gICAgICBmaWx0ZXJBcmVhWzNdID0gc3RhdGUuc291cmNlRnJhbWUueTtcbiAgICAgIGdsb2JhbFVuaWZvcm1zLmZpbHRlckNsYW1wID0gZ2xvYmFsVW5pZm9ybXMuaW5wdXRDbGFtcDtcbiAgICB9XG4gICAgdGhpcy5nbG9iYWxVbmlmb3Jtcy51cGRhdGUoKTtcbiAgICBjb25zdCBsYXN0U3RhdGUgPSBmaWx0ZXJTdGFja1tmaWx0ZXJTdGFjay5sZW5ndGggLSAxXTtcbiAgICB0aGlzLnJlbmRlcmVyLmZyYW1lYnVmZmVyLmJsaXQoKTtcbiAgICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGZpbHRlcnNbMF0uYXBwbHkodGhpcywgc3RhdGUucmVuZGVyVGV4dHVyZSwgbGFzdFN0YXRlLnJlbmRlclRleHR1cmUsIENMRUFSX01PREVTLkJMRU5ELCBzdGF0ZSk7XG4gICAgICB0aGlzLnJldHVybkZpbHRlclRleHR1cmUoc3RhdGUucmVuZGVyVGV4dHVyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBmbGlwID0gc3RhdGUucmVuZGVyVGV4dHVyZTtcbiAgICAgIGxldCBmbG9wID0gdGhpcy5nZXRPcHRpbWFsRmlsdGVyVGV4dHVyZShmbGlwLndpZHRoLCBmbGlwLmhlaWdodCwgc3RhdGUucmVzb2x1dGlvbik7XG4gICAgICBmbG9wLmZpbHRlckZyYW1lID0gZmxpcC5maWx0ZXJGcmFtZTtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBpZiAoaSA9PT0gMSAmJiBzdGF0ZS5tdWx0aXNhbXBsZSA+IDEpIHtcbiAgICAgICAgICBmbG9wID0gdGhpcy5nZXRPcHRpbWFsRmlsdGVyVGV4dHVyZShmbGlwLndpZHRoLCBmbGlwLmhlaWdodCwgc3RhdGUucmVzb2x1dGlvbik7XG4gICAgICAgICAgZmxvcC5maWx0ZXJGcmFtZSA9IGZsaXAuZmlsdGVyRnJhbWU7XG4gICAgICAgIH1cbiAgICAgICAgZmlsdGVyc1tpXS5hcHBseSh0aGlzLCBmbGlwLCBmbG9wLCBDTEVBUl9NT0RFUy5DTEVBUiwgc3RhdGUpO1xuICAgICAgICBjb25zdCB0ID0gZmxpcDtcbiAgICAgICAgZmxpcCA9IGZsb3A7XG4gICAgICAgIGZsb3AgPSB0O1xuICAgICAgfVxuICAgICAgZmlsdGVyc1tpXS5hcHBseSh0aGlzLCBmbGlwLCBsYXN0U3RhdGUucmVuZGVyVGV4dHVyZSwgQ0xFQVJfTU9ERVMuQkxFTkQsIHN0YXRlKTtcbiAgICAgIGlmIChpID4gMSAmJiBzdGF0ZS5tdWx0aXNhbXBsZSA+IDEpIHtcbiAgICAgICAgdGhpcy5yZXR1cm5GaWx0ZXJUZXh0dXJlKHN0YXRlLnJlbmRlclRleHR1cmUpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXR1cm5GaWx0ZXJUZXh0dXJlKGZsaXApO1xuICAgICAgdGhpcy5yZXR1cm5GaWx0ZXJUZXh0dXJlKGZsb3ApO1xuICAgIH1cbiAgICBzdGF0ZS5jbGVhcigpO1xuICAgIHRoaXMuc3RhdGVQb29sLnB1c2goc3RhdGUpO1xuICB9XG4gIGJpbmRBbmRDbGVhcihmaWx0ZXJUZXh0dXJlLCBjbGVhck1vZGUgPSBDTEVBUl9NT0RFUy5DTEVBUikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbmRlclRleHR1cmU6IHJlbmRlclRleHR1cmVTeXN0ZW0sXG4gICAgICBzdGF0ZTogc3RhdGVTeXN0ZW1cbiAgICB9ID0gdGhpcy5yZW5kZXJlcjtcbiAgICBpZiAoZmlsdGVyVGV4dHVyZSA9PT0gdGhpcy5kZWZhdWx0RmlsdGVyU3RhY2tbdGhpcy5kZWZhdWx0RmlsdGVyU3RhY2subGVuZ3RoIC0gMV0ucmVuZGVyVGV4dHVyZSkge1xuICAgICAgdGhpcy5yZW5kZXJlci5wcm9qZWN0aW9uLnRyYW5zZm9ybSA9IHRoaXMuYWN0aXZlU3RhdGUudHJhbnNmb3JtO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGZpbHRlclRleHR1cmU/LmZpbHRlckZyYW1lKSB7XG4gICAgICBjb25zdCBkZXN0aW5hdGlvbkZyYW1lID0gdGhpcy50ZW1wUmVjdDtcbiAgICAgIGRlc3RpbmF0aW9uRnJhbWUueCA9IDA7XG4gICAgICBkZXN0aW5hdGlvbkZyYW1lLnkgPSAwO1xuICAgICAgZGVzdGluYXRpb25GcmFtZS53aWR0aCA9IGZpbHRlclRleHR1cmUuZmlsdGVyRnJhbWUud2lkdGg7XG4gICAgICBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCA9IGZpbHRlclRleHR1cmUuZmlsdGVyRnJhbWUuaGVpZ2h0O1xuICAgICAgcmVuZGVyVGV4dHVyZVN5c3RlbS5iaW5kKGZpbHRlclRleHR1cmUsIGZpbHRlclRleHR1cmUuZmlsdGVyRnJhbWUsIGRlc3RpbmF0aW9uRnJhbWUpO1xuICAgIH0gZWxzZSBpZiAoZmlsdGVyVGV4dHVyZSAhPT0gdGhpcy5kZWZhdWx0RmlsdGVyU3RhY2tbdGhpcy5kZWZhdWx0RmlsdGVyU3RhY2subGVuZ3RoIC0gMV0ucmVuZGVyVGV4dHVyZSkge1xuICAgICAgcmVuZGVyVGV4dHVyZVN5c3RlbS5iaW5kKGZpbHRlclRleHR1cmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlclRleHR1cmUuYmluZChmaWx0ZXJUZXh0dXJlLCB0aGlzLmFjdGl2ZVN0YXRlLmJpbmRpbmdTb3VyY2VGcmFtZSwgdGhpcy5hY3RpdmVTdGF0ZS5iaW5kaW5nRGVzdGluYXRpb25GcmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGF1dG9DbGVhciA9IHN0YXRlU3lzdGVtLnN0YXRlSWQgJiAxIHx8IHRoaXMuZm9yY2VDbGVhcjtcbiAgICBpZiAoY2xlYXJNb2RlID09PSBDTEVBUl9NT0RFUy5DTEVBUiB8fCBjbGVhck1vZGUgPT09IENMRUFSX01PREVTLkJMSVQgJiYgYXV0b0NsZWFyKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLmZyYW1lYnVmZmVyLmNsZWFyKDAsIDAsIDAsIDApO1xuICAgIH1cbiAgfVxuICBhcHBseUZpbHRlcihmaWx0ZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyTW9kZSkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICByZW5kZXJlci5zdGF0ZS5zZXQoZmlsdGVyLnN0YXRlKTtcbiAgICB0aGlzLmJpbmRBbmRDbGVhcihvdXRwdXQsIGNsZWFyTW9kZSk7XG4gICAgZmlsdGVyLnVuaWZvcm1zLnVTYW1wbGVyID0gaW5wdXQ7XG4gICAgZmlsdGVyLnVuaWZvcm1zLmZpbHRlckdsb2JhbHMgPSB0aGlzLmdsb2JhbFVuaWZvcm1zO1xuICAgIHJlbmRlcmVyLnNoYWRlci5iaW5kKGZpbHRlcik7XG4gICAgZmlsdGVyLmxlZ2FjeSA9ICEhZmlsdGVyLnByb2dyYW0uYXR0cmlidXRlRGF0YS5hVGV4dHVyZUNvb3JkO1xuICAgIGlmIChmaWx0ZXIubGVnYWN5KSB7XG4gICAgICB0aGlzLnF1YWRVdi5tYXAoaW5wdXQuX2ZyYW1lLCBpbnB1dC5maWx0ZXJGcmFtZSk7XG4gICAgICByZW5kZXJlci5nZW9tZXRyeS5iaW5kKHRoaXMucXVhZFV2KTtcbiAgICAgIHJlbmRlcmVyLmdlb21ldHJ5LmRyYXcoRFJBV19NT0RFUy5UUklBTkdMRVMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW5kZXJlci5nZW9tZXRyeS5iaW5kKHRoaXMucXVhZCk7XG4gICAgICByZW5kZXJlci5nZW9tZXRyeS5kcmF3KERSQVdfTU9ERVMuVFJJQU5HTEVfU1RSSVApO1xuICAgIH1cbiAgfVxuICBjYWxjdWxhdGVTcHJpdGVNYXRyaXgob3V0cHV0TWF0cml4LCBzcHJpdGUpIHtcbiAgICBjb25zdCB7IHNvdXJjZUZyYW1lLCBkZXN0aW5hdGlvbkZyYW1lIH0gPSB0aGlzLmFjdGl2ZVN0YXRlO1xuICAgIGNvbnN0IHsgb3JpZyB9ID0gc3ByaXRlLl90ZXh0dXJlO1xuICAgIGNvbnN0IG1hcHBlZE1hdHJpeCA9IG91dHB1dE1hdHJpeC5zZXQoZGVzdGluYXRpb25GcmFtZS53aWR0aCwgMCwgMCwgZGVzdGluYXRpb25GcmFtZS5oZWlnaHQsIHNvdXJjZUZyYW1lLngsIHNvdXJjZUZyYW1lLnkpO1xuICAgIGNvbnN0IHdvcmxkVHJhbnNmb3JtID0gc3ByaXRlLndvcmxkVHJhbnNmb3JtLmNvcHlUbyhNYXRyaXguVEVNUF9NQVRSSVgpO1xuICAgIHdvcmxkVHJhbnNmb3JtLmludmVydCgpO1xuICAgIG1hcHBlZE1hdHJpeC5wcmVwZW5kKHdvcmxkVHJhbnNmb3JtKTtcbiAgICBtYXBwZWRNYXRyaXguc2NhbGUoMSAvIG9yaWcud2lkdGgsIDEgLyBvcmlnLmhlaWdodCk7XG4gICAgbWFwcGVkTWF0cml4LnRyYW5zbGF0ZShzcHJpdGUuYW5jaG9yLngsIHNwcml0ZS5hbmNob3IueSk7XG4gICAgcmV0dXJuIG1hcHBlZE1hdHJpeDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMudGV4dHVyZVBvb2wuY2xlYXIoZmFsc2UpO1xuICB9XG4gIGdldE9wdGltYWxGaWx0ZXJUZXh0dXJlKG1pbldpZHRoLCBtaW5IZWlnaHQsIHJlc29sdXRpb24gPSAxLCBtdWx0aXNhbXBsZSA9IE1TQUFfUVVBTElUWS5OT05FKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dHVyZVBvb2wuZ2V0T3B0aW1hbFRleHR1cmUobWluV2lkdGgsIG1pbkhlaWdodCwgcmVzb2x1dGlvbiwgbXVsdGlzYW1wbGUpO1xuICB9XG4gIGdldEZpbHRlclRleHR1cmUoaW5wdXQsIHJlc29sdXRpb24sIG11bHRpc2FtcGxlKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3Qgc3dhcCA9IGlucHV0O1xuICAgICAgaW5wdXQgPSByZXNvbHV0aW9uO1xuICAgICAgcmVzb2x1dGlvbiA9IHN3YXA7XG4gICAgfVxuICAgIGlucHV0ID0gaW5wdXQgfHwgdGhpcy5hY3RpdmVTdGF0ZS5yZW5kZXJUZXh0dXJlO1xuICAgIGNvbnN0IGZpbHRlclRleHR1cmUgPSB0aGlzLnRleHR1cmVQb29sLmdldE9wdGltYWxUZXh0dXJlKGlucHV0LndpZHRoLCBpbnB1dC5oZWlnaHQsIHJlc29sdXRpb24gfHwgaW5wdXQucmVzb2x1dGlvbiwgbXVsdGlzYW1wbGUgfHwgTVNBQV9RVUFMSVRZLk5PTkUpO1xuICAgIGZpbHRlclRleHR1cmUuZmlsdGVyRnJhbWUgPSBpbnB1dC5maWx0ZXJGcmFtZTtcbiAgICByZXR1cm4gZmlsdGVyVGV4dHVyZTtcbiAgfVxuICByZXR1cm5GaWx0ZXJUZXh0dXJlKHJlbmRlclRleHR1cmUpIHtcbiAgICB0aGlzLnRleHR1cmVQb29sLnJldHVyblRleHR1cmUocmVuZGVyVGV4dHVyZSk7XG4gIH1cbiAgZW1wdHlQb29sKCkge1xuICAgIHRoaXMudGV4dHVyZVBvb2wuY2xlYXIodHJ1ZSk7XG4gIH1cbiAgcmVzaXplKCkge1xuICAgIHRoaXMudGV4dHVyZVBvb2wuc2V0U2NyZWVuU2l6ZSh0aGlzLnJlbmRlcmVyLnZpZXcpO1xuICB9XG4gIHRyYW5zZm9ybUFBQkIobWF0cml4LCByZWN0KSB7XG4gICAgY29uc3QgbHQgPSB0ZW1wUG9pbnRzWzBdO1xuICAgIGNvbnN0IGxiID0gdGVtcFBvaW50c1sxXTtcbiAgICBjb25zdCBydCA9IHRlbXBQb2ludHNbMl07XG4gICAgY29uc3QgcmIgPSB0ZW1wUG9pbnRzWzNdO1xuICAgIGx0LnNldChyZWN0LmxlZnQsIHJlY3QudG9wKTtcbiAgICBsYi5zZXQocmVjdC5sZWZ0LCByZWN0LmJvdHRvbSk7XG4gICAgcnQuc2V0KHJlY3QucmlnaHQsIHJlY3QudG9wKTtcbiAgICByYi5zZXQocmVjdC5yaWdodCwgcmVjdC5ib3R0b20pO1xuICAgIG1hdHJpeC5hcHBseShsdCwgbHQpO1xuICAgIG1hdHJpeC5hcHBseShsYiwgbGIpO1xuICAgIG1hdHJpeC5hcHBseShydCwgcnQpO1xuICAgIG1hdHJpeC5hcHBseShyYiwgcmIpO1xuICAgIGNvbnN0IHgwID0gTWF0aC5taW4obHQueCwgbGIueCwgcnQueCwgcmIueCk7XG4gICAgY29uc3QgeTAgPSBNYXRoLm1pbihsdC55LCBsYi55LCBydC55LCByYi55KTtcbiAgICBjb25zdCB4MSA9IE1hdGgubWF4KGx0LngsIGxiLngsIHJ0LngsIHJiLngpO1xuICAgIGNvbnN0IHkxID0gTWF0aC5tYXgobHQueSwgbGIueSwgcnQueSwgcmIueSk7XG4gICAgcmVjdC54ID0geDA7XG4gICAgcmVjdC55ID0geTA7XG4gICAgcmVjdC53aWR0aCA9IHgxIC0geDA7XG4gICAgcmVjdC5oZWlnaHQgPSB5MSAtIHkwO1xuICB9XG4gIHJvdW5kRnJhbWUoZnJhbWUsIHJlc29sdXRpb24sIGJpbmRpbmdTb3VyY2VGcmFtZSwgYmluZGluZ0Rlc3RpbmF0aW9uRnJhbWUsIHRyYW5zZm9ybSkge1xuICAgIGlmIChmcmFtZS53aWR0aCA8PSAwIHx8IGZyYW1lLmhlaWdodCA8PSAwIHx8IGJpbmRpbmdTb3VyY2VGcmFtZS53aWR0aCA8PSAwIHx8IGJpbmRpbmdTb3VyY2VGcmFtZS5oZWlnaHQgPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICBjb25zdCB7IGEsIGIsIGMsIGQgfSA9IHRyYW5zZm9ybTtcbiAgICAgIGlmICgoTWF0aC5hYnMoYikgPiAxZS00IHx8IE1hdGguYWJzKGMpID4gMWUtNCkgJiYgKE1hdGguYWJzKGEpID4gMWUtNCB8fCBNYXRoLmFicyhkKSA+IDFlLTQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJhbnNmb3JtID0gdHJhbnNmb3JtID8gdGVtcE1hdHJpeC5jb3B5RnJvbSh0cmFuc2Zvcm0pIDogdGVtcE1hdHJpeC5pZGVudGl0eSgpO1xuICAgIHRyYW5zZm9ybS50cmFuc2xhdGUoLWJpbmRpbmdTb3VyY2VGcmFtZS54LCAtYmluZGluZ1NvdXJjZUZyYW1lLnkpLnNjYWxlKGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLndpZHRoIC8gYmluZGluZ1NvdXJjZUZyYW1lLndpZHRoLCBiaW5kaW5nRGVzdGluYXRpb25GcmFtZS5oZWlnaHQgLyBiaW5kaW5nU291cmNlRnJhbWUuaGVpZ2h0KS50cmFuc2xhdGUoYmluZGluZ0Rlc3RpbmF0aW9uRnJhbWUueCwgYmluZGluZ0Rlc3RpbmF0aW9uRnJhbWUueSk7XG4gICAgdGhpcy50cmFuc2Zvcm1BQUJCKHRyYW5zZm9ybSwgZnJhbWUpO1xuICAgIGZyYW1lLmNlaWwocmVzb2x1dGlvbik7XG4gICAgdGhpcy50cmFuc2Zvcm1BQUJCKHRyYW5zZm9ybS5pbnZlcnQoKSwgZnJhbWUpO1xuICB9XG59XG5GaWx0ZXJTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcImZpbHRlclwiXG59O1xuZXh0ZW5zaW9ucy5hZGQoRmlsdGVyU3lzdGVtKTtcblxuZXhwb3J0IHsgRmlsdGVyU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWx0ZXJTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgTVNBQV9RVUFMSVRZIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcblxuY2xhc3MgR0xGcmFtZWJ1ZmZlciB7XG4gIGNvbnN0cnVjdG9yKGZyYW1lYnVmZmVyKSB7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlciA9IGZyYW1lYnVmZmVyO1xuICAgIHRoaXMuc3RlbmNpbCA9IG51bGw7XG4gICAgdGhpcy5kaXJ0eUlkID0gLTE7XG4gICAgdGhpcy5kaXJ0eUZvcm1hdCA9IC0xO1xuICAgIHRoaXMuZGlydHlTaXplID0gLTE7XG4gICAgdGhpcy5tdWx0aXNhbXBsZSA9IE1TQUFfUVVBTElUWS5OT05FO1xuICAgIHRoaXMubXNhYUJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5ibGl0RnJhbWVidWZmZXIgPSBudWxsO1xuICAgIHRoaXMubWlwTGV2ZWwgPSAwO1xuICB9XG59XG5cbmV4cG9ydCB7IEdMRnJhbWVidWZmZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdMRnJhbWVidWZmZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgRU5WLCBCVUZGRVJfQklUUywgTVNBQV9RVUFMSVRZIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tICdAcGl4aS9leHRlbnNpb25zJztcbmltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gJ0BwaXhpL21hdGgnO1xuaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tICdAcGl4aS9zZXR0aW5ncyc7XG5pbXBvcnQgeyBGcmFtZWJ1ZmZlciB9IGZyb20gJy4vRnJhbWVidWZmZXIubWpzJztcbmltcG9ydCB7IEdMRnJhbWVidWZmZXIgfSBmcm9tICcuL0dMRnJhbWVidWZmZXIubWpzJztcblxuY29uc3QgdGVtcFJlY3RhbmdsZSA9IG5ldyBSZWN0YW5nbGUoKTtcbmNsYXNzIEZyYW1lYnVmZmVyU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5tYW5hZ2VkRnJhbWVidWZmZXJzID0gW107XG4gICAgdGhpcy51bmtub3duRnJhbWVidWZmZXIgPSBuZXcgRnJhbWVidWZmZXIoMTAsIDEwKTtcbiAgICB0aGlzLm1zYWFTYW1wbGVzID0gbnVsbDtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKCkge1xuICAgIHRoaXMuZGlzcG9zZUFsbCh0cnVlKTtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuICAgIHRoaXMuQ09OVEVYVF9VSUQgPSB0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEO1xuICAgIHRoaXMuY3VycmVudCA9IHRoaXMudW5rbm93bkZyYW1lYnVmZmVyO1xuICAgIHRoaXMudmlld3BvcnQgPSBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgdGhpcy5oYXNNUlQgPSB0cnVlO1xuICAgIHRoaXMud3JpdGVEZXB0aFRleHR1cmUgPSB0cnVlO1xuICAgIGlmICh0aGlzLnJlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uID09PSAxKSB7XG4gICAgICBsZXQgbmF0aXZlRHJhd0J1ZmZlcnNFeHRlbnNpb24gPSB0aGlzLnJlbmRlcmVyLmNvbnRleHQuZXh0ZW5zaW9ucy5kcmF3QnVmZmVycztcbiAgICAgIGxldCBuYXRpdmVEZXB0aFRleHR1cmVFeHRlbnNpb24gPSB0aGlzLnJlbmRlcmVyLmNvbnRleHQuZXh0ZW5zaW9ucy5kZXB0aFRleHR1cmU7XG4gICAgICBpZiAoc2V0dGluZ3MuUFJFRkVSX0VOViA9PT0gRU5WLldFQkdMX0xFR0FDWSkge1xuICAgICAgICBuYXRpdmVEcmF3QnVmZmVyc0V4dGVuc2lvbiA9IG51bGw7XG4gICAgICAgIG5hdGl2ZURlcHRoVGV4dHVyZUV4dGVuc2lvbiA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAobmF0aXZlRHJhd0J1ZmZlcnNFeHRlbnNpb24pIHtcbiAgICAgICAgZ2wuZHJhd0J1ZmZlcnMgPSAoYWN0aXZlVGV4dHVyZXMpID0+IG5hdGl2ZURyYXdCdWZmZXJzRXh0ZW5zaW9uLmRyYXdCdWZmZXJzV0VCR0woYWN0aXZlVGV4dHVyZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYXNNUlQgPSBmYWxzZTtcbiAgICAgICAgZ2wuZHJhd0J1ZmZlcnMgPSAoKSA9PiB7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoIW5hdGl2ZURlcHRoVGV4dHVyZUV4dGVuc2lvbikge1xuICAgICAgICB0aGlzLndyaXRlRGVwdGhUZXh0dXJlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubXNhYVNhbXBsZXMgPSBnbC5nZXRJbnRlcm5hbGZvcm1hdFBhcmFtZXRlcihnbC5SRU5ERVJCVUZGRVIsIGdsLlJHQkE4LCBnbC5TQU1QTEVTKTtcbiAgICB9XG4gIH1cbiAgYmluZChmcmFtZWJ1ZmZlciwgZnJhbWUsIG1pcExldmVsID0gMCkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgaWYgKGZyYW1lYnVmZmVyKSB7XG4gICAgICBjb25zdCBmYm8gPSBmcmFtZWJ1ZmZlci5nbEZyYW1lYnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXSB8fCB0aGlzLmluaXRGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcik7XG4gICAgICBpZiAodGhpcy5jdXJyZW50ICE9PSBmcmFtZWJ1ZmZlcikge1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBmcmFtZWJ1ZmZlcjtcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmYm8uZnJhbWVidWZmZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGZiby5taXBMZXZlbCAhPT0gbWlwTGV2ZWwpIHtcbiAgICAgICAgZnJhbWVidWZmZXIuZGlydHlJZCsrO1xuICAgICAgICBmcmFtZWJ1ZmZlci5kaXJ0eUZvcm1hdCsrO1xuICAgICAgICBmYm8ubWlwTGV2ZWwgPSBtaXBMZXZlbDtcbiAgICAgIH1cbiAgICAgIGlmIChmYm8uZGlydHlJZCAhPT0gZnJhbWVidWZmZXIuZGlydHlJZCkge1xuICAgICAgICBmYm8uZGlydHlJZCA9IGZyYW1lYnVmZmVyLmRpcnR5SWQ7XG4gICAgICAgIGlmIChmYm8uZGlydHlGb3JtYXQgIT09IGZyYW1lYnVmZmVyLmRpcnR5Rm9ybWF0KSB7XG4gICAgICAgICAgZmJvLmRpcnR5Rm9ybWF0ID0gZnJhbWVidWZmZXIuZGlydHlGb3JtYXQ7XG4gICAgICAgICAgZmJvLmRpcnR5U2l6ZSA9IGZyYW1lYnVmZmVyLmRpcnR5U2l6ZTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyLCBtaXBMZXZlbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmJvLmRpcnR5U2l6ZSAhPT0gZnJhbWVidWZmZXIuZGlydHlTaXplKSB7XG4gICAgICAgICAgZmJvLmRpcnR5U2l6ZSA9IGZyYW1lYnVmZmVyLmRpcnR5U2l6ZTtcbiAgICAgICAgICB0aGlzLnJlc2l6ZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZWJ1ZmZlci5jb2xvclRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRleCA9IGZyYW1lYnVmZmVyLmNvbG9yVGV4dHVyZXNbaV07XG4gICAgICAgIHRoaXMucmVuZGVyZXIudGV4dHVyZS51bmJpbmQodGV4LnBhcmVudFRleHR1cmVBcnJheSB8fCB0ZXgpO1xuICAgICAgfVxuICAgICAgaWYgKGZyYW1lYnVmZmVyLmRlcHRoVGV4dHVyZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnRleHR1cmUudW5iaW5kKGZyYW1lYnVmZmVyLmRlcHRoVGV4dHVyZSk7XG4gICAgICB9XG4gICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgY29uc3QgbWlwV2lkdGggPSBmcmFtZS53aWR0aCA+PiBtaXBMZXZlbDtcbiAgICAgICAgY29uc3QgbWlwSGVpZ2h0ID0gZnJhbWUuaGVpZ2h0ID4+IG1pcExldmVsO1xuICAgICAgICBjb25zdCBzY2FsZSA9IG1pcFdpZHRoIC8gZnJhbWUud2lkdGg7XG4gICAgICAgIHRoaXMuc2V0Vmlld3BvcnQoZnJhbWUueCAqIHNjYWxlLCBmcmFtZS55ICogc2NhbGUsIG1pcFdpZHRoLCBtaXBIZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWlwV2lkdGggPSBmcmFtZWJ1ZmZlci53aWR0aCA+PiBtaXBMZXZlbDtcbiAgICAgICAgY29uc3QgbWlwSGVpZ2h0ID0gZnJhbWVidWZmZXIuaGVpZ2h0ID4+IG1pcExldmVsO1xuICAgICAgICB0aGlzLnNldFZpZXdwb3J0KDAsIDAsIG1pcFdpZHRoLCBtaXBIZWlnaHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50KSB7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICB9XG4gICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgdGhpcy5zZXRWaWV3cG9ydChmcmFtZS54LCBmcmFtZS55LCBmcmFtZS53aWR0aCwgZnJhbWUuaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0Vmlld3BvcnQoMCwgMCwgdGhpcy5yZW5kZXJlci53aWR0aCwgdGhpcy5yZW5kZXJlci5oZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzZXRWaWV3cG9ydCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgdiA9IHRoaXMudmlld3BvcnQ7XG4gICAgeCA9IE1hdGgucm91bmQoeCk7XG4gICAgeSA9IE1hdGgucm91bmQoeSk7XG4gICAgd2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoKTtcbiAgICBoZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCk7XG4gICAgaWYgKHYud2lkdGggIT09IHdpZHRoIHx8IHYuaGVpZ2h0ICE9PSBoZWlnaHQgfHwgdi54ICE9PSB4IHx8IHYueSAhPT0geSkge1xuICAgICAgdi54ID0geDtcbiAgICAgIHYueSA9IHk7XG4gICAgICB2LndpZHRoID0gd2lkdGg7XG4gICAgICB2LmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHRoaXMuZ2wudmlld3BvcnQoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICB9XG4gIGdldCBzaXplKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAsIHdpZHRoOiB0aGlzLmN1cnJlbnQud2lkdGgsIGhlaWdodDogdGhpcy5jdXJyZW50LmhlaWdodCB9O1xuICAgIH1cbiAgICByZXR1cm4geyB4OiAwLCB5OiAwLCB3aWR0aDogdGhpcy5yZW5kZXJlci53aWR0aCwgaGVpZ2h0OiB0aGlzLnJlbmRlcmVyLmhlaWdodCB9O1xuICB9XG4gIGNsZWFyKHIsIGcsIGIsIGEsIG1hc2sgPSBCVUZGRVJfQklUUy5DT0xPUiB8IEJVRkZFUl9CSVRTLkRFUFRIKSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcztcbiAgICBnbC5jbGVhckNvbG9yKHIsIGcsIGIsIGEpO1xuICAgIGdsLmNsZWFyKG1hc2spO1xuICB9XG4gIGluaXRGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcikge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgY29uc3QgZmJvID0gbmV3IEdMRnJhbWVidWZmZXIoZ2wuY3JlYXRlRnJhbWVidWZmZXIoKSk7XG4gICAgZmJvLm11bHRpc2FtcGxlID0gdGhpcy5kZXRlY3RTYW1wbGVzKGZyYW1lYnVmZmVyLm11bHRpc2FtcGxlKTtcbiAgICBmcmFtZWJ1ZmZlci5nbEZyYW1lYnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXSA9IGZibztcbiAgICB0aGlzLm1hbmFnZWRGcmFtZWJ1ZmZlcnMucHVzaChmcmFtZWJ1ZmZlcik7XG4gICAgZnJhbWVidWZmZXIuZGlzcG9zZVJ1bm5lci5hZGQodGhpcyk7XG4gICAgcmV0dXJuIGZibztcbiAgfVxuICByZXNpemVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcikge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgY29uc3QgZmJvID0gZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgaWYgKGZiby5zdGVuY2lsKSB7XG4gICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgZmJvLnN0ZW5jaWwpO1xuICAgICAgaWYgKGZiby5tc2FhQnVmZmVyKSB7XG4gICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZShnbC5SRU5ERVJCVUZGRVIsIGZiby5tdWx0aXNhbXBsZSwgZ2wuREVQVEgyNF9TVEVOQ0lMOCwgZnJhbWVidWZmZXIud2lkdGgsIGZyYW1lYnVmZmVyLmhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTCwgZnJhbWVidWZmZXIud2lkdGgsIGZyYW1lYnVmZmVyLmhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yVGV4dHVyZXMgPSBmcmFtZWJ1ZmZlci5jb2xvclRleHR1cmVzO1xuICAgIGxldCBjb3VudCA9IGNvbG9yVGV4dHVyZXMubGVuZ3RoO1xuICAgIGlmICghZ2wuZHJhd0J1ZmZlcnMpIHtcbiAgICAgIGNvdW50ID0gTWF0aC5taW4oY291bnQsIDEpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBjb2xvclRleHR1cmVzW2ldO1xuICAgICAgY29uc3QgcGFyZW50VGV4dHVyZSA9IHRleHR1cmUucGFyZW50VGV4dHVyZUFycmF5IHx8IHRleHR1cmU7XG4gICAgICB0aGlzLnJlbmRlcmVyLnRleHR1cmUuYmluZChwYXJlbnRUZXh0dXJlLCAwKTtcbiAgICAgIGlmIChpID09PSAwICYmIGZiby5tc2FhQnVmZmVyKSB7XG4gICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBmYm8ubXNhYUJ1ZmZlcik7XG4gICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZShnbC5SRU5ERVJCVUZGRVIsIGZiby5tdWx0aXNhbXBsZSwgcGFyZW50VGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXS5pbnRlcm5hbEZvcm1hdCwgZnJhbWVidWZmZXIud2lkdGgsIGZyYW1lYnVmZmVyLmhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmcmFtZWJ1ZmZlci5kZXB0aFRleHR1cmUgJiYgdGhpcy53cml0ZURlcHRoVGV4dHVyZSkge1xuICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLmJpbmQoZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlLCAwKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlRnJhbWVidWZmZXIoZnJhbWVidWZmZXIsIG1pcExldmVsKSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcztcbiAgICBjb25zdCBmYm8gPSBmcmFtZWJ1ZmZlci5nbEZyYW1lYnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgICBjb25zdCBjb2xvclRleHR1cmVzID0gZnJhbWVidWZmZXIuY29sb3JUZXh0dXJlcztcbiAgICBsZXQgY291bnQgPSBjb2xvclRleHR1cmVzLmxlbmd0aDtcbiAgICBpZiAoIWdsLmRyYXdCdWZmZXJzKSB7XG4gICAgICBjb3VudCA9IE1hdGgubWluKGNvdW50LCAxKTtcbiAgICB9XG4gICAgaWYgKGZiby5tdWx0aXNhbXBsZSA+IDEgJiYgdGhpcy5jYW5NdWx0aXNhbXBsZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKSkge1xuICAgICAgZmJvLm1zYWFCdWZmZXIgPSBmYm8ubXNhYUJ1ZmZlciB8fCBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICB9IGVsc2UgaWYgKGZiby5tc2FhQnVmZmVyKSB7XG4gICAgICBnbC5kZWxldGVSZW5kZXJidWZmZXIoZmJvLm1zYWFCdWZmZXIpO1xuICAgICAgZmJvLm1zYWFCdWZmZXIgPSBudWxsO1xuICAgICAgaWYgKGZiby5ibGl0RnJhbWVidWZmZXIpIHtcbiAgICAgICAgZmJvLmJsaXRGcmFtZWJ1ZmZlci5kaXNwb3NlKCk7XG4gICAgICAgIGZiby5ibGl0RnJhbWVidWZmZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhY3RpdmVUZXh0dXJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgdGV4dHVyZSA9IGNvbG9yVGV4dHVyZXNbaV07XG4gICAgICBjb25zdCBwYXJlbnRUZXh0dXJlID0gdGV4dHVyZS5wYXJlbnRUZXh0dXJlQXJyYXkgfHwgdGV4dHVyZTtcbiAgICAgIHRoaXMucmVuZGVyZXIudGV4dHVyZS5iaW5kKHBhcmVudFRleHR1cmUsIDApO1xuICAgICAgaWYgKGkgPT09IDAgJiYgZmJvLm1zYWFCdWZmZXIpIHtcbiAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIGZiby5tc2FhQnVmZmVyKTtcbiAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKGdsLlJFTkRFUkJVRkZFUiwgZmJvLm11bHRpc2FtcGxlLCBwYXJlbnRUZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdLmludGVybmFsRm9ybWF0LCBmcmFtZWJ1ZmZlci53aWR0aCwgZnJhbWVidWZmZXIuaGVpZ2h0KTtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5SRU5ERVJCVUZGRVIsIGZiby5tc2FhQnVmZmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGksIHRleHR1cmUudGFyZ2V0LCBwYXJlbnRUZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdLnRleHR1cmUsIG1pcExldmVsKTtcbiAgICAgICAgYWN0aXZlVGV4dHVyZXMucHVzaChnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWN0aXZlVGV4dHVyZXMubGVuZ3RoID4gMSkge1xuICAgICAgZ2wuZHJhd0J1ZmZlcnMoYWN0aXZlVGV4dHVyZXMpO1xuICAgIH1cbiAgICBpZiAoZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlKSB7XG4gICAgICBjb25zdCB3cml0ZURlcHRoVGV4dHVyZSA9IHRoaXMud3JpdGVEZXB0aFRleHR1cmU7XG4gICAgICBpZiAod3JpdGVEZXB0aFRleHR1cmUpIHtcbiAgICAgICAgY29uc3QgZGVwdGhUZXh0dXJlID0gZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnRleHR1cmUuYmluZChkZXB0aFRleHR1cmUsIDApO1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfQVRUQUNITUVOVCwgZ2wuVEVYVFVSRV8yRCwgZGVwdGhUZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdLnRleHR1cmUsIG1pcExldmVsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKChmcmFtZWJ1ZmZlci5zdGVuY2lsIHx8IGZyYW1lYnVmZmVyLmRlcHRoKSAmJiAhKGZyYW1lYnVmZmVyLmRlcHRoVGV4dHVyZSAmJiB0aGlzLndyaXRlRGVwdGhUZXh0dXJlKSkge1xuICAgICAgZmJvLnN0ZW5jaWwgPSBmYm8uc3RlbmNpbCB8fCBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBmYm8uc3RlbmNpbCk7XG4gICAgICBpZiAoZmJvLm1zYWFCdWZmZXIpIHtcbiAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKGdsLlJFTkRFUkJVRkZFUiwgZmJvLm11bHRpc2FtcGxlLCBnbC5ERVBUSDI0X1NURU5DSUw4LCBmcmFtZWJ1ZmZlci53aWR0aCwgZnJhbWVidWZmZXIuaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9TVEVOQ0lMLCBmcmFtZWJ1ZmZlci53aWR0aCwgZnJhbWVidWZmZXIuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgZmJvLnN0ZW5jaWwpO1xuICAgIH0gZWxzZSBpZiAoZmJvLnN0ZW5jaWwpIHtcbiAgICAgIGdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcihmYm8uc3RlbmNpbCk7XG4gICAgICBmYm8uc3RlbmNpbCA9IG51bGw7XG4gICAgfVxuICB9XG4gIGNhbk11bHRpc2FtcGxlRnJhbWVidWZmZXIoZnJhbWVidWZmZXIpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5jb250ZXh0LndlYkdMVmVyc2lvbiAhPT0gMSAmJiBmcmFtZWJ1ZmZlci5jb2xvclRleHR1cmVzLmxlbmd0aCA8PSAxICYmICFmcmFtZWJ1ZmZlci5kZXB0aFRleHR1cmU7XG4gIH1cbiAgZGV0ZWN0U2FtcGxlcyhzYW1wbGVzKSB7XG4gICAgY29uc3QgeyBtc2FhU2FtcGxlcyB9ID0gdGhpcztcbiAgICBsZXQgcmVzID0gTVNBQV9RVUFMSVRZLk5PTkU7XG4gICAgaWYgKHNhbXBsZXMgPD0gMSB8fCBtc2FhU2FtcGxlcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtc2FhU2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG1zYWFTYW1wbGVzW2ldIDw9IHNhbXBsZXMpIHtcbiAgICAgICAgcmVzID0gbXNhYVNhbXBsZXNbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzID09PSAxKSB7XG4gICAgICByZXMgPSBNU0FBX1FVQUxJVFkuTk9ORTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBibGl0KGZyYW1lYnVmZmVyLCBzb3VyY2VQaXhlbHMsIGRlc3RQaXhlbHMpIHtcbiAgICBjb25zdCB7IGN1cnJlbnQsIHJlbmRlcmVyLCBnbCwgQ09OVEVYVF9VSUQgfSA9IHRoaXM7XG4gICAgaWYgKHJlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uICE9PSAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmYm8gPSBjdXJyZW50LmdsRnJhbWVidWZmZXJzW0NPTlRFWFRfVUlEXTtcbiAgICBpZiAoIWZibykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWZyYW1lYnVmZmVyKSB7XG4gICAgICBpZiAoIWZiby5tc2FhQnVmZmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbG9yVGV4dHVyZSA9IGN1cnJlbnQuY29sb3JUZXh0dXJlc1swXTtcbiAgICAgIGlmICghY29sb3JUZXh0dXJlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghZmJvLmJsaXRGcmFtZWJ1ZmZlcikge1xuICAgICAgICBmYm8uYmxpdEZyYW1lYnVmZmVyID0gbmV3IEZyYW1lYnVmZmVyKGN1cnJlbnQud2lkdGgsIGN1cnJlbnQuaGVpZ2h0KTtcbiAgICAgICAgZmJvLmJsaXRGcmFtZWJ1ZmZlci5hZGRDb2xvclRleHR1cmUoMCwgY29sb3JUZXh0dXJlKTtcbiAgICAgIH1cbiAgICAgIGZyYW1lYnVmZmVyID0gZmJvLmJsaXRGcmFtZWJ1ZmZlcjtcbiAgICAgIGlmIChmcmFtZWJ1ZmZlci5jb2xvclRleHR1cmVzWzBdICE9PSBjb2xvclRleHR1cmUpIHtcbiAgICAgICAgZnJhbWVidWZmZXIuY29sb3JUZXh0dXJlc1swXSA9IGNvbG9yVGV4dHVyZTtcbiAgICAgICAgZnJhbWVidWZmZXIuZGlydHlJZCsrO1xuICAgICAgICBmcmFtZWJ1ZmZlci5kaXJ0eUZvcm1hdCsrO1xuICAgICAgfVxuICAgICAgaWYgKGZyYW1lYnVmZmVyLndpZHRoICE9PSBjdXJyZW50LndpZHRoIHx8IGZyYW1lYnVmZmVyLmhlaWdodCAhPT0gY3VycmVudC5oZWlnaHQpIHtcbiAgICAgICAgZnJhbWVidWZmZXIud2lkdGggPSBjdXJyZW50LndpZHRoO1xuICAgICAgICBmcmFtZWJ1ZmZlci5oZWlnaHQgPSBjdXJyZW50LmhlaWdodDtcbiAgICAgICAgZnJhbWVidWZmZXIuZGlydHlJZCsrO1xuICAgICAgICBmcmFtZWJ1ZmZlci5kaXJ0eVNpemUrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzb3VyY2VQaXhlbHMpIHtcbiAgICAgIHNvdXJjZVBpeGVscyA9IHRlbXBSZWN0YW5nbGU7XG4gICAgICBzb3VyY2VQaXhlbHMud2lkdGggPSBjdXJyZW50LndpZHRoO1xuICAgICAgc291cmNlUGl4ZWxzLmhlaWdodCA9IGN1cnJlbnQuaGVpZ2h0O1xuICAgIH1cbiAgICBpZiAoIWRlc3RQaXhlbHMpIHtcbiAgICAgIGRlc3RQaXhlbHMgPSBzb3VyY2VQaXhlbHM7XG4gICAgfVxuICAgIGNvbnN0IHNhbWVTaXplID0gc291cmNlUGl4ZWxzLndpZHRoID09PSBkZXN0UGl4ZWxzLndpZHRoICYmIHNvdXJjZVBpeGVscy5oZWlnaHQgPT09IGRlc3RQaXhlbHMuaGVpZ2h0O1xuICAgIHRoaXMuYmluZChmcmFtZWJ1ZmZlcik7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLlJFQURfRlJBTUVCVUZGRVIsIGZiby5mcmFtZWJ1ZmZlcik7XG4gICAgZ2wuYmxpdEZyYW1lYnVmZmVyKHNvdXJjZVBpeGVscy5sZWZ0LCBzb3VyY2VQaXhlbHMudG9wLCBzb3VyY2VQaXhlbHMucmlnaHQsIHNvdXJjZVBpeGVscy5ib3R0b20sIGRlc3RQaXhlbHMubGVmdCwgZGVzdFBpeGVscy50b3AsIGRlc3RQaXhlbHMucmlnaHQsIGRlc3RQaXhlbHMuYm90dG9tLCBnbC5DT0xPUl9CVUZGRVJfQklULCBzYW1lU2l6ZSA/IGdsLk5FQVJFU1QgOiBnbC5MSU5FQVIpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5SRUFEX0ZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlci5nbEZyYW1lYnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXS5mcmFtZWJ1ZmZlcik7XG4gIH1cbiAgZGlzcG9zZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyLCBjb250ZXh0TG9zdCkge1xuICAgIGNvbnN0IGZibyA9IGZyYW1lYnVmZmVyLmdsRnJhbWVidWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBpZiAoIWZibykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWxldGUgZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLm1hbmFnZWRGcmFtZWJ1ZmZlcnMuaW5kZXhPZihmcmFtZWJ1ZmZlcik7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMubWFuYWdlZEZyYW1lYnVmZmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBmcmFtZWJ1ZmZlci5kaXNwb3NlUnVubmVyLnJlbW92ZSh0aGlzKTtcbiAgICBpZiAoIWNvbnRleHRMb3N0KSB7XG4gICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihmYm8uZnJhbWVidWZmZXIpO1xuICAgICAgaWYgKGZiby5tc2FhQnVmZmVyKSB7XG4gICAgICAgIGdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcihmYm8ubXNhYUJ1ZmZlcik7XG4gICAgICB9XG4gICAgICBpZiAoZmJvLnN0ZW5jaWwpIHtcbiAgICAgICAgZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKGZiby5zdGVuY2lsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZiby5ibGl0RnJhbWVidWZmZXIpIHtcbiAgICAgIHRoaXMuZGlzcG9zZUZyYW1lYnVmZmVyKGZiby5ibGl0RnJhbWVidWZmZXIsIGNvbnRleHRMb3N0KTtcbiAgICB9XG4gIH1cbiAgZGlzcG9zZUFsbChjb250ZXh0TG9zdCkge1xuICAgIGNvbnN0IGxpc3QgPSB0aGlzLm1hbmFnZWRGcmFtZWJ1ZmZlcnM7XG4gICAgdGhpcy5tYW5hZ2VkRnJhbWVidWZmZXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmRpc3Bvc2VGcmFtZWJ1ZmZlcihsaXN0W2ldLCBjb250ZXh0TG9zdCk7XG4gICAgfVxuICB9XG4gIGZvcmNlU3RlbmNpbCgpIHtcbiAgICBjb25zdCBmcmFtZWJ1ZmZlciA9IHRoaXMuY3VycmVudDtcbiAgICBpZiAoIWZyYW1lYnVmZmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZibyA9IGZyYW1lYnVmZmVyLmdsRnJhbWVidWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgIGlmICghZmJvIHx8IGZiby5zdGVuY2lsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZyYW1lYnVmZmVyLnN0ZW5jaWwgPSB0cnVlO1xuICAgIGNvbnN0IHcgPSBmcmFtZWJ1ZmZlci53aWR0aDtcbiAgICBjb25zdCBoID0gZnJhbWVidWZmZXIuaGVpZ2h0O1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBjb25zdCBzdGVuY2lsID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG4gICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIHN0ZW5jaWwpO1xuICAgIGlmIChmYm8ubXNhYUJ1ZmZlcikge1xuICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKGdsLlJFTkRFUkJVRkZFUiwgZmJvLm11bHRpc2FtcGxlLCBnbC5ERVBUSDI0X1NURU5DSUw4LCB3LCBoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX1NURU5DSUwsIHcsIGgpO1xuICAgIH1cbiAgICBmYm8uc3RlbmNpbCA9IHN0ZW5jaWw7XG4gICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgZ2wuUkVOREVSQlVGRkVSLCBzdGVuY2lsKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnVua25vd25GcmFtZWJ1ZmZlcjtcbiAgICB0aGlzLnZpZXdwb3J0ID0gbmV3IFJlY3RhbmdsZSgpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cbkZyYW1lYnVmZmVyU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJmcmFtZWJ1ZmZlclwiXG59O1xuZXh0ZW5zaW9ucy5hZGQoRnJhbWVidWZmZXJTeXN0ZW0pO1xuXG5leHBvcnQgeyBGcmFtZWJ1ZmZlclN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnJhbWVidWZmZXJTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRU5WLCBCVUZGRVJfVFlQRSB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvZXh0ZW5zaW9ucyc7XG5pbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gJ0BwaXhpL3NldHRpbmdzJztcblxuY29uc3QgYnl0ZVNpemVNYXAgPSB7IDUxMjY6IDQsIDUxMjM6IDIsIDUxMjE6IDEgfTtcbmNsYXNzIEdlb21ldHJ5U3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5fYWN0aXZlR2VvbWV0cnkgPSBudWxsO1xuICAgIHRoaXMuX2FjdGl2ZVZhbyA9IG51bGw7XG4gICAgdGhpcy5oYXNWYW8gPSB0cnVlO1xuICAgIHRoaXMuaGFzSW5zdGFuY2UgPSB0cnVlO1xuICAgIHRoaXMuY2FuVXNlVUludDMyRWxlbWVudEluZGV4ID0gZmFsc2U7XG4gICAgdGhpcy5tYW5hZ2VkR2VvbWV0cmllcyA9IHt9O1xuICB9XG4gIGNvbnRleHRDaGFuZ2UoKSB7XG4gICAgdGhpcy5kaXNwb3NlQWxsKHRydWUpO1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMucmVuZGVyZXIuY29udGV4dDtcbiAgICB0aGlzLkNPTlRFWFRfVUlEID0gdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRDtcbiAgICBpZiAoY29udGV4dC53ZWJHTFZlcnNpb24gIT09IDIpIHtcbiAgICAgIGxldCBuYXRpdmVWYW9FeHRlbnNpb24gPSB0aGlzLnJlbmRlcmVyLmNvbnRleHQuZXh0ZW5zaW9ucy52ZXJ0ZXhBcnJheU9iamVjdDtcbiAgICAgIGlmIChzZXR0aW5ncy5QUkVGRVJfRU5WID09PSBFTlYuV0VCR0xfTEVHQUNZKSB7XG4gICAgICAgIG5hdGl2ZVZhb0V4dGVuc2lvbiA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAobmF0aXZlVmFvRXh0ZW5zaW9uKSB7XG4gICAgICAgIGdsLmNyZWF0ZVZlcnRleEFycmF5ID0gKCkgPT4gbmF0aXZlVmFvRXh0ZW5zaW9uLmNyZWF0ZVZlcnRleEFycmF5T0VTKCk7XG4gICAgICAgIGdsLmJpbmRWZXJ0ZXhBcnJheSA9ICh2YW8pID0+IG5hdGl2ZVZhb0V4dGVuc2lvbi5iaW5kVmVydGV4QXJyYXlPRVModmFvKTtcbiAgICAgICAgZ2wuZGVsZXRlVmVydGV4QXJyYXkgPSAodmFvKSA9PiBuYXRpdmVWYW9FeHRlbnNpb24uZGVsZXRlVmVydGV4QXJyYXlPRVModmFvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFzVmFvID0gZmFsc2U7XG4gICAgICAgIGdsLmNyZWF0ZVZlcnRleEFycmF5ID0gKCkgPT4gbnVsbDtcbiAgICAgICAgZ2wuYmluZFZlcnRleEFycmF5ID0gKCkgPT4gbnVsbDtcbiAgICAgICAgZ2wuZGVsZXRlVmVydGV4QXJyYXkgPSAoKSA9PiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGV4dC53ZWJHTFZlcnNpb24gIT09IDIpIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlRXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKFwiQU5HTEVfaW5zdGFuY2VkX2FycmF5c1wiKTtcbiAgICAgIGlmIChpbnN0YW5jZUV4dCkge1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yID0gKGEsIGIpID0+IGluc3RhbmNlRXh0LnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRShhLCBiKTtcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzSW5zdGFuY2VkID0gKGEsIGIsIGMsIGQsIGUpID0+IGluc3RhbmNlRXh0LmRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFKGEsIGIsIGMsIGQsIGUpO1xuICAgICAgICBnbC5kcmF3QXJyYXlzSW5zdGFuY2VkID0gKGEsIGIsIGMsIGQpID0+IGluc3RhbmNlRXh0LmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRShhLCBiLCBjLCBkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFzSW5zdGFuY2UgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jYW5Vc2VVSW50MzJFbGVtZW50SW5kZXggPSBjb250ZXh0LndlYkdMVmVyc2lvbiA9PT0gMiB8fCAhIWNvbnRleHQuZXh0ZW5zaW9ucy51aW50MzJFbGVtZW50SW5kZXg7XG4gIH1cbiAgYmluZChnZW9tZXRyeSwgc2hhZGVyKSB7XG4gICAgc2hhZGVyID0gc2hhZGVyIHx8IHRoaXMucmVuZGVyZXIuc2hhZGVyLnNoYWRlcjtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzO1xuICAgIGxldCB2YW9zID0gZ2VvbWV0cnkuZ2xWZXJ0ZXhBcnJheU9iamVjdHNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgbGV0IGluY1JlZkNvdW50ID0gZmFsc2U7XG4gICAgaWYgKCF2YW9zKSB7XG4gICAgICB0aGlzLm1hbmFnZWRHZW9tZXRyaWVzW2dlb21ldHJ5LmlkXSA9IGdlb21ldHJ5O1xuICAgICAgZ2VvbWV0cnkuZGlzcG9zZVJ1bm5lci5hZGQodGhpcyk7XG4gICAgICBnZW9tZXRyeS5nbFZlcnRleEFycmF5T2JqZWN0c1t0aGlzLkNPTlRFWFRfVUlEXSA9IHZhb3MgPSB7fTtcbiAgICAgIGluY1JlZkNvdW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgdmFvID0gdmFvc1tzaGFkZXIucHJvZ3JhbS5pZF0gfHwgdGhpcy5pbml0R2VvbWV0cnlWYW8oZ2VvbWV0cnksIHNoYWRlciwgaW5jUmVmQ291bnQpO1xuICAgIHRoaXMuX2FjdGl2ZUdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZVZhbyAhPT0gdmFvKSB7XG4gICAgICB0aGlzLl9hY3RpdmVWYW8gPSB2YW87XG4gICAgICBpZiAodGhpcy5oYXNWYW8pIHtcbiAgICAgICAgZ2wuYmluZFZlcnRleEFycmF5KHZhbyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFjdGl2YXRlVmFvKGdlb21ldHJ5LCBzaGFkZXIucHJvZ3JhbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudXBkYXRlQnVmZmVycygpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMudW5iaW5kKCk7XG4gIH1cbiAgdXBkYXRlQnVmZmVycygpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuX2FjdGl2ZUdlb21ldHJ5O1xuICAgIGNvbnN0IGJ1ZmZlclN5c3RlbSA9IHRoaXMucmVuZGVyZXIuYnVmZmVyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvbWV0cnkuYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYnVmZmVyID0gZ2VvbWV0cnkuYnVmZmVyc1tpXTtcbiAgICAgIGJ1ZmZlclN5c3RlbS51cGRhdGUoYnVmZmVyKTtcbiAgICB9XG4gIH1cbiAgY2hlY2tDb21wYXRpYmlsaXR5KGdlb21ldHJ5LCBwcm9ncmFtKSB7XG4gICAgY29uc3QgZ2VvbWV0cnlBdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcbiAgICBjb25zdCBzaGFkZXJBdHRyaWJ1dGVzID0gcHJvZ3JhbS5hdHRyaWJ1dGVEYXRhO1xuICAgIGZvciAoY29uc3QgaiBpbiBzaGFkZXJBdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoIWdlb21ldHJ5QXR0cmlidXRlc1tqXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNoYWRlciBhbmQgZ2VvbWV0cnkgaW5jb21wYXRpYmxlLCBnZW9tZXRyeSBtaXNzaW5nIHRoZSBcIiR7an1cIiBhdHRyaWJ1dGVgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0U2lnbmF0dXJlKGdlb21ldHJ5LCBwcm9ncmFtKSB7XG4gICAgY29uc3QgYXR0cmlicyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgY29uc3Qgc2hhZGVyQXR0cmlidXRlcyA9IHByb2dyYW0uYXR0cmlidXRlRGF0YTtcbiAgICBjb25zdCBzdHJpbmdzID0gW1wiZ1wiLCBnZW9tZXRyeS5pZF07XG4gICAgZm9yIChjb25zdCBpIGluIGF0dHJpYnMpIHtcbiAgICAgIGlmIChzaGFkZXJBdHRyaWJ1dGVzW2ldKSB7XG4gICAgICAgIHN0cmluZ3MucHVzaChpLCBzaGFkZXJBdHRyaWJ1dGVzW2ldLmxvY2F0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ3Muam9pbihcIi1cIik7XG4gIH1cbiAgaW5pdEdlb21ldHJ5VmFvKGdlb21ldHJ5LCBzaGFkZXIsIGluY1JlZkNvdW50ID0gdHJ1ZSkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBjb25zdCBDT05URVhUX1VJRCA9IHRoaXMuQ09OVEVYVF9VSUQ7XG4gICAgY29uc3QgYnVmZmVyU3lzdGVtID0gdGhpcy5yZW5kZXJlci5idWZmZXI7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHNoYWRlci5wcm9ncmFtO1xuICAgIGlmICghcHJvZ3JhbS5nbFByb2dyYW1zW0NPTlRFWFRfVUlEXSkge1xuICAgICAgdGhpcy5yZW5kZXJlci5zaGFkZXIuZ2VuZXJhdGVQcm9ncmFtKHNoYWRlcik7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tDb21wYXRpYmlsaXR5KGdlb21ldHJ5LCBwcm9ncmFtKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSB0aGlzLmdldFNpZ25hdHVyZShnZW9tZXRyeSwgcHJvZ3JhbSk7XG4gICAgY29uc3QgdmFvT2JqZWN0SGFzaCA9IGdlb21ldHJ5LmdsVmVydGV4QXJyYXlPYmplY3RzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgIGxldCB2YW8gPSB2YW9PYmplY3RIYXNoW3NpZ25hdHVyZV07XG4gICAgaWYgKHZhbykge1xuICAgICAgdmFvT2JqZWN0SGFzaFtwcm9ncmFtLmlkXSA9IHZhbztcbiAgICAgIHJldHVybiB2YW87XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlcnMgPSBnZW9tZXRyeS5idWZmZXJzO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuICAgIGNvbnN0IHRlbXBTdHJpZGUgPSB7fTtcbiAgICBjb25zdCB0ZW1wU3RhcnQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGogaW4gYnVmZmVycykge1xuICAgICAgdGVtcFN0cmlkZVtqXSA9IDA7XG4gICAgICB0ZW1wU3RhcnRbal0gPSAwO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGogaW4gYXR0cmlidXRlcykge1xuICAgICAgaWYgKCFhdHRyaWJ1dGVzW2pdLnNpemUgJiYgcHJvZ3JhbS5hdHRyaWJ1dGVEYXRhW2pdKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbal0uc2l6ZSA9IHByb2dyYW0uYXR0cmlidXRlRGF0YVtqXS5zaXplO1xuICAgICAgfSBlbHNlIGlmICghYXR0cmlidXRlc1tqXS5zaXplKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgUElYSSBHZW9tZXRyeSBhdHRyaWJ1dGUgJyR7an0nIHNpemUgY2Fubm90IGJlIGRldGVybWluZWQgKGxpa2VseSB0aGUgYm91bmQgc2hhZGVyIGRvZXMgbm90IGhhdmUgdGhlIGF0dHJpYnV0ZSlgKTtcbiAgICAgIH1cbiAgICAgIHRlbXBTdHJpZGVbYXR0cmlidXRlc1tqXS5idWZmZXJdICs9IGF0dHJpYnV0ZXNbal0uc2l6ZSAqIGJ5dGVTaXplTWFwW2F0dHJpYnV0ZXNbal0udHlwZV07XG4gICAgfVxuICAgIGZvciAoY29uc3QgaiBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2pdO1xuICAgICAgY29uc3QgYXR0cmliU2l6ZSA9IGF0dHJpYnV0ZS5zaXplO1xuICAgICAgaWYgKGF0dHJpYnV0ZS5zdHJpZGUgPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAodGVtcFN0cmlkZVthdHRyaWJ1dGUuYnVmZmVyXSA9PT0gYXR0cmliU2l6ZSAqIGJ5dGVTaXplTWFwW2F0dHJpYnV0ZS50eXBlXSkge1xuICAgICAgICAgIGF0dHJpYnV0ZS5zdHJpZGUgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF0dHJpYnV0ZS5zdHJpZGUgPSB0ZW1wU3RyaWRlW2F0dHJpYnV0ZS5idWZmZXJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYXR0cmlidXRlLnN0YXJ0ID09PSB2b2lkIDApIHtcbiAgICAgICAgYXR0cmlidXRlLnN0YXJ0ID0gdGVtcFN0YXJ0W2F0dHJpYnV0ZS5idWZmZXJdO1xuICAgICAgICB0ZW1wU3RhcnRbYXR0cmlidXRlLmJ1ZmZlcl0gKz0gYXR0cmliU2l6ZSAqIGJ5dGVTaXplTWFwW2F0dHJpYnV0ZS50eXBlXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFvID0gZ2wuY3JlYXRlVmVydGV4QXJyYXkoKTtcbiAgICBnbC5iaW5kVmVydGV4QXJyYXkodmFvKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGJ1ZmZlcnNbaV07XG4gICAgICBidWZmZXJTeXN0ZW0uYmluZChidWZmZXIpO1xuICAgICAgaWYgKGluY1JlZkNvdW50KSB7XG4gICAgICAgIGJ1ZmZlci5fZ2xCdWZmZXJzW0NPTlRFWFRfVUlEXS5yZWZDb3VudCsrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFjdGl2YXRlVmFvKGdlb21ldHJ5LCBwcm9ncmFtKTtcbiAgICB2YW9PYmplY3RIYXNoW3Byb2dyYW0uaWRdID0gdmFvO1xuICAgIHZhb09iamVjdEhhc2hbc2lnbmF0dXJlXSA9IHZhbztcbiAgICBnbC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XG4gICAgYnVmZmVyU3lzdGVtLnVuYmluZChCVUZGRVJfVFlQRS5BUlJBWV9CVUZGRVIpO1xuICAgIHJldHVybiB2YW87XG4gIH1cbiAgZGlzcG9zZUdlb21ldHJ5KGdlb21ldHJ5LCBjb250ZXh0TG9zdCkge1xuICAgIGlmICghdGhpcy5tYW5hZ2VkR2VvbWV0cmllc1tnZW9tZXRyeS5pZF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMubWFuYWdlZEdlb21ldHJpZXNbZ2VvbWV0cnkuaWRdO1xuICAgIGNvbnN0IHZhb3MgPSBnZW9tZXRyeS5nbFZlcnRleEFycmF5T2JqZWN0c1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgY29uc3QgYnVmZmVycyA9IGdlb21ldHJ5LmJ1ZmZlcnM7XG4gICAgY29uc3QgYnVmZmVyU3lzdGVtID0gdGhpcy5yZW5kZXJlcj8uYnVmZmVyO1xuICAgIGdlb21ldHJ5LmRpc3Bvc2VSdW5uZXIucmVtb3ZlKHRoaXMpO1xuICAgIGlmICghdmFvcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYnVmZmVyU3lzdGVtKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYnVmID0gYnVmZmVyc1tpXS5fZ2xCdWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgICAgICBpZiAoYnVmKSB7XG4gICAgICAgICAgYnVmLnJlZkNvdW50LS07XG4gICAgICAgICAgaWYgKGJ1Zi5yZWZDb3VudCA9PT0gMCAmJiAhY29udGV4dExvc3QpIHtcbiAgICAgICAgICAgIGJ1ZmZlclN5c3RlbS5kaXNwb3NlKGJ1ZmZlcnNbaV0sIGNvbnRleHRMb3N0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjb250ZXh0TG9zdCkge1xuICAgICAgZm9yIChjb25zdCB2YW9JZCBpbiB2YW9zKSB7XG4gICAgICAgIGlmICh2YW9JZFswXSA9PT0gXCJnXCIpIHtcbiAgICAgICAgICBjb25zdCB2YW8gPSB2YW9zW3Zhb0lkXTtcbiAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlVmFvID09PSB2YW8pIHtcbiAgICAgICAgICAgIHRoaXMudW5iaW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdsLmRlbGV0ZVZlcnRleEFycmF5KHZhbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlIGdlb21ldHJ5LmdsVmVydGV4QXJyYXlPYmplY3RzW3RoaXMuQ09OVEVYVF9VSURdO1xuICB9XG4gIGRpc3Bvc2VBbGwoY29udGV4dExvc3QpIHtcbiAgICBjb25zdCBhbGwgPSBPYmplY3Qua2V5cyh0aGlzLm1hbmFnZWRHZW9tZXRyaWVzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5kaXNwb3NlR2VvbWV0cnkodGhpcy5tYW5hZ2VkR2VvbWV0cmllc1thbGxbaV1dLCBjb250ZXh0TG9zdCk7XG4gICAgfVxuICB9XG4gIGFjdGl2YXRlVmFvKGdlb21ldHJ5LCBwcm9ncmFtKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGNvbnN0IENPTlRFWFRfVUlEID0gdGhpcy5DT05URVhUX1VJRDtcbiAgICBjb25zdCBidWZmZXJTeXN0ZW0gPSB0aGlzLnJlbmRlcmVyLmJ1ZmZlcjtcbiAgICBjb25zdCBidWZmZXJzID0gZ2VvbWV0cnkuYnVmZmVycztcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcbiAgICBpZiAoZ2VvbWV0cnkuaW5kZXhCdWZmZXIpIHtcbiAgICAgIGJ1ZmZlclN5c3RlbS5iaW5kKGdlb21ldHJ5LmluZGV4QnVmZmVyKTtcbiAgICB9XG4gICAgbGV0IGxhc3RCdWZmZXIgPSBudWxsO1xuICAgIGZvciAoY29uc3QgaiBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2pdO1xuICAgICAgY29uc3QgYnVmZmVyID0gYnVmZmVyc1thdHRyaWJ1dGUuYnVmZmVyXTtcbiAgICAgIGNvbnN0IGdsQnVmZmVyID0gYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdO1xuICAgICAgaWYgKHByb2dyYW0uYXR0cmlidXRlRGF0YVtqXSkge1xuICAgICAgICBpZiAobGFzdEJ1ZmZlciAhPT0gZ2xCdWZmZXIpIHtcbiAgICAgICAgICBidWZmZXJTeXN0ZW0uYmluZChidWZmZXIpO1xuICAgICAgICAgIGxhc3RCdWZmZXIgPSBnbEJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHByb2dyYW0uYXR0cmlidXRlRGF0YVtqXS5sb2NhdGlvbjtcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobG9jYXRpb24pO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGxvY2F0aW9uLCBhdHRyaWJ1dGUuc2l6ZSwgYXR0cmlidXRlLnR5cGUgfHwgZ2wuRkxPQVQsIGF0dHJpYnV0ZS5ub3JtYWxpemVkLCBhdHRyaWJ1dGUuc3RyaWRlLCBhdHRyaWJ1dGUuc3RhcnQpO1xuICAgICAgICBpZiAoYXR0cmlidXRlLmluc3RhbmNlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaGFzSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IobG9jYXRpb24sIGF0dHJpYnV0ZS5kaXZpc29yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2VvbWV0cnkgZXJyb3IsIEdQVSBJbnN0YW5jaW5nIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2VcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRyYXcodHlwZSwgc2l6ZSwgc3RhcnQsIGluc3RhbmNlQ291bnQpIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzO1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5fYWN0aXZlR2VvbWV0cnk7XG4gICAgaWYgKGdlb21ldHJ5LmluZGV4QnVmZmVyKSB7XG4gICAgICBjb25zdCBieXRlU2l6ZSA9IGdlb21ldHJ5LmluZGV4QnVmZmVyLmRhdGEuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgICBjb25zdCBnbFR5cGUgPSBieXRlU2l6ZSA9PT0gMiA/IGdsLlVOU0lHTkVEX1NIT1JUIDogZ2wuVU5TSUdORURfSU5UO1xuICAgICAgaWYgKGJ5dGVTaXplID09PSAyIHx8IGJ5dGVTaXplID09PSA0ICYmIHRoaXMuY2FuVXNlVUludDMyRWxlbWVudEluZGV4KSB7XG4gICAgICAgIGlmIChnZW9tZXRyeS5pbnN0YW5jZWQpIHtcbiAgICAgICAgICBnbC5kcmF3RWxlbWVudHNJbnN0YW5jZWQodHlwZSwgc2l6ZSB8fCBnZW9tZXRyeS5pbmRleEJ1ZmZlci5kYXRhLmxlbmd0aCwgZ2xUeXBlLCAoc3RhcnQgfHwgMCkgKiBieXRlU2l6ZSwgaW5zdGFuY2VDb3VudCB8fCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnbC5kcmF3RWxlbWVudHModHlwZSwgc2l6ZSB8fCBnZW9tZXRyeS5pbmRleEJ1ZmZlci5kYXRhLmxlbmd0aCwgZ2xUeXBlLCAoc3RhcnQgfHwgMCkgKiBieXRlU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcInVuc3VwcG9ydGVkIGluZGV4IGJ1ZmZlciB0eXBlOiB1aW50MzJcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeS5pbnN0YW5jZWQpIHtcbiAgICAgIGdsLmRyYXdBcnJheXNJbnN0YW5jZWQodHlwZSwgc3RhcnQsIHNpemUgfHwgZ2VvbWV0cnkuZ2V0U2l6ZSgpLCBpbnN0YW5jZUNvdW50IHx8IDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC5kcmF3QXJyYXlzKHR5cGUsIHN0YXJ0LCBzaXplIHx8IGdlb21ldHJ5LmdldFNpemUoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHVuYmluZCgpIHtcbiAgICB0aGlzLmdsLmJpbmRWZXJ0ZXhBcnJheShudWxsKTtcbiAgICB0aGlzLl9hY3RpdmVWYW8gPSBudWxsO1xuICAgIHRoaXMuX2FjdGl2ZUdlb21ldHJ5ID0gbnVsbDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG5HZW9tZXRyeVN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwiZ2VvbWV0cnlcIlxufTtcbmV4dGVuc2lvbnMuYWRkKEdlb21ldHJ5U3lzdGVtKTtcblxuZXhwb3J0IHsgR2VvbWV0cnlTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdlb21ldHJ5U3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gJ0BwaXhpL21hdGgnO1xuXG5jb25zdCB0ZW1wTWF0ID0gbmV3IE1hdHJpeCgpO1xuY2xhc3MgVGV4dHVyZU1hdHJpeCB7XG4gIGNvbnN0cnVjdG9yKHRleHR1cmUsIGNsYW1wTWFyZ2luKSB7XG4gICAgdGhpcy5fdGV4dHVyZSA9IHRleHR1cmU7XG4gICAgdGhpcy5tYXBDb29yZCA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLnVDbGFtcEZyYW1lID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgICB0aGlzLnVDbGFtcE9mZnNldCA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG4gICAgdGhpcy5fdGV4dHVyZUlEID0gLTE7XG4gICAgdGhpcy5fdXBkYXRlSUQgPSAwO1xuICAgIHRoaXMuY2xhbXBPZmZzZXQgPSAwO1xuICAgIHRoaXMuY2xhbXBNYXJnaW4gPSB0eXBlb2YgY2xhbXBNYXJnaW4gPT09IFwidW5kZWZpbmVkXCIgPyAwLjUgOiBjbGFtcE1hcmdpbjtcbiAgICB0aGlzLmlzU2ltcGxlID0gZmFsc2U7XG4gIH1cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmU7XG4gIH1cbiAgc2V0IHRleHR1cmUodmFsdWUpIHtcbiAgICB0aGlzLl90ZXh0dXJlID0gdmFsdWU7XG4gICAgdGhpcy5fdGV4dHVyZUlEID0gLTE7XG4gIH1cbiAgbXVsdGlwbHlVdnModXZzLCBvdXQpIHtcbiAgICBpZiAob3V0ID09PSB2b2lkIDApIHtcbiAgICAgIG91dCA9IHV2cztcbiAgICB9XG4gICAgY29uc3QgbWF0ID0gdGhpcy5tYXBDb29yZDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHV2cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgY29uc3QgeCA9IHV2c1tpXTtcbiAgICAgIGNvbnN0IHkgPSB1dnNbaSArIDFdO1xuICAgICAgb3V0W2ldID0geCAqIG1hdC5hICsgeSAqIG1hdC5jICsgbWF0LnR4O1xuICAgICAgb3V0W2kgKyAxXSA9IHggKiBtYXQuYiArIHkgKiBtYXQuZCArIG1hdC50eTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICB1cGRhdGUoZm9yY2VVcGRhdGUpIHtcbiAgICBjb25zdCB0ZXggPSB0aGlzLl90ZXh0dXJlO1xuICAgIGlmICghdGV4IHx8ICF0ZXgudmFsaWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFmb3JjZVVwZGF0ZSAmJiB0aGlzLl90ZXh0dXJlSUQgPT09IHRleC5fdXBkYXRlSUQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fdGV4dHVyZUlEID0gdGV4Ll91cGRhdGVJRDtcbiAgICB0aGlzLl91cGRhdGVJRCsrO1xuICAgIGNvbnN0IHV2cyA9IHRleC5fdXZzO1xuICAgIHRoaXMubWFwQ29vcmQuc2V0KHV2cy54MSAtIHV2cy54MCwgdXZzLnkxIC0gdXZzLnkwLCB1dnMueDMgLSB1dnMueDAsIHV2cy55MyAtIHV2cy55MCwgdXZzLngwLCB1dnMueTApO1xuICAgIGNvbnN0IG9yaWcgPSB0ZXgub3JpZztcbiAgICBjb25zdCB0cmltID0gdGV4LnRyaW07XG4gICAgaWYgKHRyaW0pIHtcbiAgICAgIHRlbXBNYXQuc2V0KG9yaWcud2lkdGggLyB0cmltLndpZHRoLCAwLCAwLCBvcmlnLmhlaWdodCAvIHRyaW0uaGVpZ2h0LCAtdHJpbS54IC8gdHJpbS53aWR0aCwgLXRyaW0ueSAvIHRyaW0uaGVpZ2h0KTtcbiAgICAgIHRoaXMubWFwQ29vcmQuYXBwZW5kKHRlbXBNYXQpO1xuICAgIH1cbiAgICBjb25zdCB0ZXhCYXNlID0gdGV4LmJhc2VUZXh0dXJlO1xuICAgIGNvbnN0IGZyYW1lID0gdGhpcy51Q2xhbXBGcmFtZTtcbiAgICBjb25zdCBtYXJnaW4gPSB0aGlzLmNsYW1wTWFyZ2luIC8gdGV4QmFzZS5yZXNvbHV0aW9uO1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuY2xhbXBPZmZzZXQ7XG4gICAgZnJhbWVbMF0gPSAodGV4Ll9mcmFtZS54ICsgbWFyZ2luICsgb2Zmc2V0KSAvIHRleEJhc2Uud2lkdGg7XG4gICAgZnJhbWVbMV0gPSAodGV4Ll9mcmFtZS55ICsgbWFyZ2luICsgb2Zmc2V0KSAvIHRleEJhc2UuaGVpZ2h0O1xuICAgIGZyYW1lWzJdID0gKHRleC5fZnJhbWUueCArIHRleC5fZnJhbWUud2lkdGggLSBtYXJnaW4gKyBvZmZzZXQpIC8gdGV4QmFzZS53aWR0aDtcbiAgICBmcmFtZVszXSA9ICh0ZXguX2ZyYW1lLnkgKyB0ZXguX2ZyYW1lLmhlaWdodCAtIG1hcmdpbiArIG9mZnNldCkgLyB0ZXhCYXNlLmhlaWdodDtcbiAgICB0aGlzLnVDbGFtcE9mZnNldFswXSA9IG9mZnNldCAvIHRleEJhc2UucmVhbFdpZHRoO1xuICAgIHRoaXMudUNsYW1wT2Zmc2V0WzFdID0gb2Zmc2V0IC8gdGV4QmFzZS5yZWFsSGVpZ2h0O1xuICAgIHRoaXMuaXNTaW1wbGUgPSB0ZXguX2ZyYW1lLndpZHRoID09PSB0ZXhCYXNlLndpZHRoICYmIHRleC5fZnJhbWUuaGVpZ2h0ID09PSB0ZXhCYXNlLmhlaWdodCAmJiB0ZXgucm90YXRlID09PSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCB7IFRleHR1cmVNYXRyaXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHR1cmVNYXRyaXgubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzIgdk1hc2tDb29yZDtcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG51bmlmb3JtIHNhbXBsZXIyRCBtYXNrO1xcbnVuaWZvcm0gZmxvYXQgYWxwaGE7XFxudW5pZm9ybSBmbG9hdCBucG1BbHBoYTtcXG51bmlmb3JtIHZlYzQgbWFza0NsYW1wO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgZmxvYXQgY2xpcCA9IHN0ZXAoMy41LFxcbiAgICAgICAgc3RlcChtYXNrQ2xhbXAueCwgdk1hc2tDb29yZC54KSArXFxuICAgICAgICBzdGVwKG1hc2tDbGFtcC55LCB2TWFza0Nvb3JkLnkpICtcXG4gICAgICAgIHN0ZXAodk1hc2tDb29yZC54LCBtYXNrQ2xhbXAueikgK1xcbiAgICAgICAgc3RlcCh2TWFza0Nvb3JkLnksIG1hc2tDbGFtcC53KSk7XFxuXFxuICAgIHZlYzQgb3JpZ2luYWwgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcbiAgICB2ZWM0IG1hc2t5ID0gdGV4dHVyZTJEKG1hc2ssIHZNYXNrQ29vcmQpO1xcbiAgICBmbG9hdCBhbHBoYU11bCA9IDEuMCAtIG5wbUFscGhhICogKDEuMCAtIG1hc2t5LmEpO1xcblxcbiAgICBvcmlnaW5hbCAqPSAoYWxwaGFNdWwgKiBtYXNreS5yICogYWxwaGEgKiBjbGlwKTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gb3JpZ2luYWw7XFxufVxcblwiO1xuXG5leHBvcnQgeyBmcmFnbWVudCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcHJpdGVNYXNrRmlsdGVyMi5tanMubWFwXG4iLCJ2YXIgdmVydGV4ID0gXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG51bmlmb3JtIG1hdDMgb3RoZXJNYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZNYXNrQ29vcmQ7XFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXG5cXG4gICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxuICAgIHZNYXNrQ29vcmQgPSAoIG90aGVyTWF0cml4ICogdmVjMyggYVRleHR1cmVDb29yZCwgMS4wKSAgKS54eTtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IHZlcnRleCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcHJpdGVNYXNrRmlsdGVyMy5tanMubWFwXG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tICdAcGl4aS9tYXRoJztcbmltcG9ydCB7IFRleHR1cmVNYXRyaXggfSBmcm9tICcuLi8uLi90ZXh0dXJlcy9UZXh0dXJlTWF0cml4Lm1qcyc7XG5pbXBvcnQgeyBGaWx0ZXIgfSBmcm9tICcuLi9GaWx0ZXIubWpzJztcbmltcG9ydCBmcmFnbWVudCBmcm9tICcuL3Nwcml0ZU1hc2tGaWx0ZXIyLm1qcyc7XG5pbXBvcnQgdmVydGV4IGZyb20gJy4vc3ByaXRlTWFza0ZpbHRlcjMubWpzJztcblxuY2xhc3MgU3ByaXRlTWFza0ZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yKHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIHVuaWZvcm1zKSB7XG4gICAgbGV0IHNwcml0ZSA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiB2ZXJ0ZXhTcmMgIT09IFwic3RyaW5nXCIgJiYgZnJhZ21lbnRTcmMgPT09IHZvaWQgMCAmJiB1bmlmb3JtcyA9PT0gdm9pZCAwKSB7XG4gICAgICBzcHJpdGUgPSB2ZXJ0ZXhTcmM7XG4gICAgICB2ZXJ0ZXhTcmMgPSB2b2lkIDA7XG4gICAgICBmcmFnbWVudFNyYyA9IHZvaWQgMDtcbiAgICAgIHVuaWZvcm1zID0gdm9pZCAwO1xuICAgIH1cbiAgICBzdXBlcih2ZXJ0ZXhTcmMgfHwgdmVydGV4LCBmcmFnbWVudFNyYyB8fCBmcmFnbWVudCwgdW5pZm9ybXMpO1xuICAgIHRoaXMubWFza1Nwcml0ZSA9IHNwcml0ZTtcbiAgICB0aGlzLm1hc2tNYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gIH1cbiAgZ2V0IG1hc2tTcHJpdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hc2tTcHJpdGU7XG4gIH1cbiAgc2V0IG1hc2tTcHJpdGUodmFsdWUpIHtcbiAgICB0aGlzLl9tYXNrU3ByaXRlID0gdmFsdWU7XG4gICAgaWYgKHRoaXMuX21hc2tTcHJpdGUpIHtcbiAgICAgIHRoaXMuX21hc2tTcHJpdGUucmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpIHtcbiAgICBjb25zdCBtYXNrU3ByaXRlID0gdGhpcy5fbWFza1Nwcml0ZTtcbiAgICBjb25zdCB0ZXggPSBtYXNrU3ByaXRlLl90ZXh0dXJlO1xuICAgIGlmICghdGV4LnZhbGlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGV4LnV2TWF0cml4KSB7XG4gICAgICB0ZXgudXZNYXRyaXggPSBuZXcgVGV4dHVyZU1hdHJpeCh0ZXgsIDApO1xuICAgIH1cbiAgICB0ZXgudXZNYXRyaXgudXBkYXRlKCk7XG4gICAgdGhpcy51bmlmb3Jtcy5ucG1BbHBoYSA9IHRleC5iYXNlVGV4dHVyZS5hbHBoYU1vZGUgPyAwIDogMTtcbiAgICB0aGlzLnVuaWZvcm1zLm1hc2sgPSB0ZXg7XG4gICAgdGhpcy51bmlmb3Jtcy5vdGhlck1hdHJpeCA9IGZpbHRlck1hbmFnZXIuY2FsY3VsYXRlU3ByaXRlTWF0cml4KHRoaXMubWFza01hdHJpeCwgbWFza1Nwcml0ZSkucHJlcGVuZCh0ZXgudXZNYXRyaXgubWFwQ29vcmQpO1xuICAgIHRoaXMudW5pZm9ybXMuYWxwaGEgPSBtYXNrU3ByaXRlLndvcmxkQWxwaGE7XG4gICAgdGhpcy51bmlmb3Jtcy5tYXNrQ2xhbXAgPSB0ZXgudXZNYXRyaXgudUNsYW1wRnJhbWU7XG4gICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpO1xuICB9XG59XG5cbmV4cG9ydCB7IFNwcml0ZU1hc2tGaWx0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNwcml0ZU1hc2tGaWx0ZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgTUFTS19UWVBFUyB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBGaWx0ZXIgfSBmcm9tICcuLi9maWx0ZXJzL0ZpbHRlci5tanMnO1xuXG5jbGFzcyBNYXNrRGF0YSB7XG4gIGNvbnN0cnVjdG9yKG1hc2tPYmplY3QgPSBudWxsKSB7XG4gICAgdGhpcy50eXBlID0gTUFTS19UWVBFUy5OT05FO1xuICAgIHRoaXMuYXV0b0RldGVjdCA9IHRydWU7XG4gICAgdGhpcy5tYXNrT2JqZWN0ID0gbWFza09iamVjdCB8fCBudWxsO1xuICAgIHRoaXMucG9vbGVkID0gZmFsc2U7XG4gICAgdGhpcy5pc01hc2tEYXRhID0gdHJ1ZTtcbiAgICB0aGlzLnJlc29sdXRpb24gPSBudWxsO1xuICAgIHRoaXMubXVsdGlzYW1wbGUgPSBGaWx0ZXIuZGVmYXVsdE11bHRpc2FtcGxlO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5jb2xvck1hc2sgPSAxNTtcbiAgICB0aGlzLl9maWx0ZXJzID0gbnVsbDtcbiAgICB0aGlzLl9zdGVuY2lsQ291bnRlciA9IDA7XG4gICAgdGhpcy5fc2Npc3NvckNvdW50ZXIgPSAwO1xuICAgIHRoaXMuX3NjaXNzb3JSZWN0ID0gbnVsbDtcbiAgICB0aGlzLl9zY2lzc29yUmVjdExvY2FsID0gbnVsbDtcbiAgICB0aGlzLl9jb2xvck1hc2sgPSAxNTtcbiAgICB0aGlzLl90YXJnZXQgPSBudWxsO1xuICB9XG4gIGdldCBmaWx0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbHRlcnMgPyB0aGlzLl9maWx0ZXJzWzBdIDogbnVsbDtcbiAgfVxuICBzZXQgZmlsdGVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5fZmlsdGVycykge1xuICAgICAgICB0aGlzLl9maWx0ZXJzWzBdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9maWx0ZXJzID0gW3ZhbHVlXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZmlsdGVycyA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLnBvb2xlZCkge1xuICAgICAgdGhpcy5tYXNrT2JqZWN0ID0gbnVsbDtcbiAgICAgIHRoaXMudHlwZSA9IE1BU0tfVFlQRVMuTk9ORTtcbiAgICAgIHRoaXMuYXV0b0RldGVjdCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX3RhcmdldCA9IG51bGw7XG4gICAgdGhpcy5fc2Npc3NvclJlY3RMb2NhbCA9IG51bGw7XG4gIH1cbiAgY29weUNvdW50ZXJzT3JSZXNldChtYXNrQWJvdmUpIHtcbiAgICBpZiAobWFza0Fib3ZlKSB7XG4gICAgICB0aGlzLl9zdGVuY2lsQ291bnRlciA9IG1hc2tBYm92ZS5fc3RlbmNpbENvdW50ZXI7XG4gICAgICB0aGlzLl9zY2lzc29yQ291bnRlciA9IG1hc2tBYm92ZS5fc2Npc3NvckNvdW50ZXI7XG4gICAgICB0aGlzLl9zY2lzc29yUmVjdCA9IG1hc2tBYm92ZS5fc2Npc3NvclJlY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N0ZW5jaWxDb3VudGVyID0gMDtcbiAgICAgIHRoaXMuX3NjaXNzb3JDb3VudGVyID0gMDtcbiAgICAgIHRoaXMuX3NjaXNzb3JSZWN0ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgTWFza0RhdGEgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hc2tEYXRhLm1qcy5tYXBcbiIsImltcG9ydCB7IE1BU0tfVFlQRVMgfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2V4dGVuc2lvbnMnO1xuaW1wb3J0IHsgU3ByaXRlTWFza0ZpbHRlciB9IGZyb20gJy4uL2ZpbHRlcnMvc3ByaXRlTWFzay9TcHJpdGVNYXNrRmlsdGVyLm1qcyc7XG5pbXBvcnQgeyBNYXNrRGF0YSB9IGZyb20gJy4vTWFza0RhdGEubWpzJztcblxuY2xhc3MgTWFza1N5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMuZW5hYmxlU2Npc3NvciA9IHRydWU7XG4gICAgdGhpcy5hbHBoYU1hc2tQb29sID0gW107XG4gICAgdGhpcy5tYXNrRGF0YVBvb2wgPSBbXTtcbiAgICB0aGlzLm1hc2tTdGFjayA9IFtdO1xuICAgIHRoaXMuYWxwaGFNYXNrSW5kZXggPSAwO1xuICB9XG4gIHNldE1hc2tTdGFjayhtYXNrU3RhY2spIHtcbiAgICB0aGlzLm1hc2tTdGFjayA9IG1hc2tTdGFjaztcbiAgICB0aGlzLnJlbmRlcmVyLnNjaXNzb3Iuc2V0TWFza1N0YWNrKG1hc2tTdGFjayk7XG4gICAgdGhpcy5yZW5kZXJlci5zdGVuY2lsLnNldE1hc2tTdGFjayhtYXNrU3RhY2spO1xuICB9XG4gIHB1c2godGFyZ2V0LCBtYXNrRGF0YU9yVGFyZ2V0KSB7XG4gICAgbGV0IG1hc2tEYXRhID0gbWFza0RhdGFPclRhcmdldDtcbiAgICBpZiAoIW1hc2tEYXRhLmlzTWFza0RhdGEpIHtcbiAgICAgIGNvbnN0IGQgPSB0aGlzLm1hc2tEYXRhUG9vbC5wb3AoKSB8fCBuZXcgTWFza0RhdGEoKTtcbiAgICAgIGQucG9vbGVkID0gdHJ1ZTtcbiAgICAgIGQubWFza09iamVjdCA9IG1hc2tEYXRhT3JUYXJnZXQ7XG4gICAgICBtYXNrRGF0YSA9IGQ7XG4gICAgfVxuICAgIGNvbnN0IG1hc2tBYm92ZSA9IHRoaXMubWFza1N0YWNrLmxlbmd0aCAhPT0gMCA/IHRoaXMubWFza1N0YWNrW3RoaXMubWFza1N0YWNrLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICBtYXNrRGF0YS5jb3B5Q291bnRlcnNPclJlc2V0KG1hc2tBYm92ZSk7XG4gICAgbWFza0RhdGEuX2NvbG9yTWFzayA9IG1hc2tBYm92ZSA/IG1hc2tBYm92ZS5fY29sb3JNYXNrIDogMTU7XG4gICAgaWYgKG1hc2tEYXRhLmF1dG9EZXRlY3QpIHtcbiAgICAgIHRoaXMuZGV0ZWN0KG1hc2tEYXRhKTtcbiAgICB9XG4gICAgbWFza0RhdGEuX3RhcmdldCA9IHRhcmdldDtcbiAgICBpZiAobWFza0RhdGEudHlwZSAhPT0gTUFTS19UWVBFUy5TUFJJVEUpIHtcbiAgICAgIHRoaXMubWFza1N0YWNrLnB1c2gobWFza0RhdGEpO1xuICAgIH1cbiAgICBpZiAobWFza0RhdGEuZW5hYmxlZCkge1xuICAgICAgc3dpdGNoIChtYXNrRGF0YS50eXBlKSB7XG4gICAgICAgIGNhc2UgTUFTS19UWVBFUy5TQ0lTU09SOlxuICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2Npc3Nvci5wdXNoKG1hc2tEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBNQVNLX1RZUEVTLlNURU5DSUw6XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5zdGVuY2lsLnB1c2gobWFza0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE1BU0tfVFlQRVMuU1BSSVRFOlxuICAgICAgICAgIG1hc2tEYXRhLmNvcHlDb3VudGVyc09yUmVzZXQobnVsbCk7XG4gICAgICAgICAgdGhpcy5wdXNoU3ByaXRlTWFzayhtYXNrRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTUFTS19UWVBFUy5DT0xPUjpcbiAgICAgICAgICB0aGlzLnB1c2hDb2xvck1hc2sobWFza0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWFza0RhdGEudHlwZSA9PT0gTUFTS19UWVBFUy5TUFJJVEUpIHtcbiAgICAgIHRoaXMubWFza1N0YWNrLnB1c2gobWFza0RhdGEpO1xuICAgIH1cbiAgfVxuICBwb3AodGFyZ2V0KSB7XG4gICAgY29uc3QgbWFza0RhdGEgPSB0aGlzLm1hc2tTdGFjay5wb3AoKTtcbiAgICBpZiAoIW1hc2tEYXRhIHx8IG1hc2tEYXRhLl90YXJnZXQgIT09IHRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWFza0RhdGEuZW5hYmxlZCkge1xuICAgICAgc3dpdGNoIChtYXNrRGF0YS50eXBlKSB7XG4gICAgICAgIGNhc2UgTUFTS19UWVBFUy5TQ0lTU09SOlxuICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2Npc3Nvci5wb3AobWFza0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE1BU0tfVFlQRVMuU1RFTkNJTDpcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnN0ZW5jaWwucG9wKG1hc2tEYXRhLm1hc2tPYmplY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE1BU0tfVFlQRVMuU1BSSVRFOlxuICAgICAgICAgIHRoaXMucG9wU3ByaXRlTWFzayhtYXNrRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTUFTS19UWVBFUy5DT0xPUjpcbiAgICAgICAgICB0aGlzLnBvcENvbG9yTWFzayhtYXNrRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIG1hc2tEYXRhLnJlc2V0KCk7XG4gICAgaWYgKG1hc2tEYXRhLnBvb2xlZCkge1xuICAgICAgdGhpcy5tYXNrRGF0YVBvb2wucHVzaChtYXNrRGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hc2tTdGFjay5sZW5ndGggIT09IDApIHtcbiAgICAgIGNvbnN0IG1hc2tDdXJyZW50ID0gdGhpcy5tYXNrU3RhY2tbdGhpcy5tYXNrU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBpZiAobWFza0N1cnJlbnQudHlwZSA9PT0gTUFTS19UWVBFUy5TUFJJVEUgJiYgbWFza0N1cnJlbnQuX2ZpbHRlcnMpIHtcbiAgICAgICAgbWFza0N1cnJlbnQuX2ZpbHRlcnNbMF0ubWFza1Nwcml0ZSA9IG1hc2tDdXJyZW50Lm1hc2tPYmplY3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRldGVjdChtYXNrRGF0YSkge1xuICAgIGNvbnN0IG1hc2tPYmplY3QgPSBtYXNrRGF0YS5tYXNrT2JqZWN0O1xuICAgIGlmICghbWFza09iamVjdCkge1xuICAgICAgbWFza0RhdGEudHlwZSA9IE1BU0tfVFlQRVMuQ09MT1I7XG4gICAgfSBlbHNlIGlmIChtYXNrT2JqZWN0LmlzU3ByaXRlKSB7XG4gICAgICBtYXNrRGF0YS50eXBlID0gTUFTS19UWVBFUy5TUFJJVEU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVuYWJsZVNjaXNzb3IgJiYgdGhpcy5yZW5kZXJlci5zY2lzc29yLnRlc3RTY2lzc29yKG1hc2tEYXRhKSkge1xuICAgICAgbWFza0RhdGEudHlwZSA9IE1BU0tfVFlQRVMuU0NJU1NPUjtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFza0RhdGEudHlwZSA9IE1BU0tfVFlQRVMuU1RFTkNJTDtcbiAgICB9XG4gIH1cbiAgcHVzaFNwcml0ZU1hc2sobWFza0RhdGEpIHtcbiAgICBjb25zdCB7IG1hc2tPYmplY3QgfSA9IG1hc2tEYXRhO1xuICAgIGNvbnN0IHRhcmdldCA9IG1hc2tEYXRhLl90YXJnZXQ7XG4gICAgbGV0IGFscGhhTWFza0ZpbHRlciA9IG1hc2tEYXRhLl9maWx0ZXJzO1xuICAgIGlmICghYWxwaGFNYXNrRmlsdGVyKSB7XG4gICAgICBhbHBoYU1hc2tGaWx0ZXIgPSB0aGlzLmFscGhhTWFza1Bvb2xbdGhpcy5hbHBoYU1hc2tJbmRleF07XG4gICAgICBpZiAoIWFscGhhTWFza0ZpbHRlcikge1xuICAgICAgICBhbHBoYU1hc2tGaWx0ZXIgPSB0aGlzLmFscGhhTWFza1Bvb2xbdGhpcy5hbHBoYU1hc2tJbmRleF0gPSBbbmV3IFNwcml0ZU1hc2tGaWx0ZXIoKV07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBjb25zdCByZW5kZXJUZXh0dXJlU3lzdGVtID0gcmVuZGVyZXIucmVuZGVyVGV4dHVyZTtcbiAgICBsZXQgcmVzb2x1dGlvbjtcbiAgICBsZXQgbXVsdGlzYW1wbGU7XG4gICAgaWYgKHJlbmRlclRleHR1cmVTeXN0ZW0uY3VycmVudCkge1xuICAgICAgY29uc3QgcmVuZGVyVGV4dHVyZSA9IHJlbmRlclRleHR1cmVTeXN0ZW0uY3VycmVudDtcbiAgICAgIHJlc29sdXRpb24gPSBtYXNrRGF0YS5yZXNvbHV0aW9uIHx8IHJlbmRlclRleHR1cmUucmVzb2x1dGlvbjtcbiAgICAgIG11bHRpc2FtcGxlID0gbWFza0RhdGEubXVsdGlzYW1wbGUgPz8gcmVuZGVyVGV4dHVyZS5tdWx0aXNhbXBsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x1dGlvbiA9IG1hc2tEYXRhLnJlc29sdXRpb24gfHwgcmVuZGVyZXIucmVzb2x1dGlvbjtcbiAgICAgIG11bHRpc2FtcGxlID0gbWFza0RhdGEubXVsdGlzYW1wbGUgPz8gcmVuZGVyZXIubXVsdGlzYW1wbGU7XG4gICAgfVxuICAgIGFscGhhTWFza0ZpbHRlclswXS5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICBhbHBoYU1hc2tGaWx0ZXJbMF0ubXVsdGlzYW1wbGUgPSBtdWx0aXNhbXBsZTtcbiAgICBhbHBoYU1hc2tGaWx0ZXJbMF0ubWFza1Nwcml0ZSA9IG1hc2tPYmplY3Q7XG4gICAgY29uc3Qgc3Rhc2hGaWx0ZXJBcmVhID0gdGFyZ2V0LmZpbHRlckFyZWE7XG4gICAgdGFyZ2V0LmZpbHRlckFyZWEgPSBtYXNrT2JqZWN0LmdldEJvdW5kcyh0cnVlKTtcbiAgICByZW5kZXJlci5maWx0ZXIucHVzaCh0YXJnZXQsIGFscGhhTWFza0ZpbHRlcik7XG4gICAgdGFyZ2V0LmZpbHRlckFyZWEgPSBzdGFzaEZpbHRlckFyZWE7XG4gICAgaWYgKCFtYXNrRGF0YS5fZmlsdGVycykge1xuICAgICAgdGhpcy5hbHBoYU1hc2tJbmRleCsrO1xuICAgIH1cbiAgfVxuICBwb3BTcHJpdGVNYXNrKG1hc2tEYXRhKSB7XG4gICAgdGhpcy5yZW5kZXJlci5maWx0ZXIucG9wKCk7XG4gICAgaWYgKG1hc2tEYXRhLl9maWx0ZXJzKSB7XG4gICAgICBtYXNrRGF0YS5fZmlsdGVyc1swXS5tYXNrU3ByaXRlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hbHBoYU1hc2tJbmRleC0tO1xuICAgICAgdGhpcy5hbHBoYU1hc2tQb29sW3RoaXMuYWxwaGFNYXNrSW5kZXhdWzBdLm1hc2tTcHJpdGUgPSBudWxsO1xuICAgIH1cbiAgfVxuICBwdXNoQ29sb3JNYXNrKG1hc2tEYXRhKSB7XG4gICAgY29uc3QgY3VyckNvbG9yTWFzayA9IG1hc2tEYXRhLl9jb2xvck1hc2s7XG4gICAgY29uc3QgbmV4dENvbG9yTWFzayA9IG1hc2tEYXRhLl9jb2xvck1hc2sgPSBjdXJyQ29sb3JNYXNrICYgbWFza0RhdGEuY29sb3JNYXNrO1xuICAgIGlmIChuZXh0Q29sb3JNYXNrICE9PSBjdXJyQ29sb3JNYXNrKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLmdsLmNvbG9yTWFzaygobmV4dENvbG9yTWFzayAmIDEpICE9PSAwLCAobmV4dENvbG9yTWFzayAmIDIpICE9PSAwLCAobmV4dENvbG9yTWFzayAmIDQpICE9PSAwLCAobmV4dENvbG9yTWFzayAmIDgpICE9PSAwKTtcbiAgICB9XG4gIH1cbiAgcG9wQ29sb3JNYXNrKG1hc2tEYXRhKSB7XG4gICAgY29uc3QgY3VyckNvbG9yTWFzayA9IG1hc2tEYXRhLl9jb2xvck1hc2s7XG4gICAgY29uc3QgbmV4dENvbG9yTWFzayA9IHRoaXMubWFza1N0YWNrLmxlbmd0aCA+IDAgPyB0aGlzLm1hc2tTdGFja1t0aGlzLm1hc2tTdGFjay5sZW5ndGggLSAxXS5fY29sb3JNYXNrIDogMTU7XG4gICAgaWYgKG5leHRDb2xvck1hc2sgIT09IGN1cnJDb2xvck1hc2spIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuZ2wuY29sb3JNYXNrKChuZXh0Q29sb3JNYXNrICYgMSkgIT09IDAsIChuZXh0Q29sb3JNYXNrICYgMikgIT09IDAsIChuZXh0Q29sb3JNYXNrICYgNCkgIT09IDAsIChuZXh0Q29sb3JNYXNrICYgOCkgIT09IDApO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG5NYXNrU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJtYXNrXCJcbn07XG5leHRlbnNpb25zLmFkZChNYXNrU3lzdGVtKTtcblxuZXhwb3J0IHsgTWFza1N5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFza1N5c3RlbS5tanMubWFwXG4iLCJjbGFzcyBBYnN0cmFjdE1hc2tTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLm1hc2tTdGFjayA9IFtdO1xuICAgIHRoaXMuZ2xDb25zdCA9IDA7XG4gIH1cbiAgZ2V0U3RhY2tMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFza1N0YWNrLmxlbmd0aDtcbiAgfVxuICBzZXRNYXNrU3RhY2sobWFza1N0YWNrKSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcy5yZW5kZXJlcjtcbiAgICBjb25zdCBjdXJTdGFja0xlbiA9IHRoaXMuZ2V0U3RhY2tMZW5ndGgoKTtcbiAgICB0aGlzLm1hc2tTdGFjayA9IG1hc2tTdGFjaztcbiAgICBjb25zdCBuZXdTdGFja0xlbiA9IHRoaXMuZ2V0U3RhY2tMZW5ndGgoKTtcbiAgICBpZiAobmV3U3RhY2tMZW4gIT09IGN1clN0YWNrTGVuKSB7XG4gICAgICBpZiAobmV3U3RhY2tMZW4gPT09IDApIHtcbiAgICAgICAgZ2wuZGlzYWJsZSh0aGlzLmdsQ29uc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuZW5hYmxlKHRoaXMuZ2xDb25zdCk7XG4gICAgICAgIHRoaXMuX3VzZUN1cnJlbnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3VzZUN1cnJlbnQoKSB7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLm1hc2tTdGFjayA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHsgQWJzdHJhY3RNYXNrU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYnN0cmFjdE1hc2tTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2V4dGVuc2lvbnMnO1xuaW1wb3J0IHsgTWF0cml4LCBSZWN0YW5nbGUgfSBmcm9tICdAcGl4aS9tYXRoJztcbmltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSAnQHBpeGkvc2V0dGluZ3MnO1xuaW1wb3J0IHsgQWJzdHJhY3RNYXNrU3lzdGVtIH0gZnJvbSAnLi9BYnN0cmFjdE1hc2tTeXN0ZW0ubWpzJztcblxuY29uc3QgdGVtcE1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbmNvbnN0IHJlY3RQb29sID0gW107XG5jb25zdCBfU2Npc3NvclN5c3RlbSA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RNYXNrU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICBzdXBlcihyZW5kZXJlcik7XG4gICAgdGhpcy5nbENvbnN0ID0gc2V0dGluZ3MuQURBUFRFUi5nZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQoKS5TQ0lTU09SX1RFU1Q7XG4gIH1cbiAgZ2V0U3RhY2tMZW5ndGgoKSB7XG4gICAgY29uc3QgbWFza0RhdGEgPSB0aGlzLm1hc2tTdGFja1t0aGlzLm1hc2tTdGFjay5sZW5ndGggLSAxXTtcbiAgICBpZiAobWFza0RhdGEpIHtcbiAgICAgIHJldHVybiBtYXNrRGF0YS5fc2Npc3NvckNvdW50ZXI7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGNhbGNTY2lzc29yUmVjdChtYXNrRGF0YSkge1xuICAgIGlmIChtYXNrRGF0YS5fc2Npc3NvclJlY3RMb2NhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwcmV2RGF0YSA9IG1hc2tEYXRhLl9zY2lzc29yUmVjdDtcbiAgICBjb25zdCB7IG1hc2tPYmplY3QgfSA9IG1hc2tEYXRhO1xuICAgIGNvbnN0IHsgcmVuZGVyZXIgfSA9IHRoaXM7XG4gICAgY29uc3QgcmVuZGVyVGV4dHVyZVN5c3RlbSA9IHJlbmRlcmVyLnJlbmRlclRleHR1cmU7XG4gICAgY29uc3QgcmVjdCA9IG1hc2tPYmplY3QuZ2V0Qm91bmRzKHRydWUsIHJlY3RQb29sLnBvcCgpID8/IG5ldyBSZWN0YW5nbGUoKSk7XG4gICAgdGhpcy5yb3VuZEZyYW1lVG9QaXhlbHMocmVjdCwgcmVuZGVyVGV4dHVyZVN5c3RlbS5jdXJyZW50ID8gcmVuZGVyVGV4dHVyZVN5c3RlbS5jdXJyZW50LnJlc29sdXRpb24gOiByZW5kZXJlci5yZXNvbHV0aW9uLCByZW5kZXJUZXh0dXJlU3lzdGVtLnNvdXJjZUZyYW1lLCByZW5kZXJUZXh0dXJlU3lzdGVtLmRlc3RpbmF0aW9uRnJhbWUsIHJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtKTtcbiAgICBpZiAocHJldkRhdGEpIHtcbiAgICAgIHJlY3QuZml0KHByZXZEYXRhKTtcbiAgICB9XG4gICAgbWFza0RhdGEuX3NjaXNzb3JSZWN0TG9jYWwgPSByZWN0O1xuICB9XG4gIHN0YXRpYyBpc01hdHJpeFJvdGF0ZWQobWF0cml4KSB7XG4gICAgaWYgKCFtYXRyaXgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeyBhLCBiLCBjLCBkIH0gPSBtYXRyaXg7XG4gICAgcmV0dXJuIChNYXRoLmFicyhiKSA+IDFlLTQgfHwgTWF0aC5hYnMoYykgPiAxZS00KSAmJiAoTWF0aC5hYnMoYSkgPiAxZS00IHx8IE1hdGguYWJzKGQpID4gMWUtNCk7XG4gIH1cbiAgdGVzdFNjaXNzb3IobWFza0RhdGEpIHtcbiAgICBjb25zdCB7IG1hc2tPYmplY3QgfSA9IG1hc2tEYXRhO1xuICAgIGlmICghbWFza09iamVjdC5pc0Zhc3RSZWN0IHx8ICFtYXNrT2JqZWN0LmlzRmFzdFJlY3QoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoX1NjaXNzb3JTeXN0ZW0uaXNNYXRyaXhSb3RhdGVkKG1hc2tPYmplY3Qud29ybGRUcmFuc2Zvcm0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChfU2Npc3NvclN5c3RlbS5pc01hdHJpeFJvdGF0ZWQodGhpcy5yZW5kZXJlci5wcm9qZWN0aW9uLnRyYW5zZm9ybSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5jYWxjU2Npc3NvclJlY3QobWFza0RhdGEpO1xuICAgIGNvbnN0IHJlY3QgPSBtYXNrRGF0YS5fc2Npc3NvclJlY3RMb2NhbDtcbiAgICByZXR1cm4gcmVjdC53aWR0aCA+IDAgJiYgcmVjdC5oZWlnaHQgPiAwO1xuICB9XG4gIHJvdW5kRnJhbWVUb1BpeGVscyhmcmFtZSwgcmVzb2x1dGlvbiwgYmluZGluZ1NvdXJjZUZyYW1lLCBiaW5kaW5nRGVzdGluYXRpb25GcmFtZSwgdHJhbnNmb3JtKSB7XG4gICAgaWYgKF9TY2lzc29yU3lzdGVtLmlzTWF0cml4Um90YXRlZCh0cmFuc2Zvcm0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyYW5zZm9ybSA9IHRyYW5zZm9ybSA/IHRlbXBNYXRyaXguY29weUZyb20odHJhbnNmb3JtKSA6IHRlbXBNYXRyaXguaWRlbnRpdHkoKTtcbiAgICB0cmFuc2Zvcm0udHJhbnNsYXRlKC1iaW5kaW5nU291cmNlRnJhbWUueCwgLWJpbmRpbmdTb3VyY2VGcmFtZS55KS5zY2FsZShiaW5kaW5nRGVzdGluYXRpb25GcmFtZS53aWR0aCAvIGJpbmRpbmdTb3VyY2VGcmFtZS53aWR0aCwgYmluZGluZ0Rlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0IC8gYmluZGluZ1NvdXJjZUZyYW1lLmhlaWdodCkudHJhbnNsYXRlKGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLngsIGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lLnkpO1xuICAgIHRoaXMucmVuZGVyZXIuZmlsdGVyLnRyYW5zZm9ybUFBQkIodHJhbnNmb3JtLCBmcmFtZSk7XG4gICAgZnJhbWUuZml0KGJpbmRpbmdEZXN0aW5hdGlvbkZyYW1lKTtcbiAgICBmcmFtZS54ID0gTWF0aC5yb3VuZChmcmFtZS54ICogcmVzb2x1dGlvbik7XG4gICAgZnJhbWUueSA9IE1hdGgucm91bmQoZnJhbWUueSAqIHJlc29sdXRpb24pO1xuICAgIGZyYW1lLndpZHRoID0gTWF0aC5yb3VuZChmcmFtZS53aWR0aCAqIHJlc29sdXRpb24pO1xuICAgIGZyYW1lLmhlaWdodCA9IE1hdGgucm91bmQoZnJhbWUuaGVpZ2h0ICogcmVzb2x1dGlvbik7XG4gIH1cbiAgcHVzaChtYXNrRGF0YSkge1xuICAgIGlmICghbWFza0RhdGEuX3NjaXNzb3JSZWN0TG9jYWwpIHtcbiAgICAgIHRoaXMuY2FsY1NjaXNzb3JSZWN0KG1hc2tEYXRhKTtcbiAgICB9XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcy5yZW5kZXJlcjtcbiAgICBpZiAoIW1hc2tEYXRhLl9zY2lzc29yUmVjdCkge1xuICAgICAgZ2wuZW5hYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgfVxuICAgIG1hc2tEYXRhLl9zY2lzc29yQ291bnRlcisrO1xuICAgIG1hc2tEYXRhLl9zY2lzc29yUmVjdCA9IG1hc2tEYXRhLl9zY2lzc29yUmVjdExvY2FsO1xuICAgIHRoaXMuX3VzZUN1cnJlbnQoKTtcbiAgfVxuICBwb3AobWFza0RhdGEpIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzLnJlbmRlcmVyO1xuICAgIGlmIChtYXNrRGF0YSkge1xuICAgICAgcmVjdFBvb2wucHVzaChtYXNrRGF0YS5fc2Npc3NvclJlY3RMb2NhbCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmdldFN0YWNrTGVuZ3RoKCkgPiAwKSB7XG4gICAgICB0aGlzLl91c2VDdXJyZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLmRpc2FibGUoZ2wuU0NJU1NPUl9URVNUKTtcbiAgICB9XG4gIH1cbiAgX3VzZUN1cnJlbnQoKSB7XG4gICAgY29uc3QgcmVjdCA9IHRoaXMubWFza1N0YWNrW3RoaXMubWFza1N0YWNrLmxlbmd0aCAtIDFdLl9zY2lzc29yUmVjdDtcbiAgICBsZXQgeTtcbiAgICBpZiAodGhpcy5yZW5kZXJlci5yZW5kZXJUZXh0dXJlLmN1cnJlbnQpIHtcbiAgICAgIHkgPSByZWN0Lnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgPSB0aGlzLnJlbmRlcmVyLmhlaWdodCAtIHJlY3QuaGVpZ2h0IC0gcmVjdC55O1xuICAgIH1cbiAgICB0aGlzLnJlbmRlcmVyLmdsLnNjaXNzb3IocmVjdC54LCB5LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gIH1cbn07XG5sZXQgU2Npc3NvclN5c3RlbSA9IF9TY2lzc29yU3lzdGVtO1xuU2Npc3NvclN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwic2Npc3NvclwiXG59O1xuZXh0ZW5zaW9ucy5hZGQoU2Npc3NvclN5c3RlbSk7XG5cbmV4cG9ydCB7IFNjaXNzb3JTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNjaXNzb3JTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2V4dGVuc2lvbnMnO1xuaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tICdAcGl4aS9zZXR0aW5ncyc7XG5pbXBvcnQgeyBBYnN0cmFjdE1hc2tTeXN0ZW0gfSBmcm9tICcuL0Fic3RyYWN0TWFza1N5c3RlbS5tanMnO1xuXG5jbGFzcyBTdGVuY2lsU3lzdGVtIGV4dGVuZHMgQWJzdHJhY3RNYXNrU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICBzdXBlcihyZW5kZXJlcik7XG4gICAgdGhpcy5nbENvbnN0ID0gc2V0dGluZ3MuQURBUFRFUi5nZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQoKS5TVEVOQ0lMX1RFU1Q7XG4gIH1cbiAgZ2V0U3RhY2tMZW5ndGgoKSB7XG4gICAgY29uc3QgbWFza0RhdGEgPSB0aGlzLm1hc2tTdGFja1t0aGlzLm1hc2tTdGFjay5sZW5ndGggLSAxXTtcbiAgICBpZiAobWFza0RhdGEpIHtcbiAgICAgIHJldHVybiBtYXNrRGF0YS5fc3RlbmNpbENvdW50ZXI7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIHB1c2gobWFza0RhdGEpIHtcbiAgICBjb25zdCBtYXNrT2JqZWN0ID0gbWFza0RhdGEubWFza09iamVjdDtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzLnJlbmRlcmVyO1xuICAgIGNvbnN0IHByZXZNYXNrQ291bnQgPSBtYXNrRGF0YS5fc3RlbmNpbENvdW50ZXI7XG4gICAgaWYgKHByZXZNYXNrQ291bnQgPT09IDApIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuZnJhbWVidWZmZXIuZm9yY2VTdGVuY2lsKCk7XG4gICAgICBnbC5jbGVhclN0ZW5jaWwoMCk7XG4gICAgICBnbC5jbGVhcihnbC5TVEVOQ0lMX0JVRkZFUl9CSVQpO1xuICAgICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgfVxuICAgIG1hc2tEYXRhLl9zdGVuY2lsQ291bnRlcisrO1xuICAgIGNvbnN0IGNvbG9yTWFzayA9IG1hc2tEYXRhLl9jb2xvck1hc2s7XG4gICAgaWYgKGNvbG9yTWFzayAhPT0gMCkge1xuICAgICAgbWFza0RhdGEuX2NvbG9yTWFzayA9IDA7XG4gICAgICBnbC5jb2xvck1hc2soZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuICAgIH1cbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgcHJldk1hc2tDb3VudCwgNDI5NDk2NzI5NSk7XG4gICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsIGdsLktFRVAsIGdsLklOQ1IpO1xuICAgIG1hc2tPYmplY3QucmVuZGVyYWJsZSA9IHRydWU7XG4gICAgbWFza09iamVjdC5yZW5kZXIodGhpcy5yZW5kZXJlcik7XG4gICAgdGhpcy5yZW5kZXJlci5iYXRjaC5mbHVzaCgpO1xuICAgIG1hc2tPYmplY3QucmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgIGlmIChjb2xvck1hc2sgIT09IDApIHtcbiAgICAgIG1hc2tEYXRhLl9jb2xvck1hc2sgPSBjb2xvck1hc2s7XG4gICAgICBnbC5jb2xvck1hc2soKGNvbG9yTWFzayAmIDEpICE9PSAwLCAoY29sb3JNYXNrICYgMikgIT09IDAsIChjb2xvck1hc2sgJiA0KSAhPT0gMCwgKGNvbG9yTWFzayAmIDgpICE9PSAwKTtcbiAgICB9XG4gICAgdGhpcy5fdXNlQ3VycmVudCgpO1xuICB9XG4gIHBvcChtYXNrT2JqZWN0KSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuICAgIGlmICh0aGlzLmdldFN0YWNrTGVuZ3RoKCkgPT09IDApIHtcbiAgICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWFza0RhdGEgPSB0aGlzLm1hc2tTdGFjay5sZW5ndGggIT09IDAgPyB0aGlzLm1hc2tTdGFja1t0aGlzLm1hc2tTdGFjay5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICBjb25zdCBjb2xvck1hc2sgPSBtYXNrRGF0YSA/IG1hc2tEYXRhLl9jb2xvck1hc2sgOiAxNTtcbiAgICAgIGlmIChjb2xvck1hc2sgIT09IDApIHtcbiAgICAgICAgbWFza0RhdGEuX2NvbG9yTWFzayA9IDA7XG4gICAgICAgIGdsLmNvbG9yTWFzayhmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuREVDUik7XG4gICAgICBtYXNrT2JqZWN0LnJlbmRlcmFibGUgPSB0cnVlO1xuICAgICAgbWFza09iamVjdC5yZW5kZXIodGhpcy5yZW5kZXJlcik7XG4gICAgICB0aGlzLnJlbmRlcmVyLmJhdGNoLmZsdXNoKCk7XG4gICAgICBtYXNrT2JqZWN0LnJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgIGlmIChjb2xvck1hc2sgIT09IDApIHtcbiAgICAgICAgbWFza0RhdGEuX2NvbG9yTWFzayA9IGNvbG9yTWFzaztcbiAgICAgICAgZ2wuY29sb3JNYXNrKChjb2xvck1hc2sgJiAxKSAhPT0gMCwgKGNvbG9yTWFzayAmIDIpICE9PSAwLCAoY29sb3JNYXNrICYgNCkgIT09IDAsIChjb2xvck1hc2sgJiA4KSAhPT0gMCk7XG4gICAgICB9XG4gICAgICB0aGlzLl91c2VDdXJyZW50KCk7XG4gICAgfVxuICB9XG4gIF91c2VDdXJyZW50KCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5yZW5kZXJlci5nbDtcbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgdGhpcy5nZXRTdGFja0xlbmd0aCgpLCA0Mjk0OTY3Mjk1KTtcbiAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuS0VFUCk7XG4gIH1cbn1cblN0ZW5jaWxTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcInN0ZW5jaWxcIlxufTtcbmV4dGVuc2lvbnMuYWRkKFN0ZW5jaWxTeXN0ZW0pO1xuXG5leHBvcnQgeyBTdGVuY2lsU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGVuY2lsU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tICdAcGl4aS9leHRlbnNpb25zJztcbmltcG9ydCB7IGRlcHJlY2F0aW9uIH0gZnJvbSAnQHBpeGkvdXRpbHMnO1xuXG5jbGFzcyBQbHVnaW5TeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLnBsdWdpbnMgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLnBsdWdpbnMsIHtcbiAgICAgIGV4dHJhY3Q6IHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICBkZXByZWNhdGlvbihcIjcuMC4wXCIsIFwicmVuZGVyZXIucGx1Z2lucy5leHRyYWN0IGhhcyBtb3ZlZCB0byByZW5kZXJlci5leHRyYWN0XCIpO1xuICAgICAgICAgIHJldHVybiByZW5kZXJlci5leHRyYWN0O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJlcGFyZToge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJyZW5kZXJlci5wbHVnaW5zLnByZXBhcmUgaGFzIG1vdmVkIHRvIHJlbmRlcmVyLnByZXBhcmVcIik7XG4gICAgICAgICAgcmV0dXJuIHJlbmRlcmVyLnByZXBhcmU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpbnRlcmFjdGlvbjoge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJyZW5kZXJlci5wbHVnaW5zLmludGVyYWN0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHVzZSByZW5kZXJlci5ldmVudHNcIik7XG4gICAgICAgICAgcmV0dXJuIHJlbmRlcmVyLmV2ZW50cztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGluaXQoKSB7XG4gICAgY29uc3Qgc3RhdGljTWFwID0gdGhpcy5yZW5kZXJlclBsdWdpbnM7XG4gICAgZm9yIChjb25zdCBvIGluIHN0YXRpY01hcCkge1xuICAgICAgdGhpcy5wbHVnaW5zW29dID0gbmV3IHN0YXRpY01hcFtvXSh0aGlzLnJlbmRlcmVyKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IG8gaW4gdGhpcy5wbHVnaW5zKSB7XG4gICAgICB0aGlzLnBsdWdpbnNbb10uZGVzdHJveSgpO1xuICAgICAgdGhpcy5wbHVnaW5zW29dID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblBsdWdpblN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUmVuZGVyZXJTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJfcGx1Z2luXCJcbn07XG5leHRlbnNpb25zLmFkZChQbHVnaW5TeXN0ZW0pO1xuXG5leHBvcnQgeyBQbHVnaW5TeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBsdWdpblN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvZXh0ZW5zaW9ucyc7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tICdAcGl4aS9tYXRoJztcblxuY2xhc3MgUHJvamVjdGlvblN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMuZGVzdGluYXRpb25GcmFtZSA9IG51bGw7XG4gICAgdGhpcy5zb3VyY2VGcmFtZSA9IG51bGw7XG4gICAgdGhpcy5kZWZhdWx0RnJhbWUgPSBudWxsO1xuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG51bGw7XG4gIH1cbiAgdXBkYXRlKGRlc3RpbmF0aW9uRnJhbWUsIHNvdXJjZUZyYW1lLCByZXNvbHV0aW9uLCByb290KSB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbkZyYW1lID0gZGVzdGluYXRpb25GcmFtZSB8fCB0aGlzLmRlc3RpbmF0aW9uRnJhbWUgfHwgdGhpcy5kZWZhdWx0RnJhbWU7XG4gICAgdGhpcy5zb3VyY2VGcmFtZSA9IHNvdXJjZUZyYW1lIHx8IHRoaXMuc291cmNlRnJhbWUgfHwgZGVzdGluYXRpb25GcmFtZTtcbiAgICB0aGlzLmNhbGN1bGF0ZVByb2plY3Rpb24odGhpcy5kZXN0aW5hdGlvbkZyYW1lLCB0aGlzLnNvdXJjZUZyYW1lLCByZXNvbHV0aW9uLCByb290KTtcbiAgICBpZiAodGhpcy50cmFuc2Zvcm0pIHtcbiAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeC5hcHBlbmQodGhpcy50cmFuc2Zvcm0pO1xuICAgIH1cbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgcmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMudW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCA9IHRoaXMucHJvamVjdGlvbk1hdHJpeDtcbiAgICByZW5kZXJlci5nbG9iYWxVbmlmb3Jtcy51cGRhdGUoKTtcbiAgICBpZiAocmVuZGVyZXIuc2hhZGVyLnNoYWRlcikge1xuICAgICAgcmVuZGVyZXIuc2hhZGVyLnN5bmNVbmlmb3JtR3JvdXAocmVuZGVyZXIuc2hhZGVyLnNoYWRlci51bmlmb3Jtcy5nbG9iYWxzKTtcbiAgICB9XG4gIH1cbiAgY2FsY3VsYXRlUHJvamVjdGlvbihfZGVzdGluYXRpb25GcmFtZSwgc291cmNlRnJhbWUsIF9yZXNvbHV0aW9uLCByb290KSB7XG4gICAgY29uc3QgcG0gPSB0aGlzLnByb2plY3Rpb25NYXRyaXg7XG4gICAgY29uc3Qgc2lnbiA9ICFyb290ID8gMSA6IC0xO1xuICAgIHBtLmlkZW50aXR5KCk7XG4gICAgcG0uYSA9IDEgLyBzb3VyY2VGcmFtZS53aWR0aCAqIDI7XG4gICAgcG0uZCA9IHNpZ24gKiAoMSAvIHNvdXJjZUZyYW1lLmhlaWdodCAqIDIpO1xuICAgIHBtLnR4ID0gLTEgLSBzb3VyY2VGcmFtZS54ICogcG0uYTtcbiAgICBwbS50eSA9IC1zaWduIC0gc291cmNlRnJhbWUueSAqIHBtLmQ7XG4gIH1cbiAgc2V0VHJhbnNmb3JtKF9tYXRyaXgpIHtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG5Qcm9qZWN0aW9uU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJwcm9qZWN0aW9uXCJcbn07XG5leHRlbnNpb25zLmFkZChQcm9qZWN0aW9uU3lzdGVtKTtcblxuZXhwb3J0IHsgUHJvamVjdGlvblN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJvamVjdGlvblN5c3RlbS5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvZXh0ZW5zaW9ucyc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0sIE1hdHJpeCB9IGZyb20gJ0BwaXhpL21hdGgnO1xuaW1wb3J0IHsgUmVuZGVyVGV4dHVyZSB9IGZyb20gJy4vUmVuZGVyVGV4dHVyZS5tanMnO1xuXG5jb25zdCB0ZW1wVHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybSgpO1xuY2xhc3MgR2VuZXJhdGVUZXh0dXJlU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5fdGVtcE1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgfVxuICBnZW5lcmF0ZVRleHR1cmUoZGlzcGxheU9iamVjdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgcmVnaW9uOiBtYW51YWxSZWdpb24sIC4uLnRleHR1cmVPcHRpb25zIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHJlZ2lvbiA9IG1hbnVhbFJlZ2lvbiB8fCBkaXNwbGF5T2JqZWN0LmdldExvY2FsQm91bmRzKG51bGwsIHRydWUpO1xuICAgIGlmIChyZWdpb24ud2lkdGggPT09IDApXG4gICAgICByZWdpb24ud2lkdGggPSAxO1xuICAgIGlmIChyZWdpb24uaGVpZ2h0ID09PSAwKVxuICAgICAgcmVnaW9uLmhlaWdodCA9IDE7XG4gICAgY29uc3QgcmVuZGVyVGV4dHVyZSA9IFJlbmRlclRleHR1cmUuY3JlYXRlKHtcbiAgICAgIHdpZHRoOiByZWdpb24ud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlZ2lvbi5oZWlnaHQsXG4gICAgICAuLi50ZXh0dXJlT3B0aW9uc1xuICAgIH0pO1xuICAgIHRoaXMuX3RlbXBNYXRyaXgudHggPSAtcmVnaW9uLng7XG4gICAgdGhpcy5fdGVtcE1hdHJpeC50eSA9IC1yZWdpb24ueTtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBkaXNwbGF5T2JqZWN0LnRyYW5zZm9ybTtcbiAgICBkaXNwbGF5T2JqZWN0LnRyYW5zZm9ybSA9IHRlbXBUcmFuc2Zvcm07XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIoZGlzcGxheU9iamVjdCwge1xuICAgICAgcmVuZGVyVGV4dHVyZSxcbiAgICAgIHRyYW5zZm9ybTogdGhpcy5fdGVtcE1hdHJpeCxcbiAgICAgIHNraXBVcGRhdGVUcmFuc2Zvcm06ICEhZGlzcGxheU9iamVjdC5wYXJlbnQsXG4gICAgICBibGl0OiB0cnVlXG4gICAgfSk7XG4gICAgZGlzcGxheU9iamVjdC50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgcmV0dXJuIHJlbmRlclRleHR1cmU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgfVxufVxuR2VuZXJhdGVUZXh0dXJlU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNSZW5kZXJlclN5c3RlbVxuICBdLFxuICBuYW1lOiBcInRleHR1cmVHZW5lcmF0b3JcIlxufTtcbmV4dGVuc2lvbnMuYWRkKEdlbmVyYXRlVGV4dHVyZVN5c3RlbSk7XG5cbmV4cG9ydCB7IEdlbmVyYXRlVGV4dHVyZVN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2VuZXJhdGVUZXh0dXJlU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAnQHBpeGkvY29sb3InO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2V4dGVuc2lvbnMnO1xuaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnQHBpeGkvbWF0aCc7XG5cbmNvbnN0IHRlbXBSZWN0ID0gbmV3IFJlY3RhbmdsZSgpO1xuY29uc3QgdGVtcFJlY3QyID0gbmV3IFJlY3RhbmdsZSgpO1xuY2xhc3MgUmVuZGVyVGV4dHVyZVN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMuZGVmYXVsdE1hc2tTdGFjayA9IFtdO1xuICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5zb3VyY2VGcmFtZSA9IG5ldyBSZWN0YW5nbGUoKTtcbiAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUgPSBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgdGhpcy52aWV3cG9ydEZyYW1lID0gbmV3IFJlY3RhbmdsZSgpO1xuICB9XG4gIGNvbnRleHRDaGFuZ2UoKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHRoaXMucmVuZGVyZXI/LmdsLmdldENvbnRleHRBdHRyaWJ1dGVzKCk7XG4gICAgdGhpcy5fcmVuZGVyZXJQcmVtdWx0aXBsaWVkQWxwaGEgPSAhIShhdHRyaWJ1dGVzICYmIGF0dHJpYnV0ZXMuYWxwaGEgJiYgYXR0cmlidXRlcy5wcmVtdWx0aXBsaWVkQWxwaGEpO1xuICB9XG4gIGJpbmQocmVuZGVyVGV4dHVyZSA9IG51bGwsIHNvdXJjZUZyYW1lLCBkZXN0aW5hdGlvbkZyYW1lKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIHRoaXMuY3VycmVudCA9IHJlbmRlclRleHR1cmU7XG4gICAgbGV0IGJhc2VUZXh0dXJlO1xuICAgIGxldCBmcmFtZWJ1ZmZlcjtcbiAgICBsZXQgcmVzb2x1dGlvbjtcbiAgICBpZiAocmVuZGVyVGV4dHVyZSkge1xuICAgICAgYmFzZVRleHR1cmUgPSByZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgICAgcmVzb2x1dGlvbiA9IGJhc2VUZXh0dXJlLnJlc29sdXRpb247XG4gICAgICBpZiAoIXNvdXJjZUZyYW1lKSB7XG4gICAgICAgIHRlbXBSZWN0LndpZHRoID0gcmVuZGVyVGV4dHVyZS5mcmFtZS53aWR0aDtcbiAgICAgICAgdGVtcFJlY3QuaGVpZ2h0ID0gcmVuZGVyVGV4dHVyZS5mcmFtZS5oZWlnaHQ7XG4gICAgICAgIHNvdXJjZUZyYW1lID0gdGVtcFJlY3Q7XG4gICAgICB9XG4gICAgICBpZiAoIWRlc3RpbmF0aW9uRnJhbWUpIHtcbiAgICAgICAgdGVtcFJlY3QyLnggPSByZW5kZXJUZXh0dXJlLmZyYW1lLng7XG4gICAgICAgIHRlbXBSZWN0Mi55ID0gcmVuZGVyVGV4dHVyZS5mcmFtZS55O1xuICAgICAgICB0ZW1wUmVjdDIud2lkdGggPSBzb3VyY2VGcmFtZS53aWR0aDtcbiAgICAgICAgdGVtcFJlY3QyLmhlaWdodCA9IHNvdXJjZUZyYW1lLmhlaWdodDtcbiAgICAgICAgZGVzdGluYXRpb25GcmFtZSA9IHRlbXBSZWN0MjtcbiAgICAgIH1cbiAgICAgIGZyYW1lYnVmZmVyID0gYmFzZVRleHR1cmUuZnJhbWVidWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgICAgaWYgKCFzb3VyY2VGcmFtZSkge1xuICAgICAgICB0ZW1wUmVjdC53aWR0aCA9IHJlbmRlcmVyLl92aWV3LnNjcmVlbi53aWR0aDtcbiAgICAgICAgdGVtcFJlY3QuaGVpZ2h0ID0gcmVuZGVyZXIuX3ZpZXcuc2NyZWVuLmhlaWdodDtcbiAgICAgICAgc291cmNlRnJhbWUgPSB0ZW1wUmVjdDtcbiAgICAgIH1cbiAgICAgIGlmICghZGVzdGluYXRpb25GcmFtZSkge1xuICAgICAgICBkZXN0aW5hdGlvbkZyYW1lID0gdGVtcFJlY3Q7XG4gICAgICAgIGRlc3RpbmF0aW9uRnJhbWUud2lkdGggPSBzb3VyY2VGcmFtZS53aWR0aDtcbiAgICAgICAgZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgPSBzb3VyY2VGcmFtZS5oZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHZpZXdwb3J0RnJhbWUgPSB0aGlzLnZpZXdwb3J0RnJhbWU7XG4gICAgdmlld3BvcnRGcmFtZS54ID0gZGVzdGluYXRpb25GcmFtZS54ICogcmVzb2x1dGlvbjtcbiAgICB2aWV3cG9ydEZyYW1lLnkgPSBkZXN0aW5hdGlvbkZyYW1lLnkgKiByZXNvbHV0aW9uO1xuICAgIHZpZXdwb3J0RnJhbWUud2lkdGggPSBkZXN0aW5hdGlvbkZyYW1lLndpZHRoICogcmVzb2x1dGlvbjtcbiAgICB2aWV3cG9ydEZyYW1lLmhlaWdodCA9IGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0ICogcmVzb2x1dGlvbjtcbiAgICBpZiAoIXJlbmRlclRleHR1cmUpIHtcbiAgICAgIHZpZXdwb3J0RnJhbWUueSA9IHJlbmRlcmVyLnZpZXcuaGVpZ2h0IC0gKHZpZXdwb3J0RnJhbWUueSArIHZpZXdwb3J0RnJhbWUuaGVpZ2h0KTtcbiAgICB9XG4gICAgdmlld3BvcnRGcmFtZS5jZWlsKCk7XG4gICAgdGhpcy5yZW5kZXJlci5mcmFtZWJ1ZmZlci5iaW5kKGZyYW1lYnVmZmVyLCB2aWV3cG9ydEZyYW1lKTtcbiAgICB0aGlzLnJlbmRlcmVyLnByb2plY3Rpb24udXBkYXRlKGRlc3RpbmF0aW9uRnJhbWUsIHNvdXJjZUZyYW1lLCByZXNvbHV0aW9uLCAhZnJhbWVidWZmZXIpO1xuICAgIGlmIChyZW5kZXJUZXh0dXJlKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLm1hc2suc2V0TWFza1N0YWNrKGJhc2VUZXh0dXJlLm1hc2tTdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubWFzay5zZXRNYXNrU3RhY2sodGhpcy5kZWZhdWx0TWFza1N0YWNrKTtcbiAgICB9XG4gICAgdGhpcy5zb3VyY2VGcmFtZS5jb3B5RnJvbShzb3VyY2VGcmFtZSk7XG4gICAgdGhpcy5kZXN0aW5hdGlvbkZyYW1lLmNvcHlGcm9tKGRlc3RpbmF0aW9uRnJhbWUpO1xuICB9XG4gIGNsZWFyKGNsZWFyQ29sb3IsIG1hc2spIHtcbiAgICBjb25zdCBmYWxsYmFja0NvbG9yID0gdGhpcy5jdXJyZW50ID8gdGhpcy5jdXJyZW50LmJhc2VUZXh0dXJlLmNsZWFyIDogdGhpcy5yZW5kZXJlci5iYWNrZ3JvdW5kLmJhY2tncm91bmRDb2xvcjtcbiAgICBjb25zdCBjb2xvciA9IENvbG9yLnNoYXJlZC5zZXRWYWx1ZShjbGVhckNvbG9yID8gY2xlYXJDb2xvciA6IGZhbGxiYWNrQ29sb3IpO1xuICAgIGlmICh0aGlzLmN1cnJlbnQgJiYgdGhpcy5jdXJyZW50LmJhc2VUZXh0dXJlLmFscGhhTW9kZSA+IDAgfHwgIXRoaXMuY3VycmVudCAmJiB0aGlzLl9yZW5kZXJlclByZW11bHRpcGxpZWRBbHBoYSkge1xuICAgICAgY29sb3IucHJlbXVsdGlwbHkoY29sb3IuYWxwaGEpO1xuICAgIH1cbiAgICBjb25zdCBkZXN0aW5hdGlvbkZyYW1lID0gdGhpcy5kZXN0aW5hdGlvbkZyYW1lO1xuICAgIGNvbnN0IGJhc2VGcmFtZSA9IHRoaXMuY3VycmVudCA/IHRoaXMuY3VycmVudC5iYXNlVGV4dHVyZSA6IHRoaXMucmVuZGVyZXIuX3ZpZXcuc2NyZWVuO1xuICAgIGNvbnN0IGNsZWFyTWFzayA9IGRlc3RpbmF0aW9uRnJhbWUud2lkdGggIT09IGJhc2VGcmFtZS53aWR0aCB8fCBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCAhPT0gYmFzZUZyYW1lLmhlaWdodDtcbiAgICBpZiAoY2xlYXJNYXNrKSB7XG4gICAgICBsZXQgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLnZpZXdwb3J0RnJhbWU7XG4gICAgICB4ID0gTWF0aC5yb3VuZCh4KTtcbiAgICAgIHkgPSBNYXRoLnJvdW5kKHkpO1xuICAgICAgd2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoKTtcbiAgICAgIGhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0KTtcbiAgICAgIHRoaXMucmVuZGVyZXIuZ2wuZW5hYmxlKHRoaXMucmVuZGVyZXIuZ2wuU0NJU1NPUl9URVNUKTtcbiAgICAgIHRoaXMucmVuZGVyZXIuZ2wuc2Npc3Nvcih4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJlci5mcmFtZWJ1ZmZlci5jbGVhcihjb2xvci5yZWQsIGNvbG9yLmdyZWVuLCBjb2xvci5ibHVlLCBjb2xvci5hbHBoYSwgbWFzayk7XG4gICAgaWYgKGNsZWFyTWFzaykge1xuICAgICAgdGhpcy5yZW5kZXJlci5zY2lzc29yLnBvcCgpO1xuICAgIH1cbiAgfVxuICByZXNpemUoKSB7XG4gICAgdGhpcy5iaW5kKG51bGwpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuYmluZChudWxsKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG5SZW5kZXJUZXh0dXJlU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJyZW5kZXJUZXh0dXJlXCJcbn07XG5leHRlbnNpb25zLmFkZChSZW5kZXJUZXh0dXJlU3lzdGVtKTtcblxuZXhwb3J0IHsgUmVuZGVyVGV4dHVyZVN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVuZGVyVGV4dHVyZVN5c3RlbS5tanMubWFwXG4iLCJjbGFzcyBJR0xVbmlmb3JtRGF0YSB7XG59XG5jbGFzcyBHTFByb2dyYW0ge1xuICBjb25zdHJ1Y3Rvcihwcm9ncmFtLCB1bmlmb3JtRGF0YSkge1xuICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG4gICAgdGhpcy51bmlmb3JtRGF0YSA9IHVuaWZvcm1EYXRhO1xuICAgIHRoaXMudW5pZm9ybUdyb3VwcyA9IHt9O1xuICAgIHRoaXMudW5pZm9ybURpcnR5R3JvdXBzID0ge307XG4gICAgdGhpcy51bmlmb3JtQnVmZmVyQmluZGluZ3MgPSB7fTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5pZm9ybURhdGEgPSBudWxsO1xuICAgIHRoaXMudW5pZm9ybUdyb3VwcyA9IG51bGw7XG4gICAgdGhpcy51bmlmb3JtRGlydHlHcm91cHMgPSBudWxsO1xuICAgIHRoaXMudW5pZm9ybUJ1ZmZlckJpbmRpbmdzID0gbnVsbDtcbiAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICB9XG59XG5cbmV4cG9ydCB7IEdMUHJvZ3JhbSwgSUdMVW5pZm9ybURhdGEgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdMUHJvZ3JhbS5tanMubWFwXG4iLCJmdW5jdGlvbiBjb21waWxlU2hhZGVyKGdsLCB0eXBlLCBzcmMpIHtcbiAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzcmMpO1xuICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG4gIHJldHVybiBzaGFkZXI7XG59XG5cbmV4cG9ydCB7IGNvbXBpbGVTaGFkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBpbGVTaGFkZXIubWpzLm1hcFxuIiwiZnVuY3Rpb24gYm9vbGVhbkFycmF5KHNpemUpIHtcbiAgY29uc3QgYXJyYXkgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBhcnJheVtpXSA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRWYWx1ZSh0eXBlLCBzaXplKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJmbG9hdFwiOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSBcInZlYzJcIjpcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KDIgKiBzaXplKTtcbiAgICBjYXNlIFwidmVjM1wiOlxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoMyAqIHNpemUpO1xuICAgIGNhc2UgXCJ2ZWM0XCI6XG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSg0ICogc2l6ZSk7XG4gICAgY2FzZSBcImludFwiOlxuICAgIGNhc2UgXCJ1aW50XCI6XG4gICAgY2FzZSBcInNhbXBsZXIyRFwiOlxuICAgIGNhc2UgXCJzYW1wbGVyMkRBcnJheVwiOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSBcIml2ZWMyXCI6XG4gICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoMiAqIHNpemUpO1xuICAgIGNhc2UgXCJpdmVjM1wiOlxuICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KDMgKiBzaXplKTtcbiAgICBjYXNlIFwiaXZlYzRcIjpcbiAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheSg0ICogc2l6ZSk7XG4gICAgY2FzZSBcInV2ZWMyXCI6XG4gICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KDIgKiBzaXplKTtcbiAgICBjYXNlIFwidXZlYzNcIjpcbiAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoMyAqIHNpemUpO1xuICAgIGNhc2UgXCJ1dmVjNFwiOlxuICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheSg0ICogc2l6ZSk7XG4gICAgY2FzZSBcImJvb2xcIjpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjYXNlIFwiYnZlYzJcIjpcbiAgICAgIHJldHVybiBib29sZWFuQXJyYXkoMiAqIHNpemUpO1xuICAgIGNhc2UgXCJidmVjM1wiOlxuICAgICAgcmV0dXJuIGJvb2xlYW5BcnJheSgzICogc2l6ZSk7XG4gICAgY2FzZSBcImJ2ZWM0XCI6XG4gICAgICByZXR1cm4gYm9vbGVhbkFycmF5KDQgKiBzaXplKTtcbiAgICBjYXNlIFwibWF0MlwiOlxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxXG4gICAgICBdKTtcbiAgICBjYXNlIFwibWF0M1wiOlxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxXG4gICAgICBdKTtcbiAgICBjYXNlIFwibWF0NFwiOlxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxXG4gICAgICBdKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IHsgZGVmYXVsdFZhbHVlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0VmFsdWUubWpzLm1hcFxuIiwiaW1wb3J0IHsgbWFwU2l6ZSB9IGZyb20gJy4vbWFwU2l6ZS5tanMnO1xuaW1wb3J0IHsgbWFwVHlwZSB9IGZyb20gJy4vbWFwVHlwZS5tanMnO1xuXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVEYXRhKHByb2dyYW0sIGdsKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgY29uc3QgdG90YWxBdHRyaWJ1dGVzID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5BQ1RJVkVfQVRUUklCVVRFUyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxBdHRyaWJ1dGVzOyBpKyspIHtcbiAgICBjb25zdCBhdHRyaWJEYXRhID0gZ2wuZ2V0QWN0aXZlQXR0cmliKHByb2dyYW0sIGkpO1xuICAgIGlmIChhdHRyaWJEYXRhLm5hbWUuc3RhcnRzV2l0aChcImdsX1wiKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBtYXBUeXBlKGdsLCBhdHRyaWJEYXRhLnR5cGUpO1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICB0eXBlLFxuICAgICAgbmFtZTogYXR0cmliRGF0YS5uYW1lLFxuICAgICAgc2l6ZTogbWFwU2l6ZSh0eXBlKSxcbiAgICAgIGxvY2F0aW9uOiBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBhdHRyaWJEYXRhLm5hbWUpXG4gICAgfTtcbiAgICBhdHRyaWJ1dGVzW2F0dHJpYkRhdGEubmFtZV0gPSBkYXRhO1xuICB9XG4gIHJldHVybiBhdHRyaWJ1dGVzO1xufVxuXG5leHBvcnQgeyBnZXRBdHRyaWJ1dGVEYXRhIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRBdHRyaWJ1dGVEYXRhLm1qcy5tYXBcbiIsImltcG9ydCB7IGRlZmF1bHRWYWx1ZSB9IGZyb20gJy4vZGVmYXVsdFZhbHVlLm1qcyc7XG5pbXBvcnQgeyBtYXBUeXBlIH0gZnJvbSAnLi9tYXBUeXBlLm1qcyc7XG5cbmZ1bmN0aW9uIGdldFVuaWZvcm1EYXRhKHByb2dyYW0sIGdsKSB7XG4gIGNvbnN0IHVuaWZvcm1zID0ge307XG4gIGNvbnN0IHRvdGFsVW5pZm9ybXMgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkFDVElWRV9VTklGT1JNUyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxVbmlmb3JtczsgaSsrKSB7XG4gICAgY29uc3QgdW5pZm9ybURhdGEgPSBnbC5nZXRBY3RpdmVVbmlmb3JtKHByb2dyYW0sIGkpO1xuICAgIGNvbnN0IG5hbWUgPSB1bmlmb3JtRGF0YS5uYW1lLnJlcGxhY2UoL1xcWy4qP1xcXSQvLCBcIlwiKTtcbiAgICBjb25zdCBpc0FycmF5ID0gISF1bmlmb3JtRGF0YS5uYW1lLm1hdGNoKC9cXFsuKj9cXF0kLyk7XG4gICAgY29uc3QgdHlwZSA9IG1hcFR5cGUoZ2wsIHVuaWZvcm1EYXRhLnR5cGUpO1xuICAgIHVuaWZvcm1zW25hbWVdID0ge1xuICAgICAgbmFtZSxcbiAgICAgIGluZGV4OiBpLFxuICAgICAgdHlwZSxcbiAgICAgIHNpemU6IHVuaWZvcm1EYXRhLnNpemUsXG4gICAgICBpc0FycmF5LFxuICAgICAgdmFsdWU6IGRlZmF1bHRWYWx1ZSh0eXBlLCB1bmlmb3JtRGF0YS5zaXplKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHVuaWZvcm1zO1xufVxuXG5leHBvcnQgeyBnZXRVbmlmb3JtRGF0YSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0VW5pZm9ybURhdGEubWpzLm1hcFxuIiwiZnVuY3Rpb24gbG9nUHJldHR5U2hhZGVyRXJyb3IoZ2wsIHNoYWRlcikge1xuICBjb25zdCBzaGFkZXJTcmMgPSBnbC5nZXRTaGFkZXJTb3VyY2Uoc2hhZGVyKS5zcGxpdChcIlxcblwiKS5tYXAoKGxpbmUsIGluZGV4KSA9PiBgJHtpbmRleH06ICR7bGluZX1gKTtcbiAgY29uc3Qgc2hhZGVyTG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xuICBjb25zdCBzcGxpdFNoYWRlciA9IHNoYWRlckxvZy5zcGxpdChcIlxcblwiKTtcbiAgY29uc3QgZGVkdXBlID0ge307XG4gIGNvbnN0IGxpbmVOdW1iZXJzID0gc3BsaXRTaGFkZXIubWFwKChsaW5lKSA9PiBwYXJzZUZsb2F0KGxpbmUucmVwbGFjZSgvXkVSUk9SXFw6IDBcXDooW1xcZF0rKVxcOi4qJC8sIFwiJDFcIikpKS5maWx0ZXIoKG4pID0+IHtcbiAgICBpZiAobiAmJiAhZGVkdXBlW25dKSB7XG4gICAgICBkZWR1cGVbbl0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG4gIGNvbnN0IGxvZ0FyZ3MgPSBbXCJcIl07XG4gIGxpbmVOdW1iZXJzLmZvckVhY2goKG51bWJlcikgPT4ge1xuICAgIHNoYWRlclNyY1tudW1iZXIgLSAxXSA9IGAlYyR7c2hhZGVyU3JjW251bWJlciAtIDFdfSVjYDtcbiAgICBsb2dBcmdzLnB1c2goXCJiYWNrZ3JvdW5kOiAjRkYwMDAwOyBjb2xvcjojRkZGRkZGOyBmb250LXNpemU6IDEwcHhcIiwgXCJmb250LXNpemU6IDEwcHhcIik7XG4gIH0pO1xuICBjb25zdCBmcmFnbWVudFNvdXJjZVRvTG9nID0gc2hhZGVyU3JjLmpvaW4oXCJcXG5cIik7XG4gIGxvZ0FyZ3NbMF0gPSBmcmFnbWVudFNvdXJjZVRvTG9nO1xuICBjb25zb2xlLmVycm9yKHNoYWRlckxvZyk7XG4gIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXCJjbGljayB0byB2aWV3IGZ1bGwgc2hhZGVyIGNvZGVcIik7XG4gIGNvbnNvbGUud2FybiguLi5sb2dBcmdzKTtcbiAgY29uc29sZS5ncm91cEVuZCgpO1xufVxuZnVuY3Rpb24gbG9nUHJvZ3JhbUVycm9yKGdsLCBwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyKSB7XG4gIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcih2ZXJ0ZXhTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgbG9nUHJldHR5U2hhZGVyRXJyb3IoZ2wsIHZlcnRleFNoYWRlcik7XG4gICAgfVxuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKGZyYWdtZW50U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgIGxvZ1ByZXR0eVNoYWRlckVycm9yKGdsLCBmcmFnbWVudFNoYWRlcik7XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoXCJQaXhpSlMgRXJyb3I6IENvdWxkIG5vdCBpbml0aWFsaXplIHNoYWRlci5cIik7XG4gICAgaWYgKGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pICE9PSBcIlwiKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJQaXhpSlMgV2FybmluZzogZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coKVwiLCBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IGxvZ1Byb2dyYW1FcnJvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nUHJvZ3JhbUVycm9yLm1qcy5tYXBcbiIsImltcG9ydCB7IEdMUHJvZ3JhbSB9IGZyb20gJy4uL0dMUHJvZ3JhbS5tanMnO1xuaW1wb3J0IHsgY29tcGlsZVNoYWRlciB9IGZyb20gJy4vY29tcGlsZVNoYWRlci5tanMnO1xuaW1wb3J0IHsgZGVmYXVsdFZhbHVlIH0gZnJvbSAnLi9kZWZhdWx0VmFsdWUubWpzJztcbmltcG9ydCB7IGdldEF0dHJpYnV0ZURhdGEgfSBmcm9tICcuL2dldEF0dHJpYnV0ZURhdGEubWpzJztcbmltcG9ydCB7IGdldFVuaWZvcm1EYXRhIH0gZnJvbSAnLi9nZXRVbmlmb3JtRGF0YS5tanMnO1xuaW1wb3J0IHsgbG9nUHJvZ3JhbUVycm9yIH0gZnJvbSAnLi9sb2dQcm9ncmFtRXJyb3IubWpzJztcblxuZnVuY3Rpb24gZ2VuZXJhdGVQcm9ncmFtKGdsLCBwcm9ncmFtKSB7XG4gIGNvbnN0IGdsVmVydFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHByb2dyYW0udmVydGV4U3JjKTtcbiAgY29uc3QgZ2xGcmFnU2hhZGVyID0gY29tcGlsZVNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBwcm9ncmFtLmZyYWdtZW50U3JjKTtcbiAgY29uc3Qgd2ViR0xQcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICBnbC5hdHRhY2hTaGFkZXIod2ViR0xQcm9ncmFtLCBnbFZlcnRTaGFkZXIpO1xuICBnbC5hdHRhY2hTaGFkZXIod2ViR0xQcm9ncmFtLCBnbEZyYWdTaGFkZXIpO1xuICBjb25zdCB0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzID0gcHJvZ3JhbS5leHRyYT8udHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncztcbiAgaWYgKHRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MpIHtcbiAgICBpZiAodHlwZW9mIGdsLnRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc29sZS53YXJuKGBUcmFuc2Zvcm1GZWVkYmFjayBpcyBub3Qgc3VwcG9ydGVkIGJ1dCBUcmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzIGFyZSBnaXZlbi5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wudHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncyh3ZWJHTFByb2dyYW0sIHRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MubmFtZXMsIHRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MuYnVmZmVyTW9kZSA9PT0gXCJzZXBhcmF0ZVwiID8gZ2wuU0VQQVJBVEVfQVRUUklCUyA6IGdsLklOVEVSTEVBVkVEX0FUVFJJQlMpO1xuICAgIH1cbiAgfVxuICBnbC5saW5rUHJvZ3JhbSh3ZWJHTFByb2dyYW0pO1xuICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIod2ViR0xQcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICBsb2dQcm9ncmFtRXJyb3IoZ2wsIHdlYkdMUHJvZ3JhbSwgZ2xWZXJ0U2hhZGVyLCBnbEZyYWdTaGFkZXIpO1xuICB9XG4gIHByb2dyYW0uYXR0cmlidXRlRGF0YSA9IGdldEF0dHJpYnV0ZURhdGEod2ViR0xQcm9ncmFtLCBnbCk7XG4gIHByb2dyYW0udW5pZm9ybURhdGEgPSBnZXRVbmlmb3JtRGF0YSh3ZWJHTFByb2dyYW0sIGdsKTtcbiAgaWYgKCEvXlsgXFx0XSojWyBcXHRdKnZlcnNpb25bIFxcdF0rMzAwWyBcXHRdK2VzWyBcXHRdKiQvbS50ZXN0KHByb2dyYW0udmVydGV4U3JjKSkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9ncmFtLmF0dHJpYnV0ZURhdGEpO1xuICAgIGtleXMuc29ydCgoYSwgYikgPT4gYSA+IGIgPyAxIDogLTEpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvZ3JhbS5hdHRyaWJ1dGVEYXRhW2tleXNbaV1dLmxvY2F0aW9uID0gaTtcbiAgICAgIGdsLmJpbmRBdHRyaWJMb2NhdGlvbih3ZWJHTFByb2dyYW0sIGksIGtleXNbaV0pO1xuICAgIH1cbiAgICBnbC5saW5rUHJvZ3JhbSh3ZWJHTFByb2dyYW0pO1xuICB9XG4gIGdsLmRlbGV0ZVNoYWRlcihnbFZlcnRTaGFkZXIpO1xuICBnbC5kZWxldGVTaGFkZXIoZ2xGcmFnU2hhZGVyKTtcbiAgY29uc3QgdW5pZm9ybURhdGEgPSB7fTtcbiAgZm9yIChjb25zdCBpIGluIHByb2dyYW0udW5pZm9ybURhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gcHJvZ3JhbS51bmlmb3JtRGF0YVtpXTtcbiAgICB1bmlmb3JtRGF0YVtpXSA9IHtcbiAgICAgIGxvY2F0aW9uOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24od2ViR0xQcm9ncmFtLCBpKSxcbiAgICAgIHZhbHVlOiBkZWZhdWx0VmFsdWUoZGF0YS50eXBlLCBkYXRhLnNpemUpXG4gICAgfTtcbiAgfVxuICBjb25zdCBnbFByb2dyYW0gPSBuZXcgR0xQcm9ncmFtKHdlYkdMUHJvZ3JhbSwgdW5pZm9ybURhdGEpO1xuICByZXR1cm4gZ2xQcm9ncmFtO1xufVxuXG5leHBvcnQgeyBnZW5lcmF0ZVByb2dyYW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbmVyYXRlUHJvZ3JhbS5tanMubWFwXG4iLCJpbXBvcnQgJy4vaW5kZXgubWpzJztcbmltcG9ydCB7IHVuaWZvcm1QYXJzZXJzIH0gZnJvbSAnLi91bmlmb3JtUGFyc2Vycy5tanMnO1xuaW1wb3J0IHsgbWFwU2l6ZSB9IGZyb20gJy4vbWFwU2l6ZS5tanMnO1xuXG5mdW5jdGlvbiB1Ym9VcGRhdGUoX3VkLCBfdXYsIF9yZW5kZXJlciwgX3N5bmNEYXRhLCBidWZmZXIpIHtcbiAgX3JlbmRlcmVyLmJ1ZmZlci51cGRhdGUoYnVmZmVyKTtcbn1cbmNvbnN0IFVCT19UT19TSU5HTEVfU0VUVEVSUyA9IHtcbiAgZmxvYXQ6IGBcbiAgICAgICAgZGF0YVtvZmZzZXRdID0gdjtcbiAgICBgLFxuICB2ZWMyOiBgXG4gICAgICAgIGRhdGFbb2Zmc2V0XSA9IHZbMF07XG4gICAgICAgIGRhdGFbb2Zmc2V0KzFdID0gdlsxXTtcbiAgICBgLFxuICB2ZWMzOiBgXG4gICAgICAgIGRhdGFbb2Zmc2V0XSA9IHZbMF07XG4gICAgICAgIGRhdGFbb2Zmc2V0KzFdID0gdlsxXTtcbiAgICAgICAgZGF0YVtvZmZzZXQrMl0gPSB2WzJdO1xuXG4gICAgYCxcbiAgdmVjNDogYFxuICAgICAgICBkYXRhW29mZnNldF0gPSB2WzBdO1xuICAgICAgICBkYXRhW29mZnNldCsxXSA9IHZbMV07XG4gICAgICAgIGRhdGFbb2Zmc2V0KzJdID0gdlsyXTtcbiAgICAgICAgZGF0YVtvZmZzZXQrM10gPSB2WzNdO1xuICAgIGAsXG4gIG1hdDI6IGBcbiAgICAgICAgZGF0YVtvZmZzZXRdID0gdlswXTtcbiAgICAgICAgZGF0YVtvZmZzZXQrMV0gPSB2WzFdO1xuXG4gICAgICAgIGRhdGFbb2Zmc2V0KzRdID0gdlsyXTtcbiAgICAgICAgZGF0YVtvZmZzZXQrNV0gPSB2WzNdO1xuICAgIGAsXG4gIG1hdDM6IGBcbiAgICAgICAgZGF0YVtvZmZzZXRdID0gdlswXTtcbiAgICAgICAgZGF0YVtvZmZzZXQrMV0gPSB2WzFdO1xuICAgICAgICBkYXRhW29mZnNldCsyXSA9IHZbMl07XG5cbiAgICAgICAgZGF0YVtvZmZzZXQgKyA0XSA9IHZbM107XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgNV0gPSB2WzRdO1xuICAgICAgICBkYXRhW29mZnNldCArIDZdID0gdls1XTtcblxuICAgICAgICBkYXRhW29mZnNldCArIDhdID0gdls2XTtcbiAgICAgICAgZGF0YVtvZmZzZXQgKyA5XSA9IHZbN107XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgMTBdID0gdls4XTtcbiAgICBgLFxuICBtYXQ0OiBgXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBkYXRhW29mZnNldCArIGldID0gdltpXTtcbiAgICAgICAgfVxuICAgIGBcbn07XG5jb25zdCBHTFNMX1RPX1NURDQwX1NJWkUgPSB7XG4gIGZsb2F0OiA0LFxuICB2ZWMyOiA4LFxuICB2ZWMzOiAxMixcbiAgdmVjNDogMTYsXG4gIGludDogNCxcbiAgaXZlYzI6IDgsXG4gIGl2ZWMzOiAxMixcbiAgaXZlYzQ6IDE2LFxuICB1aW50OiA0LFxuICB1dmVjMjogOCxcbiAgdXZlYzM6IDEyLFxuICB1dmVjNDogMTYsXG4gIGJvb2w6IDQsXG4gIGJ2ZWMyOiA4LFxuICBidmVjMzogMTIsXG4gIGJ2ZWM0OiAxNixcbiAgbWF0MjogMTYgKiAyLFxuICBtYXQzOiAxNiAqIDMsXG4gIG1hdDQ6IDE2ICogNFxufTtcbmZ1bmN0aW9uIGNyZWF0ZVVCT0VsZW1lbnRzKHVuaWZvcm1EYXRhKSB7XG4gIGNvbnN0IHVib0VsZW1lbnRzID0gdW5pZm9ybURhdGEubWFwKChkYXRhKSA9PiAoe1xuICAgIGRhdGEsXG4gICAgb2Zmc2V0OiAwLFxuICAgIGRhdGFMZW46IDAsXG4gICAgZGlydHk6IDBcbiAgfSkpO1xuICBsZXQgc2l6ZSA9IDA7XG4gIGxldCBjaHVua1NpemUgPSAwO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB1Ym9FbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHVib0VsZW1lbnQgPSB1Ym9FbGVtZW50c1tpXTtcbiAgICBzaXplID0gR0xTTF9UT19TVEQ0MF9TSVpFW3Vib0VsZW1lbnQuZGF0YS50eXBlXTtcbiAgICBpZiAodWJvRWxlbWVudC5kYXRhLnNpemUgPiAxKSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoc2l6ZSwgMTYpICogdWJvRWxlbWVudC5kYXRhLnNpemU7XG4gICAgfVxuICAgIHVib0VsZW1lbnQuZGF0YUxlbiA9IHNpemU7XG4gICAgaWYgKGNodW5rU2l6ZSAlIHNpemUgIT09IDAgJiYgY2h1bmtTaXplIDwgMTYpIHtcbiAgICAgIGNvbnN0IGxpbmVVcFZhbHVlID0gY2h1bmtTaXplICUgc2l6ZSAlIDE2O1xuICAgICAgY2h1bmtTaXplICs9IGxpbmVVcFZhbHVlO1xuICAgICAgb2Zmc2V0ICs9IGxpbmVVcFZhbHVlO1xuICAgIH1cbiAgICBpZiAoY2h1bmtTaXplICsgc2l6ZSA+IDE2KSB7XG4gICAgICBvZmZzZXQgPSBNYXRoLmNlaWwob2Zmc2V0IC8gMTYpICogMTY7XG4gICAgICB1Ym9FbGVtZW50Lm9mZnNldCA9IG9mZnNldDtcbiAgICAgIG9mZnNldCArPSBzaXplO1xuICAgICAgY2h1bmtTaXplID0gc2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdWJvRWxlbWVudC5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBjaHVua1NpemUgKz0gc2l6ZTtcbiAgICAgIG9mZnNldCArPSBzaXplO1xuICAgIH1cbiAgfVxuICBvZmZzZXQgPSBNYXRoLmNlaWwob2Zmc2V0IC8gMTYpICogMTY7XG4gIHJldHVybiB7IHVib0VsZW1lbnRzLCBzaXplOiBvZmZzZXQgfTtcbn1cbmZ1bmN0aW9uIGdldFVCT0RhdGEodW5pZm9ybXMsIHVuaWZvcm1EYXRhKSB7XG4gIGNvbnN0IHVzZWRVbmlmb3JtRGF0YXMgPSBbXTtcbiAgZm9yIChjb25zdCBpIGluIHVuaWZvcm1zKSB7XG4gICAgaWYgKHVuaWZvcm1EYXRhW2ldKSB7XG4gICAgICB1c2VkVW5pZm9ybURhdGFzLnB1c2godW5pZm9ybURhdGFbaV0pO1xuICAgIH1cbiAgfVxuICB1c2VkVW5pZm9ybURhdGFzLnNvcnQoKGEsIGIpID0+IGEuaW5kZXggLSBiLmluZGV4KTtcbiAgcmV0dXJuIHVzZWRVbmlmb3JtRGF0YXM7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVVuaWZvcm1CdWZmZXJTeW5jKGdyb3VwLCB1bmlmb3JtRGF0YSkge1xuICBpZiAoIWdyb3VwLmF1dG9NYW5hZ2UpIHtcbiAgICByZXR1cm4geyBzaXplOiAwLCBzeW5jRnVuYzogdWJvVXBkYXRlIH07XG4gIH1cbiAgY29uc3QgdXNlZFVuaWZvcm1EYXRhcyA9IGdldFVCT0RhdGEoZ3JvdXAudW5pZm9ybXMsIHVuaWZvcm1EYXRhKTtcbiAgY29uc3QgeyB1Ym9FbGVtZW50cywgc2l6ZSB9ID0gY3JlYXRlVUJPRWxlbWVudHModXNlZFVuaWZvcm1EYXRhcyk7XG4gIGNvbnN0IGZ1bmNGcmFnbWVudHMgPSBbYFxuICAgIHZhciB2ID0gbnVsbDtcbiAgICB2YXIgdjIgPSBudWxsO1xuICAgIHZhciBjdiA9IG51bGw7XG4gICAgdmFyIHQgPSAwO1xuICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgZGF0YSA9IGJ1ZmZlci5kYXRhO1xuICAgIGBdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHVib0VsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdWJvRWxlbWVudCA9IHVib0VsZW1lbnRzW2ldO1xuICAgIGNvbnN0IHVuaWZvcm0gPSBncm91cC51bmlmb3Jtc1t1Ym9FbGVtZW50LmRhdGEubmFtZV07XG4gICAgY29uc3QgbmFtZSA9IHVib0VsZW1lbnQuZGF0YS5uYW1lO1xuICAgIGxldCBwYXJzZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHVuaWZvcm1QYXJzZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCB1bmlmb3JtUGFyc2VyID0gdW5pZm9ybVBhcnNlcnNbal07XG4gICAgICBpZiAodW5pZm9ybVBhcnNlci5jb2RlVWJvICYmIHVuaWZvcm1QYXJzZXIudGVzdCh1Ym9FbGVtZW50LmRhdGEsIHVuaWZvcm0pKSB7XG4gICAgICAgIGZ1bmNGcmFnbWVudHMucHVzaChgb2Zmc2V0ID0gJHt1Ym9FbGVtZW50Lm9mZnNldCAvIDR9O2AsIHVuaWZvcm1QYXJzZXJzW2pdLmNvZGVVYm8odWJvRWxlbWVudC5kYXRhLm5hbWUsIHVuaWZvcm0pKTtcbiAgICAgICAgcGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICBpZiAodWJvRWxlbWVudC5kYXRhLnNpemUgPiAxKSB7XG4gICAgICAgIGNvbnN0IHNpemUyID0gbWFwU2l6ZSh1Ym9FbGVtZW50LmRhdGEudHlwZSk7XG4gICAgICAgIGNvbnN0IHJvd1NpemUgPSBNYXRoLm1heChHTFNMX1RPX1NURDQwX1NJWkVbdWJvRWxlbWVudC5kYXRhLnR5cGVdIC8gMTYsIDEpO1xuICAgICAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHNpemUyIC8gcm93U2l6ZTtcbiAgICAgICAgY29uc3QgcmVtYWluZGVyID0gKDQgLSBlbGVtZW50U2l6ZSAlIDQpICUgNDtcbiAgICAgICAgZnVuY0ZyYWdtZW50cy5wdXNoKGBcbiAgICAgICAgICAgICAgICBjdiA9IHVkLiR7bmFtZX0udmFsdWU7XG4gICAgICAgICAgICAgICAgdiA9IHV2LiR7bmFtZX07XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gJHt1Ym9FbGVtZW50Lm9mZnNldCAvIDR9O1xuXG4gICAgICAgICAgICAgICAgdCA9IDA7XG5cbiAgICAgICAgICAgICAgICBmb3IodmFyIGk9MDsgaSA8ICR7dWJvRWxlbWVudC5kYXRhLnNpemUgKiByb3dTaXplfTsgaSsrKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8ICR7ZWxlbWVudFNpemV9OyBqKyspXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0KytdID0gdlt0KytdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSAke3JlbWFpbmRlcn07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IFVCT19UT19TSU5HTEVfU0VUVEVSU1t1Ym9FbGVtZW50LmRhdGEudHlwZV07XG4gICAgICAgIGZ1bmNGcmFnbWVudHMucHVzaChgXG4gICAgICAgICAgICAgICAgY3YgPSB1ZC4ke25hbWV9LnZhbHVlO1xuICAgICAgICAgICAgICAgIHYgPSB1di4ke25hbWV9O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9ICR7dWJvRWxlbWVudC5vZmZzZXQgLyA0fTtcbiAgICAgICAgICAgICAgICAke3RlbXBsYXRlfTtcbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY0ZyYWdtZW50cy5wdXNoKGBcbiAgICAgICByZW5kZXJlci5idWZmZXIudXBkYXRlKGJ1ZmZlcik7XG4gICAgYCk7XG4gIHJldHVybiB7XG4gICAgc2l6ZSxcbiAgICBzeW5jRnVuYzogbmV3IEZ1bmN0aW9uKFwidWRcIiwgXCJ1dlwiLCBcInJlbmRlcmVyXCIsIFwic3luY0RhdGFcIiwgXCJidWZmZXJcIiwgZnVuY0ZyYWdtZW50cy5qb2luKFwiXFxuXCIpKVxuICB9O1xufVxuXG5leHBvcnQgeyBjcmVhdGVVQk9FbGVtZW50cywgZ2VuZXJhdGVVbmlmb3JtQnVmZmVyU3luYywgZ2V0VUJPRGF0YSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2VuZXJhdGVVbmlmb3JtQnVmZmVyU3luYy5tanMubWFwXG4iLCJsZXQgdW5zYWZlRXZhbDtcbmZ1bmN0aW9uIHVuc2FmZUV2YWxTdXBwb3J0ZWQoKSB7XG4gIGlmICh0eXBlb2YgdW5zYWZlRXZhbCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gdW5zYWZlRXZhbDtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IGZ1bmMgPSBuZXcgRnVuY3Rpb24oXCJwYXJhbTFcIiwgXCJwYXJhbTJcIiwgXCJwYXJhbTNcIiwgXCJyZXR1cm4gcGFyYW0xW3BhcmFtMl0gPT09IHBhcmFtMztcIik7XG4gICAgdW5zYWZlRXZhbCA9IGZ1bmMoeyBhOiBcImJcIiB9LCBcImFcIiwgXCJiXCIpID09PSB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdW5zYWZlRXZhbCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB1bnNhZmVFdmFsO1xufVxuXG5leHBvcnQgeyB1bnNhZmVFdmFsU3VwcG9ydGVkIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bnNhZmVFdmFsU3VwcG9ydGVkLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tICdAcGl4aS9leHRlbnNpb25zJztcbmltcG9ydCAnLi91dGlscy9pbmRleC5tanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVQcm9ncmFtIH0gZnJvbSAnLi91dGlscy9nZW5lcmF0ZVByb2dyYW0ubWpzJztcbmltcG9ydCB7IGdlbmVyYXRlVW5pZm9ybUJ1ZmZlclN5bmMgfSBmcm9tICcuL3V0aWxzL2dlbmVyYXRlVW5pZm9ybUJ1ZmZlclN5bmMubWpzJztcbmltcG9ydCB7IHVuc2FmZUV2YWxTdXBwb3J0ZWQgfSBmcm9tICcuL3V0aWxzL3Vuc2FmZUV2YWxTdXBwb3J0ZWQubWpzJztcbmltcG9ydCB7IGdlbmVyYXRlVW5pZm9ybXNTeW5jIH0gZnJvbSAnLi91dGlscy9nZW5lcmF0ZVVuaWZvcm1zU3luYy5tanMnO1xuXG5sZXQgVUlEID0gMDtcbmNvbnN0IGRlZmF1bHRTeW5jRGF0YSA9IHsgdGV4dHVyZUNvdW50OiAwLCB1Ym9Db3VudDogMCB9O1xuY2xhc3MgU2hhZGVyU3lzdGVtIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLnN5c3RlbUNoZWNrKCk7XG4gICAgdGhpcy5nbCA9IG51bGw7XG4gICAgdGhpcy5zaGFkZXIgPSBudWxsO1xuICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgIHRoaXMuX3Vib0NhY2hlID0ge307XG4gICAgdGhpcy5pZCA9IFVJRCsrO1xuICB9XG4gIHN5c3RlbUNoZWNrKCkge1xuICAgIGlmICghdW5zYWZlRXZhbFN1cHBvcnRlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IGFsbG93IHVuc2FmZS1ldmFsLCBwbGVhc2UgdXNlIEBwaXhpL3Vuc2FmZS1ldmFsIG1vZHVsZSB0byBlbmFibGUgc3VwcG9ydC5cIik7XG4gICAgfVxuICB9XG4gIGNvbnRleHRDaGFuZ2UoZ2wpIHtcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG4gIGJpbmQoc2hhZGVyLCBkb250U3luYykge1xuICAgIHNoYWRlci5kaXNwb3NlUnVubmVyLmFkZCh0aGlzKTtcbiAgICBzaGFkZXIudW5pZm9ybXMuZ2xvYmFscyA9IHRoaXMucmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXM7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHNoYWRlci5wcm9ncmFtO1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IHByb2dyYW0uZ2xQcm9ncmFtc1t0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEXSB8fCB0aGlzLmdlbmVyYXRlUHJvZ3JhbShzaGFkZXIpO1xuICAgIHRoaXMuc2hhZGVyID0gc2hhZGVyO1xuICAgIGlmICh0aGlzLnByb2dyYW0gIT09IHByb2dyYW0pIHtcbiAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICB0aGlzLmdsLnVzZVByb2dyYW0oZ2xQcm9ncmFtLnByb2dyYW0pO1xuICAgIH1cbiAgICBpZiAoIWRvbnRTeW5jKSB7XG4gICAgICBkZWZhdWx0U3luY0RhdGEudGV4dHVyZUNvdW50ID0gMDtcbiAgICAgIGRlZmF1bHRTeW5jRGF0YS51Ym9Db3VudCA9IDA7XG4gICAgICB0aGlzLnN5bmNVbmlmb3JtR3JvdXAoc2hhZGVyLnVuaWZvcm1Hcm91cCwgZGVmYXVsdFN5bmNEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGdsUHJvZ3JhbTtcbiAgfVxuICBzZXRVbmlmb3Jtcyh1bmlmb3Jtcykge1xuICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuc2hhZGVyLnByb2dyYW07XG4gICAgY29uc3QgZ2xQcm9ncmFtID0gc2hhZGVyLmdsUHJvZ3JhbXNbdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRF07XG4gICAgc2hhZGVyLnN5bmNVbmlmb3JtcyhnbFByb2dyYW0udW5pZm9ybURhdGEsIHVuaWZvcm1zLCB0aGlzLnJlbmRlcmVyKTtcbiAgfVxuICBzeW5jVW5pZm9ybUdyb3VwKGdyb3VwLCBzeW5jRGF0YSkge1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IHRoaXMuZ2V0R2xQcm9ncmFtKCk7XG4gICAgaWYgKCFncm91cC5zdGF0aWMgfHwgZ3JvdXAuZGlydHlJZCAhPT0gZ2xQcm9ncmFtLnVuaWZvcm1EaXJ0eUdyb3Vwc1tncm91cC5pZF0pIHtcbiAgICAgIGdsUHJvZ3JhbS51bmlmb3JtRGlydHlHcm91cHNbZ3JvdXAuaWRdID0gZ3JvdXAuZGlydHlJZDtcbiAgICAgIHRoaXMuc3luY1VuaWZvcm1zKGdyb3VwLCBnbFByb2dyYW0sIHN5bmNEYXRhKTtcbiAgICB9XG4gIH1cbiAgc3luY1VuaWZvcm1zKGdyb3VwLCBnbFByb2dyYW0sIHN5bmNEYXRhKSB7XG4gICAgY29uc3Qgc3luY0Z1bmMgPSBncm91cC5zeW5jVW5pZm9ybXNbdGhpcy5zaGFkZXIucHJvZ3JhbS5pZF0gfHwgdGhpcy5jcmVhdGVTeW5jR3JvdXBzKGdyb3VwKTtcbiAgICBzeW5jRnVuYyhnbFByb2dyYW0udW5pZm9ybURhdGEsIGdyb3VwLnVuaWZvcm1zLCB0aGlzLnJlbmRlcmVyLCBzeW5jRGF0YSk7XG4gIH1cbiAgY3JlYXRlU3luY0dyb3Vwcyhncm91cCkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXRTaWduYXR1cmUoZ3JvdXAsIHRoaXMuc2hhZGVyLnByb2dyYW0udW5pZm9ybURhdGEsIFwidVwiKTtcbiAgICBpZiAoIXRoaXMuY2FjaGVbaWRdKSB7XG4gICAgICB0aGlzLmNhY2hlW2lkXSA9IGdlbmVyYXRlVW5pZm9ybXNTeW5jKGdyb3VwLCB0aGlzLnNoYWRlci5wcm9ncmFtLnVuaWZvcm1EYXRhKTtcbiAgICB9XG4gICAgZ3JvdXAuc3luY1VuaWZvcm1zW3RoaXMuc2hhZGVyLnByb2dyYW0uaWRdID0gdGhpcy5jYWNoZVtpZF07XG4gICAgcmV0dXJuIGdyb3VwLnN5bmNVbmlmb3Jtc1t0aGlzLnNoYWRlci5wcm9ncmFtLmlkXTtcbiAgfVxuICBzeW5jVW5pZm9ybUJ1ZmZlckdyb3VwKGdyb3VwLCBuYW1lKSB7XG4gICAgY29uc3QgZ2xQcm9ncmFtID0gdGhpcy5nZXRHbFByb2dyYW0oKTtcbiAgICBpZiAoIWdyb3VwLnN0YXRpYyB8fCBncm91cC5kaXJ0eUlkICE9PSAwIHx8ICFnbFByb2dyYW0udW5pZm9ybUdyb3Vwc1tncm91cC5pZF0pIHtcbiAgICAgIGdyb3VwLmRpcnR5SWQgPSAwO1xuICAgICAgY29uc3Qgc3luY0Z1bmMgPSBnbFByb2dyYW0udW5pZm9ybUdyb3Vwc1tncm91cC5pZF0gfHwgdGhpcy5jcmVhdGVTeW5jQnVmZmVyR3JvdXAoZ3JvdXAsIGdsUHJvZ3JhbSwgbmFtZSk7XG4gICAgICBncm91cC5idWZmZXIudXBkYXRlKCk7XG4gICAgICBzeW5jRnVuYyhnbFByb2dyYW0udW5pZm9ybURhdGEsIGdyb3VwLnVuaWZvcm1zLCB0aGlzLnJlbmRlcmVyLCBkZWZhdWx0U3luY0RhdGEsIGdyb3VwLmJ1ZmZlcik7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyZXIuYnVmZmVyLmJpbmRCdWZmZXJCYXNlKGdyb3VwLmJ1ZmZlciwgZ2xQcm9ncmFtLnVuaWZvcm1CdWZmZXJCaW5kaW5nc1tuYW1lXSk7XG4gIH1cbiAgY3JlYXRlU3luY0J1ZmZlckdyb3VwKGdyb3VwLCBnbFByb2dyYW0sIG5hbWUpIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzLnJlbmRlcmVyO1xuICAgIHRoaXMucmVuZGVyZXIuYnVmZmVyLmJpbmQoZ3JvdXAuYnVmZmVyKTtcbiAgICBjb25zdCB1bmlmb3JtQmxvY2tJbmRleCA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUJsb2NrSW5kZXgoZ2xQcm9ncmFtLnByb2dyYW0sIG5hbWUpO1xuICAgIGdsUHJvZ3JhbS51bmlmb3JtQnVmZmVyQmluZGluZ3NbbmFtZV0gPSB0aGlzLnNoYWRlci51bmlmb3JtQmluZENvdW50O1xuICAgIGdsLnVuaWZvcm1CbG9ja0JpbmRpbmcoZ2xQcm9ncmFtLnByb2dyYW0sIHVuaWZvcm1CbG9ja0luZGV4LCB0aGlzLnNoYWRlci51bmlmb3JtQmluZENvdW50KTtcbiAgICB0aGlzLnNoYWRlci51bmlmb3JtQmluZENvdW50Kys7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdldFNpZ25hdHVyZShncm91cCwgdGhpcy5zaGFkZXIucHJvZ3JhbS51bmlmb3JtRGF0YSwgXCJ1Ym9cIik7XG4gICAgbGV0IHVib0RhdGEgPSB0aGlzLl91Ym9DYWNoZVtpZF07XG4gICAgaWYgKCF1Ym9EYXRhKSB7XG4gICAgICB1Ym9EYXRhID0gdGhpcy5fdWJvQ2FjaGVbaWRdID0gZ2VuZXJhdGVVbmlmb3JtQnVmZmVyU3luYyhncm91cCwgdGhpcy5zaGFkZXIucHJvZ3JhbS51bmlmb3JtRGF0YSk7XG4gICAgfVxuICAgIGlmIChncm91cC5hdXRvTWFuYWdlKSB7XG4gICAgICBjb25zdCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheSh1Ym9EYXRhLnNpemUgLyA0KTtcbiAgICAgIGdyb3VwLmJ1ZmZlci51cGRhdGUoZGF0YSk7XG4gICAgfVxuICAgIGdsUHJvZ3JhbS51bmlmb3JtR3JvdXBzW2dyb3VwLmlkXSA9IHVib0RhdGEuc3luY0Z1bmM7XG4gICAgcmV0dXJuIGdsUHJvZ3JhbS51bmlmb3JtR3JvdXBzW2dyb3VwLmlkXTtcbiAgfVxuICBnZXRTaWduYXR1cmUoZ3JvdXAsIHVuaWZvcm1EYXRhLCBwcmVGaXgpIHtcbiAgICBjb25zdCB1bmlmb3JtcyA9IGdyb3VwLnVuaWZvcm1zO1xuICAgIGNvbnN0IHN0cmluZ3MgPSBbYCR7cHJlRml4fS1gXTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdW5pZm9ybXMpIHtcbiAgICAgIHN0cmluZ3MucHVzaChpKTtcbiAgICAgIGlmICh1bmlmb3JtRGF0YVtpXSkge1xuICAgICAgICBzdHJpbmdzLnB1c2godW5pZm9ybURhdGFbaV0udHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdzLmpvaW4oXCItXCIpO1xuICB9XG4gIGdldEdsUHJvZ3JhbSgpIHtcbiAgICBpZiAodGhpcy5zaGFkZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnNoYWRlci5wcm9ncmFtLmdsUHJvZ3JhbXNbdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRF07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdlbmVyYXRlUHJvZ3JhbShzaGFkZXIpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHNoYWRlci5wcm9ncmFtO1xuICAgIGNvbnN0IGdsUHJvZ3JhbSA9IGdlbmVyYXRlUHJvZ3JhbShnbCwgcHJvZ3JhbSk7XG4gICAgcHJvZ3JhbS5nbFByb2dyYW1zW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdID0gZ2xQcm9ncmFtO1xuICAgIHJldHVybiBnbFByb2dyYW07XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICB0aGlzLnNoYWRlciA9IG51bGw7XG4gIH1cbiAgZGlzcG9zZVNoYWRlcihzaGFkZXIpIHtcbiAgICBpZiAodGhpcy5zaGFkZXIgPT09IHNoYWRlcikge1xuICAgICAgdGhpcy5zaGFkZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxufVxuU2hhZGVyU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJzaGFkZXJcIlxufTtcbmV4dGVuc2lvbnMuYWRkKFNoYWRlclN5c3RlbSk7XG5cbmV4cG9ydCB7IFNoYWRlclN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2hhZGVyU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tICdAcGl4aS9leHRlbnNpb25zJztcblxuY2xhc3MgU3RhcnR1cFN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIHJ1bihvcHRpb25zKSB7XG4gICAgY29uc3QgeyByZW5kZXJlciB9ID0gdGhpcztcbiAgICByZW5kZXJlci5ydW5uZXJzLmluaXQuZW1pdChyZW5kZXJlci5vcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5oZWxsbykge1xuICAgICAgY29uc29sZS5sb2coYFBpeGlKUyAke1wiNy4yLjRcIn0gLSAke3JlbmRlcmVyLnJlbmRlcmVyTG9nSWR9IC0gaHR0cHM6Ly9waXhpanMuY29tYCk7XG4gICAgfVxuICAgIHJlbmRlcmVyLnJlc2l6ZShyZW5kZXJlci5zY3JlZW4ud2lkdGgsIHJlbmRlcmVyLnNjcmVlbi5oZWlnaHQpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gIH1cbn1cblN0YXJ0dXBTeXN0ZW0uZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGhlbGxvOiBmYWxzZVxufTtcblN0YXJ0dXBTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBbXG4gICAgRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgICBFeHRlbnNpb25UeXBlLkNhbnZhc1JlbmRlcmVyU3lzdGVtXG4gIF0sXG4gIG5hbWU6IFwic3RhcnR1cFwiXG59O1xuZXh0ZW5zaW9ucy5hZGQoU3RhcnR1cFN5c3RlbSk7XG5cbmV4cG9ydCB7IFN0YXJ0dXBTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0YXJ0dXBTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgQkxFTkRfTU9ERVMgfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuXG5mdW5jdGlvbiBtYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkoZ2wsIGFycmF5ID0gW10pIHtcbiAgYXJyYXlbQkxFTkRfTU9ERVMuTk9STUFMXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICBhcnJheVtCTEVORF9NT0RFUy5BRERdID0gW2dsLk9ORSwgZ2wuT05FXTtcbiAgYXJyYXlbQkxFTkRfTU9ERVMuTVVMVElQTFldID0gW2dsLkRTVF9DT0xPUiwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgYXJyYXlbQkxFTkRfTU9ERVMuU0NSRUVOXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQ09MT1IsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W0JMRU5EX01PREVTLk9WRVJMQVldID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W0JMRU5EX01PREVTLkRBUktFTl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgYXJyYXlbQkxFTkRfTU9ERVMuTElHSFRFTl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgYXJyYXlbQkxFTkRfTU9ERVMuQ09MT1JfRE9ER0VdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W0JMRU5EX01PREVTLkNPTE9SX0JVUk5dID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W0JMRU5EX01PREVTLkhBUkRfTElHSFRdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W0JMRU5EX01PREVTLlNPRlRfTElHSFRdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W0JMRU5EX01PREVTLkRJRkZFUkVOQ0VdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W0JMRU5EX01PREVTLkVYQ0xVU0lPTl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgYXJyYXlbQkxFTkRfTU9ERVMuSFVFXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICBhcnJheVtCTEVORF9NT0RFUy5TQVRVUkFUSU9OXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICBhcnJheVtCTEVORF9NT0RFUy5DT0xPUl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgYXJyYXlbQkxFTkRfTU9ERVMuTFVNSU5PU0lUWV0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgYXJyYXlbQkxFTkRfTU9ERVMuTk9ORV0gPSBbMCwgMF07XG4gIGFycmF5W0JMRU5EX01PREVTLk5PUk1BTF9OUE1dID0gW2dsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgYXJyYXlbQkxFTkRfTU9ERVMuQUREX05QTV0gPSBbZ2wuU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORSwgZ2wuT05FXTtcbiAgYXJyYXlbQkxFTkRfTU9ERVMuU0NSRUVOX05QTV0gPSBbZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICBhcnJheVtCTEVORF9NT0RFUy5TUkNfSU5dID0gW2dsLkRTVF9BTFBIQSwgZ2wuWkVST107XG4gIGFycmF5W0JMRU5EX01PREVTLlNSQ19PVVRdID0gW2dsLk9ORV9NSU5VU19EU1RfQUxQSEEsIGdsLlpFUk9dO1xuICBhcnJheVtCTEVORF9NT0RFUy5TUkNfQVRPUF0gPSBbZ2wuRFNUX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgYXJyYXlbQkxFTkRfTU9ERVMuRFNUX09WRVJdID0gW2dsLk9ORV9NSU5VU19EU1RfQUxQSEEsIGdsLk9ORV07XG4gIGFycmF5W0JMRU5EX01PREVTLkRTVF9JTl0gPSBbZ2wuWkVSTywgZ2wuU1JDX0FMUEhBXTtcbiAgYXJyYXlbQkxFTkRfTU9ERVMuRFNUX09VVF0gPSBbZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gIGFycmF5W0JMRU5EX01PREVTLkRTVF9BVE9QXSA9IFtnbC5PTkVfTUlOVVNfRFNUX0FMUEhBLCBnbC5TUkNfQUxQSEFdO1xuICBhcnJheVtCTEVORF9NT0RFUy5YT1JdID0gW2dsLk9ORV9NSU5VU19EU1RfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICBhcnJheVtCTEVORF9NT0RFUy5TVUJUUkFDVF0gPSBbZ2wuT05FLCBnbC5PTkUsIGdsLk9ORSwgZ2wuT05FLCBnbC5GVU5DX1JFVkVSU0VfU1VCVFJBQ1QsIGdsLkZVTkNfQUREXTtcbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgeyBtYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aS5tanMubWFwXG4iLCJpbXBvcnQgeyBCTEVORF9NT0RFUyB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvZXh0ZW5zaW9ucyc7XG5pbXBvcnQgeyBTdGF0ZSB9IGZyb20gJy4vU3RhdGUubWpzJztcbmltcG9ydCB7IG1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aSB9IGZyb20gJy4vdXRpbHMvbWFwV2ViR0xCbGVuZE1vZGVzVG9QaXhpLm1qcyc7XG5cbmNvbnN0IEJMRU5EID0gMDtcbmNvbnN0IE9GRlNFVCA9IDE7XG5jb25zdCBDVUxMSU5HID0gMjtcbmNvbnN0IERFUFRIX1RFU1QgPSAzO1xuY29uc3QgV0lORElORyA9IDQ7XG5jb25zdCBERVBUSF9NQVNLID0gNTtcbmNvbnN0IF9TdGF0ZVN5c3RlbSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5nbCA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZUlkID0gMDtcbiAgICB0aGlzLnBvbHlnb25PZmZzZXQgPSAwO1xuICAgIHRoaXMuYmxlbmRNb2RlID0gQkxFTkRfTU9ERVMuTk9ORTtcbiAgICB0aGlzLl9ibGVuZEVxID0gZmFsc2U7XG4gICAgdGhpcy5tYXAgPSBbXTtcbiAgICB0aGlzLm1hcFtCTEVORF0gPSB0aGlzLnNldEJsZW5kO1xuICAgIHRoaXMubWFwW09GRlNFVF0gPSB0aGlzLnNldE9mZnNldDtcbiAgICB0aGlzLm1hcFtDVUxMSU5HXSA9IHRoaXMuc2V0Q3VsbEZhY2U7XG4gICAgdGhpcy5tYXBbREVQVEhfVEVTVF0gPSB0aGlzLnNldERlcHRoVGVzdDtcbiAgICB0aGlzLm1hcFtXSU5ESU5HXSA9IHRoaXMuc2V0RnJvbnRGYWNlO1xuICAgIHRoaXMubWFwW0RFUFRIX01BU0tdID0gdGhpcy5zZXREZXB0aE1hc2s7XG4gICAgdGhpcy5jaGVja3MgPSBbXTtcbiAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IG5ldyBTdGF0ZSgpO1xuICAgIHRoaXMuZGVmYXVsdFN0YXRlLmJsZW5kID0gdHJ1ZTtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKGdsKSB7XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMuYmxlbmRNb2RlcyA9IG1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aShnbCk7XG4gICAgdGhpcy5zZXQodGhpcy5kZWZhdWx0U3RhdGUpO1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuICBzZXQoc3RhdGUpIHtcbiAgICBzdGF0ZSA9IHN0YXRlIHx8IHRoaXMuZGVmYXVsdFN0YXRlO1xuICAgIGlmICh0aGlzLnN0YXRlSWQgIT09IHN0YXRlLmRhdGEpIHtcbiAgICAgIGxldCBkaWZmID0gdGhpcy5zdGF0ZUlkIF4gc3RhdGUuZGF0YTtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIHdoaWxlIChkaWZmKSB7XG4gICAgICAgIGlmIChkaWZmICYgMSkge1xuICAgICAgICAgIHRoaXMubWFwW2ldLmNhbGwodGhpcywgISEoc3RhdGUuZGF0YSAmIDEgPDwgaSkpO1xuICAgICAgICB9XG4gICAgICAgIGRpZmYgPSBkaWZmID4+IDE7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGVJZCA9IHN0YXRlLmRhdGE7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGVja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuY2hlY2tzW2ldKHRoaXMsIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZm9yY2VTdGF0ZShzdGF0ZSkge1xuICAgIHN0YXRlID0gc3RhdGUgfHwgdGhpcy5kZWZhdWx0U3RhdGU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hcC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5tYXBbaV0uY2FsbCh0aGlzLCAhIShzdGF0ZS5kYXRhICYgMSA8PCBpKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGVja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuY2hlY2tzW2ldKHRoaXMsIHN0YXRlKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZUlkID0gc3RhdGUuZGF0YTtcbiAgfVxuICBzZXRCbGVuZCh2YWx1ZSkge1xuICAgIHRoaXMudXBkYXRlQ2hlY2soX1N0YXRlU3lzdGVtLmNoZWNrQmxlbmRNb2RlLCB2YWx1ZSk7XG4gICAgdGhpcy5nbFt2YWx1ZSA/IFwiZW5hYmxlXCIgOiBcImRpc2FibGVcIl0odGhpcy5nbC5CTEVORCk7XG4gIH1cbiAgc2V0T2Zmc2V0KHZhbHVlKSB7XG4gICAgdGhpcy51cGRhdGVDaGVjayhfU3RhdGVTeXN0ZW0uY2hlY2tQb2x5Z29uT2Zmc2V0LCB2YWx1ZSk7XG4gICAgdGhpcy5nbFt2YWx1ZSA/IFwiZW5hYmxlXCIgOiBcImRpc2FibGVcIl0odGhpcy5nbC5QT0xZR09OX09GRlNFVF9GSUxMKTtcbiAgfVxuICBzZXREZXB0aFRlc3QodmFsdWUpIHtcbiAgICB0aGlzLmdsW3ZhbHVlID8gXCJlbmFibGVcIiA6IFwiZGlzYWJsZVwiXSh0aGlzLmdsLkRFUFRIX1RFU1QpO1xuICB9XG4gIHNldERlcHRoTWFzayh2YWx1ZSkge1xuICAgIHRoaXMuZ2wuZGVwdGhNYXNrKHZhbHVlKTtcbiAgfVxuICBzZXRDdWxsRmFjZSh2YWx1ZSkge1xuICAgIHRoaXMuZ2xbdmFsdWUgPyBcImVuYWJsZVwiIDogXCJkaXNhYmxlXCJdKHRoaXMuZ2wuQ1VMTF9GQUNFKTtcbiAgfVxuICBzZXRGcm9udEZhY2UodmFsdWUpIHtcbiAgICB0aGlzLmdsLmZyb250RmFjZSh0aGlzLmdsW3ZhbHVlID8gXCJDV1wiIDogXCJDQ1dcIl0pO1xuICB9XG4gIHNldEJsZW5kTW9kZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5ibGVuZE1vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5ibGVuZE1vZGUgPSB2YWx1ZTtcbiAgICBjb25zdCBtb2RlID0gdGhpcy5ibGVuZE1vZGVzW3ZhbHVlXTtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgaWYgKG1vZGUubGVuZ3RoID09PSAyKSB7XG4gICAgICBnbC5ibGVuZEZ1bmMobW9kZVswXSwgbW9kZVsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKG1vZGVbMF0sIG1vZGVbMV0sIG1vZGVbMl0sIG1vZGVbM10pO1xuICAgIH1cbiAgICBpZiAobW9kZS5sZW5ndGggPT09IDYpIHtcbiAgICAgIHRoaXMuX2JsZW5kRXEgPSB0cnVlO1xuICAgICAgZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKG1vZGVbNF0sIG1vZGVbNV0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fYmxlbmRFcSkge1xuICAgICAgdGhpcy5fYmxlbmRFcSA9IGZhbHNlO1xuICAgICAgZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCk7XG4gICAgfVxuICB9XG4gIHNldFBvbHlnb25PZmZzZXQodmFsdWUsIHNjYWxlKSB7XG4gICAgdGhpcy5nbC5wb2x5Z29uT2Zmc2V0KHZhbHVlLCBzY2FsZSk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5nbC5waXhlbFN0b3JlaSh0aGlzLmdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcbiAgICB0aGlzLmZvcmNlU3RhdGUodGhpcy5kZWZhdWx0U3RhdGUpO1xuICAgIHRoaXMuX2JsZW5kRXEgPSB0cnVlO1xuICAgIHRoaXMuYmxlbmRNb2RlID0gLTE7XG4gICAgdGhpcy5zZXRCbGVuZE1vZGUoMCk7XG4gIH1cbiAgdXBkYXRlQ2hlY2soZnVuYywgdmFsdWUpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuY2hlY2tzLmluZGV4T2YoZnVuYyk7XG4gICAgaWYgKHZhbHVlICYmIGluZGV4ID09PSAtMSkge1xuICAgICAgdGhpcy5jaGVja3MucHVzaChmdW5jKTtcbiAgICB9IGVsc2UgaWYgKCF2YWx1ZSAmJiBpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuY2hlY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjaGVja0JsZW5kTW9kZShzeXN0ZW0sIHN0YXRlKSB7XG4gICAgc3lzdGVtLnNldEJsZW5kTW9kZShzdGF0ZS5ibGVuZE1vZGUpO1xuICB9XG4gIHN0YXRpYyBjaGVja1BvbHlnb25PZmZzZXQoc3lzdGVtLCBzdGF0ZSkge1xuICAgIHN5c3RlbS5zZXRQb2x5Z29uT2Zmc2V0KDEsIHN0YXRlLnBvbHlnb25PZmZzZXQpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5nbCA9IG51bGw7XG4gIH1cbn07XG5sZXQgU3RhdGVTeXN0ZW0gPSBfU3RhdGVTeXN0ZW07XG5TdGF0ZVN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwic3RhdGVcIlxufTtcbmV4dGVuc2lvbnMuYWRkKFN0YXRlU3lzdGVtKTtcblxuZXhwb3J0IHsgU3RhdGVTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0YXRlU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IFJ1bm5lciB9IGZyb20gJ0BwaXhpL3J1bm5lcic7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdAcGl4aS91dGlscyc7XG5cbmNsYXNzIFN5c3RlbU1hbmFnZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMucnVubmVycyA9IHt9O1xuICAgIHRoaXMuX3N5c3RlbXNIYXNoID0ge307XG4gIH1cbiAgc2V0dXAoY29uZmlnKSB7XG4gICAgdGhpcy5hZGRSdW5uZXJzKC4uLmNvbmZpZy5ydW5uZXJzKTtcbiAgICBjb25zdCBwcmlvcml0eSA9IChjb25maWcucHJpb3JpdHkgPz8gW10pLmZpbHRlcigoa2V5KSA9PiBjb25maWcuc3lzdGVtc1trZXldKTtcbiAgICBjb25zdCBvcmRlckJ5UHJpb3JpdHkgPSBbXG4gICAgICAuLi5wcmlvcml0eSxcbiAgICAgIC4uLk9iamVjdC5rZXlzKGNvbmZpZy5zeXN0ZW1zKS5maWx0ZXIoKGtleSkgPT4gIXByaW9yaXR5LmluY2x1ZGVzKGtleSkpXG4gICAgXTtcbiAgICBmb3IgKGNvbnN0IGkgb2Ygb3JkZXJCeVByaW9yaXR5KSB7XG4gICAgICB0aGlzLmFkZFN5c3RlbShjb25maWcuc3lzdGVtc1tpXSwgaSk7XG4gICAgfVxuICB9XG4gIGFkZFJ1bm5lcnMoLi4ucnVubmVySWRzKSB7XG4gICAgcnVubmVySWRzLmZvckVhY2goKHJ1bm5lcklkKSA9PiB7XG4gICAgICB0aGlzLnJ1bm5lcnNbcnVubmVySWRdID0gbmV3IFJ1bm5lcihydW5uZXJJZCk7XG4gICAgfSk7XG4gIH1cbiAgYWRkU3lzdGVtKENsYXNzUmVmLCBuYW1lKSB7XG4gICAgY29uc3Qgc3lzdGVtID0gbmV3IENsYXNzUmVmKHRoaXMpO1xuICAgIGlmICh0aGlzW25hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFdob29wcyEgVGhlIG5hbWUgXCIke25hbWV9XCIgaXMgYWxyZWFkeSBpbiB1c2VgKTtcbiAgICB9XG4gICAgdGhpc1tuYW1lXSA9IHN5c3RlbTtcbiAgICB0aGlzLl9zeXN0ZW1zSGFzaFtuYW1lXSA9IHN5c3RlbTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5ydW5uZXJzKSB7XG4gICAgICB0aGlzLnJ1bm5lcnNbaV0uYWRkKHN5c3RlbSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGVtaXRXaXRoQ3VzdG9tT3B0aW9ucyhydW5uZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzeXN0ZW1IYXNoS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX3N5c3RlbXNIYXNoKTtcbiAgICBydW5uZXIuaXRlbXMuZm9yRWFjaCgoc3lzdGVtKSA9PiB7XG4gICAgICBjb25zdCBzeXN0ZW1OYW1lID0gc3lzdGVtSGFzaEtleXMuZmluZCgoc3lzdGVtSWQpID0+IHRoaXMuX3N5c3RlbXNIYXNoW3N5c3RlbUlkXSA9PT0gc3lzdGVtKTtcbiAgICAgIHN5c3RlbVtydW5uZXIubmFtZV0ob3B0aW9uc1tzeXN0ZW1OYW1lXSk7XG4gICAgfSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBPYmplY3QudmFsdWVzKHRoaXMucnVubmVycykuZm9yRWFjaCgocnVubmVyKSA9PiB7XG4gICAgICBydW5uZXIuZGVzdHJveSgpO1xuICAgIH0pO1xuICAgIHRoaXMuX3N5c3RlbXNIYXNoID0ge307XG4gIH1cbn1cblxuZXhwb3J0IHsgU3lzdGVtTWFuYWdlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3lzdGVtTWFuYWdlci5tanMubWFwXG4iLCJpbXBvcnQgeyBHQ19NT0RFUyB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvZXh0ZW5zaW9ucyc7XG5cbmNvbnN0IF9UZXh0dXJlR0NTeXN0ZW0gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMuY291bnQgPSAwO1xuICAgIHRoaXMuY2hlY2tDb3VudCA9IDA7XG4gICAgdGhpcy5tYXhJZGxlID0gX1RleHR1cmVHQ1N5c3RlbS5kZWZhdWx0TWF4SWRsZTtcbiAgICB0aGlzLmNoZWNrQ291bnRNYXggPSBfVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRDaGVja0NvdW50TWF4O1xuICAgIHRoaXMubW9kZSA9IF9UZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdE1vZGU7XG4gIH1cbiAgcG9zdHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMucmVuZGVyZXIub2JqZWN0UmVuZGVyZXIucmVuZGVyaW5nVG9TY3JlZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jb3VudCsrO1xuICAgIGlmICh0aGlzLm1vZGUgPT09IEdDX01PREVTLk1BTlVBTCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrQ291bnQrKztcbiAgICBpZiAodGhpcy5jaGVja0NvdW50ID4gdGhpcy5jaGVja0NvdW50TWF4KSB7XG4gICAgICB0aGlzLmNoZWNrQ291bnQgPSAwO1xuICAgICAgdGhpcy5ydW4oKTtcbiAgICB9XG4gIH1cbiAgcnVuKCkge1xuICAgIGNvbnN0IHRtID0gdGhpcy5yZW5kZXJlci50ZXh0dXJlO1xuICAgIGNvbnN0IG1hbmFnZWRUZXh0dXJlcyA9IHRtLm1hbmFnZWRUZXh0dXJlcztcbiAgICBsZXQgd2FzUmVtb3ZlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFuYWdlZFRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gbWFuYWdlZFRleHR1cmVzW2ldO1xuICAgICAgaWYgKCF0ZXh0dXJlLmZyYW1lYnVmZmVyICYmIHRoaXMuY291bnQgLSB0ZXh0dXJlLnRvdWNoZWQgPiB0aGlzLm1heElkbGUpIHtcbiAgICAgICAgdG0uZGVzdHJveVRleHR1cmUodGV4dHVyZSwgdHJ1ZSk7XG4gICAgICAgIG1hbmFnZWRUZXh0dXJlc1tpXSA9IG51bGw7XG4gICAgICAgIHdhc1JlbW92ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAod2FzUmVtb3ZlZCkge1xuICAgICAgbGV0IGogPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYW5hZ2VkVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG1hbmFnZWRUZXh0dXJlc1tpXSAhPT0gbnVsbCkge1xuICAgICAgICAgIG1hbmFnZWRUZXh0dXJlc1tqKytdID0gbWFuYWdlZFRleHR1cmVzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtYW5hZ2VkVGV4dHVyZXMubGVuZ3RoID0gajtcbiAgICB9XG4gIH1cbiAgdW5sb2FkKGRpc3BsYXlPYmplY3QpIHtcbiAgICBjb25zdCB0bSA9IHRoaXMucmVuZGVyZXIudGV4dHVyZTtcbiAgICBjb25zdCB0ZXh0dXJlID0gZGlzcGxheU9iamVjdC5fdGV4dHVyZTtcbiAgICBpZiAodGV4dHVyZSAmJiAhdGV4dHVyZS5mcmFtZWJ1ZmZlcikge1xuICAgICAgdG0uZGVzdHJveVRleHR1cmUodGV4dHVyZSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBkaXNwbGF5T2JqZWN0LmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLnVubG9hZChkaXNwbGF5T2JqZWN0LmNoaWxkcmVuW2ldKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxufTtcbmxldCBUZXh0dXJlR0NTeXN0ZW0gPSBfVGV4dHVyZUdDU3lzdGVtO1xuVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRNb2RlID0gR0NfTU9ERVMuQVVUTztcblRleHR1cmVHQ1N5c3RlbS5kZWZhdWx0TWF4SWRsZSA9IDYwICogNjA7XG5UZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdENoZWNrQ291bnRNYXggPSA2MCAqIDEwO1xuVGV4dHVyZUdDU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJ0ZXh0dXJlR0NcIlxufTtcbmV4dGVuc2lvbnMuYWRkKFRleHR1cmVHQ1N5c3RlbSk7XG5cbmV4cG9ydCB7IFRleHR1cmVHQ1N5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dHVyZUdDU3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IFRZUEVTLCBGT1JNQVRTIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcblxuY2xhc3MgR0xUZXh0dXJlIHtcbiAgY29uc3RydWN0b3IodGV4dHVyZSkge1xuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgdGhpcy53aWR0aCA9IC0xO1xuICAgIHRoaXMuaGVpZ2h0ID0gLTE7XG4gICAgdGhpcy5kaXJ0eUlkID0gLTE7XG4gICAgdGhpcy5kaXJ0eVN0eWxlSWQgPSAtMTtcbiAgICB0aGlzLm1pcG1hcCA9IGZhbHNlO1xuICAgIHRoaXMud3JhcE1vZGUgPSAzMzA3MTtcbiAgICB0aGlzLnR5cGUgPSBUWVBFUy5VTlNJR05FRF9CWVRFO1xuICAgIHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBGT1JNQVRTLlJHQkE7XG4gICAgdGhpcy5zYW1wbGVyVHlwZSA9IDA7XG4gIH1cbn1cblxuZXhwb3J0IHsgR0xUZXh0dXJlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HTFRleHR1cmUubWpzLm1hcFxuIiwiaW1wb3J0IHsgVFlQRVMsIEZPUk1BVFMgfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuXG5mdW5jdGlvbiBtYXBUeXBlQW5kRm9ybWF0VG9JbnRlcm5hbEZvcm1hdChnbCkge1xuICBsZXQgdGFibGU7XG4gIGlmIChcIldlYkdMMlJlbmRlcmluZ0NvbnRleHRcIiBpbiBnbG9iYWxUaGlzICYmIGdsIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5XZWJHTDJSZW5kZXJpbmdDb250ZXh0KSB7XG4gICAgdGFibGUgPSB7XG4gICAgICBbVFlQRVMuVU5TSUdORURfQllURV06IHtcbiAgICAgICAgW0ZPUk1BVFMuUkdCQV06IGdsLlJHQkE4LFxuICAgICAgICBbRk9STUFUUy5SR0JdOiBnbC5SR0I4LFxuICAgICAgICBbRk9STUFUUy5SR106IGdsLlJHOCxcbiAgICAgICAgW0ZPUk1BVFMuUkVEXTogZ2wuUjgsXG4gICAgICAgIFtGT1JNQVRTLlJHQkFfSU5URUdFUl06IGdsLlJHQkE4VUksXG4gICAgICAgIFtGT1JNQVRTLlJHQl9JTlRFR0VSXTogZ2wuUkdCOFVJLFxuICAgICAgICBbRk9STUFUUy5SR19JTlRFR0VSXTogZ2wuUkc4VUksXG4gICAgICAgIFtGT1JNQVRTLlJFRF9JTlRFR0VSXTogZ2wuUjhVSSxcbiAgICAgICAgW0ZPUk1BVFMuQUxQSEFdOiBnbC5BTFBIQSxcbiAgICAgICAgW0ZPUk1BVFMuTFVNSU5BTkNFXTogZ2wuTFVNSU5BTkNFLFxuICAgICAgICBbRk9STUFUUy5MVU1JTkFOQ0VfQUxQSEFdOiBnbC5MVU1JTkFOQ0VfQUxQSEFcbiAgICAgIH0sXG4gICAgICBbVFlQRVMuQllURV06IHtcbiAgICAgICAgW0ZPUk1BVFMuUkdCQV06IGdsLlJHQkE4X1NOT1JNLFxuICAgICAgICBbRk9STUFUUy5SR0JdOiBnbC5SR0I4X1NOT1JNLFxuICAgICAgICBbRk9STUFUUy5SR106IGdsLlJHOF9TTk9STSxcbiAgICAgICAgW0ZPUk1BVFMuUkVEXTogZ2wuUjhfU05PUk0sXG4gICAgICAgIFtGT1JNQVRTLlJHQkFfSU5URUdFUl06IGdsLlJHQkE4SSxcbiAgICAgICAgW0ZPUk1BVFMuUkdCX0lOVEVHRVJdOiBnbC5SR0I4SSxcbiAgICAgICAgW0ZPUk1BVFMuUkdfSU5URUdFUl06IGdsLlJHOEksXG4gICAgICAgIFtGT1JNQVRTLlJFRF9JTlRFR0VSXTogZ2wuUjhJXG4gICAgICB9LFxuICAgICAgW1RZUEVTLlVOU0lHTkVEX1NIT1JUXToge1xuICAgICAgICBbRk9STUFUUy5SR0JBX0lOVEVHRVJdOiBnbC5SR0JBMTZVSSxcbiAgICAgICAgW0ZPUk1BVFMuUkdCX0lOVEVHRVJdOiBnbC5SR0IxNlVJLFxuICAgICAgICBbRk9STUFUUy5SR19JTlRFR0VSXTogZ2wuUkcxNlVJLFxuICAgICAgICBbRk9STUFUUy5SRURfSU5URUdFUl06IGdsLlIxNlVJLFxuICAgICAgICBbRk9STUFUUy5ERVBUSF9DT01QT05FTlRdOiBnbC5ERVBUSF9DT01QT05FTlQxNlxuICAgICAgfSxcbiAgICAgIFtUWVBFUy5TSE9SVF06IHtcbiAgICAgICAgW0ZPUk1BVFMuUkdCQV9JTlRFR0VSXTogZ2wuUkdCQTE2SSxcbiAgICAgICAgW0ZPUk1BVFMuUkdCX0lOVEVHRVJdOiBnbC5SR0IxNkksXG4gICAgICAgIFtGT1JNQVRTLlJHX0lOVEVHRVJdOiBnbC5SRzE2SSxcbiAgICAgICAgW0ZPUk1BVFMuUkVEX0lOVEVHRVJdOiBnbC5SMTZJXG4gICAgICB9LFxuICAgICAgW1RZUEVTLlVOU0lHTkVEX0lOVF06IHtcbiAgICAgICAgW0ZPUk1BVFMuUkdCQV9JTlRFR0VSXTogZ2wuUkdCQTMyVUksXG4gICAgICAgIFtGT1JNQVRTLlJHQl9JTlRFR0VSXTogZ2wuUkdCMzJVSSxcbiAgICAgICAgW0ZPUk1BVFMuUkdfSU5URUdFUl06IGdsLlJHMzJVSSxcbiAgICAgICAgW0ZPUk1BVFMuUkVEX0lOVEVHRVJdOiBnbC5SMzJVSSxcbiAgICAgICAgW0ZPUk1BVFMuREVQVEhfQ09NUE9ORU5UXTogZ2wuREVQVEhfQ09NUE9ORU5UMjRcbiAgICAgIH0sXG4gICAgICBbVFlQRVMuSU5UXToge1xuICAgICAgICBbRk9STUFUUy5SR0JBX0lOVEVHRVJdOiBnbC5SR0JBMzJJLFxuICAgICAgICBbRk9STUFUUy5SR0JfSU5URUdFUl06IGdsLlJHQjMySSxcbiAgICAgICAgW0ZPUk1BVFMuUkdfSU5URUdFUl06IGdsLlJHMzJJLFxuICAgICAgICBbRk9STUFUUy5SRURfSU5URUdFUl06IGdsLlIzMklcbiAgICAgIH0sXG4gICAgICBbVFlQRVMuRkxPQVRdOiB7XG4gICAgICAgIFtGT1JNQVRTLlJHQkFdOiBnbC5SR0JBMzJGLFxuICAgICAgICBbRk9STUFUUy5SR0JdOiBnbC5SR0IzMkYsXG4gICAgICAgIFtGT1JNQVRTLlJHXTogZ2wuUkczMkYsXG4gICAgICAgIFtGT1JNQVRTLlJFRF06IGdsLlIzMkYsXG4gICAgICAgIFtGT1JNQVRTLkRFUFRIX0NPTVBPTkVOVF06IGdsLkRFUFRIX0NPTVBPTkVOVDMyRlxuICAgICAgfSxcbiAgICAgIFtUWVBFUy5IQUxGX0ZMT0FUXToge1xuICAgICAgICBbRk9STUFUUy5SR0JBXTogZ2wuUkdCQTE2RixcbiAgICAgICAgW0ZPUk1BVFMuUkdCXTogZ2wuUkdCMTZGLFxuICAgICAgICBbRk9STUFUUy5SR106IGdsLlJHMTZGLFxuICAgICAgICBbRk9STUFUUy5SRURdOiBnbC5SMTZGXG4gICAgICB9LFxuICAgICAgW1RZUEVTLlVOU0lHTkVEX1NIT1JUXzVfNl81XToge1xuICAgICAgICBbRk9STUFUUy5SR0JdOiBnbC5SR0I1NjVcbiAgICAgIH0sXG4gICAgICBbVFlQRVMuVU5TSUdORURfU0hPUlRfNF80XzRfNF06IHtcbiAgICAgICAgW0ZPUk1BVFMuUkdCQV06IGdsLlJHQkE0XG4gICAgICB9LFxuICAgICAgW1RZUEVTLlVOU0lHTkVEX1NIT1JUXzVfNV81XzFdOiB7XG4gICAgICAgIFtGT1JNQVRTLlJHQkFdOiBnbC5SR0I1X0ExXG4gICAgICB9LFxuICAgICAgW1RZUEVTLlVOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFVl06IHtcbiAgICAgICAgW0ZPUk1BVFMuUkdCQV06IGdsLlJHQjEwX0EyLFxuICAgICAgICBbRk9STUFUUy5SR0JBX0lOVEVHRVJdOiBnbC5SR0IxMF9BMlVJXG4gICAgICB9LFxuICAgICAgW1RZUEVTLlVOU0lHTkVEX0lOVF8xMEZfMTFGXzExRl9SRVZdOiB7XG4gICAgICAgIFtGT1JNQVRTLlJHQl06IGdsLlIxMUZfRzExRl9CMTBGXG4gICAgICB9LFxuICAgICAgW1RZUEVTLlVOU0lHTkVEX0lOVF81XzlfOV85X1JFVl06IHtcbiAgICAgICAgW0ZPUk1BVFMuUkdCXTogZ2wuUkdCOV9FNVxuICAgICAgfSxcbiAgICAgIFtUWVBFUy5VTlNJR05FRF9JTlRfMjRfOF06IHtcbiAgICAgICAgW0ZPUk1BVFMuREVQVEhfU1RFTkNJTF06IGdsLkRFUFRIMjRfU1RFTkNJTDhcbiAgICAgIH0sXG4gICAgICBbVFlQRVMuRkxPQVRfMzJfVU5TSUdORURfSU5UXzI0XzhfUkVWXToge1xuICAgICAgICBbRk9STUFUUy5ERVBUSF9TVEVOQ0lMXTogZ2wuREVQVEgzMkZfU1RFTkNJTDhcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRhYmxlID0ge1xuICAgICAgW1RZUEVTLlVOU0lHTkVEX0JZVEVdOiB7XG4gICAgICAgIFtGT1JNQVRTLlJHQkFdOiBnbC5SR0JBLFxuICAgICAgICBbRk9STUFUUy5SR0JdOiBnbC5SR0IsXG4gICAgICAgIFtGT1JNQVRTLkFMUEhBXTogZ2wuQUxQSEEsXG4gICAgICAgIFtGT1JNQVRTLkxVTUlOQU5DRV06IGdsLkxVTUlOQU5DRSxcbiAgICAgICAgW0ZPUk1BVFMuTFVNSU5BTkNFX0FMUEhBXTogZ2wuTFVNSU5BTkNFX0FMUEhBXG4gICAgICB9LFxuICAgICAgW1RZUEVTLlVOU0lHTkVEX1NIT1JUXzVfNl81XToge1xuICAgICAgICBbRk9STUFUUy5SR0JdOiBnbC5SR0JcbiAgICAgIH0sXG4gICAgICBbVFlQRVMuVU5TSUdORURfU0hPUlRfNF80XzRfNF06IHtcbiAgICAgICAgW0ZPUk1BVFMuUkdCQV06IGdsLlJHQkFcbiAgICAgIH0sXG4gICAgICBbVFlQRVMuVU5TSUdORURfU0hPUlRfNV81XzVfMV06IHtcbiAgICAgICAgW0ZPUk1BVFMuUkdCQV06IGdsLlJHQkFcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiB0YWJsZTtcbn1cblxuZXhwb3J0IHsgbWFwVHlwZUFuZEZvcm1hdFRvSW50ZXJuYWxGb3JtYXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcFR5cGVBbmRGb3JtYXRUb0ludGVybmFsRm9ybWF0Lm1qcy5tYXBcbiIsImltcG9ydCB7IFNBTVBMRVJfVFlQRVMsIFRZUEVTLCBNSVBNQVBfTU9ERVMsIFdSQVBfTU9ERVMsIFNDQUxFX01PREVTIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tICdAcGl4aS9leHRlbnNpb25zJztcbmltcG9ydCB7IHJlbW92ZUl0ZW1zIH0gZnJvbSAnQHBpeGkvdXRpbHMnO1xuaW1wb3J0IHsgQmFzZVRleHR1cmUgfSBmcm9tICcuL0Jhc2VUZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyBHTFRleHR1cmUgfSBmcm9tICcuL0dMVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgbWFwVHlwZUFuZEZvcm1hdFRvSW50ZXJuYWxGb3JtYXQgfSBmcm9tICcuL3V0aWxzL21hcFR5cGVBbmRGb3JtYXRUb0ludGVybmFsRm9ybWF0Lm1qcyc7XG5cbmNsYXNzIFRleHR1cmVTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLmJvdW5kVGV4dHVyZXMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IC0xO1xuICAgIHRoaXMubWFuYWdlZFRleHR1cmVzID0gW107XG4gICAgdGhpcy5fdW5rbm93bkJvdW5kVGV4dHVyZXMgPSBmYWxzZTtcbiAgICB0aGlzLnVua25vd25UZXh0dXJlID0gbmV3IEJhc2VUZXh0dXJlKCk7XG4gICAgdGhpcy5oYXNJbnRlZ2VyVGV4dHVyZXMgPSBmYWxzZTtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgdGhpcy5DT05URVhUX1VJRCA9IHRoaXMucmVuZGVyZXIuQ09OVEVYVF9VSUQ7XG4gICAgdGhpcy53ZWJHTFZlcnNpb24gPSB0aGlzLnJlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uO1xuICAgIHRoaXMuaW50ZXJuYWxGb3JtYXRzID0gbWFwVHlwZUFuZEZvcm1hdFRvSW50ZXJuYWxGb3JtYXQoZ2wpO1xuICAgIGNvbnN0IG1heFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKTtcbiAgICB0aGlzLmJvdW5kVGV4dHVyZXMubGVuZ3RoID0gbWF4VGV4dHVyZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhUZXh0dXJlczsgaSsrKSB7XG4gICAgICB0aGlzLmJvdW5kVGV4dHVyZXNbaV0gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmVtcHR5VGV4dHVyZXMgPSB7fTtcbiAgICBjb25zdCBlbXB0eVRleHR1cmUyRCA9IG5ldyBHTFRleHR1cmUoZ2wuY3JlYXRlVGV4dHVyZSgpKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBlbXB0eVRleHR1cmUyRC50ZXh0dXJlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG5ldyBVaW50OEFycmF5KDQpKTtcbiAgICB0aGlzLmVtcHR5VGV4dHVyZXNbZ2wuVEVYVFVSRV8yRF0gPSBlbXB0eVRleHR1cmUyRDtcbiAgICB0aGlzLmVtcHR5VGV4dHVyZXNbZ2wuVEVYVFVSRV9DVUJFX01BUF0gPSBuZXcgR0xUZXh0dXJlKGdsLmNyZWF0ZVRleHR1cmUoKSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGhpcy5lbXB0eVRleHR1cmVzW2dsLlRFWFRVUkVfQ1VCRV9NQVBdLnRleHR1cmUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsLlJHQkEsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICAgIH1cbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYm91bmRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5iaW5kKG51bGwsIGkpO1xuICAgIH1cbiAgfVxuICBiaW5kKHRleHR1cmUsIGxvY2F0aW9uID0gMCkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgdGV4dHVyZSA9IHRleHR1cmU/LmNhc3RUb0Jhc2VUZXh0dXJlKCk7XG4gICAgaWYgKHRleHR1cmU/LnZhbGlkICYmICF0ZXh0dXJlLnBhcmVudFRleHR1cmVBcnJheSkge1xuICAgICAgdGV4dHVyZS50b3VjaGVkID0gdGhpcy5yZW5kZXJlci50ZXh0dXJlR0MuY291bnQ7XG4gICAgICBjb25zdCBnbFRleHR1cmUgPSB0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdIHx8IHRoaXMuaW5pdFRleHR1cmUodGV4dHVyZSk7XG4gICAgICBpZiAodGhpcy5ib3VuZFRleHR1cmVzW2xvY2F0aW9uXSAhPT0gdGV4dHVyZSkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50TG9jYXRpb24gIT09IGxvY2F0aW9uKSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgbG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKHRleHR1cmUudGFyZ2V0LCBnbFRleHR1cmUudGV4dHVyZSk7XG4gICAgICB9XG4gICAgICBpZiAoZ2xUZXh0dXJlLmRpcnR5SWQgIT09IHRleHR1cmUuZGlydHlJZCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50TG9jYXRpb24gIT09IGxvY2F0aW9uKSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgbG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICAgIH0gZWxzZSBpZiAoZ2xUZXh0dXJlLmRpcnR5U3R5bGVJZCAhPT0gdGV4dHVyZS5kaXJ0eVN0eWxlSWQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0dXJlU3R5bGUodGV4dHVyZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmJvdW5kVGV4dHVyZXNbbG9jYXRpb25dID0gdGV4dHVyZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuY3VycmVudExvY2F0aW9uICE9PSBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgbG9jYXRpb24pO1xuICAgICAgfVxuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5lbXB0eVRleHR1cmVzW2dsLlRFWFRVUkVfMkRdLnRleHR1cmUpO1xuICAgICAgdGhpcy5ib3VuZFRleHR1cmVzW2xvY2F0aW9uXSA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3Vua25vd25Cb3VuZFRleHR1cmVzID0gdHJ1ZTtcbiAgICB0aGlzLmhhc0ludGVnZXJUZXh0dXJlcyA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudExvY2F0aW9uID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJvdW5kVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuYm91bmRUZXh0dXJlc1tpXSA9IHRoaXMudW5rbm93blRleHR1cmU7XG4gICAgfVxuICB9XG4gIHVuYmluZCh0ZXh0dXJlKSB7XG4gICAgY29uc3QgeyBnbCwgYm91bmRUZXh0dXJlcyB9ID0gdGhpcztcbiAgICBpZiAodGhpcy5fdW5rbm93bkJvdW5kVGV4dHVyZXMpIHtcbiAgICAgIHRoaXMuX3Vua25vd25Cb3VuZFRleHR1cmVzID0gZmFsc2U7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvdW5kVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGJvdW5kVGV4dHVyZXNbaV0gPT09IHRoaXMudW5rbm93blRleHR1cmUpIHtcbiAgICAgICAgICB0aGlzLmJpbmQobnVsbCwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3VuZFRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYm91bmRUZXh0dXJlc1tpXSA9PT0gdGV4dHVyZSkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50TG9jYXRpb24gIT09IGkpIHtcbiAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgaSk7XG4gICAgICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBpO1xuICAgICAgICB9XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKHRleHR1cmUudGFyZ2V0LCB0aGlzLmVtcHR5VGV4dHVyZXNbdGV4dHVyZS50YXJnZXRdLnRleHR1cmUpO1xuICAgICAgICBib3VuZFRleHR1cmVzW2ldID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZW5zdXJlU2FtcGxlclR5cGUobWF4VGV4dHVyZXMpIHtcbiAgICBjb25zdCB7IGJvdW5kVGV4dHVyZXMsIGhhc0ludGVnZXJUZXh0dXJlcywgQ09OVEVYVF9VSUQgfSA9IHRoaXM7XG4gICAgaWYgKCFoYXNJbnRlZ2VyVGV4dHVyZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IG1heFRleHR1cmVzIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHRleCA9IGJvdW5kVGV4dHVyZXNbaV07XG4gICAgICBpZiAodGV4KSB7XG4gICAgICAgIGNvbnN0IGdsVGV4dHVyZSA9IHRleC5fZ2xUZXh0dXJlc1tDT05URVhUX1VJRF07XG4gICAgICAgIGlmIChnbFRleHR1cmUuc2FtcGxlclR5cGUgIT09IFNBTVBMRVJfVFlQRVMuRkxPQVQpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnRleHR1cmUudW5iaW5kKHRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaW5pdFRleHR1cmUodGV4dHVyZSkge1xuICAgIGNvbnN0IGdsVGV4dHVyZSA9IG5ldyBHTFRleHR1cmUodGhpcy5nbC5jcmVhdGVUZXh0dXJlKCkpO1xuICAgIGdsVGV4dHVyZS5kaXJ0eUlkID0gLTE7XG4gICAgdGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXSA9IGdsVGV4dHVyZTtcbiAgICB0aGlzLm1hbmFnZWRUZXh0dXJlcy5wdXNoKHRleHR1cmUpO1xuICAgIHRleHR1cmUub24oXCJkaXNwb3NlXCIsIHRoaXMuZGVzdHJveVRleHR1cmUsIHRoaXMpO1xuICAgIHJldHVybiBnbFRleHR1cmU7XG4gIH1cbiAgaW5pdFRleHR1cmVUeXBlKHRleHR1cmUsIGdsVGV4dHVyZSkge1xuICAgIGdsVGV4dHVyZS5pbnRlcm5hbEZvcm1hdCA9IHRoaXMuaW50ZXJuYWxGb3JtYXRzW3RleHR1cmUudHlwZV0/Llt0ZXh0dXJlLmZvcm1hdF0gPz8gdGV4dHVyZS5mb3JtYXQ7XG4gICAgaWYgKHRoaXMud2ViR0xWZXJzaW9uID09PSAyICYmIHRleHR1cmUudHlwZSA9PT0gVFlQRVMuSEFMRl9GTE9BVCkge1xuICAgICAgZ2xUZXh0dXJlLnR5cGUgPSB0aGlzLmdsLkhBTEZfRkxPQVQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsVGV4dHVyZS50eXBlID0gdGV4dHVyZS50eXBlO1xuICAgIH1cbiAgfVxuICB1cGRhdGVUZXh0dXJlKHRleHR1cmUpIHtcbiAgICBjb25zdCBnbFRleHR1cmUgPSB0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgIGlmICghZ2xUZXh0dXJlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICB0aGlzLmluaXRUZXh0dXJlVHlwZSh0ZXh0dXJlLCBnbFRleHR1cmUpO1xuICAgIGlmICh0ZXh0dXJlLnJlc291cmNlPy51cGxvYWQocmVuZGVyZXIsIHRleHR1cmUsIGdsVGV4dHVyZSkpIHtcbiAgICAgIGlmIChnbFRleHR1cmUuc2FtcGxlclR5cGUgIT09IFNBTVBMRVJfVFlQRVMuRkxPQVQpIHtcbiAgICAgICAgdGhpcy5oYXNJbnRlZ2VyVGV4dHVyZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3aWR0aCA9IHRleHR1cmUucmVhbFdpZHRoO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gdGV4dHVyZS5yZWFsSGVpZ2h0O1xuICAgICAgY29uc3QgZ2wgPSByZW5kZXJlci5nbDtcbiAgICAgIGlmIChnbFRleHR1cmUud2lkdGggIT09IHdpZHRoIHx8IGdsVGV4dHVyZS5oZWlnaHQgIT09IGhlaWdodCB8fCBnbFRleHR1cmUuZGlydHlJZCA8IDApIHtcbiAgICAgICAgZ2xUZXh0dXJlLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGdsVGV4dHVyZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGdsLnRleEltYWdlMkQodGV4dHVyZS50YXJnZXQsIDAsIGdsVGV4dHVyZS5pbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgdGV4dHVyZS5mb3JtYXQsIGdsVGV4dHVyZS50eXBlLCBudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRleHR1cmUuZGlydHlTdHlsZUlkICE9PSBnbFRleHR1cmUuZGlydHlTdHlsZUlkKSB7XG4gICAgICB0aGlzLnVwZGF0ZVRleHR1cmVTdHlsZSh0ZXh0dXJlKTtcbiAgICB9XG4gICAgZ2xUZXh0dXJlLmRpcnR5SWQgPSB0ZXh0dXJlLmRpcnR5SWQ7XG4gIH1cbiAgZGVzdHJveVRleHR1cmUodGV4dHVyZSwgc2tpcFJlbW92ZSkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgdGV4dHVyZSA9IHRleHR1cmUuY2FzdFRvQmFzZVRleHR1cmUoKTtcbiAgICBpZiAodGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXSkge1xuICAgICAgdGhpcy51bmJpbmQodGV4dHVyZSk7XG4gICAgICBnbC5kZWxldGVUZXh0dXJlKHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF0udGV4dHVyZSk7XG4gICAgICB0ZXh0dXJlLm9mZihcImRpc3Bvc2VcIiwgdGhpcy5kZXN0cm95VGV4dHVyZSwgdGhpcyk7XG4gICAgICBkZWxldGUgdGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgICAgIGlmICghc2tpcFJlbW92ZSkge1xuICAgICAgICBjb25zdCBpID0gdGhpcy5tYW5hZ2VkVGV4dHVyZXMuaW5kZXhPZih0ZXh0dXJlKTtcbiAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgcmVtb3ZlSXRlbXModGhpcy5tYW5hZ2VkVGV4dHVyZXMsIGksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHVwZGF0ZVRleHR1cmVTdHlsZSh0ZXh0dXJlKSB7XG4gICAgY29uc3QgZ2xUZXh0dXJlID0gdGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgICBpZiAoIWdsVGV4dHVyZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoKHRleHR1cmUubWlwbWFwID09PSBNSVBNQVBfTU9ERVMuUE9XMiB8fCB0aGlzLndlYkdMVmVyc2lvbiAhPT0gMikgJiYgIXRleHR1cmUuaXNQb3dlck9mVHdvKSB7XG4gICAgICBnbFRleHR1cmUubWlwbWFwID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsVGV4dHVyZS5taXBtYXAgPSB0ZXh0dXJlLm1pcG1hcCA+PSAxO1xuICAgIH1cbiAgICBpZiAodGhpcy53ZWJHTFZlcnNpb24gIT09IDIgJiYgIXRleHR1cmUuaXNQb3dlck9mVHdvKSB7XG4gICAgICBnbFRleHR1cmUud3JhcE1vZGUgPSBXUkFQX01PREVTLkNMQU1QO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbFRleHR1cmUud3JhcE1vZGUgPSB0ZXh0dXJlLndyYXBNb2RlO1xuICAgIH1cbiAgICBpZiAodGV4dHVyZS5yZXNvdXJjZT8uc3R5bGUodGhpcy5yZW5kZXJlciwgdGV4dHVyZSwgZ2xUZXh0dXJlKSkge1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFN0eWxlKHRleHR1cmUsIGdsVGV4dHVyZSk7XG4gICAgfVxuICAgIGdsVGV4dHVyZS5kaXJ0eVN0eWxlSWQgPSB0ZXh0dXJlLmRpcnR5U3R5bGVJZDtcbiAgfVxuICBzZXRTdHlsZSh0ZXh0dXJlLCBnbFRleHR1cmUpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgaWYgKGdsVGV4dHVyZS5taXBtYXAgJiYgdGV4dHVyZS5taXBtYXAgIT09IE1JUE1BUF9NT0RFUy5PTl9NQU5VQUwpIHtcbiAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKHRleHR1cmUudGFyZ2V0KTtcbiAgICB9XG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlLnRhcmdldCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsVGV4dHVyZS53cmFwTW9kZSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlLnRhcmdldCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsVGV4dHVyZS53cmFwTW9kZSk7XG4gICAgaWYgKGdsVGV4dHVyZS5taXBtYXApIHtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkodGV4dHVyZS50YXJnZXQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGV4dHVyZS5zY2FsZU1vZGUgPT09IFNDQUxFX01PREVTLkxJTkVBUiA/IGdsLkxJTkVBUl9NSVBNQVBfTElORUFSIDogZ2wuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCk7XG4gICAgICBjb25zdCBhbmlzb3Ryb3BpY0V4dCA9IHRoaXMucmVuZGVyZXIuY29udGV4dC5leHRlbnNpb25zLmFuaXNvdHJvcGljRmlsdGVyaW5nO1xuICAgICAgaWYgKGFuaXNvdHJvcGljRXh0ICYmIHRleHR1cmUuYW5pc290cm9waWNMZXZlbCA+IDAgJiYgdGV4dHVyZS5zY2FsZU1vZGUgPT09IFNDQUxFX01PREVTLkxJTkVBUikge1xuICAgICAgICBjb25zdCBsZXZlbCA9IE1hdGgubWluKHRleHR1cmUuYW5pc290cm9waWNMZXZlbCwgZ2wuZ2V0UGFyYW1ldGVyKGFuaXNvdHJvcGljRXh0Lk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCkpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJmKHRleHR1cmUudGFyZ2V0LCBhbmlzb3Ryb3BpY0V4dC5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgbGV2ZWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmUudGFyZ2V0LCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRleHR1cmUuc2NhbGVNb2RlID09PSBTQ0FMRV9NT0RFUy5MSU5FQVIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcbiAgICB9XG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlLnRhcmdldCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0ZXh0dXJlLnNjYWxlTW9kZSA9PT0gU0NBTEVfTU9ERVMuTElORUFSID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuVGV4dHVyZVN5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gIG5hbWU6IFwidGV4dHVyZVwiXG59O1xuZXh0ZW5zaW9ucy5hZGQoVGV4dHVyZVN5c3RlbSk7XG5cbmV4cG9ydCB7IFRleHR1cmVTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHR1cmVTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2V4dGVuc2lvbnMnO1xuXG5jbGFzcyBUcmFuc2Zvcm1GZWVkYmFja1N5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIGNvbnRleHRDaGFuZ2UoKSB7XG4gICAgdGhpcy5nbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgdGhpcy5DT05URVhUX1VJRCA9IHRoaXMucmVuZGVyZXIuQ09OVEVYVF9VSUQ7XG4gIH1cbiAgYmluZCh0cmFuc2Zvcm1GZWVkYmFjaykge1xuICAgIGNvbnN0IHsgZ2wsIENPTlRFWFRfVUlEIH0gPSB0aGlzO1xuICAgIGNvbnN0IGdsVHJhbnNmb3JtRmVlZGJhY2sgPSB0cmFuc2Zvcm1GZWVkYmFjay5fZ2xUcmFuc2Zvcm1GZWVkYmFja3NbQ09OVEVYVF9VSURdIHx8IHRoaXMuY3JlYXRlR0xUcmFuc2Zvcm1GZWVkYmFjayh0cmFuc2Zvcm1GZWVkYmFjayk7XG4gICAgZ2wuYmluZFRyYW5zZm9ybUZlZWRiYWNrKGdsLlRSQU5TRk9STV9GRUVEQkFDSywgZ2xUcmFuc2Zvcm1GZWVkYmFjayk7XG4gIH1cbiAgdW5iaW5kKCkge1xuICAgIGNvbnN0IHsgZ2wgfSA9IHRoaXM7XG4gICAgZ2wuYmluZFRyYW5zZm9ybUZlZWRiYWNrKGdsLlRSQU5TRk9STV9GRUVEQkFDSywgbnVsbCk7XG4gIH1cbiAgYmVnaW5UcmFuc2Zvcm1GZWVkYmFjayhkcmF3TW9kZSwgc2hhZGVyKSB7XG4gICAgY29uc3QgeyBnbCwgcmVuZGVyZXIgfSA9IHRoaXM7XG4gICAgaWYgKHNoYWRlcikge1xuICAgICAgcmVuZGVyZXIuc2hhZGVyLmJpbmQoc2hhZGVyKTtcbiAgICB9XG4gICAgZ2wuYmVnaW5UcmFuc2Zvcm1GZWVkYmFjayhkcmF3TW9kZSk7XG4gIH1cbiAgZW5kVHJhbnNmb3JtRmVlZGJhY2soKSB7XG4gICAgY29uc3QgeyBnbCB9ID0gdGhpcztcbiAgICBnbC5lbmRUcmFuc2Zvcm1GZWVkYmFjaygpO1xuICB9XG4gIGNyZWF0ZUdMVHJhbnNmb3JtRmVlZGJhY2sodGYpIHtcbiAgICBjb25zdCB7IGdsLCByZW5kZXJlciwgQ09OVEVYVF9VSUQgfSA9IHRoaXM7XG4gICAgY29uc3QgZ2xUcmFuc2Zvcm1GZWVkYmFjayA9IGdsLmNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrKCk7XG4gICAgdGYuX2dsVHJhbnNmb3JtRmVlZGJhY2tzW0NPTlRFWFRfVUlEXSA9IGdsVHJhbnNmb3JtRmVlZGJhY2s7XG4gICAgZ2wuYmluZFRyYW5zZm9ybUZlZWRiYWNrKGdsLlRSQU5TRk9STV9GRUVEQkFDSywgZ2xUcmFuc2Zvcm1GZWVkYmFjayk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0Zi5idWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSB0Zi5idWZmZXJzW2ldO1xuICAgICAgaWYgKCFidWZmZXIpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgcmVuZGVyZXIuYnVmZmVyLnVwZGF0ZShidWZmZXIpO1xuICAgICAgYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdLnJlZkNvdW50Kys7XG4gICAgICBnbC5iaW5kQnVmZmVyQmFzZShnbC5UUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSLCBpLCBidWZmZXIuX2dsQnVmZmVyc1tDT05URVhUX1VJRF0uYnVmZmVyIHx8IG51bGwpO1xuICAgIH1cbiAgICBnbC5iaW5kVHJhbnNmb3JtRmVlZGJhY2soZ2wuVFJBTlNGT1JNX0ZFRURCQUNLLCBudWxsKTtcbiAgICB0Zi5kaXNwb3NlUnVubmVyLmFkZCh0aGlzKTtcbiAgICByZXR1cm4gZ2xUcmFuc2Zvcm1GZWVkYmFjaztcbiAgfVxuICBkaXNwb3NlVHJhbnNmb3JtRmVlZGJhY2sodGYsIGNvbnRleHRMb3N0KSB7XG4gICAgY29uc3QgZ2xURiA9IHRmLl9nbFRyYW5zZm9ybUZlZWRiYWNrc1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgdGYuZGlzcG9zZVJ1bm5lci5yZW1vdmUodGhpcyk7XG4gICAgY29uc3QgYnVmZmVyU3lzdGVtID0gdGhpcy5yZW5kZXJlci5idWZmZXI7XG4gICAgaWYgKGJ1ZmZlclN5c3RlbSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0Zi5idWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRmLmJ1ZmZlcnNbaV07XG4gICAgICAgIGlmICghYnVmZmVyKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBidWYgPSBidWZmZXIuX2dsQnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgICAgICAgaWYgKGJ1Zikge1xuICAgICAgICAgIGJ1Zi5yZWZDb3VudC0tO1xuICAgICAgICAgIGlmIChidWYucmVmQ291bnQgPT09IDAgJiYgIWNvbnRleHRMb3N0KSB7XG4gICAgICAgICAgICBidWZmZXJTeXN0ZW0uZGlzcG9zZShidWZmZXIsIGNvbnRleHRMb3N0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFnbFRGKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY29udGV4dExvc3QpIHtcbiAgICAgIGdsLmRlbGV0ZVRyYW5zZm9ybUZlZWRiYWNrKGdsVEYpO1xuICAgIH1cbiAgICBkZWxldGUgdGYuX2dsVHJhbnNmb3JtRmVlZGJhY2tzW3RoaXMuQ09OVEVYVF9VSURdO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbn1cblRyYW5zZm9ybUZlZWRiYWNrU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJ0cmFuc2Zvcm1GZWVkYmFja1wiXG59O1xuZXh0ZW5zaW9ucy5hZGQoVHJhbnNmb3JtRmVlZGJhY2tTeXN0ZW0pO1xuXG5leHBvcnQgeyBUcmFuc2Zvcm1GZWVkYmFja1N5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNmb3JtRmVlZGJhY2tTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2V4dGVuc2lvbnMnO1xuaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnQHBpeGkvbWF0aCc7XG5pbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gJ0BwaXhpL3NldHRpbmdzJztcblxuY2xhc3MgVmlld1N5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIGluaXQob3B0aW9ucykge1xuICAgIHRoaXMuc2NyZWVuID0gbmV3IFJlY3RhbmdsZSgwLCAwLCBvcHRpb25zLndpZHRoLCBvcHRpb25zLmhlaWdodCk7XG4gICAgdGhpcy5lbGVtZW50ID0gb3B0aW9ucy52aWV3IHx8IHNldHRpbmdzLkFEQVBURVIuY3JlYXRlQ2FudmFzKCk7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gb3B0aW9ucy5yZXNvbHV0aW9uIHx8IHNldHRpbmdzLlJFU09MVVRJT047XG4gICAgdGhpcy5hdXRvRGVuc2l0eSA9ICEhb3B0aW9ucy5hdXRvRGVuc2l0eTtcbiAgfVxuICByZXNpemVWaWV3KGRlc2lyZWRTY3JlZW5XaWR0aCwgZGVzaXJlZFNjcmVlbkhlaWdodCkge1xuICAgIHRoaXMuZWxlbWVudC53aWR0aCA9IE1hdGgucm91bmQoZGVzaXJlZFNjcmVlbldpZHRoICogdGhpcy5yZXNvbHV0aW9uKTtcbiAgICB0aGlzLmVsZW1lbnQuaGVpZ2h0ID0gTWF0aC5yb3VuZChkZXNpcmVkU2NyZWVuSGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uKTtcbiAgICBjb25zdCBzY3JlZW5XaWR0aCA9IHRoaXMuZWxlbWVudC53aWR0aCAvIHRoaXMucmVzb2x1dGlvbjtcbiAgICBjb25zdCBzY3JlZW5IZWlnaHQgPSB0aGlzLmVsZW1lbnQuaGVpZ2h0IC8gdGhpcy5yZXNvbHV0aW9uO1xuICAgIHRoaXMuc2NyZWVuLndpZHRoID0gc2NyZWVuV2lkdGg7XG4gICAgdGhpcy5zY3JlZW4uaGVpZ2h0ID0gc2NyZWVuSGVpZ2h0O1xuICAgIGlmICh0aGlzLmF1dG9EZW5zaXR5KSB7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHtzY3JlZW5XaWR0aH1weGA7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7c2NyZWVuSGVpZ2h0fXB4YDtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJlci5lbWl0KFwicmVzaXplXCIsIHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQpO1xuICAgIHRoaXMucmVuZGVyZXIucnVubmVycy5yZXNpemUuZW1pdCh0aGlzLnNjcmVlbi53aWR0aCwgdGhpcy5zY3JlZW4uaGVpZ2h0KTtcbiAgfVxuICBkZXN0cm95KHJlbW92ZVZpZXcpIHtcbiAgICBpZiAocmVtb3ZlVmlldykge1xuICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGU/LnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5zY3JlZW4gPSBudWxsO1xuICB9XG59XG5WaWV3U3lzdGVtLmRlZmF1bHRPcHRpb25zID0ge1xuICB3aWR0aDogODAwLFxuICBoZWlnaHQ6IDYwMCxcbiAgcmVzb2x1dGlvbjogc2V0dGluZ3MuUkVTT0xVVElPTixcbiAgYXV0b0RlbnNpdHk6IGZhbHNlXG59O1xuVmlld1N5c3RlbS5leHRlbnNpb24gPSB7XG4gIHR5cGU6IFtcbiAgICBFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICAgIEV4dGVuc2lvblR5cGUuQ2FudmFzUmVuZGVyZXJTeXN0ZW1cbiAgXSxcbiAgbmFtZTogXCJfdmlld1wiXG59O1xuZXh0ZW5zaW9ucy5hZGQoVmlld1N5c3RlbSk7XG5cbmV4cG9ydCB7IFZpZXdTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZpZXdTeXN0ZW0ubWpzLm1hcFxuIiwiZXhwb3J0IHsgQmFja2dyb3VuZFN5c3RlbSB9IGZyb20gJy4vYmFja2dyb3VuZC9CYWNrZ3JvdW5kU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBCYXRjaFN5c3RlbSB9IGZyb20gJy4vYmF0Y2gvQmF0Y2hTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IENvbnRleHRTeXN0ZW0gfSBmcm9tICcuL2NvbnRleHQvQ29udGV4dFN5c3RlbS5tanMnO1xuZXhwb3J0IHsgRmlsdGVyU3lzdGVtIH0gZnJvbSAnLi9maWx0ZXJzL0ZpbHRlclN5c3RlbS5tanMnO1xuZXhwb3J0IHsgRnJhbWVidWZmZXJTeXN0ZW0gfSBmcm9tICcuL2ZyYW1lYnVmZmVyL0ZyYW1lYnVmZmVyU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBHZW9tZXRyeVN5c3RlbSB9IGZyb20gJy4vZ2VvbWV0cnkvR2VvbWV0cnlTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IE1hc2tTeXN0ZW0gfSBmcm9tICcuL21hc2svTWFza1N5c3RlbS5tanMnO1xuZXhwb3J0IHsgU2Npc3NvclN5c3RlbSB9IGZyb20gJy4vbWFzay9TY2lzc29yU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBTdGVuY2lsU3lzdGVtIH0gZnJvbSAnLi9tYXNrL1N0ZW5jaWxTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IFBsdWdpblN5c3RlbSB9IGZyb20gJy4vcGx1Z2luL1BsdWdpblN5c3RlbS5tanMnO1xuZXhwb3J0IHsgUHJvamVjdGlvblN5c3RlbSB9IGZyb20gJy4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBHZW5lcmF0ZVRleHR1cmVTeXN0ZW0gfSBmcm9tICcuL3JlbmRlclRleHR1cmUvR2VuZXJhdGVUZXh0dXJlU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBSZW5kZXJUZXh0dXJlU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJUZXh0dXJlL1JlbmRlclRleHR1cmVTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IFNoYWRlclN5c3RlbSB9IGZyb20gJy4vc2hhZGVyL1NoYWRlclN5c3RlbS5tanMnO1xuZXhwb3J0IHsgU3RhcnR1cFN5c3RlbSB9IGZyb20gJy4vc3RhcnR1cC9TdGFydHVwU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBTdGF0ZVN5c3RlbSB9IGZyb20gJy4vc3RhdGUvU3RhdGVTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IFN5c3RlbU1hbmFnZXIgfSBmcm9tICcuL3N5c3RlbS9TeXN0ZW1NYW5hZ2VyLm1qcyc7XG5leHBvcnQgeyBUZXh0dXJlR0NTeXN0ZW0gfSBmcm9tICcuL3RleHR1cmVzL1RleHR1cmVHQ1N5c3RlbS5tanMnO1xuZXhwb3J0IHsgVGV4dHVyZVN5c3RlbSB9IGZyb20gJy4vdGV4dHVyZXMvVGV4dHVyZVN5c3RlbS5tanMnO1xuZXhwb3J0IHsgVHJhbnNmb3JtRmVlZGJhY2tTeXN0ZW0gfSBmcm9tICcuL3RyYW5zZm9ybUZlZWRiYWNrL1RyYW5zZm9ybUZlZWRiYWNrU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBWaWV3U3lzdGVtIH0gZnJvbSAnLi92aWV3L1ZpZXdTeXN0ZW0ubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN5c3RlbXMubWpzLm1hcFxuIiwiaW1wb3J0IHsgRU5WIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcbmltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSAnQHBpeGkvc2V0dGluZ3MnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24gfSBmcm9tICdAcGl4aS91dGlscyc7XG5pbXBvcnQgeyBCYXRjaFJlbmRlcmVyIH0gZnJvbSAnLi9iYXRjaC9CYXRjaFJlbmRlcmVyLm1qcyc7XG5pbXBvcnQgeyBGaWx0ZXIgfSBmcm9tICcuL2ZpbHRlcnMvRmlsdGVyLm1qcyc7XG5pbXBvcnQgeyBQcm9ncmFtIH0gZnJvbSAnLi9zaGFkZXIvUHJvZ3JhbS5tanMnO1xuaW1wb3J0ICcuL3N5c3RlbXMubWpzJztcbmltcG9ydCB7IEJhc2VUZXh0dXJlIH0gZnJvbSAnLi90ZXh0dXJlcy9CYXNlVGV4dHVyZS5tanMnO1xuaW1wb3J0IHsgQ29udGV4dFN5c3RlbSB9IGZyb20gJy4vY29udGV4dC9Db250ZXh0U3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBCYWNrZ3JvdW5kU3lzdGVtIH0gZnJvbSAnLi9iYWNrZ3JvdW5kL0JhY2tncm91bmRTeXN0ZW0ubWpzJztcbmltcG9ydCB7IFZpZXdTeXN0ZW0gfSBmcm9tICcuL3ZpZXcvVmlld1N5c3RlbS5tanMnO1xuaW1wb3J0IHsgU3RhcnR1cFN5c3RlbSB9IGZyb20gJy4vc3RhcnR1cC9TdGFydHVwU3lzdGVtLm1qcyc7XG5pbXBvcnQgeyBUZXh0dXJlR0NTeXN0ZW0gfSBmcm9tICcuL3RleHR1cmVzL1RleHR1cmVHQ1N5c3RlbS5tanMnO1xuXG5zZXR0aW5ncy5QUkVGRVJfRU5WID0gRU5WLldFQkdMMjtcbnNldHRpbmdzLlNUUklDVF9URVhUVVJFX0NBQ0hFID0gZmFsc2U7XG5zZXR0aW5ncy5SRU5ERVJfT1BUSU9OUyA9IHtcbiAgLi4uQ29udGV4dFN5c3RlbS5kZWZhdWx0T3B0aW9ucyxcbiAgLi4uQmFja2dyb3VuZFN5c3RlbS5kZWZhdWx0T3B0aW9ucyxcbiAgLi4uVmlld1N5c3RlbS5kZWZhdWx0T3B0aW9ucyxcbiAgLi4uU3RhcnR1cFN5c3RlbS5kZWZhdWx0T3B0aW9uc1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNldHRpbmdzLCB7XG4gIFdSQVBfTU9ERToge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBCYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy53cmFwTW9kZTtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLldSQVBfTU9ERSBpcyBkZXByZWNhdGVkLCB1c2UgQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMud3JhcE1vZGVcIik7XG4gICAgICBCYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy53cmFwTW9kZSA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgU0NBTEVfTU9ERToge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBCYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5zY2FsZU1vZGU7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIGRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5TQ0FMRV9NT0RFIGlzIGRlcHJlY2F0ZWQsIHVzZSBCYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5zY2FsZU1vZGVcIik7XG4gICAgICBCYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5zY2FsZU1vZGUgPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG4gIE1JUE1BUF9URVhUVVJFUzoge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBCYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5taXBtYXA7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIGRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5NSVBNQVBfVEVYVFVSRVMgaXMgZGVwcmVjYXRlZCwgdXNlIEJhc2VUZXh0dXJlLmRlZmF1bHRPcHRpb25zLm1pcG1hcFwiKTtcbiAgICAgIEJhc2VUZXh0dXJlLmRlZmF1bHRPcHRpb25zLm1pcG1hcCA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgQU5JU09UUk9QSUNfTEVWRUw6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMuYW5pc290cm9waWNMZXZlbDtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLkFOSVNPVFJPUElDX0xFVkVMIGlzIGRlcHJlY2F0ZWQsIHVzZSBCYXNlVGV4dHVyZS5kZWZhdWx0T3B0aW9ucy5hbmlzb3Ryb3BpY0xldmVsXCIpO1xuICAgICAgQmFzZVRleHR1cmUuZGVmYXVsdE9wdGlvbnMuYW5pc290cm9waWNMZXZlbCA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgRklMVEVSX1JFU09MVVRJT046IHtcbiAgICBnZXQoKSB7XG4gICAgICBkZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuRklMVEVSX1JFU09MVVRJT04gaXMgZGVwcmVjYXRlZCwgdXNlIEZpbHRlci5kZWZhdWx0UmVzb2x1dGlvblwiKTtcbiAgICAgIHJldHVybiBGaWx0ZXIuZGVmYXVsdFJlc29sdXRpb247XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIEZpbHRlci5kZWZhdWx0UmVzb2x1dGlvbiA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgRklMVEVSX01VTFRJU0FNUExFOiB7XG4gICAgZ2V0KCkge1xuICAgICAgZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLkZJTFRFUl9NVUxUSVNBTVBMRSBpcyBkZXByZWNhdGVkLCB1c2UgRmlsdGVyLmRlZmF1bHRNdWx0aXNhbXBsZVwiKTtcbiAgICAgIHJldHVybiBGaWx0ZXIuZGVmYXVsdE11bHRpc2FtcGxlO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBGaWx0ZXIuZGVmYXVsdE11bHRpc2FtcGxlID0gdmFsdWU7XG4gICAgfVxuICB9LFxuICBTUFJJVEVfTUFYX1RFWFRVUkVTOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIEJhdGNoUmVuZGVyZXIuZGVmYXVsdE1heFRleHR1cmVzO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBkZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuU1BSSVRFX01BWF9URVhUVVJFUyBpcyBkZXByZWNhdGVkLCB1c2UgQmF0Y2hSZW5kZXJlci5kZWZhdWx0TWF4VGV4dHVyZXNcIik7XG4gICAgICBCYXRjaFJlbmRlcmVyLmRlZmF1bHRNYXhUZXh0dXJlcyA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgU1BSSVRFX0JBVENIX1NJWkU6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gQmF0Y2hSZW5kZXJlci5kZWZhdWx0QmF0Y2hTaXplO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBkZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuU1BSSVRFX0JBVENIX1NJWkUgaXMgZGVwcmVjYXRlZCwgdXNlIEJhdGNoUmVuZGVyZXIuZGVmYXVsdEJhdGNoU2l6ZVwiKTtcbiAgICAgIEJhdGNoUmVuZGVyZXIuZGVmYXVsdEJhdGNoU2l6ZSA9IHZhbHVlO1xuICAgIH1cbiAgfSxcbiAgQ0FOX1VQTE9BRF9TQU1FX0JVRkZFUjoge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBCYXRjaFJlbmRlcmVyLmNhblVwbG9hZFNhbWVCdWZmZXI7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIGRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5DQU5fVVBMT0FEX1NBTUVfQlVGRkVSIGlzIGRlcHJlY2F0ZWQsIHVzZSBCYXRjaFJlbmRlcmVyLmNhblVwbG9hZFNhbWVCdWZmZXJcIik7XG4gICAgICBCYXRjaFJlbmRlcmVyLmNhblVwbG9hZFNhbWVCdWZmZXIgPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG4gIEdDX01PREU6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRNb2RlO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBkZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuR0NfTU9ERSBpcyBkZXByZWNhdGVkLCB1c2UgVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRNb2RlXCIpO1xuICAgICAgVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRNb2RlID0gdmFsdWU7XG4gICAgfVxuICB9LFxuICBHQ19NQVhfSURMRToge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBUZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdE1heElkbGU7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIGRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5HQ19NQVhfSURMRSBpcyBkZXByZWNhdGVkLCB1c2UgVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRNYXhJZGxlXCIpO1xuICAgICAgVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRNYXhJZGxlID0gdmFsdWU7XG4gICAgfVxuICB9LFxuICBHQ19NQVhfQ0hFQ0tfQ09VTlQ6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gVGV4dHVyZUdDU3lzdGVtLmRlZmF1bHRDaGVja0NvdW50TWF4O1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBkZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuR0NfTUFYX0NIRUNLX0NPVU5UIGlzIGRlcHJlY2F0ZWQsIHVzZSBUZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdENoZWNrQ291bnRNYXhcIik7XG4gICAgICBUZXh0dXJlR0NTeXN0ZW0uZGVmYXVsdENoZWNrQ291bnRNYXggPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG4gIFBSRUNJU0lPTl9WRVJURVg6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gUHJvZ3JhbS5kZWZhdWx0VmVydGV4UHJlY2lzaW9uO1xuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBkZXByZWNhdGlvbihcIjcuMS4wXCIsIFwic2V0dGluZ3MuUFJFQ0lTSU9OX1ZFUlRFWCBpcyBkZXByZWNhdGVkLCB1c2UgUHJvZ3JhbS5kZWZhdWx0VmVydGV4UHJlY2lzaW9uXCIpO1xuICAgICAgUHJvZ3JhbS5kZWZhdWx0VmVydGV4UHJlY2lzaW9uID0gdmFsdWU7XG4gICAgfVxuICB9LFxuICBQUkVDSVNJT05fRlJBR01FTlQ6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gUHJvZ3JhbS5kZWZhdWx0RnJhZ21lbnRQcmVjaXNpb247XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIGRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5QUkVDSVNJT05fRlJBR01FTlQgaXMgZGVwcmVjYXRlZCwgdXNlIFByb2dyYW0uZGVmYXVsdEZyYWdtZW50UHJlY2lzaW9uXCIpO1xuICAgICAgUHJvZ3JhbS5kZWZhdWx0RnJhZ21lbnRQcmVjaXNpb24gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0dGluZ3MubWpzLm1hcFxuIiwidmFyIFVQREFURV9QUklPUklUWSA9IC8qIEBfX1BVUkVfXyAqLyAoKFVQREFURV9QUklPUklUWTIpID0+IHtcbiAgVVBEQVRFX1BSSU9SSVRZMltVUERBVEVfUFJJT1JJVFkyW1wiSU5URVJBQ1RJT05cIl0gPSA1MF0gPSBcIklOVEVSQUNUSU9OXCI7XG4gIFVQREFURV9QUklPUklUWTJbVVBEQVRFX1BSSU9SSVRZMltcIkhJR0hcIl0gPSAyNV0gPSBcIkhJR0hcIjtcbiAgVVBEQVRFX1BSSU9SSVRZMltVUERBVEVfUFJJT1JJVFkyW1wiTk9STUFMXCJdID0gMF0gPSBcIk5PUk1BTFwiO1xuICBVUERBVEVfUFJJT1JJVFkyW1VQREFURV9QUklPUklUWTJbXCJMT1dcIl0gPSAtMjVdID0gXCJMT1dcIjtcbiAgVVBEQVRFX1BSSU9SSVRZMltVUERBVEVfUFJJT1JJVFkyW1wiVVRJTElUWVwiXSA9IC01MF0gPSBcIlVUSUxJVFlcIjtcbiAgcmV0dXJuIFVQREFURV9QUklPUklUWTI7XG59KShVUERBVEVfUFJJT1JJVFkgfHwge30pO1xuXG5leHBvcnQgeyBVUERBVEVfUFJJT1JJVFkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0Lm1qcy5tYXBcbiIsImNsYXNzIFRpY2tlckxpc3RlbmVyIHtcbiAgY29uc3RydWN0b3IoZm4sIGNvbnRleHQgPSBudWxsLCBwcmlvcml0eSA9IDAsIG9uY2UgPSBmYWxzZSkge1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgdGhpcy5wcmV2aW91cyA9IG51bGw7XG4gICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5mbiA9IGZuO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5wcmlvcml0eSA9IHByaW9yaXR5O1xuICAgIHRoaXMub25jZSA9IG9uY2U7XG4gIH1cbiAgbWF0Y2goZm4sIGNvbnRleHQgPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZm4gPT09IGZuICYmIHRoaXMuY29udGV4dCA9PT0gY29udGV4dDtcbiAgfVxuICBlbWl0KGRlbHRhVGltZSkge1xuICAgIGlmICh0aGlzLmZuKSB7XG4gICAgICBpZiAodGhpcy5jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuZm4uY2FsbCh0aGlzLmNvbnRleHQsIGRlbHRhVGltZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZuKGRlbHRhVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlZGlyZWN0ID0gdGhpcy5uZXh0O1xuICAgIGlmICh0aGlzLm9uY2UpIHtcbiAgICAgIHRoaXMuZGVzdHJveSh0cnVlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkge1xuICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlZGlyZWN0O1xuICB9XG4gIGNvbm5lY3QocHJldmlvdXMpIHtcbiAgICB0aGlzLnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgaWYgKHByZXZpb3VzLm5leHQpIHtcbiAgICAgIHByZXZpb3VzLm5leHQucHJldmlvdXMgPSB0aGlzO1xuICAgIH1cbiAgICB0aGlzLm5leHQgPSBwcmV2aW91cy5uZXh0O1xuICAgIHByZXZpb3VzLm5leHQgPSB0aGlzO1xuICB9XG4gIGRlc3Ryb3koaGFyZCA9IGZhbHNlKSB7XG4gICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLmZuID0gbnVsbDtcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgIGlmICh0aGlzLnByZXZpb3VzKSB7XG4gICAgICB0aGlzLnByZXZpb3VzLm5leHQgPSB0aGlzLm5leHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgIHRoaXMubmV4dC5wcmV2aW91cyA9IHRoaXMucHJldmlvdXM7XG4gICAgfVxuICAgIGNvbnN0IHJlZGlyZWN0ID0gdGhpcy5uZXh0O1xuICAgIHRoaXMubmV4dCA9IGhhcmQgPyBudWxsIDogcmVkaXJlY3Q7XG4gICAgdGhpcy5wcmV2aW91cyA9IG51bGw7XG4gICAgcmV0dXJuIHJlZGlyZWN0O1xuICB9XG59XG5cbmV4cG9ydCB7IFRpY2tlckxpc3RlbmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWNrZXJMaXN0ZW5lci5tanMubWFwXG4iLCJpbXBvcnQgeyBVUERBVEVfUFJJT1JJVFkgfSBmcm9tICcuL2NvbnN0Lm1qcyc7XG5pbXBvcnQgeyBUaWNrZXJMaXN0ZW5lciB9IGZyb20gJy4vVGlja2VyTGlzdGVuZXIubWpzJztcblxuY29uc3QgX1RpY2tlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5hdXRvU3RhcnQgPSBmYWxzZTtcbiAgICB0aGlzLmRlbHRhVGltZSA9IDE7XG4gICAgdGhpcy5sYXN0VGltZSA9IC0xO1xuICAgIHRoaXMuc3BlZWQgPSAxO1xuICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlcXVlc3RJZCA9IG51bGw7XG4gICAgdGhpcy5fbWF4RWxhcHNlZE1TID0gMTAwO1xuICAgIHRoaXMuX21pbkVsYXBzZWRNUyA9IDA7XG4gICAgdGhpcy5fcHJvdGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fbGFzdEZyYW1lID0gLTE7XG4gICAgdGhpcy5faGVhZCA9IG5ldyBUaWNrZXJMaXN0ZW5lcihudWxsLCBudWxsLCBJbmZpbml0eSk7XG4gICAgdGhpcy5kZWx0YU1TID0gMSAvIF9UaWNrZXIudGFyZ2V0RlBNUztcbiAgICB0aGlzLmVsYXBzZWRNUyA9IDEgLyBfVGlja2VyLnRhcmdldEZQTVM7XG4gICAgdGhpcy5fdGljayA9ICh0aW1lKSA9PiB7XG4gICAgICB0aGlzLl9yZXF1ZXN0SWQgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSh0aW1lKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCAmJiB0aGlzLl9yZXF1ZXN0SWQgPT09IG51bGwgJiYgdGhpcy5faGVhZC5uZXh0KSB7XG4gICAgICAgICAgdGhpcy5fcmVxdWVzdElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3RpY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBfcmVxdWVzdElmTmVlZGVkKCkge1xuICAgIGlmICh0aGlzLl9yZXF1ZXN0SWQgPT09IG51bGwgJiYgdGhpcy5faGVhZC5uZXh0KSB7XG4gICAgICB0aGlzLmxhc3RUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB0aGlzLl9sYXN0RnJhbWUgPSB0aGlzLmxhc3RUaW1lO1xuICAgICAgdGhpcy5fcmVxdWVzdElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3RpY2spO1xuICAgIH1cbiAgfVxuICBfY2FuY2VsSWZOZWVkZWQoKSB7XG4gICAgaWYgKHRoaXMuX3JlcXVlc3RJZCAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVxdWVzdElkKTtcbiAgICAgIHRoaXMuX3JlcXVlc3RJZCA9IG51bGw7XG4gICAgfVxuICB9XG4gIF9zdGFydElmUG9zc2libGUoKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgdGhpcy5fcmVxdWVzdElmTmVlZGVkKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmF1dG9TdGFydCkge1xuICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbiAgfVxuICBhZGQoZm4sIGNvbnRleHQsIHByaW9yaXR5ID0gVVBEQVRFX1BSSU9SSVRZLk5PUk1BTCkge1xuICAgIHJldHVybiB0aGlzLl9hZGRMaXN0ZW5lcihuZXcgVGlja2VyTGlzdGVuZXIoZm4sIGNvbnRleHQsIHByaW9yaXR5KSk7XG4gIH1cbiAgYWRkT25jZShmbiwgY29udGV4dCwgcHJpb3JpdHkgPSBVUERBVEVfUFJJT1JJVFkuTk9STUFMKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZExpc3RlbmVyKG5ldyBUaWNrZXJMaXN0ZW5lcihmbiwgY29udGV4dCwgcHJpb3JpdHksIHRydWUpKTtcbiAgfVxuICBfYWRkTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQubmV4dDtcbiAgICBsZXQgcHJldmlvdXMgPSB0aGlzLl9oZWFkO1xuICAgIGlmICghY3VycmVudCkge1xuICAgICAgbGlzdGVuZXIuY29ubmVjdChwcmV2aW91cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgIGlmIChsaXN0ZW5lci5wcmlvcml0eSA+IGN1cnJlbnQucHJpb3JpdHkpIHtcbiAgICAgICAgICBsaXN0ZW5lci5jb25uZWN0KHByZXZpb3VzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICB9XG4gICAgICBpZiAoIWxpc3RlbmVyLnByZXZpb3VzKSB7XG4gICAgICAgIGxpc3RlbmVyLmNvbm5lY3QocHJldmlvdXMpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9zdGFydElmUG9zc2libGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZW1vdmUoZm4sIGNvbnRleHQpIHtcbiAgICBsZXQgbGlzdGVuZXIgPSB0aGlzLl9oZWFkLm5leHQ7XG4gICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICBpZiAobGlzdGVuZXIubWF0Y2goZm4sIGNvbnRleHQpKSB7XG4gICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIuZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuX2hlYWQubmV4dCkge1xuICAgICAgdGhpcy5fY2FuY2VsSWZOZWVkZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0IGNvdW50KCkge1xuICAgIGlmICghdGhpcy5faGVhZCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGxldCBjb3VudCA9IDA7XG4gICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgIHdoaWxlIChjdXJyZW50ID0gY3VycmVudC5uZXh0KSB7XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG4gIH1cbiAgc3RhcnQoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICB0aGlzLl9yZXF1ZXN0SWZOZWVkZWQoKTtcbiAgICB9XG4gIH1cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2NhbmNlbElmTmVlZGVkKCk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKCF0aGlzLl9wcm90ZWN0ZWQpIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgbGV0IGxpc3RlbmVyID0gdGhpcy5faGVhZC5uZXh0O1xuICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIuZGVzdHJveSh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2hlYWQuZGVzdHJveSgpO1xuICAgICAgdGhpcy5faGVhZCA9IG51bGw7XG4gICAgfVxuICB9XG4gIHVwZGF0ZShjdXJyZW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpKSB7XG4gICAgbGV0IGVsYXBzZWRNUztcbiAgICBpZiAoY3VycmVudFRpbWUgPiB0aGlzLmxhc3RUaW1lKSB7XG4gICAgICBlbGFwc2VkTVMgPSB0aGlzLmVsYXBzZWRNUyA9IGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VGltZTtcbiAgICAgIGlmIChlbGFwc2VkTVMgPiB0aGlzLl9tYXhFbGFwc2VkTVMpIHtcbiAgICAgICAgZWxhcHNlZE1TID0gdGhpcy5fbWF4RWxhcHNlZE1TO1xuICAgICAgfVxuICAgICAgZWxhcHNlZE1TICo9IHRoaXMuc3BlZWQ7XG4gICAgICBpZiAodGhpcy5fbWluRWxhcHNlZE1TKSB7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gY3VycmVudFRpbWUgLSB0aGlzLl9sYXN0RnJhbWUgfCAwO1xuICAgICAgICBpZiAoZGVsdGEgPCB0aGlzLl9taW5FbGFwc2VkTVMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lID0gY3VycmVudFRpbWUgLSBkZWx0YSAlIHRoaXMuX21pbkVsYXBzZWRNUztcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVsdGFNUyA9IGVsYXBzZWRNUztcbiAgICAgIHRoaXMuZGVsdGFUaW1lID0gdGhpcy5kZWx0YU1TICogX1RpY2tlci50YXJnZXRGUE1TO1xuICAgICAgY29uc3QgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgICBsZXQgbGlzdGVuZXIgPSBoZWFkLm5leHQ7XG4gICAgICB3aGlsZSAobGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5lbWl0KHRoaXMuZGVsdGFUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmICghaGVhZC5uZXh0KSB7XG4gICAgICAgIHRoaXMuX2NhbmNlbElmTmVlZGVkKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVsdGFUaW1lID0gdGhpcy5kZWx0YU1TID0gdGhpcy5lbGFwc2VkTVMgPSAwO1xuICAgIH1cbiAgICB0aGlzLmxhc3RUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cbiAgZ2V0IEZQUygpIHtcbiAgICByZXR1cm4gMWUzIC8gdGhpcy5lbGFwc2VkTVM7XG4gIH1cbiAgZ2V0IG1pbkZQUygpIHtcbiAgICByZXR1cm4gMWUzIC8gdGhpcy5fbWF4RWxhcHNlZE1TO1xuICB9XG4gIHNldCBtaW5GUFMoZnBzKSB7XG4gICAgY29uc3QgbWluRlBTID0gTWF0aC5taW4odGhpcy5tYXhGUFMsIGZwcyk7XG4gICAgY29uc3QgbWluRlBNUyA9IE1hdGgubWluKE1hdGgubWF4KDAsIG1pbkZQUykgLyAxZTMsIF9UaWNrZXIudGFyZ2V0RlBNUyk7XG4gICAgdGhpcy5fbWF4RWxhcHNlZE1TID0gMSAvIG1pbkZQTVM7XG4gIH1cbiAgZ2V0IG1heEZQUygpIHtcbiAgICBpZiAodGhpcy5fbWluRWxhcHNlZE1TKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCgxZTMgLyB0aGlzLl9taW5FbGFwc2VkTVMpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBzZXQgbWF4RlBTKGZwcykge1xuICAgIGlmIChmcHMgPT09IDApIHtcbiAgICAgIHRoaXMuX21pbkVsYXBzZWRNUyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1heEZQUyA9IE1hdGgubWF4KHRoaXMubWluRlBTLCBmcHMpO1xuICAgICAgdGhpcy5fbWluRWxhcHNlZE1TID0gMSAvIChtYXhGUFMgLyAxZTMpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IHNoYXJlZCgpIHtcbiAgICBpZiAoIV9UaWNrZXIuX3NoYXJlZCkge1xuICAgICAgY29uc3Qgc2hhcmVkID0gX1RpY2tlci5fc2hhcmVkID0gbmV3IF9UaWNrZXIoKTtcbiAgICAgIHNoYXJlZC5hdXRvU3RhcnQgPSB0cnVlO1xuICAgICAgc2hhcmVkLl9wcm90ZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gX1RpY2tlci5fc2hhcmVkO1xuICB9XG4gIHN0YXRpYyBnZXQgc3lzdGVtKCkge1xuICAgIGlmICghX1RpY2tlci5fc3lzdGVtKSB7XG4gICAgICBjb25zdCBzeXN0ZW0gPSBfVGlja2VyLl9zeXN0ZW0gPSBuZXcgX1RpY2tlcigpO1xuICAgICAgc3lzdGVtLmF1dG9TdGFydCA9IHRydWU7XG4gICAgICBzeXN0ZW0uX3Byb3RlY3RlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBfVGlja2VyLl9zeXN0ZW07XG4gIH1cbn07XG5sZXQgVGlja2VyID0gX1RpY2tlcjtcblRpY2tlci50YXJnZXRGUE1TID0gMC4wNjtcblxuZXhwb3J0IHsgVGlja2VyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWNrZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tICdAcGl4aS9zZXR0aW5ncyc7XG5leHBvcnQgeyBzZXR0aW5ncyB9IGZyb20gJ0BwaXhpL3NldHRpbmdzJztcbmltcG9ydCB7IGRlcHJlY2F0aW9uIH0gZnJvbSAnQHBpeGkvdXRpbHMnO1xuaW1wb3J0IHsgVGlja2VyIH0gZnJvbSAnLi9UaWNrZXIubWpzJztcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc2V0dGluZ3MsIHtcbiAgVEFSR0VUX0ZQTVM6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gVGlja2VyLnRhcmdldEZQTVM7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIGRlcHJlY2F0aW9uKFwiNy4xLjBcIiwgXCJzZXR0aW5ncy5UQVJHRVRfRlBNUyBpcyBkZXByZWNhdGVkLCB1c2UgVGlja2VyLnRhcmdldEZQTVNcIik7XG4gICAgICBUaWNrZXIudGFyZ2V0RlBNUyA9IHZhbHVlO1xuICAgIH1cbiAgfVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXR0aW5ncy5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvZXh0ZW5zaW9ucyc7XG5pbXBvcnQgeyBVUERBVEVfUFJJT1JJVFkgfSBmcm9tICcuL2NvbnN0Lm1qcyc7XG5pbXBvcnQgeyBUaWNrZXIgfSBmcm9tICcuL1RpY2tlci5tanMnO1xuXG5jbGFzcyBUaWNrZXJQbHVnaW4ge1xuICBzdGF0aWMgaW5pdChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgYXV0b1N0YXJ0OiB0cnVlLFxuICAgICAgc2hhcmVkVGlja2VyOiBmYWxzZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRpY2tlclwiLCB7XG4gICAgICBzZXQodGlja2VyKSB7XG4gICAgICAgIGlmICh0aGlzLl90aWNrZXIpIHtcbiAgICAgICAgICB0aGlzLl90aWNrZXIucmVtb3ZlKHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90aWNrZXIgPSB0aWNrZXI7XG4gICAgICAgIGlmICh0aWNrZXIpIHtcbiAgICAgICAgICB0aWNrZXIuYWRkKHRoaXMucmVuZGVyLCB0aGlzLCBVUERBVEVfUFJJT1JJVFkuTE9XKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpY2tlcjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnN0b3AgPSAoKSA9PiB7XG4gICAgICB0aGlzLl90aWNrZXIuc3RvcCgpO1xuICAgIH07XG4gICAgdGhpcy5zdGFydCA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3RpY2tlci5zdGFydCgpO1xuICAgIH07XG4gICAgdGhpcy5fdGlja2VyID0gbnVsbDtcbiAgICB0aGlzLnRpY2tlciA9IG9wdGlvbnMuc2hhcmVkVGlja2VyID8gVGlja2VyLnNoYXJlZCA6IG5ldyBUaWNrZXIoKTtcbiAgICBpZiAob3B0aW9ucy5hdXRvU3RhcnQpIHtcbiAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX3RpY2tlcikge1xuICAgICAgY29uc3Qgb2xkVGlja2VyID0gdGhpcy5fdGlja2VyO1xuICAgICAgdGhpcy50aWNrZXIgPSBudWxsO1xuICAgICAgb2xkVGlja2VyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn1cblRpY2tlclBsdWdpbi5leHRlbnNpb24gPSBFeHRlbnNpb25UeXBlLkFwcGxpY2F0aW9uO1xuZXh0ZW5zaW9ucy5hZGQoVGlja2VyUGx1Z2luKTtcblxuZXhwb3J0IHsgVGlja2VyUGx1Z2luIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWNrZXJQbHVnaW4ubWpzLm1hcFxuIiwiaW1wb3J0ICcuL3NldHRpbmdzLm1qcyc7XG5leHBvcnQgeyBVUERBVEVfUFJJT1JJVFkgfSBmcm9tICcuL2NvbnN0Lm1qcyc7XG5leHBvcnQgeyBUaWNrZXIgfSBmcm9tICcuL1RpY2tlci5tanMnO1xuZXhwb3J0IHsgVGlja2VyUGx1Z2luIH0gZnJvbSAnLi9UaWNrZXJQbHVnaW4ubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IGV4dGVuc2lvbnMsIEV4dGVuc2lvblR5cGUgfSBmcm9tICdAcGl4aS9leHRlbnNpb25zJztcblxuY29uc3QgcmVuZGVyZXJzID0gW107XG5leHRlbnNpb25zLmhhbmRsZUJ5TGlzdChFeHRlbnNpb25UeXBlLlJlbmRlcmVyLCByZW5kZXJlcnMpO1xuZnVuY3Rpb24gYXV0b0RldGVjdFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgZm9yIChjb25zdCBSZW5kZXJlclR5cGUgb2YgcmVuZGVyZXJzKSB7XG4gICAgaWYgKFJlbmRlcmVyVHlwZS50ZXN0KG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gbmV3IFJlbmRlcmVyVHlwZShvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGF1dG8tZGV0ZWN0IGEgc3VpdGFibGUgcmVuZGVyZXIuXCIpO1xufVxuXG5leHBvcnQgeyBhdXRvRGV0ZWN0UmVuZGVyZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dG9EZXRlY3RSZW5kZXJlci5tanMubWFwXG4iLCJ2YXIgJGRlZmF1bHRWZXJ0ZXggPSBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcbn1cIjtcblxuZXhwb3J0IHsgJGRlZmF1bHRWZXJ0ZXggYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdC5tanMubWFwXG4iLCJ2YXIgJGRlZmF1bHRGaWx0ZXJWZXJ0ZXggPSBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXG5cXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIHZlYzQgaW5wdXRTaXplO1xcbnVuaWZvcm0gdmVjNCBvdXRwdXRGcmFtZTtcXG5cXG52ZWM0IGZpbHRlclZlcnRleFBvc2l0aW9uKCB2b2lkIClcXG57XFxuICAgIHZlYzIgcG9zaXRpb24gPSBhVmVydGV4UG9zaXRpb24gKiBtYXgob3V0cHV0RnJhbWUuencsIHZlYzIoMC4pKSArIG91dHB1dEZyYW1lLnh5O1xcblxcbiAgICByZXR1cm4gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMocG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxufVxcblxcbnZlYzIgZmlsdGVyVGV4dHVyZUNvb3JkKCB2b2lkIClcXG57XFxuICAgIHJldHVybiBhVmVydGV4UG9zaXRpb24gKiAob3V0cHV0RnJhbWUuencgKiBpbnB1dFNpemUuencpO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX1Bvc2l0aW9uID0gZmlsdGVyVmVydGV4UG9zaXRpb24oKTtcXG4gICAgdlRleHR1cmVDb29yZCA9IGZpbHRlclRleHR1cmVDb29yZCgpO1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgJGRlZmF1bHRGaWx0ZXJWZXJ0ZXggYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdEZpbHRlci5tanMubWFwXG4iLCJpbXBvcnQgJGRlZmF1bHRWZXJ0ZXggZnJvbSAnLi9kZWZhdWx0Lm1qcyc7XG5pbXBvcnQgJGRlZmF1bHRGaWx0ZXJWZXJ0ZXggZnJvbSAnLi9kZWZhdWx0RmlsdGVyLm1qcyc7XG5cbmNvbnN0IGRlZmF1bHRWZXJ0ZXggPSAkZGVmYXVsdFZlcnRleDtcbmNvbnN0IGRlZmF1bHRGaWx0ZXJWZXJ0ZXggPSAkZGVmYXVsdEZpbHRlclZlcnRleDtcblxuZXhwb3J0IHsgZGVmYXVsdEZpbHRlclZlcnRleCwgZGVmYXVsdFZlcnRleCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgTVNBQV9RVUFMSVRZIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tICdAcGl4aS9leHRlbnNpb25zJztcblxuY2xhc3MgTXVsdGlzYW1wbGVTeXN0ZW0ge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKGdsKSB7XG4gICAgbGV0IHNhbXBsZXM7XG4gICAgaWYgKHRoaXMucmVuZGVyZXIuY29udGV4dC53ZWJHTFZlcnNpb24gPT09IDEpIHtcbiAgICAgIGNvbnN0IGZyYW1lYnVmZmVyID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLkZSQU1FQlVGRkVSX0JJTkRJTkcpO1xuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgIHNhbXBsZXMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuU0FNUExFUyk7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZnJhbWVidWZmZXIgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuRFJBV19GUkFNRUJVRkZFUl9CSU5ESU5HKTtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5EUkFXX0ZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgIHNhbXBsZXMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuU0FNUExFUyk7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRFJBV19GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpO1xuICAgIH1cbiAgICBpZiAoc2FtcGxlcyA+PSBNU0FBX1FVQUxJVFkuSElHSCkge1xuICAgICAgdGhpcy5tdWx0aXNhbXBsZSA9IE1TQUFfUVVBTElUWS5ISUdIO1xuICAgIH0gZWxzZSBpZiAoc2FtcGxlcyA+PSBNU0FBX1FVQUxJVFkuTUVESVVNKSB7XG4gICAgICB0aGlzLm11bHRpc2FtcGxlID0gTVNBQV9RVUFMSVRZLk1FRElVTTtcbiAgICB9IGVsc2UgaWYgKHNhbXBsZXMgPj0gTVNBQV9RVUFMSVRZLkxPVykge1xuICAgICAgdGhpcy5tdWx0aXNhbXBsZSA9IE1TQUFfUVVBTElUWS5MT1c7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubXVsdGlzYW1wbGUgPSBNU0FBX1FVQUxJVFkuTk9ORTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgfVxufVxuTXVsdGlzYW1wbGVTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcIl9tdWx0aXNhbXBsZVwiXG59O1xuZXh0ZW5zaW9ucy5hZGQoTXVsdGlzYW1wbGVTeXN0ZW0pO1xuXG5leHBvcnQgeyBNdWx0aXNhbXBsZVN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TXVsdGlzYW1wbGVTeXN0ZW0ubWpzLm1hcFxuIiwiY2xhc3MgR0xCdWZmZXIge1xuICBjb25zdHJ1Y3RvcihidWZmZXIpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlciB8fCBudWxsO1xuICAgIHRoaXMudXBkYXRlSUQgPSAtMTtcbiAgICB0aGlzLmJ5dGVMZW5ndGggPSAtMTtcbiAgICB0aGlzLnJlZkNvdW50ID0gMDtcbiAgfVxufVxuXG5leHBvcnQgeyBHTEJ1ZmZlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R0xCdWZmZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2V4dGVuc2lvbnMnO1xuaW1wb3J0IHsgR0xCdWZmZXIgfSBmcm9tICcuL0dMQnVmZmVyLm1qcyc7XG5cbmNsYXNzIEJ1ZmZlclN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMubWFuYWdlZEJ1ZmZlcnMgPSB7fTtcbiAgICB0aGlzLmJvdW5kQnVmZmVyQmFzZXMgPSB7fTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG4gIGNvbnRleHRDaGFuZ2UoKSB7XG4gICAgdGhpcy5kaXNwb3NlQWxsKHRydWUpO1xuICAgIHRoaXMuZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuICAgIHRoaXMuQ09OVEVYVF9VSUQgPSB0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEO1xuICB9XG4gIGJpbmQoYnVmZmVyKSB7XG4gICAgY29uc3QgeyBnbCwgQ09OVEVYVF9VSUQgfSA9IHRoaXM7XG4gICAgY29uc3QgZ2xCdWZmZXIgPSBidWZmZXIuX2dsQnVmZmVyc1tDT05URVhUX1VJRF0gfHwgdGhpcy5jcmVhdGVHTEJ1ZmZlcihidWZmZXIpO1xuICAgIGdsLmJpbmRCdWZmZXIoYnVmZmVyLnR5cGUsIGdsQnVmZmVyLmJ1ZmZlcik7XG4gIH1cbiAgdW5iaW5kKHR5cGUpIHtcbiAgICBjb25zdCB7IGdsIH0gPSB0aGlzO1xuICAgIGdsLmJpbmRCdWZmZXIodHlwZSwgbnVsbCk7XG4gIH1cbiAgYmluZEJ1ZmZlckJhc2UoYnVmZmVyLCBpbmRleCkge1xuICAgIGNvbnN0IHsgZ2wsIENPTlRFWFRfVUlEIH0gPSB0aGlzO1xuICAgIGlmICh0aGlzLmJvdW5kQnVmZmVyQmFzZXNbaW5kZXhdICE9PSBidWZmZXIpIHtcbiAgICAgIGNvbnN0IGdsQnVmZmVyID0gYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdIHx8IHRoaXMuY3JlYXRlR0xCdWZmZXIoYnVmZmVyKTtcbiAgICAgIHRoaXMuYm91bmRCdWZmZXJCYXNlc1tpbmRleF0gPSBidWZmZXI7XG4gICAgICBnbC5iaW5kQnVmZmVyQmFzZShnbC5VTklGT1JNX0JVRkZFUiwgaW5kZXgsIGdsQnVmZmVyLmJ1ZmZlcik7XG4gICAgfVxuICB9XG4gIGJpbmRCdWZmZXJSYW5nZShidWZmZXIsIGluZGV4LCBvZmZzZXQpIHtcbiAgICBjb25zdCB7IGdsLCBDT05URVhUX1VJRCB9ID0gdGhpcztcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICBjb25zdCBnbEJ1ZmZlciA9IGJ1ZmZlci5fZ2xCdWZmZXJzW0NPTlRFWFRfVUlEXSB8fCB0aGlzLmNyZWF0ZUdMQnVmZmVyKGJ1ZmZlcik7XG4gICAgZ2wuYmluZEJ1ZmZlclJhbmdlKGdsLlVOSUZPUk1fQlVGRkVSLCBpbmRleCB8fCAwLCBnbEJ1ZmZlci5idWZmZXIsIG9mZnNldCAqIDI1NiwgMjU2KTtcbiAgfVxuICB1cGRhdGUoYnVmZmVyKSB7XG4gICAgY29uc3QgeyBnbCwgQ09OVEVYVF9VSUQgfSA9IHRoaXM7XG4gICAgY29uc3QgZ2xCdWZmZXIgPSBidWZmZXIuX2dsQnVmZmVyc1tDT05URVhUX1VJRF0gfHwgdGhpcy5jcmVhdGVHTEJ1ZmZlcihidWZmZXIpO1xuICAgIGlmIChidWZmZXIuX3VwZGF0ZUlEID09PSBnbEJ1ZmZlci51cGRhdGVJRCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBnbEJ1ZmZlci51cGRhdGVJRCA9IGJ1ZmZlci5fdXBkYXRlSUQ7XG4gICAgZ2wuYmluZEJ1ZmZlcihidWZmZXIudHlwZSwgZ2xCdWZmZXIuYnVmZmVyKTtcbiAgICBpZiAoZ2xCdWZmZXIuYnl0ZUxlbmd0aCA+PSBidWZmZXIuZGF0YS5ieXRlTGVuZ3RoKSB7XG4gICAgICBnbC5idWZmZXJTdWJEYXRhKGJ1ZmZlci50eXBlLCAwLCBidWZmZXIuZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRyYXdUeXBlID0gYnVmZmVyLnN0YXRpYyA/IGdsLlNUQVRJQ19EUkFXIDogZ2wuRFlOQU1JQ19EUkFXO1xuICAgICAgZ2xCdWZmZXIuYnl0ZUxlbmd0aCA9IGJ1ZmZlci5kYXRhLmJ5dGVMZW5ndGg7XG4gICAgICBnbC5idWZmZXJEYXRhKGJ1ZmZlci50eXBlLCBidWZmZXIuZGF0YSwgZHJhd1R5cGUpO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlKGJ1ZmZlciwgY29udGV4dExvc3QpIHtcbiAgICBpZiAoIXRoaXMubWFuYWdlZEJ1ZmZlcnNbYnVmZmVyLmlkXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5tYW5hZ2VkQnVmZmVyc1tidWZmZXIuaWRdO1xuICAgIGNvbnN0IGdsQnVmZmVyID0gYnVmZmVyLl9nbEJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGJ1ZmZlci5kaXNwb3NlUnVubmVyLnJlbW92ZSh0aGlzKTtcbiAgICBpZiAoIWdsQnVmZmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY29udGV4dExvc3QpIHtcbiAgICAgIGdsLmRlbGV0ZUJ1ZmZlcihnbEJ1ZmZlci5idWZmZXIpO1xuICAgIH1cbiAgICBkZWxldGUgYnVmZmVyLl9nbEJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gIH1cbiAgZGlzcG9zZUFsbChjb250ZXh0TG9zdCkge1xuICAgIGNvbnN0IGFsbCA9IE9iamVjdC5rZXlzKHRoaXMubWFuYWdlZEJ1ZmZlcnMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmRpc3Bvc2UodGhpcy5tYW5hZ2VkQnVmZmVyc1thbGxbaV1dLCBjb250ZXh0TG9zdCk7XG4gICAgfVxuICB9XG4gIGNyZWF0ZUdMQnVmZmVyKGJ1ZmZlcikge1xuICAgIGNvbnN0IHsgQ09OVEVYVF9VSUQsIGdsIH0gPSB0aGlzO1xuICAgIGJ1ZmZlci5fZ2xCdWZmZXJzW0NPTlRFWFRfVUlEXSA9IG5ldyBHTEJ1ZmZlcihnbC5jcmVhdGVCdWZmZXIoKSk7XG4gICAgdGhpcy5tYW5hZ2VkQnVmZmVyc1tidWZmZXIuaWRdID0gYnVmZmVyO1xuICAgIGJ1ZmZlci5kaXNwb3NlUnVubmVyLmFkZCh0aGlzKTtcbiAgICByZXR1cm4gYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdO1xuICB9XG59XG5CdWZmZXJTeXN0ZW0uZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtLFxuICBuYW1lOiBcImJ1ZmZlclwiXG59O1xuZXh0ZW5zaW9ucy5hZGQoQnVmZmVyU3lzdGVtKTtcblxuZXhwb3J0IHsgQnVmZmVyU3lzdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CdWZmZXJTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2V4dGVuc2lvbnMnO1xuXG5jbGFzcyBPYmplY3RSZW5kZXJlclN5c3RlbSB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIHJlbmRlcihkaXNwbGF5T2JqZWN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIGxldCByZW5kZXJUZXh0dXJlO1xuICAgIGxldCBjbGVhcjtcbiAgICBsZXQgdHJhbnNmb3JtO1xuICAgIGxldCBza2lwVXBkYXRlVHJhbnNmb3JtO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICByZW5kZXJUZXh0dXJlID0gb3B0aW9ucy5yZW5kZXJUZXh0dXJlO1xuICAgICAgY2xlYXIgPSBvcHRpb25zLmNsZWFyO1xuICAgICAgdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG4gICAgICBza2lwVXBkYXRlVHJhbnNmb3JtID0gb3B0aW9ucy5za2lwVXBkYXRlVHJhbnNmb3JtO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlcmluZ1RvU2NyZWVuID0gIXJlbmRlclRleHR1cmU7XG4gICAgcmVuZGVyZXIucnVubmVycy5wcmVyZW5kZXIuZW1pdCgpO1xuICAgIHJlbmRlcmVyLmVtaXQoXCJwcmVyZW5kZXJcIik7XG4gICAgcmVuZGVyZXIucHJvamVjdGlvbi50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgaWYgKHJlbmRlcmVyLmNvbnRleHQuaXNMb3N0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghcmVuZGVyVGV4dHVyZSkge1xuICAgICAgdGhpcy5sYXN0T2JqZWN0UmVuZGVyZWQgPSBkaXNwbGF5T2JqZWN0O1xuICAgIH1cbiAgICBpZiAoIXNraXBVcGRhdGVUcmFuc2Zvcm0pIHtcbiAgICAgIGNvbnN0IGNhY2hlUGFyZW50ID0gZGlzcGxheU9iamVjdC5lbmFibGVUZW1wUGFyZW50KCk7XG4gICAgICBkaXNwbGF5T2JqZWN0LnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgZGlzcGxheU9iamVjdC5kaXNhYmxlVGVtcFBhcmVudChjYWNoZVBhcmVudCk7XG4gICAgfVxuICAgIHJlbmRlcmVyLnJlbmRlclRleHR1cmUuYmluZChyZW5kZXJUZXh0dXJlKTtcbiAgICByZW5kZXJlci5iYXRjaC5jdXJyZW50UmVuZGVyZXIuc3RhcnQoKTtcbiAgICBpZiAoY2xlYXIgPz8gcmVuZGVyZXIuYmFja2dyb3VuZC5jbGVhckJlZm9yZVJlbmRlcikge1xuICAgICAgcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5jbGVhcigpO1xuICAgIH1cbiAgICBkaXNwbGF5T2JqZWN0LnJlbmRlcihyZW5kZXJlcik7XG4gICAgcmVuZGVyZXIuYmF0Y2guY3VycmVudFJlbmRlcmVyLmZsdXNoKCk7XG4gICAgaWYgKHJlbmRlclRleHR1cmUpIHtcbiAgICAgIGlmIChvcHRpb25zLmJsaXQpIHtcbiAgICAgICAgcmVuZGVyZXIuZnJhbWVidWZmZXIuYmxpdCgpO1xuICAgICAgfVxuICAgICAgcmVuZGVyVGV4dHVyZS5iYXNlVGV4dHVyZS51cGRhdGUoKTtcbiAgICB9XG4gICAgcmVuZGVyZXIucnVubmVycy5wb3N0cmVuZGVyLmVtaXQoKTtcbiAgICByZW5kZXJlci5wcm9qZWN0aW9uLnRyYW5zZm9ybSA9IG51bGw7XG4gICAgcmVuZGVyZXIuZW1pdChcInBvc3RyZW5kZXJcIik7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLmxhc3RPYmplY3RSZW5kZXJlZCA9IG51bGw7XG4gIH1cbn1cbk9iamVjdFJlbmRlcmVyU3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgdHlwZTogRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclN5c3RlbSxcbiAgbmFtZTogXCJvYmplY3RSZW5kZXJlclwiXG59O1xuZXh0ZW5zaW9ucy5hZGQoT2JqZWN0UmVuZGVyZXJTeXN0ZW0pO1xuXG5leHBvcnQgeyBPYmplY3RSZW5kZXJlclN5c3RlbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JqZWN0UmVuZGVyZXJTeXN0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgUkVOREVSRVJfVFlQRSB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvZXh0ZW5zaW9ucyc7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tICdAcGl4aS9tYXRoJztcbmltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSAnQHBpeGkvc2V0dGluZ3MnO1xuaW1wb3J0IHsgZGVwcmVjYXRpb24sIGlzV2ViR0xTdXBwb3J0ZWQgfSBmcm9tICdAcGl4aS91dGlscyc7XG5pbXBvcnQgeyBVbmlmb3JtR3JvdXAgfSBmcm9tICcuL3NoYWRlci9Vbmlmb3JtR3JvdXAubWpzJztcbmltcG9ydCB7IFN5c3RlbU1hbmFnZXIgfSBmcm9tICcuL3N5c3RlbS9TeXN0ZW1NYW5hZ2VyLm1qcyc7XG5cbmNvbnN0IF9SZW5kZXJlciA9IGNsYXNzIGV4dGVuZHMgU3lzdGVtTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudHlwZSA9IFJFTkRFUkVSX1RZUEUuV0VCR0w7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHNldHRpbmdzLlJFTkRFUl9PUFRJT05TLCBvcHRpb25zKTtcbiAgICB0aGlzLmdsID0gbnVsbDtcbiAgICB0aGlzLkNPTlRFWFRfVUlEID0gMDtcbiAgICB0aGlzLmdsb2JhbFVuaWZvcm1zID0gbmV3IFVuaWZvcm1Hcm91cCh7XG4gICAgICBwcm9qZWN0aW9uTWF0cml4OiBuZXcgTWF0cml4KClcbiAgICB9LCB0cnVlKTtcbiAgICBjb25zdCBzeXN0ZW1Db25maWcgPSB7XG4gICAgICBydW5uZXJzOiBbXG4gICAgICAgIFwiaW5pdFwiLFxuICAgICAgICBcImRlc3Ryb3lcIixcbiAgICAgICAgXCJjb250ZXh0Q2hhbmdlXCIsXG4gICAgICAgIFwicmVzb2x1dGlvbkNoYW5nZVwiLFxuICAgICAgICBcInJlc2V0XCIsXG4gICAgICAgIFwidXBkYXRlXCIsXG4gICAgICAgIFwicG9zdHJlbmRlclwiLFxuICAgICAgICBcInByZXJlbmRlclwiLFxuICAgICAgICBcInJlc2l6ZVwiXG4gICAgICBdLFxuICAgICAgc3lzdGVtczogX1JlbmRlcmVyLl9fc3lzdGVtcyxcbiAgICAgIHByaW9yaXR5OiBbXG4gICAgICAgIFwiX3ZpZXdcIixcbiAgICAgICAgXCJ0ZXh0dXJlR2VuZXJhdG9yXCIsXG4gICAgICAgIFwiYmFja2dyb3VuZFwiLFxuICAgICAgICBcIl9wbHVnaW5cIixcbiAgICAgICAgXCJzdGFydHVwXCIsXG4gICAgICAgIFwiY29udGV4dFwiLFxuICAgICAgICBcInN0YXRlXCIsXG4gICAgICAgIFwidGV4dHVyZVwiLFxuICAgICAgICBcImJ1ZmZlclwiLFxuICAgICAgICBcImdlb21ldHJ5XCIsXG4gICAgICAgIFwiZnJhbWVidWZmZXJcIixcbiAgICAgICAgXCJ0cmFuc2Zvcm1GZWVkYmFja1wiLFxuICAgICAgICBcIm1hc2tcIixcbiAgICAgICAgXCJzY2lzc29yXCIsXG4gICAgICAgIFwic3RlbmNpbFwiLFxuICAgICAgICBcInByb2plY3Rpb25cIixcbiAgICAgICAgXCJ0ZXh0dXJlR0NcIixcbiAgICAgICAgXCJmaWx0ZXJcIixcbiAgICAgICAgXCJyZW5kZXJUZXh0dXJlXCIsXG4gICAgICAgIFwiYmF0Y2hcIixcbiAgICAgICAgXCJvYmplY3RSZW5kZXJlclwiLFxuICAgICAgICBcIl9tdWx0aXNhbXBsZVwiXG4gICAgICBdXG4gICAgfTtcbiAgICB0aGlzLnNldHVwKHN5c3RlbUNvbmZpZyk7XG4gICAgaWYgKFwidXNlQ29udGV4dEFscGhhXCIgaW4gb3B0aW9ucykge1xuICAgICAgZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBcIm9wdGlvbnMudXNlQ29udGV4dEFscGhhIGlzIGRlcHJlY2F0ZWQsIHVzZSBvcHRpb25zLnByZW11bHRpcGxpZWRBbHBoYSBhbmQgb3B0aW9ucy5iYWNrZ3JvdW5kQWxwaGEgaW5zdGVhZFwiKTtcbiAgICAgIG9wdGlvbnMucHJlbXVsdGlwbGllZEFscGhhID0gb3B0aW9ucy51c2VDb250ZXh0QWxwaGEgJiYgb3B0aW9ucy51c2VDb250ZXh0QWxwaGEgIT09IFwibm90TXVsdGlwbGllZFwiO1xuICAgICAgb3B0aW9ucy5iYWNrZ3JvdW5kQWxwaGEgPSBvcHRpb25zLnVzZUNvbnRleHRBbHBoYSA9PT0gZmFsc2UgPyAxIDogb3B0aW9ucy5iYWNrZ3JvdW5kQWxwaGE7XG4gICAgfVxuICAgIHRoaXMuX3BsdWdpbi5yZW5kZXJlclBsdWdpbnMgPSBfUmVuZGVyZXIuX19wbHVnaW5zO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zdGFydHVwLnJ1bih0aGlzLm9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyB0ZXN0KG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucz8uZm9yY2VDYW52YXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzV2ViR0xTdXBwb3J0ZWQoKTtcbiAgfVxuICByZW5kZXIoZGlzcGxheU9iamVjdCwgb3B0aW9ucykge1xuICAgIHRoaXMub2JqZWN0UmVuZGVyZXIucmVuZGVyKGRpc3BsYXlPYmplY3QsIG9wdGlvbnMpO1xuICB9XG4gIHJlc2l6ZShkZXNpcmVkU2NyZWVuV2lkdGgsIGRlc2lyZWRTY3JlZW5IZWlnaHQpIHtcbiAgICB0aGlzLl92aWV3LnJlc2l6ZVZpZXcoZGVzaXJlZFNjcmVlbldpZHRoLCBkZXNpcmVkU2NyZWVuSGVpZ2h0KTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLnJ1bm5lcnMucmVzZXQuZW1pdCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMucmVuZGVyVGV4dHVyZS5iaW5kKCk7XG4gICAgdGhpcy5yZW5kZXJUZXh0dXJlLmNsZWFyKCk7XG4gIH1cbiAgZGVzdHJveShyZW1vdmVWaWV3ID0gZmFsc2UpIHtcbiAgICB0aGlzLnJ1bm5lcnMuZGVzdHJveS5pdGVtcy5yZXZlcnNlKCk7XG4gICAgdGhpcy5lbWl0V2l0aEN1c3RvbU9wdGlvbnModGhpcy5ydW5uZXJzLmRlc3Ryb3ksIHtcbiAgICAgIF92aWV3OiByZW1vdmVWaWV3XG4gICAgfSk7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG4gIGdldCBwbHVnaW5zKCkge1xuICAgIHJldHVybiB0aGlzLl9wbHVnaW4ucGx1Z2lucztcbiAgfVxuICBnZXQgbXVsdGlzYW1wbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX211bHRpc2FtcGxlLm11bHRpc2FtcGxlO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlldy5lbGVtZW50LndpZHRoO1xuICB9XG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXcuZWxlbWVudC5oZWlnaHQ7XG4gIH1cbiAgZ2V0IHJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXcucmVzb2x1dGlvbjtcbiAgfVxuICBzZXQgcmVzb2x1dGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX3ZpZXcucmVzb2x1dGlvbiA9IHZhbHVlO1xuICAgIHRoaXMucnVubmVycy5yZXNvbHV0aW9uQ2hhbmdlLmVtaXQodmFsdWUpO1xuICB9XG4gIGdldCBhdXRvRGVuc2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlldy5hdXRvRGVuc2l0eTtcbiAgfVxuICBnZXQgdmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlldy5lbGVtZW50O1xuICB9XG4gIGdldCBzY3JlZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXcuc2NyZWVuO1xuICB9XG4gIGdldCBsYXN0T2JqZWN0UmVuZGVyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMub2JqZWN0UmVuZGVyZXIubGFzdE9iamVjdFJlbmRlcmVkO1xuICB9XG4gIGdldCByZW5kZXJpbmdUb1NjcmVlbigpIHtcbiAgICByZXR1cm4gdGhpcy5vYmplY3RSZW5kZXJlci5yZW5kZXJpbmdUb1NjcmVlbjtcbiAgfVxuICBnZXQgcmVuZGVyZXJMb2dJZCgpIHtcbiAgICByZXR1cm4gYFdlYkdMICR7dGhpcy5jb250ZXh0LndlYkdMVmVyc2lvbn1gO1xuICB9XG4gIGdldCBjbGVhckJlZm9yZVJlbmRlcigpIHtcbiAgICBkZXByZWNhdGlvbihcIjcuMC4wXCIsIFwicmVuZGVyZXIuY2xlYXJCZWZvcmVSZW5kZXIgaGFzIGJlZW4gZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSByZW5kZXJlci5iYWNrZ3JvdW5kLmNsZWFyQmVmb3JlUmVuZGVyIGluc3RlYWQuXCIpO1xuICAgIHJldHVybiB0aGlzLmJhY2tncm91bmQuY2xlYXJCZWZvcmVSZW5kZXI7XG4gIH1cbiAgZ2V0IHVzZUNvbnRleHRBbHBoYSgpIHtcbiAgICBkZXByZWNhdGlvbihcIjcuMC4wXCIsIFwicmVuZGVyZXIudXNlQ29udGV4dEFscGhhIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgcmVuZGVyZXIuY29udGV4dC5wcmVtdWx0aXBsaWVkQWxwaGEgaW5zdGVhZC5cIik7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC51c2VDb250ZXh0QWxwaGE7XG4gIH1cbiAgZ2V0IHByZXNlcnZlRHJhd2luZ0J1ZmZlcigpIHtcbiAgICBkZXByZWNhdGlvbihcIjcuMC4wXCIsIFwicmVuZGVyZXIucHJlc2VydmVEcmF3aW5nQnVmZmVyIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHdlIGNhbm5vdCB0cnVseSBrbm93IHRoaXMgdW5sZXNzIHBpeGkgY3JlYXRlZCB0aGUgY29udGV4dFwiKTtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LnByZXNlcnZlRHJhd2luZ0J1ZmZlcjtcbiAgfVxuICBnZXQgYmFja2dyb3VuZENvbG9yKCkge1xuICAgIGRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJyZW5kZXJlci5iYWNrZ3JvdW5kQ29sb3IgaGFzIGJlZW4gZGVwcmVjYXRlZCwgdXNlIHJlbmRlcmVyLmJhY2tncm91bmQuY29sb3IgaW5zdGVhZC5cIik7XG4gICAgcmV0dXJuIHRoaXMuYmFja2dyb3VuZC5jb2xvcjtcbiAgfVxuICBzZXQgYmFja2dyb3VuZENvbG9yKHZhbHVlKSB7XG4gICAgZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBcInJlbmRlcmVyLmJhY2tncm91bmRDb2xvciBoYXMgYmVlbiBkZXByZWNhdGVkLCB1c2UgcmVuZGVyZXIuYmFja2dyb3VuZC5jb2xvciBpbnN0ZWFkLlwiKTtcbiAgICB0aGlzLmJhY2tncm91bmQuY29sb3IgPSB2YWx1ZTtcbiAgfVxuICBnZXQgYmFja2dyb3VuZEFscGhhKCkge1xuICAgIGRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJyZW5kZXJlci5iYWNrZ3JvdW5kQWxwaGEgaGFzIGJlZW4gZGVwcmVjYXRlZCwgdXNlIHJlbmRlcmVyLmJhY2tncm91bmQuYWxwaGEgaW5zdGVhZC5cIik7XG4gICAgcmV0dXJuIHRoaXMuYmFja2dyb3VuZC5hbHBoYTtcbiAgfVxuICBzZXQgYmFja2dyb3VuZEFscGhhKHZhbHVlKSB7XG4gICAgZGVwcmVjYXRpb24oXCI3LjAuMFwiLCBcInJlbmRlcmVyLmJhY2tncm91bmRBbHBoYSBoYXMgYmVlbiBkZXByZWNhdGVkLCB1c2UgcmVuZGVyZXIuYmFja2dyb3VuZC5hbHBoYSBpbnN0ZWFkLlwiKTtcbiAgICB0aGlzLmJhY2tncm91bmQuYWxwaGEgPSB2YWx1ZTtcbiAgfVxuICBnZXQgcG93ZXJQcmVmZXJlbmNlKCkge1xuICAgIGRlcHJlY2F0aW9uKFwiNy4wLjBcIiwgXCJyZW5kZXJlci5wb3dlclByZWZlcmVuY2UgaGFzIGJlZW4gZGVwcmVjYXRlZCwgd2UgY2FuIG9ubHkga25vdyB0aGlzIGlmIHBpeGkgY3JlYXRlcyB0aGUgY29udGV4dFwiKTtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LnBvd2VyUHJlZmVyZW5jZTtcbiAgfVxuICBnZW5lcmF0ZVRleHR1cmUoZGlzcGxheU9iamVjdCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnRleHR1cmVHZW5lcmF0b3IuZ2VuZXJhdGVUZXh0dXJlKGRpc3BsYXlPYmplY3QsIG9wdGlvbnMpO1xuICB9XG59O1xubGV0IFJlbmRlcmVyID0gX1JlbmRlcmVyO1xuUmVuZGVyZXIuZXh0ZW5zaW9uID0ge1xuICB0eXBlOiBFeHRlbnNpb25UeXBlLlJlbmRlcmVyLFxuICBwcmlvcml0eTogMVxufTtcblJlbmRlcmVyLl9fcGx1Z2lucyA9IHt9O1xuUmVuZGVyZXIuX19zeXN0ZW1zID0ge307XG5leHRlbnNpb25zLmhhbmRsZUJ5TWFwKEV4dGVuc2lvblR5cGUuUmVuZGVyZXJQbHVnaW4sIFJlbmRlcmVyLl9fcGx1Z2lucyk7XG5leHRlbnNpb25zLmhhbmRsZUJ5TWFwKEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sIFJlbmRlcmVyLl9fc3lzdGVtcyk7XG5leHRlbnNpb25zLmFkZChSZW5kZXJlcik7XG5cbmV4cG9ydCB7IFJlbmRlcmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZW5kZXJlci5tanMubWFwXG4iLCJpbXBvcnQgeyBCYXNlVGV4dHVyZSB9IGZyb20gJy4uL0Jhc2VUZXh0dXJlLm1qcyc7XG5pbXBvcnQgeyBhdXRvRGV0ZWN0UmVzb3VyY2UgfSBmcm9tICcuL2F1dG9EZXRlY3RSZXNvdXJjZS5tanMnO1xuaW1wb3J0IHsgUmVzb3VyY2UgfSBmcm9tICcuL1Jlc291cmNlLm1qcyc7XG5cbmNsYXNzIEFic3RyYWN0TXVsdGlSZXNvdXJjZSBleHRlbmRzIFJlc291cmNlIHtcbiAgY29uc3RydWN0b3IobGVuZ3RoLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIHN1cGVyKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICB0aGlzLml0ZW1EaXJ0eUlkcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnRUZXh0dXJlID0gbmV3IEJhc2VUZXh0dXJlKCk7XG4gICAgICB0aGlzLml0ZW1zLnB1c2gocGFydFRleHR1cmUpO1xuICAgICAgdGhpcy5pdGVtRGlydHlJZHMucHVzaCgtMik7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuX2xvYWQgPSBudWxsO1xuICAgIHRoaXMuYmFzZVRleHR1cmUgPSBudWxsO1xuICB9XG4gIGluaXRGcm9tQXJyYXkocmVzb3VyY2VzLCBvcHRpb25zKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXJlc291cmNlc1tpXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXNvdXJjZXNbaV0uY2FzdFRvQmFzZVRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5hZGRCYXNlVGV4dHVyZUF0KHJlc291cmNlc1tpXS5jYXN0VG9CYXNlVGV4dHVyZSgpLCBpKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzb3VyY2VzW2ldIGluc3RhbmNlb2YgUmVzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5hZGRSZXNvdXJjZUF0KHJlc291cmNlc1tpXSwgaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZFJlc291cmNlQXQoYXV0b0RldGVjdFJlc291cmNlKHJlc291cmNlc1tpXSwgb3B0aW9ucyksIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLml0ZW1zW2ldLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5pdGVtcyA9IG51bGw7XG4gICAgdGhpcy5pdGVtRGlydHlJZHMgPSBudWxsO1xuICAgIHRoaXMuX2xvYWQgPSBudWxsO1xuICB9XG4gIGFkZFJlc291cmNlQXQocmVzb3VyY2UsIGluZGV4KSB7XG4gICAgaWYgKCF0aGlzLml0ZW1zW2luZGV4XSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbmRleCAke2luZGV4fSBpcyBvdXQgb2YgYm91bmRzYCk7XG4gICAgfVxuICAgIGlmIChyZXNvdXJjZS52YWxpZCAmJiAhdGhpcy52YWxpZCkge1xuICAgICAgdGhpcy5yZXNpemUocmVzb3VyY2Uud2lkdGgsIHJlc291cmNlLmhlaWdodCk7XG4gICAgfVxuICAgIHRoaXMuaXRlbXNbaW5kZXhdLnNldFJlc291cmNlKHJlc291cmNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBiaW5kKGJhc2VUZXh0dXJlKSB7XG4gICAgaWYgKHRoaXMuYmFzZVRleHR1cmUgIT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIGJhc2UgdGV4dHVyZSBwZXIgVGV4dHVyZUFycmF5IGlzIGFsbG93ZWRcIik7XG4gICAgfVxuICAgIHN1cGVyLmJpbmQoYmFzZVRleHR1cmUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5pdGVtc1tpXS5wYXJlbnRUZXh0dXJlQXJyYXkgPSBiYXNlVGV4dHVyZTtcbiAgICAgIHRoaXMuaXRlbXNbaV0ub24oXCJ1cGRhdGVcIiwgYmFzZVRleHR1cmUudXBkYXRlLCBiYXNlVGV4dHVyZSk7XG4gICAgfVxuICB9XG4gIHVuYmluZChiYXNlVGV4dHVyZSkge1xuICAgIHN1cGVyLnVuYmluZChiYXNlVGV4dHVyZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLml0ZW1zW2ldLnBhcmVudFRleHR1cmVBcnJheSA9IG51bGw7XG4gICAgICB0aGlzLml0ZW1zW2ldLm9mZihcInVwZGF0ZVwiLCBiYXNlVGV4dHVyZS51cGRhdGUsIGJhc2VUZXh0dXJlKTtcbiAgICB9XG4gIH1cbiAgbG9hZCgpIHtcbiAgICBpZiAodGhpcy5fbG9hZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvYWQ7XG4gICAgfVxuICAgIGNvbnN0IHJlc291cmNlcyA9IHRoaXMuaXRlbXMubWFwKChpdGVtKSA9PiBpdGVtLnJlc291cmNlKS5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0pO1xuICAgIGNvbnN0IHByb21pc2VzID0gcmVzb3VyY2VzLm1hcCgoaXRlbSkgPT4gaXRlbS5sb2FkKCkpO1xuICAgIHRoaXMuX2xvYWQgPSBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlYWxXaWR0aCwgcmVhbEhlaWdodCB9ID0gdGhpcy5pdGVtc1swXTtcbiAgICAgIHRoaXMucmVzaXplKHJlYWxXaWR0aCwgcmVhbEhlaWdodCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9sb2FkO1xuICB9XG59XG5cbmV4cG9ydCB7IEFic3RyYWN0TXVsdGlSZXNvdXJjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJzdHJhY3RNdWx0aVJlc291cmNlLm1qcy5tYXBcbiIsImltcG9ydCB7IFRBUkdFVFMgfSBmcm9tICdAcGl4aS9jb25zdGFudHMnO1xuaW1wb3J0IHsgQWJzdHJhY3RNdWx0aVJlc291cmNlIH0gZnJvbSAnLi9BYnN0cmFjdE11bHRpUmVzb3VyY2UubWpzJztcblxuY2xhc3MgQXJyYXlSZXNvdXJjZSBleHRlbmRzIEFic3RyYWN0TXVsdGlSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgdXJscztcbiAgICBsZXQgbGVuZ3RoO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHVybHMgPSBzb3VyY2U7XG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSBzb3VyY2U7XG4gICAgfVxuICAgIHN1cGVyKGxlbmd0aCwgeyB3aWR0aCwgaGVpZ2h0IH0pO1xuICAgIGlmICh1cmxzKSB7XG4gICAgICB0aGlzLmluaXRGcm9tQXJyYXkodXJscywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGFkZEJhc2VUZXh0dXJlQXQoYmFzZVRleHR1cmUsIGluZGV4KSB7XG4gICAgaWYgKGJhc2VUZXh0dXJlLnJlc291cmNlKSB7XG4gICAgICB0aGlzLmFkZFJlc291cmNlQXQoYmFzZVRleHR1cmUucmVzb3VyY2UsIGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlSZXNvdXJjZSBkb2VzIG5vdCBzdXBwb3J0IFJlbmRlclRleHR1cmVcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGJpbmQoYmFzZVRleHR1cmUpIHtcbiAgICBzdXBlci5iaW5kKGJhc2VUZXh0dXJlKTtcbiAgICBiYXNlVGV4dHVyZS50YXJnZXQgPSBUQVJHRVRTLlRFWFRVUkVfMkRfQVJSQVk7XG4gIH1cbiAgdXBsb2FkKHJlbmRlcmVyLCB0ZXh0dXJlLCBnbFRleHR1cmUpIHtcbiAgICBjb25zdCB7IGxlbmd0aCwgaXRlbURpcnR5SWRzLCBpdGVtcyB9ID0gdGhpcztcbiAgICBjb25zdCB7IGdsIH0gPSByZW5kZXJlcjtcbiAgICBpZiAoZ2xUZXh0dXJlLmRpcnR5SWQgPCAwKSB7XG4gICAgICBnbC50ZXhJbWFnZTNEKGdsLlRFWFRVUkVfMkRfQVJSQVksIDAsIGdsVGV4dHVyZS5pbnRlcm5hbEZvcm1hdCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgbGVuZ3RoLCAwLCB0ZXh0dXJlLmZvcm1hdCwgZ2xUZXh0dXJlLnR5cGUsIG51bGwpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICBpZiAoaXRlbURpcnR5SWRzW2ldIDwgaXRlbS5kaXJ0eUlkKSB7XG4gICAgICAgIGl0ZW1EaXJ0eUlkc1tpXSA9IGl0ZW0uZGlydHlJZDtcbiAgICAgICAgaWYgKGl0ZW0udmFsaWQpIHtcbiAgICAgICAgICBnbC50ZXhTdWJJbWFnZTNEKGdsLlRFWFRVUkVfMkRfQVJSQVksIDAsIDAsIDAsIGksIGl0ZW0ucmVzb3VyY2Uud2lkdGgsIGl0ZW0ucmVzb3VyY2UuaGVpZ2h0LCAxLCB0ZXh0dXJlLmZvcm1hdCwgZ2xUZXh0dXJlLnR5cGUsIGl0ZW0ucmVzb3VyY2Uuc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnQgeyBBcnJheVJlc291cmNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcnJheVJlc291cmNlLm1qcy5tYXBcbiIsImltcG9ydCB7IEJhc2VJbWFnZVJlc291cmNlIH0gZnJvbSAnLi9CYXNlSW1hZ2VSZXNvdXJjZS5tanMnO1xuXG5jbGFzcyBDYW52YXNSZXNvdXJjZSBleHRlbmRzIEJhc2VJbWFnZVJlc291cmNlIHtcbiAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgc3VwZXIoc291cmNlKTtcbiAgfVxuICBzdGF0aWMgdGVzdChzb3VyY2UpIHtcbiAgICBjb25zdCB7IE9mZnNjcmVlbkNhbnZhcyB9ID0gZ2xvYmFsVGhpcztcbiAgICBpZiAoT2Zmc2NyZWVuQ2FudmFzICYmIHNvdXJjZSBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBnbG9iYWxUaGlzLkhUTUxDYW52YXNFbGVtZW50ICYmIHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50O1xuICB9XG59XG5cbmV4cG9ydCB7IENhbnZhc1Jlc291cmNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYW52YXNSZXNvdXJjZS5tanMubWFwXG4iLCJpbXBvcnQgeyBUQVJHRVRTIH0gZnJvbSAnQHBpeGkvY29uc3RhbnRzJztcbmltcG9ydCB7IEFic3RyYWN0TXVsdGlSZXNvdXJjZSB9IGZyb20gJy4vQWJzdHJhY3RNdWx0aVJlc291cmNlLm1qcyc7XG5cbmNvbnN0IF9DdWJlUmVzb3VyY2UgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0TXVsdGlSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgYXV0b0xvYWQsIGxpbmtCYXNlVGV4dHVyZSB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoc291cmNlICYmIHNvdXJjZS5sZW5ndGggIT09IF9DdWJlUmVzb3VyY2UuU0lERVMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBsZW5ndGguIEdvdCAke3NvdXJjZS5sZW5ndGh9LCBleHBlY3RlZCA2YCk7XG4gICAgfVxuICAgIHN1cGVyKDYsIHsgd2lkdGgsIGhlaWdodCB9KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9DdWJlUmVzb3VyY2UuU0lERVM7IGkrKykge1xuICAgICAgdGhpcy5pdGVtc1tpXS50YXJnZXQgPSBUQVJHRVRTLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGk7XG4gICAgfVxuICAgIHRoaXMubGlua0Jhc2VUZXh0dXJlID0gbGlua0Jhc2VUZXh0dXJlICE9PSBmYWxzZTtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICB0aGlzLmluaXRGcm9tQXJyYXkoc291cmNlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKGF1dG9Mb2FkICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5sb2FkKCk7XG4gICAgfVxuICB9XG4gIGJpbmQoYmFzZVRleHR1cmUpIHtcbiAgICBzdXBlci5iaW5kKGJhc2VUZXh0dXJlKTtcbiAgICBiYXNlVGV4dHVyZS50YXJnZXQgPSBUQVJHRVRTLlRFWFRVUkVfQ1VCRV9NQVA7XG4gIH1cbiAgYWRkQmFzZVRleHR1cmVBdChiYXNlVGV4dHVyZSwgaW5kZXgsIGxpbmtCYXNlVGV4dHVyZSkge1xuICAgIGlmIChsaW5rQmFzZVRleHR1cmUgPT09IHZvaWQgMCkge1xuICAgICAgbGlua0Jhc2VUZXh0dXJlID0gdGhpcy5saW5rQmFzZVRleHR1cmU7XG4gICAgfVxuICAgIGlmICghdGhpcy5pdGVtc1tpbmRleF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5kZXggJHtpbmRleH0gaXMgb3V0IG9mIGJvdW5kc2ApO1xuICAgIH1cbiAgICBpZiAoIXRoaXMubGlua0Jhc2VUZXh0dXJlIHx8IGJhc2VUZXh0dXJlLnBhcmVudFRleHR1cmVBcnJheSB8fCBPYmplY3Qua2V5cyhiYXNlVGV4dHVyZS5fZ2xUZXh0dXJlcykubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGJhc2VUZXh0dXJlLnJlc291cmNlKSB7XG4gICAgICAgIHRoaXMuYWRkUmVzb3VyY2VBdChiYXNlVGV4dHVyZS5yZXNvdXJjZSwgaW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDdWJlUmVzb3VyY2UgZG9lcyBub3Qgc3VwcG9ydCBjb3B5aW5nIG9mIHJlbmRlclRleHR1cmUuYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2VUZXh0dXJlLnRhcmdldCA9IFRBUkdFVFMuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaW5kZXg7XG4gICAgICBiYXNlVGV4dHVyZS5wYXJlbnRUZXh0dXJlQXJyYXkgPSB0aGlzLmJhc2VUZXh0dXJlO1xuICAgICAgdGhpcy5pdGVtc1tpbmRleF0gPSBiYXNlVGV4dHVyZTtcbiAgICB9XG4gICAgaWYgKGJhc2VUZXh0dXJlLnZhbGlkICYmICF0aGlzLnZhbGlkKSB7XG4gICAgICB0aGlzLnJlc2l6ZShiYXNlVGV4dHVyZS5yZWFsV2lkdGgsIGJhc2VUZXh0dXJlLnJlYWxIZWlnaHQpO1xuICAgIH1cbiAgICB0aGlzLml0ZW1zW2luZGV4XSA9IGJhc2VUZXh0dXJlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHVwbG9hZChyZW5kZXJlciwgX2Jhc2VUZXh0dXJlLCBnbFRleHR1cmUpIHtcbiAgICBjb25zdCBkaXJ0eSA9IHRoaXMuaXRlbURpcnR5SWRzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgX0N1YmVSZXNvdXJjZS5TSURFUzsgaSsrKSB7XG4gICAgICBjb25zdCBzaWRlID0gdGhpcy5pdGVtc1tpXTtcbiAgICAgIGlmIChkaXJ0eVtpXSA8IHNpZGUuZGlydHlJZCB8fCBnbFRleHR1cmUuZGlydHlJZCA8IF9iYXNlVGV4dHVyZS5kaXJ0eUlkKSB7XG4gICAgICAgIGlmIChzaWRlLnZhbGlkICYmIHNpZGUucmVzb3VyY2UpIHtcbiAgICAgICAgICBzaWRlLnJlc291cmNlLnVwbG9hZChyZW5kZXJlciwgc2lkZSwgZ2xUZXh0dXJlKTtcbiAgICAgICAgICBkaXJ0eVtpXSA9IHNpZGUuZGlydHlJZDtcbiAgICAgICAgfSBlbHNlIGlmIChkaXJ0eVtpXSA8IC0xKSB7XG4gICAgICAgICAgcmVuZGVyZXIuZ2wudGV4SW1hZ2UyRChzaWRlLnRhcmdldCwgMCwgZ2xUZXh0dXJlLmludGVybmFsRm9ybWF0LCBfYmFzZVRleHR1cmUucmVhbFdpZHRoLCBfYmFzZVRleHR1cmUucmVhbEhlaWdodCwgMCwgX2Jhc2VUZXh0dXJlLmZvcm1hdCwgZ2xUZXh0dXJlLnR5cGUsIG51bGwpO1xuICAgICAgICAgIGRpcnR5W2ldID0gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RhdGljIHRlc3Qoc291cmNlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc291cmNlKSAmJiBzb3VyY2UubGVuZ3RoID09PSBfQ3ViZVJlc291cmNlLlNJREVTO1xuICB9XG59O1xubGV0IEN1YmVSZXNvdXJjZSA9IF9DdWJlUmVzb3VyY2U7XG5DdWJlUmVzb3VyY2UuU0lERVMgPSA2O1xuXG5leHBvcnQgeyBDdWJlUmVzb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUN1YmVSZXNvdXJjZS5tanMubWFwXG4iLCJpbXBvcnQgeyBBTFBIQV9NT0RFUyB9IGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gJ0BwaXhpL3NldHRpbmdzJztcbmltcG9ydCB7IEJhc2VJbWFnZVJlc291cmNlIH0gZnJvbSAnLi9CYXNlSW1hZ2VSZXNvdXJjZS5tanMnO1xuXG5jbGFzcyBJbWFnZUJpdG1hcFJlc291cmNlIGV4dGVuZHMgQmFzZUltYWdlUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgYmFzZVNvdXJjZTtcbiAgICBsZXQgdXJsO1xuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBiYXNlU291cmNlID0gSW1hZ2VCaXRtYXBSZXNvdXJjZS5FTVBUWTtcbiAgICAgIHVybCA9IHNvdXJjZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZVNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHVybCA9IG51bGw7XG4gICAgfVxuICAgIHN1cGVyKGJhc2VTb3VyY2UpO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSBvcHRpb25zLmNyb3NzT3JpZ2luID8/IHRydWU7XG4gICAgdGhpcy5hbHBoYU1vZGUgPSB0eXBlb2Ygb3B0aW9ucy5hbHBoYU1vZGUgPT09IFwibnVtYmVyXCIgPyBvcHRpb25zLmFscGhhTW9kZSA6IG51bGw7XG4gICAgdGhpcy5fbG9hZCA9IG51bGw7XG4gICAgaWYgKG9wdGlvbnMuYXV0b0xvYWQgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmxvYWQoKTtcbiAgICB9XG4gIH1cbiAgbG9hZCgpIHtcbiAgICBpZiAodGhpcy5fbG9hZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvYWQ7XG4gICAgfVxuICAgIHRoaXMuX2xvYWQgPSBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy51cmwgPT09IG51bGwpIHtcbiAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZXR0aW5ncy5BREFQVEVSLmZldGNoKHRoaXMudXJsLCB7XG4gICAgICAgICAgbW9kZTogdGhpcy5jcm9zc09yaWdpbiA/IFwiY29yc1wiIDogXCJuby1jb3JzXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGltYWdlQmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaW1hZ2VCaXRtYXAgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChpbWFnZUJsb2IsIHtcbiAgICAgICAgICBwcmVtdWx0aXBseUFscGhhOiB0aGlzLmFscGhhTW9kZSA9PT0gbnVsbCB8fCB0aGlzLmFscGhhTW9kZSA9PT0gQUxQSEFfTU9ERVMuVU5QQUNLID8gXCJwcmVtdWx0aXBseVwiIDogXCJub25lXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuc291cmNlID0gaW1hZ2VCaXRtYXA7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgdGhpcy5vbkVycm9yLmVtaXQoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX2xvYWQ7XG4gIH1cbiAgdXBsb2FkKHJlbmRlcmVyLCBiYXNlVGV4dHVyZSwgZ2xUZXh0dXJlKSB7XG4gICAgaWYgKCEodGhpcy5zb3VyY2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCkpIHtcbiAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMuYWxwaGFNb2RlID09PSBcIm51bWJlclwiKSB7XG4gICAgICBiYXNlVGV4dHVyZS5hbHBoYU1vZGUgPSB0aGlzLmFscGhhTW9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnVwbG9hZChyZW5kZXJlciwgYmFzZVRleHR1cmUsIGdsVGV4dHVyZSk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBpZiAodGhpcy5zb3VyY2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCkge1xuICAgICAgdGhpcy5zb3VyY2UuY2xvc2UoKTtcbiAgICB9XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuX2xvYWQgPSBudWxsO1xuICB9XG4gIHN0YXRpYyB0ZXN0KHNvdXJjZSkge1xuICAgIHJldHVybiAhIWdsb2JhbFRoaXMuY3JlYXRlSW1hZ2VCaXRtYXAgJiYgdHlwZW9mIEltYWdlQml0bWFwICE9PSBcInVuZGVmaW5lZFwiICYmICh0eXBlb2Ygc291cmNlID09PSBcInN0cmluZ1wiIHx8IHNvdXJjZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwKTtcbiAgfVxuICBzdGF0aWMgZ2V0IEVNUFRZKCkge1xuICAgIEltYWdlQml0bWFwUmVzb3VyY2UuX0VNUFRZID0gSW1hZ2VCaXRtYXBSZXNvdXJjZS5fRU1QVFkgPz8gc2V0dGluZ3MuQURBUFRFUi5jcmVhdGVDYW52YXMoMCwgMCk7XG4gICAgcmV0dXJuIEltYWdlQml0bWFwUmVzb3VyY2UuX0VNUFRZO1xuICB9XG59XG5cbmV4cG9ydCB7IEltYWdlQml0bWFwUmVzb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUltYWdlQml0bWFwUmVzb3VyY2UubWpzLm1hcFxuIiwiaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tICdAcGl4aS9zZXR0aW5ncyc7XG5pbXBvcnQgeyB1aWQgfSBmcm9tICdAcGl4aS91dGlscyc7XG5pbXBvcnQgeyBCYXNlSW1hZ2VSZXNvdXJjZSB9IGZyb20gJy4vQmFzZUltYWdlUmVzb3VyY2UubWpzJztcblxuY29uc3QgX1NWR1Jlc291cmNlID0gY2xhc3MgZXh0ZW5kcyBCYXNlSW1hZ2VSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZUJhc2U2NCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHN1cGVyKHNldHRpbmdzLkFEQVBURVIuY3JlYXRlQ2FudmFzKCkpO1xuICAgIHRoaXMuX3dpZHRoID0gMDtcbiAgICB0aGlzLl9oZWlnaHQgPSAwO1xuICAgIHRoaXMuc3ZnID0gc291cmNlQmFzZTY0O1xuICAgIHRoaXMuc2NhbGUgPSBvcHRpb25zLnNjYWxlIHx8IDE7XG4gICAgdGhpcy5fb3ZlcnJpZGVXaWR0aCA9IG9wdGlvbnMud2lkdGg7XG4gICAgdGhpcy5fb3ZlcnJpZGVIZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcbiAgICB0aGlzLl9yZXNvbHZlID0gbnVsbDtcbiAgICB0aGlzLl9jcm9zc29yaWdpbiA9IG9wdGlvbnMuY3Jvc3NvcmlnaW47XG4gICAgdGhpcy5fbG9hZCA9IG51bGw7XG4gICAgaWYgKG9wdGlvbnMuYXV0b0xvYWQgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmxvYWQoKTtcbiAgICB9XG4gIH1cbiAgbG9hZCgpIHtcbiAgICBpZiAodGhpcy5fbG9hZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvYWQ7XG4gICAgfVxuICAgIHRoaXMuX2xvYWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5fcmVzb2x2ZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5yZXNpemUodGhpcy5zb3VyY2Uud2lkdGgsIHRoaXMuc291cmNlLmhlaWdodCk7XG4gICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICB9O1xuICAgICAgaWYgKF9TVkdSZXNvdXJjZS5TVkdfWE1MLnRlc3QodGhpcy5zdmcudHJpbSgpKSkge1xuICAgICAgICBpZiAoIWJ0b2EpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3VyIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IGJhc2U2NCBjb252ZXJzaW9ucy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdmcgPSBgZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCwke2J0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuc3ZnKSkpfWA7XG4gICAgICB9XG4gICAgICB0aGlzLl9sb2FkU3ZnKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX2xvYWQ7XG4gIH1cbiAgX2xvYWRTdmcoKSB7XG4gICAgY29uc3QgdGVtcEltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgQmFzZUltYWdlUmVzb3VyY2UuY3Jvc3NPcmlnaW4odGVtcEltYWdlLCB0aGlzLnN2ZywgdGhpcy5fY3Jvc3NvcmlnaW4pO1xuICAgIHRlbXBJbWFnZS5zcmMgPSB0aGlzLnN2ZztcbiAgICB0ZW1wSW1hZ2Uub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9yZXNvbHZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRlbXBJbWFnZS5vbmVycm9yID0gbnVsbDtcbiAgICAgIHRoaXMub25FcnJvci5lbWl0KGV2ZW50KTtcbiAgICB9O1xuICAgIHRlbXBJbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX3Jlc29sdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3ZnV2lkdGggPSB0ZW1wSW1hZ2Uud2lkdGg7XG4gICAgICBjb25zdCBzdmdIZWlnaHQgPSB0ZW1wSW1hZ2UuaGVpZ2h0O1xuICAgICAgaWYgKCFzdmdXaWR0aCB8fCAhc3ZnSGVpZ2h0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBTVkcgaW1hZ2UgbXVzdCBoYXZlIHdpZHRoIGFuZCBoZWlnaHQgZGVmaW5lZCAoaW4gcGl4ZWxzKSwgY2FudmFzIEFQSSBuZWVkcyB0aGVtLlwiKTtcbiAgICAgIH1cbiAgICAgIGxldCB3aWR0aCA9IHN2Z1dpZHRoICogdGhpcy5zY2FsZTtcbiAgICAgIGxldCBoZWlnaHQgPSBzdmdIZWlnaHQgKiB0aGlzLnNjYWxlO1xuICAgICAgaWYgKHRoaXMuX292ZXJyaWRlV2lkdGggfHwgdGhpcy5fb3ZlcnJpZGVIZWlnaHQpIHtcbiAgICAgICAgd2lkdGggPSB0aGlzLl9vdmVycmlkZVdpZHRoIHx8IHRoaXMuX292ZXJyaWRlSGVpZ2h0IC8gc3ZnSGVpZ2h0ICogc3ZnV2lkdGg7XG4gICAgICAgIGhlaWdodCA9IHRoaXMuX292ZXJyaWRlSGVpZ2h0IHx8IHRoaXMuX292ZXJyaWRlV2lkdGggLyBzdmdXaWR0aCAqIHN2Z0hlaWdodDtcbiAgICAgIH1cbiAgICAgIHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCk7XG4gICAgICBoZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCk7XG4gICAgICBjb25zdCBjYW52YXMgPSB0aGlzLnNvdXJjZTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIGNhbnZhcy5fcGl4aUlkID0gYGNhbnZhc18ke3VpZCgpfWA7XG4gICAgICBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLmRyYXdJbWFnZSh0ZW1wSW1hZ2UsIDAsIDAsIHN2Z1dpZHRoLCBzdmdIZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5fcmVzb2x2ZSgpO1xuICAgICAgdGhpcy5fcmVzb2x2ZSA9IG51bGw7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZ2V0U2l6ZShzdmdTdHJpbmcpIHtcbiAgICBjb25zdCBzaXplTWF0Y2ggPSBfU1ZHUmVzb3VyY2UuU1ZHX1NJWkUuZXhlYyhzdmdTdHJpbmcpO1xuICAgIGNvbnN0IHNpemUgPSB7fTtcbiAgICBpZiAoc2l6ZU1hdGNoKSB7XG4gICAgICBzaXplW3NpemVNYXRjaFsxXV0gPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoc2l6ZU1hdGNoWzNdKSk7XG4gICAgICBzaXplW3NpemVNYXRjaFs1XV0gPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoc2l6ZU1hdGNoWzddKSk7XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xuICAgIHRoaXMuX2Nyb3Nzb3JpZ2luID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgdGVzdChzb3VyY2UsIGV4dGVuc2lvbikge1xuICAgIHJldHVybiBleHRlbnNpb24gPT09IFwic3ZnXCIgfHwgdHlwZW9mIHNvdXJjZSA9PT0gXCJzdHJpbmdcIiAmJiBzb3VyY2Uuc3RhcnRzV2l0aChcImRhdGE6aW1hZ2Uvc3ZnK3htbFwiKSB8fCB0eXBlb2Ygc291cmNlID09PSBcInN0cmluZ1wiICYmIF9TVkdSZXNvdXJjZS5TVkdfWE1MLnRlc3Qoc291cmNlKTtcbiAgfVxufTtcbmxldCBTVkdSZXNvdXJjZSA9IF9TVkdSZXNvdXJjZTtcblNWR1Jlc291cmNlLlNWR19YTUwgPSAvXig8XFw/eG1sW14/XStcXD8+KT9cXHMqKDwhLS1bXigtLT4pXSotLT4pP1xccypcXDxzdmcvbTtcblNWR1Jlc291cmNlLlNWR19TSVpFID0gLzxzdmdbXj5dKig/Olxccyh3aWR0aHxoZWlnaHQpPSgnfFwiKShcXGQqKD86XFwuXFxkKyk/KSg/OnB4KT8oJ3xcIikpW14+XSooPzpcXHMod2lkdGh8aGVpZ2h0KT0oJ3xcIikoXFxkKig/OlxcLlxcZCspPykoPzpweCk/KCd8XCIpKVtePl0qPi9pO1xuXG5leHBvcnQgeyBTVkdSZXNvdXJjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U1ZHUmVzb3VyY2UubWpzLm1hcFxuIiwiaW1wb3J0IHsgVGlja2VyIH0gZnJvbSAnQHBpeGkvdGlja2VyJztcbmltcG9ydCB7IEJhc2VJbWFnZVJlc291cmNlIH0gZnJvbSAnLi9CYXNlSW1hZ2VSZXNvdXJjZS5tanMnO1xuXG5jb25zdCBfVmlkZW9SZXNvdXJjZSA9IGNsYXNzIGV4dGVuZHMgQmFzZUltYWdlUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSkge1xuICAgICAgY29uc3QgdmlkZW9FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO1xuICAgICAgdmlkZW9FbGVtZW50LnNldEF0dHJpYnV0ZShcInByZWxvYWRcIiwgXCJhdXRvXCIpO1xuICAgICAgdmlkZW9FbGVtZW50LnNldEF0dHJpYnV0ZShcIndlYmtpdC1wbGF5c2lubGluZVwiLCBcIlwiKTtcbiAgICAgIHZpZGVvRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJwbGF5c2lubGluZVwiLCBcIlwiKTtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHNvdXJjZSA9IFtzb3VyY2VdO1xuICAgICAgfVxuICAgICAgY29uc3QgZmlyc3RTcmMgPSBzb3VyY2VbMF0uc3JjIHx8IHNvdXJjZVswXTtcbiAgICAgIEJhc2VJbWFnZVJlc291cmNlLmNyb3NzT3JpZ2luKHZpZGVvRWxlbWVudCwgZmlyc3RTcmMsIG9wdGlvbnMuY3Jvc3NvcmlnaW4pO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qgc291cmNlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzb3VyY2VcIik7XG4gICAgICAgIGxldCB7IHNyYywgbWltZSB9ID0gc291cmNlW2ldO1xuICAgICAgICBzcmMgPSBzcmMgfHwgc291cmNlW2ldO1xuICAgICAgICBjb25zdCBiYXNlU3JjID0gc3JjLnNwbGl0KFwiP1wiKS5zaGlmdCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGV4dCA9IGJhc2VTcmMuc2xpY2UoYmFzZVNyYy5sYXN0SW5kZXhPZihcIi5cIikgKyAxKTtcbiAgICAgICAgbWltZSA9IG1pbWUgfHwgX1ZpZGVvUmVzb3VyY2UuTUlNRV9UWVBFU1tleHRdIHx8IGB2aWRlby8ke2V4dH1gO1xuICAgICAgICBzb3VyY2VFbGVtZW50LnNyYyA9IHNyYztcbiAgICAgICAgc291cmNlRWxlbWVudC50eXBlID0gbWltZTtcbiAgICAgICAgdmlkZW9FbGVtZW50LmFwcGVuZENoaWxkKHNvdXJjZUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgc291cmNlID0gdmlkZW9FbGVtZW50O1xuICAgIH1cbiAgICBzdXBlcihzb3VyY2UpO1xuICAgIHRoaXMubm9TdWJJbWFnZSA9IHRydWU7XG4gICAgdGhpcy5fYXV0b1VwZGF0ZSA9IHRydWU7XG4gICAgdGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlciA9IGZhbHNlO1xuICAgIHRoaXMuX3VwZGF0ZUZQUyA9IG9wdGlvbnMudXBkYXRlRlBTIHx8IDA7XG4gICAgdGhpcy5fbXNUb05leHRVcGRhdGUgPSAwO1xuICAgIHRoaXMuYXV0b1BsYXkgPSBvcHRpb25zLmF1dG9QbGF5ICE9PSBmYWxzZTtcbiAgICB0aGlzLl9sb2FkID0gbnVsbDtcbiAgICB0aGlzLl9yZXNvbHZlID0gbnVsbDtcbiAgICB0aGlzLl9vbkNhblBsYXkgPSB0aGlzLl9vbkNhblBsYXkuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkVycm9yID0gdGhpcy5fb25FcnJvci5iaW5kKHRoaXMpO1xuICAgIGlmIChvcHRpb25zLmF1dG9Mb2FkICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5sb2FkKCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZShfZGVsdGFUaW1lID0gMCkge1xuICAgIGlmICghdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIGNvbnN0IGVsYXBzZWRNUyA9IFRpY2tlci5zaGFyZWQuZWxhcHNlZE1TICogdGhpcy5zb3VyY2UucGxheWJhY2tSYXRlO1xuICAgICAgdGhpcy5fbXNUb05leHRVcGRhdGUgPSBNYXRoLmZsb29yKHRoaXMuX21zVG9OZXh0VXBkYXRlIC0gZWxhcHNlZE1TKTtcbiAgICAgIGlmICghdGhpcy5fdXBkYXRlRlBTIHx8IHRoaXMuX21zVG9OZXh0VXBkYXRlIDw9IDApIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKCk7XG4gICAgICAgIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gdGhpcy5fdXBkYXRlRlBTID8gTWF0aC5mbG9vcigxZTMgLyB0aGlzLl91cGRhdGVGUFMpIDogMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9hZCgpIHtcbiAgICBpZiAodGhpcy5fbG9hZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvYWQ7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgIGlmICgoc291cmNlLnJlYWR5U3RhdGUgPT09IHNvdXJjZS5IQVZFX0VOT1VHSF9EQVRBIHx8IHNvdXJjZS5yZWFkeVN0YXRlID09PSBzb3VyY2UuSEFWRV9GVVRVUkVfREFUQSkgJiYgc291cmNlLndpZHRoICYmIHNvdXJjZS5oZWlnaHQpIHtcbiAgICAgIHNvdXJjZS5jb21wbGV0ZSA9IHRydWU7XG4gICAgfVxuICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwicGxheVwiLCB0aGlzLl9vblBsYXlTdGFydC5iaW5kKHRoaXMpKTtcbiAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihcInBhdXNlXCIsIHRoaXMuX29uUGxheVN0b3AuYmluZCh0aGlzKSk7XG4gICAgaWYgKCF0aGlzLl9pc1NvdXJjZVJlYWR5KCkpIHtcbiAgICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwiY2FucGxheVwiLCB0aGlzLl9vbkNhblBsYXkpO1xuICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5dGhyb3VnaFwiLCB0aGlzLl9vbkNhblBsYXkpO1xuICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLl9vbkVycm9yLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb25DYW5QbGF5KCk7XG4gICAgfVxuICAgIHRoaXMuX2xvYWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgaWYgKHRoaXMudmFsaWQpIHtcbiAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICBzb3VyY2UubG9hZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9sb2FkO1xuICB9XG4gIF9vbkVycm9yKGV2ZW50KSB7XG4gICAgdGhpcy5zb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHRoaXMuX29uRXJyb3IsIHRydWUpO1xuICAgIHRoaXMub25FcnJvci5lbWl0KGV2ZW50KTtcbiAgfVxuICBfaXNTb3VyY2VQbGF5aW5nKCkge1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgIHJldHVybiAhc291cmNlLnBhdXNlZCAmJiAhc291cmNlLmVuZGVkICYmIHRoaXMuX2lzU291cmNlUmVhZHkoKTtcbiAgfVxuICBfaXNTb3VyY2VSZWFkeSgpIHtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICByZXR1cm4gc291cmNlLnJlYWR5U3RhdGUgPiAyO1xuICB9XG4gIF9vblBsYXlTdGFydCgpIHtcbiAgICBpZiAoIXRoaXMudmFsaWQpIHtcbiAgICAgIHRoaXMuX29uQ2FuUGxheSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hdXRvVXBkYXRlICYmICF0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyKSB7XG4gICAgICBUaWNrZXIuc2hhcmVkLmFkZCh0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgICB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgX29uUGxheVN0b3AoKSB7XG4gICAgaWYgKHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIpIHtcbiAgICAgIFRpY2tlci5zaGFyZWQucmVtb3ZlKHRoaXMudXBkYXRlLCB0aGlzKTtcbiAgICAgIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgX29uQ2FuUGxheSgpIHtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICBzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNhbnBsYXlcIiwgdGhpcy5fb25DYW5QbGF5KTtcbiAgICBzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNhbnBsYXl0aHJvdWdoXCIsIHRoaXMuX29uQ2FuUGxheSk7XG4gICAgY29uc3QgdmFsaWQgPSB0aGlzLnZhbGlkO1xuICAgIHRoaXMucmVzaXplKHNvdXJjZS52aWRlb1dpZHRoLCBzb3VyY2UudmlkZW9IZWlnaHQpO1xuICAgIGlmICghdmFsaWQgJiYgdGhpcy5fcmVzb2x2ZSkge1xuICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzKTtcbiAgICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5faXNTb3VyY2VQbGF5aW5nKCkpIHtcbiAgICAgIHRoaXMuX29uUGxheVN0YXJ0KCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmF1dG9QbGF5KSB7XG4gICAgICBzb3VyY2UucGxheSgpO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyKSB7XG4gICAgICBUaWNrZXIuc2hhcmVkLnJlbW92ZSh0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgICB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgdGhpcy5fb25FcnJvciwgdHJ1ZSk7XG4gICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIHNvdXJjZS5zcmMgPSBcIlwiO1xuICAgICAgc291cmNlLmxvYWQoKTtcbiAgICB9XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG4gIGdldCBhdXRvVXBkYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9hdXRvVXBkYXRlO1xuICB9XG4gIHNldCBhdXRvVXBkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9hdXRvVXBkYXRlKSB7XG4gICAgICB0aGlzLl9hdXRvVXBkYXRlID0gdmFsdWU7XG4gICAgICBpZiAoIXRoaXMuX2F1dG9VcGRhdGUgJiYgdGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlcikge1xuICAgICAgICBUaWNrZXIuc2hhcmVkLnJlbW92ZSh0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYXV0b1VwZGF0ZSAmJiAhdGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlciAmJiB0aGlzLl9pc1NvdXJjZVBsYXlpbmcoKSkge1xuICAgICAgICBUaWNrZXIuc2hhcmVkLmFkZCh0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgdXBkYXRlRlBTKCkge1xuICAgIHJldHVybiB0aGlzLl91cGRhdGVGUFM7XG4gIH1cbiAgc2V0IHVwZGF0ZUZQUyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fdXBkYXRlRlBTKSB7XG4gICAgICB0aGlzLl91cGRhdGVGUFMgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHRlc3Qoc291cmNlLCBleHRlbnNpb24pIHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5IVE1MVmlkZW9FbGVtZW50ICYmIHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgfHwgX1ZpZGVvUmVzb3VyY2UuVFlQRVMuaW5jbHVkZXMoZXh0ZW5zaW9uKTtcbiAgfVxufTtcbmxldCBWaWRlb1Jlc291cmNlID0gX1ZpZGVvUmVzb3VyY2U7XG5WaWRlb1Jlc291cmNlLlRZUEVTID0gW1wibXA0XCIsIFwibTR2XCIsIFwid2VibVwiLCBcIm9nZ1wiLCBcIm9ndlwiLCBcImgyNjRcIiwgXCJhdmlcIiwgXCJtb3ZcIl07XG5WaWRlb1Jlc291cmNlLk1JTUVfVFlQRVMgPSB7XG4gIG9ndjogXCJ2aWRlby9vZ2dcIixcbiAgbW92OiBcInZpZGVvL3F1aWNrdGltZVwiLFxuICBtNHY6IFwidmlkZW8vbXA0XCJcbn07XG5cbmV4cG9ydCB7IFZpZGVvUmVzb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZpZGVvUmVzb3VyY2UubWpzLm1hcFxuIiwiaW1wb3J0IHsgQXJyYXlSZXNvdXJjZSB9IGZyb20gJy4vQXJyYXlSZXNvdXJjZS5tanMnO1xuZXhwb3J0IHsgQXJyYXlSZXNvdXJjZSB9IGZyb20gJy4vQXJyYXlSZXNvdXJjZS5tanMnO1xuaW1wb3J0IHsgSU5TVEFMTEVEIH0gZnJvbSAnLi9hdXRvRGV0ZWN0UmVzb3VyY2UubWpzJztcbmV4cG9ydCB7IElOU1RBTExFRCwgYXV0b0RldGVjdFJlc291cmNlIH0gZnJvbSAnLi9hdXRvRGV0ZWN0UmVzb3VyY2UubWpzJztcbmltcG9ydCB7IEJ1ZmZlclJlc291cmNlIH0gZnJvbSAnLi9CdWZmZXJSZXNvdXJjZS5tanMnO1xuZXhwb3J0IHsgQnVmZmVyUmVzb3VyY2UgfSBmcm9tICcuL0J1ZmZlclJlc291cmNlLm1qcyc7XG5pbXBvcnQgeyBDYW52YXNSZXNvdXJjZSB9IGZyb20gJy4vQ2FudmFzUmVzb3VyY2UubWpzJztcbmV4cG9ydCB7IENhbnZhc1Jlc291cmNlIH0gZnJvbSAnLi9DYW52YXNSZXNvdXJjZS5tanMnO1xuaW1wb3J0IHsgQ3ViZVJlc291cmNlIH0gZnJvbSAnLi9DdWJlUmVzb3VyY2UubWpzJztcbmV4cG9ydCB7IEN1YmVSZXNvdXJjZSB9IGZyb20gJy4vQ3ViZVJlc291cmNlLm1qcyc7XG5pbXBvcnQgeyBJbWFnZUJpdG1hcFJlc291cmNlIH0gZnJvbSAnLi9JbWFnZUJpdG1hcFJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBJbWFnZUJpdG1hcFJlc291cmNlIH0gZnJvbSAnLi9JbWFnZUJpdG1hcFJlc291cmNlLm1qcyc7XG5pbXBvcnQgeyBJbWFnZVJlc291cmNlIH0gZnJvbSAnLi9JbWFnZVJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBJbWFnZVJlc291cmNlIH0gZnJvbSAnLi9JbWFnZVJlc291cmNlLm1qcyc7XG5pbXBvcnQgeyBTVkdSZXNvdXJjZSB9IGZyb20gJy4vU1ZHUmVzb3VyY2UubWpzJztcbmV4cG9ydCB7IFNWR1Jlc291cmNlIH0gZnJvbSAnLi9TVkdSZXNvdXJjZS5tanMnO1xuaW1wb3J0IHsgVmlkZW9SZXNvdXJjZSB9IGZyb20gJy4vVmlkZW9SZXNvdXJjZS5tanMnO1xuZXhwb3J0IHsgVmlkZW9SZXNvdXJjZSB9IGZyb20gJy4vVmlkZW9SZXNvdXJjZS5tanMnO1xuZXhwb3J0IHsgQmFzZUltYWdlUmVzb3VyY2UgfSBmcm9tICcuL0Jhc2VJbWFnZVJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBSZXNvdXJjZSB9IGZyb20gJy4vUmVzb3VyY2UubWpzJztcbmV4cG9ydCB7IEFic3RyYWN0TXVsdGlSZXNvdXJjZSB9IGZyb20gJy4vQWJzdHJhY3RNdWx0aVJlc291cmNlLm1qcyc7XG5cbklOU1RBTExFRC5wdXNoKEltYWdlQml0bWFwUmVzb3VyY2UsIEltYWdlUmVzb3VyY2UsIENhbnZhc1Jlc291cmNlLCBWaWRlb1Jlc291cmNlLCBTVkdSZXNvdXJjZSwgQnVmZmVyUmVzb3VyY2UsIEN1YmVSZXNvdXJjZSwgQXJyYXlSZXNvdXJjZSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBSdW5uZXIgfSBmcm9tICdAcGl4aS9ydW5uZXInO1xuXG5jbGFzcyBUcmFuc2Zvcm1GZWVkYmFjayB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2dsVHJhbnNmb3JtRmVlZGJhY2tzID0ge307XG4gICAgdGhpcy5idWZmZXJzID0gW107XG4gICAgdGhpcy5kaXNwb3NlUnVubmVyID0gbmV3IFJ1bm5lcihcImRpc3Bvc2VUcmFuc2Zvcm1GZWVkYmFja1wiKTtcbiAgfVxuICBiaW5kQnVmZmVyKGluZGV4LCBidWZmZXIpIHtcbiAgICB0aGlzLmJ1ZmZlcnNbaW5kZXhdID0gYnVmZmVyO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kaXNwb3NlUnVubmVyLmVtaXQodGhpcywgZmFsc2UpO1xuICB9XG59XG5cbmV4cG9ydCB7IFRyYW5zZm9ybUZlZWRiYWNrIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UcmFuc2Zvcm1GZWVkYmFjay5tanMubWFwXG4iLCJpbXBvcnQgJy4vc2V0dGluZ3MubWpzJztcbmV4cG9ydCAqIGZyb20gJ0BwaXhpL2NvbG9yJztcbmV4cG9ydCAqIGZyb20gJ0BwaXhpL2NvbnN0YW50cyc7XG5leHBvcnQgKiBmcm9tICdAcGl4aS9leHRlbnNpb25zJztcbmV4cG9ydCAqIGZyb20gJ0BwaXhpL21hdGgnO1xuZXhwb3J0ICogZnJvbSAnQHBpeGkvcnVubmVyJztcbmV4cG9ydCAqIGZyb20gJ0BwaXhpL3NldHRpbmdzJztcbmV4cG9ydCAqIGZyb20gJ0BwaXhpL3RpY2tlcic7XG5pbXBvcnQgKiBhcyB1dGlscyQxIGZyb20gJ0BwaXhpL3V0aWxzJztcbmV4cG9ydCB7IHV0aWxzJDEgYXMgdXRpbHMgfTtcbmV4cG9ydCB7IGF1dG9EZXRlY3RSZW5kZXJlciB9IGZyb20gJy4vYXV0b0RldGVjdFJlbmRlcmVyLm1qcyc7XG5leHBvcnQgeyBCYWNrZ3JvdW5kU3lzdGVtIH0gZnJvbSAnLi9iYWNrZ3JvdW5kL0JhY2tncm91bmRTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEJhdGNoRHJhd0NhbGwgfSBmcm9tICcuL2JhdGNoL0JhdGNoRHJhd0NhbGwubWpzJztcbmV4cG9ydCB7IEJhdGNoR2VvbWV0cnkgfSBmcm9tICcuL2JhdGNoL0JhdGNoR2VvbWV0cnkubWpzJztcbmV4cG9ydCB7IEJhdGNoUmVuZGVyZXIgfSBmcm9tICcuL2JhdGNoL0JhdGNoUmVuZGVyZXIubWpzJztcbmV4cG9ydCB7IEJhdGNoU2hhZGVyR2VuZXJhdG9yIH0gZnJvbSAnLi9iYXRjaC9CYXRjaFNoYWRlckdlbmVyYXRvci5tanMnO1xuZXhwb3J0IHsgQmF0Y2hTeXN0ZW0gfSBmcm9tICcuL2JhdGNoL0JhdGNoU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBCYXRjaFRleHR1cmVBcnJheSB9IGZyb20gJy4vYmF0Y2gvQmF0Y2hUZXh0dXJlQXJyYXkubWpzJztcbmV4cG9ydCB7IE9iamVjdFJlbmRlcmVyIH0gZnJvbSAnLi9iYXRjaC9PYmplY3RSZW5kZXJlci5tanMnO1xuZXhwb3J0IHsgQ29udGV4dFN5c3RlbSB9IGZyb20gJy4vY29udGV4dC9Db250ZXh0U3lzdGVtLm1qcyc7XG5leHBvcnQgeyBGaWx0ZXIgfSBmcm9tICcuL2ZpbHRlcnMvRmlsdGVyLm1qcyc7XG5leHBvcnQgeyBGaWx0ZXJTdGF0ZSB9IGZyb20gJy4vZmlsdGVycy9GaWx0ZXJTdGF0ZS5tanMnO1xuZXhwb3J0IHsgRmlsdGVyU3lzdGVtIH0gZnJvbSAnLi9maWx0ZXJzL0ZpbHRlclN5c3RlbS5tanMnO1xuaW1wb3J0ICcuL2ZpbHRlcnMvSUZpbHRlclRhcmdldC5tanMnO1xuZXhwb3J0IHsgU3ByaXRlTWFza0ZpbHRlciB9IGZyb20gJy4vZmlsdGVycy9zcHJpdGVNYXNrL1Nwcml0ZU1hc2tGaWx0ZXIubWpzJztcbmV4cG9ydCB7IGRlZmF1bHRGaWx0ZXJWZXJ0ZXgsIGRlZmF1bHRWZXJ0ZXggfSBmcm9tICcuL2ZyYWdtZW50cy9pbmRleC5tanMnO1xuZXhwb3J0IHsgRnJhbWVidWZmZXIgfSBmcm9tICcuL2ZyYW1lYnVmZmVyL0ZyYW1lYnVmZmVyLm1qcyc7XG5leHBvcnQgeyBGcmFtZWJ1ZmZlclN5c3RlbSB9IGZyb20gJy4vZnJhbWVidWZmZXIvRnJhbWVidWZmZXJTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdMRnJhbWVidWZmZXIgfSBmcm9tICcuL2ZyYW1lYnVmZmVyL0dMRnJhbWVidWZmZXIubWpzJztcbmV4cG9ydCB7IE11bHRpc2FtcGxlU3lzdGVtIH0gZnJvbSAnLi9mcmFtZWJ1ZmZlci9NdWx0aXNhbXBsZVN5c3RlbS5tanMnO1xuZXhwb3J0IHsgQXR0cmlidXRlIH0gZnJvbSAnLi9nZW9tZXRyeS9BdHRyaWJ1dGUubWpzJztcbmV4cG9ydCB7IEJ1ZmZlciB9IGZyb20gJy4vZ2VvbWV0cnkvQnVmZmVyLm1qcyc7XG5leHBvcnQgeyBCdWZmZXJTeXN0ZW0gfSBmcm9tICcuL2dlb21ldHJ5L0J1ZmZlclN5c3RlbS5tanMnO1xuZXhwb3J0IHsgR2VvbWV0cnkgfSBmcm9tICcuL2dlb21ldHJ5L0dlb21ldHJ5Lm1qcyc7XG5leHBvcnQgeyBHZW9tZXRyeVN5c3RlbSB9IGZyb20gJy4vZ2VvbWV0cnkvR2VvbWV0cnlTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IFZpZXdhYmxlQnVmZmVyIH0gZnJvbSAnLi9nZW9tZXRyeS9WaWV3YWJsZUJ1ZmZlci5tanMnO1xuaW1wb3J0ICcuL0lSZW5kZXJlci5tanMnO1xuZXhwb3J0IHsgTWFza0RhdGEgfSBmcm9tICcuL21hc2svTWFza0RhdGEubWpzJztcbmV4cG9ydCB7IE1hc2tTeXN0ZW0gfSBmcm9tICcuL21hc2svTWFza1N5c3RlbS5tanMnO1xuZXhwb3J0IHsgU2Npc3NvclN5c3RlbSB9IGZyb20gJy4vbWFzay9TY2lzc29yU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBTdGVuY2lsU3lzdGVtIH0gZnJvbSAnLi9tYXNrL1N0ZW5jaWxTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IFBsdWdpblN5c3RlbSB9IGZyb20gJy4vcGx1Z2luL1BsdWdpblN5c3RlbS5tanMnO1xuZXhwb3J0IHsgUHJvamVjdGlvblN5c3RlbSB9IGZyb20gJy4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBPYmplY3RSZW5kZXJlclN5c3RlbSB9IGZyb20gJy4vcmVuZGVyL09iamVjdFJlbmRlcmVyU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBSZW5kZXJlciB9IGZyb20gJy4vUmVuZGVyZXIubWpzJztcbmV4cG9ydCB7IEJhc2VSZW5kZXJUZXh0dXJlIH0gZnJvbSAnLi9yZW5kZXJUZXh0dXJlL0Jhc2VSZW5kZXJUZXh0dXJlLm1qcyc7XG5leHBvcnQgeyBHZW5lcmF0ZVRleHR1cmVTeXN0ZW0gfSBmcm9tICcuL3JlbmRlclRleHR1cmUvR2VuZXJhdGVUZXh0dXJlU3lzdGVtLm1qcyc7XG5leHBvcnQgeyBSZW5kZXJUZXh0dXJlIH0gZnJvbSAnLi9yZW5kZXJUZXh0dXJlL1JlbmRlclRleHR1cmUubWpzJztcbmV4cG9ydCB7IFJlbmRlclRleHR1cmVQb29sIH0gZnJvbSAnLi9yZW5kZXJUZXh0dXJlL1JlbmRlclRleHR1cmVQb29sLm1qcyc7XG5leHBvcnQgeyBSZW5kZXJUZXh0dXJlU3lzdGVtIH0gZnJvbSAnLi9yZW5kZXJUZXh0dXJlL1JlbmRlclRleHR1cmVTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEdMUHJvZ3JhbSwgSUdMVW5pZm9ybURhdGEgfSBmcm9tICcuL3NoYWRlci9HTFByb2dyYW0ubWpzJztcbmV4cG9ydCB7IFByb2dyYW0gfSBmcm9tICcuL3NoYWRlci9Qcm9ncmFtLm1qcyc7XG5leHBvcnQgeyBTaGFkZXIgfSBmcm9tICcuL3NoYWRlci9TaGFkZXIubWpzJztcbmV4cG9ydCB7IFNoYWRlclN5c3RlbSB9IGZyb20gJy4vc2hhZGVyL1NoYWRlclN5c3RlbS5tanMnO1xuZXhwb3J0IHsgVW5pZm9ybUdyb3VwIH0gZnJvbSAnLi9zaGFkZXIvVW5pZm9ybUdyb3VwLm1qcyc7XG5leHBvcnQgeyBjaGVja01heElmU3RhdGVtZW50c0luU2hhZGVyIH0gZnJvbSAnLi9zaGFkZXIvdXRpbHMvY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlci5tanMnO1xuZXhwb3J0IHsgZ2VuZXJhdGVQcm9ncmFtIH0gZnJvbSAnLi9zaGFkZXIvdXRpbHMvZ2VuZXJhdGVQcm9ncmFtLm1qcyc7XG5leHBvcnQgeyBjcmVhdGVVQk9FbGVtZW50cywgZ2VuZXJhdGVVbmlmb3JtQnVmZmVyU3luYywgZ2V0VUJPRGF0YSB9IGZyb20gJy4vc2hhZGVyL3V0aWxzL2dlbmVyYXRlVW5pZm9ybUJ1ZmZlclN5bmMubWpzJztcbmV4cG9ydCB7IGdldFRlc3RDb250ZXh0IH0gZnJvbSAnLi9zaGFkZXIvdXRpbHMvZ2V0VGVzdENvbnRleHQubWpzJztcbmV4cG9ydCB7IHVuaWZvcm1QYXJzZXJzIH0gZnJvbSAnLi9zaGFkZXIvdXRpbHMvdW5pZm9ybVBhcnNlcnMubWpzJztcbmV4cG9ydCB7IHVuc2FmZUV2YWxTdXBwb3J0ZWQgfSBmcm9tICcuL3NoYWRlci91dGlscy91bnNhZmVFdmFsU3VwcG9ydGVkLm1qcyc7XG5leHBvcnQgeyBTdGFydHVwU3lzdGVtIH0gZnJvbSAnLi9zdGFydHVwL1N0YXJ0dXBTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IFN0YXRlIH0gZnJvbSAnLi9zdGF0ZS9TdGF0ZS5tanMnO1xuZXhwb3J0IHsgU3RhdGVTeXN0ZW0gfSBmcm9tICcuL3N0YXRlL1N0YXRlU3lzdGVtLm1qcyc7XG5pbXBvcnQgJy4vc3lzdGVtL0lTeXN0ZW0ubWpzJztcbmltcG9ydCAnLi9zeXN0ZW1zLm1qcyc7XG5leHBvcnQgeyBCYXNlVGV4dHVyZSB9IGZyb20gJy4vdGV4dHVyZXMvQmFzZVRleHR1cmUubWpzJztcbmV4cG9ydCB7IEdMVGV4dHVyZSB9IGZyb20gJy4vdGV4dHVyZXMvR0xUZXh0dXJlLm1qcyc7XG5pbXBvcnQgJy4vdGV4dHVyZXMvcmVzb3VyY2VzL2luZGV4Lm1qcyc7XG5leHBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi90ZXh0dXJlcy9UZXh0dXJlLm1qcyc7XG5leHBvcnQgeyBUZXh0dXJlR0NTeXN0ZW0gfSBmcm9tICcuL3RleHR1cmVzL1RleHR1cmVHQ1N5c3RlbS5tanMnO1xuZXhwb3J0IHsgVGV4dHVyZU1hdHJpeCB9IGZyb20gJy4vdGV4dHVyZXMvVGV4dHVyZU1hdHJpeC5tanMnO1xuZXhwb3J0IHsgVGV4dHVyZVN5c3RlbSB9IGZyb20gJy4vdGV4dHVyZXMvVGV4dHVyZVN5c3RlbS5tanMnO1xuZXhwb3J0IHsgVGV4dHVyZVV2cyB9IGZyb20gJy4vdGV4dHVyZXMvVGV4dHVyZVV2cy5tanMnO1xuZXhwb3J0IHsgVHJhbnNmb3JtRmVlZGJhY2sgfSBmcm9tICcuL3RyYW5zZm9ybUZlZWRiYWNrL1RyYW5zZm9ybUZlZWRiYWNrLm1qcyc7XG5leHBvcnQgeyBUcmFuc2Zvcm1GZWVkYmFja1N5c3RlbSB9IGZyb20gJy4vdHJhbnNmb3JtRmVlZGJhY2svVHJhbnNmb3JtRmVlZGJhY2tTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IFF1YWQgfSBmcm9tICcuL3V0aWxzL1F1YWQubWpzJztcbmV4cG9ydCB7IFF1YWRVdiB9IGZyb20gJy4vdXRpbHMvUXVhZFV2Lm1qcyc7XG5leHBvcnQgeyBWaWV3U3lzdGVtIH0gZnJvbSAnLi92aWV3L1ZpZXdTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IFN5c3RlbU1hbmFnZXIgfSBmcm9tICcuL3N5c3RlbS9TeXN0ZW1NYW5hZ2VyLm1qcyc7XG5leHBvcnQgeyBCYXNlSW1hZ2VSZXNvdXJjZSB9IGZyb20gJy4vdGV4dHVyZXMvcmVzb3VyY2VzL0Jhc2VJbWFnZVJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBSZXNvdXJjZSB9IGZyb20gJy4vdGV4dHVyZXMvcmVzb3VyY2VzL1Jlc291cmNlLm1qcyc7XG5leHBvcnQgeyBBYnN0cmFjdE11bHRpUmVzb3VyY2UgfSBmcm9tICcuL3RleHR1cmVzL3Jlc291cmNlcy9BYnN0cmFjdE11bHRpUmVzb3VyY2UubWpzJztcbmV4cG9ydCB7IEFycmF5UmVzb3VyY2UgfSBmcm9tICcuL3RleHR1cmVzL3Jlc291cmNlcy9BcnJheVJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBJTlNUQUxMRUQsIGF1dG9EZXRlY3RSZXNvdXJjZSB9IGZyb20gJy4vdGV4dHVyZXMvcmVzb3VyY2VzL2F1dG9EZXRlY3RSZXNvdXJjZS5tanMnO1xuZXhwb3J0IHsgQnVmZmVyUmVzb3VyY2UgfSBmcm9tICcuL3RleHR1cmVzL3Jlc291cmNlcy9CdWZmZXJSZXNvdXJjZS5tanMnO1xuZXhwb3J0IHsgQ2FudmFzUmVzb3VyY2UgfSBmcm9tICcuL3RleHR1cmVzL3Jlc291cmNlcy9DYW52YXNSZXNvdXJjZS5tanMnO1xuZXhwb3J0IHsgQ3ViZVJlc291cmNlIH0gZnJvbSAnLi90ZXh0dXJlcy9yZXNvdXJjZXMvQ3ViZVJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBJbWFnZUJpdG1hcFJlc291cmNlIH0gZnJvbSAnLi90ZXh0dXJlcy9yZXNvdXJjZXMvSW1hZ2VCaXRtYXBSZXNvdXJjZS5tanMnO1xuZXhwb3J0IHsgSW1hZ2VSZXNvdXJjZSB9IGZyb20gJy4vdGV4dHVyZXMvcmVzb3VyY2VzL0ltYWdlUmVzb3VyY2UubWpzJztcbmV4cG9ydCB7IFNWR1Jlc291cmNlIH0gZnJvbSAnLi90ZXh0dXJlcy9yZXNvdXJjZXMvU1ZHUmVzb3VyY2UubWpzJztcbmV4cG9ydCB7IFZpZGVvUmVzb3VyY2UgfSBmcm9tICcuL3RleHR1cmVzL3Jlc291cmNlcy9WaWRlb1Jlc291cmNlLm1qcyc7XG5cbmNvbnN0IFZFUlNJT04gPSBcIjcuMi40XCI7XG5cbmV4cG9ydCB7IFZFUlNJT04gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuXG5jbGFzcyBCb3VuZHMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm1pblggPSBJbmZpbml0eTtcbiAgICB0aGlzLm1pblkgPSBJbmZpbml0eTtcbiAgICB0aGlzLm1heFggPSAtSW5maW5pdHk7XG4gICAgdGhpcy5tYXhZID0gLUluZmluaXR5O1xuICAgIHRoaXMucmVjdCA9IG51bGw7XG4gICAgdGhpcy51cGRhdGVJRCA9IC0xO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMubWluWCA+IHRoaXMubWF4WCB8fCB0aGlzLm1pblkgPiB0aGlzLm1heFk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5taW5YID0gSW5maW5pdHk7XG4gICAgdGhpcy5taW5ZID0gSW5maW5pdHk7XG4gICAgdGhpcy5tYXhYID0gLUluZmluaXR5O1xuICAgIHRoaXMubWF4WSA9IC1JbmZpbml0eTtcbiAgfVxuICBnZXRSZWN0YW5nbGUocmVjdCkge1xuICAgIGlmICh0aGlzLm1pblggPiB0aGlzLm1heFggfHwgdGhpcy5taW5ZID4gdGhpcy5tYXhZKSB7XG4gICAgICByZXR1cm4gUmVjdGFuZ2xlLkVNUFRZO1xuICAgIH1cbiAgICByZWN0ID0gcmVjdCB8fCBuZXcgUmVjdGFuZ2xlKDAsIDAsIDEsIDEpO1xuICAgIHJlY3QueCA9IHRoaXMubWluWDtcbiAgICByZWN0LnkgPSB0aGlzLm1pblk7XG4gICAgcmVjdC53aWR0aCA9IHRoaXMubWF4WCAtIHRoaXMubWluWDtcbiAgICByZWN0LmhlaWdodCA9IHRoaXMubWF4WSAtIHRoaXMubWluWTtcbiAgICByZXR1cm4gcmVjdDtcbiAgfVxuICBhZGRQb2ludChwb2ludCkge1xuICAgIHRoaXMubWluWCA9IE1hdGgubWluKHRoaXMubWluWCwgcG9pbnQueCk7XG4gICAgdGhpcy5tYXhYID0gTWF0aC5tYXgodGhpcy5tYXhYLCBwb2ludC54KTtcbiAgICB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIHBvaW50LnkpO1xuICAgIHRoaXMubWF4WSA9IE1hdGgubWF4KHRoaXMubWF4WSwgcG9pbnQueSk7XG4gIH1cbiAgYWRkUG9pbnRNYXRyaXgobWF0cml4LCBwb2ludCkge1xuICAgIGNvbnN0IHsgYSwgYiwgYywgZCwgdHgsIHR5IH0gPSBtYXRyaXg7XG4gICAgY29uc3QgeCA9IGEgKiBwb2ludC54ICsgYyAqIHBvaW50LnkgKyB0eDtcbiAgICBjb25zdCB5ID0gYiAqIHBvaW50LnggKyBkICogcG9pbnQueSArIHR5O1xuICAgIHRoaXMubWluWCA9IE1hdGgubWluKHRoaXMubWluWCwgeCk7XG4gICAgdGhpcy5tYXhYID0gTWF0aC5tYXgodGhpcy5tYXhYLCB4KTtcbiAgICB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIHkpO1xuICAgIHRoaXMubWF4WSA9IE1hdGgubWF4KHRoaXMubWF4WSwgeSk7XG4gIH1cbiAgYWRkUXVhZCh2ZXJ0aWNlcykge1xuICAgIGxldCBtaW5YID0gdGhpcy5taW5YO1xuICAgIGxldCBtaW5ZID0gdGhpcy5taW5ZO1xuICAgIGxldCBtYXhYID0gdGhpcy5tYXhYO1xuICAgIGxldCBtYXhZID0gdGhpcy5tYXhZO1xuICAgIGxldCB4ID0gdmVydGljZXNbMF07XG4gICAgbGV0IHkgPSB2ZXJ0aWNlc1sxXTtcbiAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcbiAgICB4ID0gdmVydGljZXNbMl07XG4gICAgeSA9IHZlcnRpY2VzWzNdO1xuICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuICAgIHggPSB2ZXJ0aWNlc1s0XTtcbiAgICB5ID0gdmVydGljZXNbNV07XG4gICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG4gICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgeCA9IHZlcnRpY2VzWzZdO1xuICAgIHkgPSB2ZXJ0aWNlc1s3XTtcbiAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcbiAgICB0aGlzLm1pblggPSBtaW5YO1xuICAgIHRoaXMubWluWSA9IG1pblk7XG4gICAgdGhpcy5tYXhYID0gbWF4WDtcbiAgICB0aGlzLm1heFkgPSBtYXhZO1xuICB9XG4gIGFkZEZyYW1lKHRyYW5zZm9ybSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICB0aGlzLmFkZEZyYW1lTWF0cml4KHRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybSwgeDAsIHkwLCB4MSwgeTEpO1xuICB9XG4gIGFkZEZyYW1lTWF0cml4KG1hdHJpeCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICBjb25zdCBhID0gbWF0cml4LmE7XG4gICAgY29uc3QgYiA9IG1hdHJpeC5iO1xuICAgIGNvbnN0IGMgPSBtYXRyaXguYztcbiAgICBjb25zdCBkID0gbWF0cml4LmQ7XG4gICAgY29uc3QgdHggPSBtYXRyaXgudHg7XG4gICAgY29uc3QgdHkgPSBtYXRyaXgudHk7XG4gICAgbGV0IG1pblggPSB0aGlzLm1pblg7XG4gICAgbGV0IG1pblkgPSB0aGlzLm1pblk7XG4gICAgbGV0IG1heFggPSB0aGlzLm1heFg7XG4gICAgbGV0IG1heFkgPSB0aGlzLm1heFk7XG4gICAgbGV0IHggPSBhICogeDAgKyBjICogeTAgKyB0eDtcbiAgICBsZXQgeSA9IGIgKiB4MCArIGQgKiB5MCArIHR5O1xuICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuICAgIHggPSBhICogeDEgKyBjICogeTAgKyB0eDtcbiAgICB5ID0gYiAqIHgxICsgZCAqIHkwICsgdHk7XG4gICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG4gICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgeCA9IGEgKiB4MCArIGMgKiB5MSArIHR4O1xuICAgIHkgPSBiICogeDAgKyBkICogeTEgKyB0eTtcbiAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcbiAgICB4ID0gYSAqIHgxICsgYyAqIHkxICsgdHg7XG4gICAgeSA9IGIgKiB4MSArIGQgKiB5MSArIHR5O1xuICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuICAgIHRoaXMubWluWCA9IG1pblg7XG4gICAgdGhpcy5taW5ZID0gbWluWTtcbiAgICB0aGlzLm1heFggPSBtYXhYO1xuICAgIHRoaXMubWF4WSA9IG1heFk7XG4gIH1cbiAgYWRkVmVydGV4RGF0YSh2ZXJ0ZXhEYXRhLCBiZWdpbk9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgbGV0IG1pblggPSB0aGlzLm1pblg7XG4gICAgbGV0IG1pblkgPSB0aGlzLm1pblk7XG4gICAgbGV0IG1heFggPSB0aGlzLm1heFg7XG4gICAgbGV0IG1heFkgPSB0aGlzLm1heFk7XG4gICAgZm9yIChsZXQgaSA9IGJlZ2luT2Zmc2V0OyBpIDwgZW5kT2Zmc2V0OyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHggPSB2ZXJ0ZXhEYXRhW2ldO1xuICAgICAgY29uc3QgeSA9IHZlcnRleERhdGFbaSArIDFdO1xuICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgfVxuICAgIHRoaXMubWluWCA9IG1pblg7XG4gICAgdGhpcy5taW5ZID0gbWluWTtcbiAgICB0aGlzLm1heFggPSBtYXhYO1xuICAgIHRoaXMubWF4WSA9IG1heFk7XG4gIH1cbiAgYWRkVmVydGljZXModHJhbnNmb3JtLCB2ZXJ0aWNlcywgYmVnaW5PZmZzZXQsIGVuZE9mZnNldCkge1xuICAgIHRoaXMuYWRkVmVydGljZXNNYXRyaXgodHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLCB2ZXJ0aWNlcywgYmVnaW5PZmZzZXQsIGVuZE9mZnNldCk7XG4gIH1cbiAgYWRkVmVydGljZXNNYXRyaXgobWF0cml4LCB2ZXJ0aWNlcywgYmVnaW5PZmZzZXQsIGVuZE9mZnNldCwgcGFkWCA9IDAsIHBhZFkgPSBwYWRYKSB7XG4gICAgY29uc3QgYSA9IG1hdHJpeC5hO1xuICAgIGNvbnN0IGIgPSBtYXRyaXguYjtcbiAgICBjb25zdCBjID0gbWF0cml4LmM7XG4gICAgY29uc3QgZCA9IG1hdHJpeC5kO1xuICAgIGNvbnN0IHR4ID0gbWF0cml4LnR4O1xuICAgIGNvbnN0IHR5ID0gbWF0cml4LnR5O1xuICAgIGxldCBtaW5YID0gdGhpcy5taW5YO1xuICAgIGxldCBtaW5ZID0gdGhpcy5taW5ZO1xuICAgIGxldCBtYXhYID0gdGhpcy5tYXhYO1xuICAgIGxldCBtYXhZID0gdGhpcy5tYXhZO1xuICAgIGZvciAobGV0IGkgPSBiZWdpbk9mZnNldDsgaSA8IGVuZE9mZnNldDsgaSArPSAyKSB7XG4gICAgICBjb25zdCByYXdYID0gdmVydGljZXNbaV07XG4gICAgICBjb25zdCByYXdZID0gdmVydGljZXNbaSArIDFdO1xuICAgICAgY29uc3QgeCA9IGEgKiByYXdYICsgYyAqIHJhd1kgKyB0eDtcbiAgICAgIGNvbnN0IHkgPSBkICogcmF3WSArIGIgKiByYXdYICsgdHk7XG4gICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCAtIHBhZFgpO1xuICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHggKyBwYWRYKTtcbiAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5IC0gcGFkWSk7XG4gICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSArIHBhZFkpO1xuICAgIH1cbiAgICB0aGlzLm1pblggPSBtaW5YO1xuICAgIHRoaXMubWluWSA9IG1pblk7XG4gICAgdGhpcy5tYXhYID0gbWF4WDtcbiAgICB0aGlzLm1heFkgPSBtYXhZO1xuICB9XG4gIGFkZEJvdW5kcyhib3VuZHMpIHtcbiAgICBjb25zdCBtaW5YID0gdGhpcy5taW5YO1xuICAgIGNvbnN0IG1pblkgPSB0aGlzLm1pblk7XG4gICAgY29uc3QgbWF4WCA9IHRoaXMubWF4WDtcbiAgICBjb25zdCBtYXhZID0gdGhpcy5tYXhZO1xuICAgIHRoaXMubWluWCA9IGJvdW5kcy5taW5YIDwgbWluWCA/IGJvdW5kcy5taW5YIDogbWluWDtcbiAgICB0aGlzLm1pblkgPSBib3VuZHMubWluWSA8IG1pblkgPyBib3VuZHMubWluWSA6IG1pblk7XG4gICAgdGhpcy5tYXhYID0gYm91bmRzLm1heFggPiBtYXhYID8gYm91bmRzLm1heFggOiBtYXhYO1xuICAgIHRoaXMubWF4WSA9IGJvdW5kcy5tYXhZID4gbWF4WSA/IGJvdW5kcy5tYXhZIDogbWF4WTtcbiAgfVxuICBhZGRCb3VuZHNNYXNrKGJvdW5kcywgbWFzaykge1xuICAgIGNvbnN0IF9taW5YID0gYm91bmRzLm1pblggPiBtYXNrLm1pblggPyBib3VuZHMubWluWCA6IG1hc2subWluWDtcbiAgICBjb25zdCBfbWluWSA9IGJvdW5kcy5taW5ZID4gbWFzay5taW5ZID8gYm91bmRzLm1pblkgOiBtYXNrLm1pblk7XG4gICAgY29uc3QgX21heFggPSBib3VuZHMubWF4WCA8IG1hc2subWF4WCA/IGJvdW5kcy5tYXhYIDogbWFzay5tYXhYO1xuICAgIGNvbnN0IF9tYXhZID0gYm91bmRzLm1heFkgPCBtYXNrLm1heFkgPyBib3VuZHMubWF4WSA6IG1hc2subWF4WTtcbiAgICBpZiAoX21pblggPD0gX21heFggJiYgX21pblkgPD0gX21heFkpIHtcbiAgICAgIGNvbnN0IG1pblggPSB0aGlzLm1pblg7XG4gICAgICBjb25zdCBtaW5ZID0gdGhpcy5taW5ZO1xuICAgICAgY29uc3QgbWF4WCA9IHRoaXMubWF4WDtcbiAgICAgIGNvbnN0IG1heFkgPSB0aGlzLm1heFk7XG4gICAgICB0aGlzLm1pblggPSBfbWluWCA8IG1pblggPyBfbWluWCA6IG1pblg7XG4gICAgICB0aGlzLm1pblkgPSBfbWluWSA8IG1pblkgPyBfbWluWSA6IG1pblk7XG4gICAgICB0aGlzLm1heFggPSBfbWF4WCA+IG1heFggPyBfbWF4WCA6IG1heFg7XG4gICAgICB0aGlzLm1heFkgPSBfbWF4WSA+IG1heFkgPyBfbWF4WSA6IG1heFk7XG4gICAgfVxuICB9XG4gIGFkZEJvdW5kc01hdHJpeChib3VuZHMsIG1hdHJpeCkge1xuICAgIHRoaXMuYWRkRnJhbWVNYXRyaXgobWF0cml4LCBib3VuZHMubWluWCwgYm91bmRzLm1pblksIGJvdW5kcy5tYXhYLCBib3VuZHMubWF4WSk7XG4gIH1cbiAgYWRkQm91bmRzQXJlYShib3VuZHMsIGFyZWEpIHtcbiAgICBjb25zdCBfbWluWCA9IGJvdW5kcy5taW5YID4gYXJlYS54ID8gYm91bmRzLm1pblggOiBhcmVhLng7XG4gICAgY29uc3QgX21pblkgPSBib3VuZHMubWluWSA+IGFyZWEueSA/IGJvdW5kcy5taW5ZIDogYXJlYS55O1xuICAgIGNvbnN0IF9tYXhYID0gYm91bmRzLm1heFggPCBhcmVhLnggKyBhcmVhLndpZHRoID8gYm91bmRzLm1heFggOiBhcmVhLnggKyBhcmVhLndpZHRoO1xuICAgIGNvbnN0IF9tYXhZID0gYm91bmRzLm1heFkgPCBhcmVhLnkgKyBhcmVhLmhlaWdodCA/IGJvdW5kcy5tYXhZIDogYXJlYS55ICsgYXJlYS5oZWlnaHQ7XG4gICAgaWYgKF9taW5YIDw9IF9tYXhYICYmIF9taW5ZIDw9IF9tYXhZKSB7XG4gICAgICBjb25zdCBtaW5YID0gdGhpcy5taW5YO1xuICAgICAgY29uc3QgbWluWSA9IHRoaXMubWluWTtcbiAgICAgIGNvbnN0IG1heFggPSB0aGlzLm1heFg7XG4gICAgICBjb25zdCBtYXhZID0gdGhpcy5tYXhZO1xuICAgICAgdGhpcy5taW5YID0gX21pblggPCBtaW5YID8gX21pblggOiBtaW5YO1xuICAgICAgdGhpcy5taW5ZID0gX21pblkgPCBtaW5ZID8gX21pblkgOiBtaW5ZO1xuICAgICAgdGhpcy5tYXhYID0gX21heFggPiBtYXhYID8gX21heFggOiBtYXhYO1xuICAgICAgdGhpcy5tYXhZID0gX21heFkgPiBtYXhZID8gX21heFkgOiBtYXhZO1xuICAgIH1cbiAgfVxuICBwYWQocGFkZGluZ1ggPSAwLCBwYWRkaW5nWSA9IHBhZGRpbmdYKSB7XG4gICAgaWYgKCF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy5taW5YIC09IHBhZGRpbmdYO1xuICAgICAgdGhpcy5tYXhYICs9IHBhZGRpbmdYO1xuICAgICAgdGhpcy5taW5ZIC09IHBhZGRpbmdZO1xuICAgICAgdGhpcy5tYXhZICs9IHBhZGRpbmdZO1xuICAgIH1cbiAgfVxuICBhZGRGcmFtZVBhZCh4MCwgeTAsIHgxLCB5MSwgcGFkWCwgcGFkWSkge1xuICAgIHgwIC09IHBhZFg7XG4gICAgeTAgLT0gcGFkWTtcbiAgICB4MSArPSBwYWRYO1xuICAgIHkxICs9IHBhZFk7XG4gICAgdGhpcy5taW5YID0gdGhpcy5taW5YIDwgeDAgPyB0aGlzLm1pblggOiB4MDtcbiAgICB0aGlzLm1heFggPSB0aGlzLm1heFggPiB4MSA/IHRoaXMubWF4WCA6IHgxO1xuICAgIHRoaXMubWluWSA9IHRoaXMubWluWSA8IHkwID8gdGhpcy5taW5ZIDogeTA7XG4gICAgdGhpcy5tYXhZID0gdGhpcy5tYXhZID4geTEgPyB0aGlzLm1heFkgOiB5MTtcbiAgfVxufVxuXG5leHBvcnQgeyBCb3VuZHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJvdW5kcy5tanMubWFwXG4iLCJpbXBvcnQgeyB1dGlscywgVHJhbnNmb3JtLCBSZWN0YW5nbGUsIFJBRF9UT19ERUcsIERFR19UT19SQUQgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IEJvdW5kcyB9IGZyb20gJy4vQm91bmRzLm1qcyc7XG5cbmNsYXNzIERpc3BsYXlPYmplY3QgZXh0ZW5kcyB1dGlscy5FdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudGVtcERpc3BsYXlPYmplY3RQYXJlbnQgPSBudWxsO1xuICAgIHRoaXMudHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybSgpO1xuICAgIHRoaXMuYWxwaGEgPSAxO1xuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5yZW5kZXJhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmN1bGxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5jdWxsQXJlYSA9IG51bGw7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMud29ybGRBbHBoYSA9IDE7XG4gICAgdGhpcy5fbGFzdFNvcnRlZEluZGV4ID0gMDtcbiAgICB0aGlzLl96SW5kZXggPSAwO1xuICAgIHRoaXMuZmlsdGVyQXJlYSA9IG51bGw7XG4gICAgdGhpcy5maWx0ZXJzID0gbnVsbDtcbiAgICB0aGlzLl9lbmFibGVkRmlsdGVycyA9IG51bGw7XG4gICAgdGhpcy5fYm91bmRzID0gbmV3IEJvdW5kcygpO1xuICAgIHRoaXMuX2xvY2FsQm91bmRzID0gbnVsbDtcbiAgICB0aGlzLl9ib3VuZHNJRCA9IDA7XG4gICAgdGhpcy5fYm91bmRzUmVjdCA9IG51bGw7XG4gICAgdGhpcy5fbG9jYWxCb3VuZHNSZWN0ID0gbnVsbDtcbiAgICB0aGlzLl9tYXNrID0gbnVsbDtcbiAgICB0aGlzLl9tYXNrUmVmQ291bnQgPSAwO1xuICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNTcHJpdGUgPSBmYWxzZTtcbiAgICB0aGlzLmlzTWFzayA9IGZhbHNlO1xuICB9XG4gIHN0YXRpYyBtaXhpbihzb3VyY2UpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IGtleXNbaV07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlzcGxheU9iamVjdC5wcm90b3R5cGUsIHByb3BlcnR5TmFtZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHByb3BlcnR5TmFtZSkpO1xuICAgIH1cbiAgfVxuICBnZXQgZGVzdHJveWVkKCkge1xuICAgIHJldHVybiB0aGlzLl9kZXN0cm95ZWQ7XG4gIH1cbiAgX3JlY3Vyc2l2ZVBvc3RVcGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5fcmVjdXJzaXZlUG9zdFVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlVHJhbnNmb3JtKHRoaXMucGFyZW50LnRyYW5zZm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZVRyYW5zZm9ybSh0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudC50cmFuc2Zvcm0pO1xuICAgIH1cbiAgfVxuICB1cGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgdGhpcy5fYm91bmRzSUQrKztcbiAgICB0aGlzLnRyYW5zZm9ybS51cGRhdGVUcmFuc2Zvcm0odGhpcy5wYXJlbnQudHJhbnNmb3JtKTtcbiAgICB0aGlzLndvcmxkQWxwaGEgPSB0aGlzLmFscGhhICogdGhpcy5wYXJlbnQud29ybGRBbHBoYTtcbiAgfVxuICBnZXRCb3VuZHMoc2tpcFVwZGF0ZSwgcmVjdCkge1xuICAgIGlmICghc2tpcFVwZGF0ZSkge1xuICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZWN1cnNpdmVQb3N0VXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl9ib3VuZHMudXBkYXRlSUQgIT09IHRoaXMuX2JvdW5kc0lEKSB7XG4gICAgICB0aGlzLmNhbGN1bGF0ZUJvdW5kcygpO1xuICAgICAgdGhpcy5fYm91bmRzLnVwZGF0ZUlEID0gdGhpcy5fYm91bmRzSUQ7XG4gICAgfVxuICAgIGlmICghcmVjdCkge1xuICAgICAgaWYgKCF0aGlzLl9ib3VuZHNSZWN0KSB7XG4gICAgICAgIHRoaXMuX2JvdW5kc1JlY3QgPSBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgICB9XG4gICAgICByZWN0ID0gdGhpcy5fYm91bmRzUmVjdDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2JvdW5kcy5nZXRSZWN0YW5nbGUocmVjdCk7XG4gIH1cbiAgZ2V0TG9jYWxCb3VuZHMocmVjdCkge1xuICAgIGlmICghcmVjdCkge1xuICAgICAgaWYgKCF0aGlzLl9sb2NhbEJvdW5kc1JlY3QpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxCb3VuZHNSZWN0ID0gbmV3IFJlY3RhbmdsZSgpO1xuICAgICAgfVxuICAgICAgcmVjdCA9IHRoaXMuX2xvY2FsQm91bmRzUmVjdDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9sb2NhbEJvdW5kcykge1xuICAgICAgdGhpcy5fbG9jYWxCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zZm9ybVJlZiA9IHRoaXMudHJhbnNmb3JtO1xuICAgIGNvbnN0IHBhcmVudFJlZiA9IHRoaXMucGFyZW50O1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50LnRyYW5zZm9ybTtcbiAgICBjb25zdCB3b3JsZEJvdW5kcyA9IHRoaXMuX2JvdW5kcztcbiAgICBjb25zdCB3b3JsZEJvdW5kc0lEID0gdGhpcy5fYm91bmRzSUQ7XG4gICAgdGhpcy5fYm91bmRzID0gdGhpcy5fbG9jYWxCb3VuZHM7XG4gICAgY29uc3QgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoZmFsc2UsIHJlY3QpO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50UmVmO1xuICAgIHRoaXMudHJhbnNmb3JtID0gdHJhbnNmb3JtUmVmO1xuICAgIHRoaXMuX2JvdW5kcyA9IHdvcmxkQm91bmRzO1xuICAgIHRoaXMuX2JvdW5kcy51cGRhdGVJRCArPSB0aGlzLl9ib3VuZHNJRCAtIHdvcmxkQm91bmRzSUQ7XG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfVxuICB0b0dsb2JhbChwb3NpdGlvbiwgcG9pbnQsIHNraXBVcGRhdGUgPSBmYWxzZSkge1xuICAgIGlmICghc2tpcFVwZGF0ZSkge1xuICAgICAgdGhpcy5fcmVjdXJzaXZlUG9zdFVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xuICAgICAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5KHBvc2l0aW9uLCBwb2ludCk7XG4gIH1cbiAgdG9Mb2NhbChwb3NpdGlvbiwgZnJvbSwgcG9pbnQsIHNraXBVcGRhdGUpIHtcbiAgICBpZiAoZnJvbSkge1xuICAgICAgcG9zaXRpb24gPSBmcm9tLnRvR2xvYmFsKHBvc2l0aW9uLCBwb2ludCwgc2tpcFVwZGF0ZSk7XG4gICAgfVxuICAgIGlmICghc2tpcFVwZGF0ZSkge1xuICAgICAgdGhpcy5fcmVjdXJzaXZlUG9zdFVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xuICAgICAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb3NpdGlvbiwgcG9pbnQpO1xuICB9XG4gIHNldFBhcmVudChjb250YWluZXIpIHtcbiAgICBpZiAoIWNvbnRhaW5lciB8fCAhY29udGFpbmVyLmFkZENoaWxkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZXRQYXJlbnQ6IEFyZ3VtZW50IG11c3QgYmUgYSBDb250YWluZXJcIik7XG4gICAgfVxuICAgIGNvbnRhaW5lci5hZGRDaGlsZCh0aGlzKTtcbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9XG4gIHJlbW92ZUZyb21QYXJlbnQoKSB7XG4gICAgdGhpcy5wYXJlbnQ/LnJlbW92ZUNoaWxkKHRoaXMpO1xuICB9XG4gIHNldFRyYW5zZm9ybSh4ID0gMCwgeSA9IDAsIHNjYWxlWCA9IDEsIHNjYWxlWSA9IDEsIHJvdGF0aW9uID0gMCwgc2tld1ggPSAwLCBza2V3WSA9IDAsIHBpdm90WCA9IDAsIHBpdm90WSA9IDApIHtcbiAgICB0aGlzLnBvc2l0aW9uLnggPSB4O1xuICAgIHRoaXMucG9zaXRpb24ueSA9IHk7XG4gICAgdGhpcy5zY2FsZS54ID0gIXNjYWxlWCA/IDEgOiBzY2FsZVg7XG4gICAgdGhpcy5zY2FsZS55ID0gIXNjYWxlWSA/IDEgOiBzY2FsZVk7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMuc2tldy54ID0gc2tld1g7XG4gICAgdGhpcy5za2V3LnkgPSBza2V3WTtcbiAgICB0aGlzLnBpdm90LnggPSBwaXZvdFg7XG4gICAgdGhpcy5waXZvdC55ID0gcGl2b3RZO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRlc3Ryb3koX29wdGlvbnMpIHtcbiAgICB0aGlzLnJlbW92ZUZyb21QYXJlbnQoKTtcbiAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMudHJhbnNmb3JtID0gbnVsbDtcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5fYm91bmRzID0gbnVsbDtcbiAgICB0aGlzLm1hc2sgPSBudWxsO1xuICAgIHRoaXMuY3VsbEFyZWEgPSBudWxsO1xuICAgIHRoaXMuZmlsdGVycyA9IG51bGw7XG4gICAgdGhpcy5maWx0ZXJBcmVhID0gbnVsbDtcbiAgICB0aGlzLmhpdEFyZWEgPSBudWxsO1xuICAgIHRoaXMuZXZlbnRNb2RlID0gXCJhdXRvXCI7XG4gICAgdGhpcy5pbnRlcmFjdGl2ZUNoaWxkcmVuID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KFwiZGVzdHJveWVkXCIpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cbiAgZ2V0IF90ZW1wRGlzcGxheU9iamVjdFBhcmVudCgpIHtcbiAgICBpZiAodGhpcy50ZW1wRGlzcGxheU9iamVjdFBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy50ZW1wRGlzcGxheU9iamVjdFBhcmVudCA9IG5ldyBUZW1wb3JhcnlEaXNwbGF5T2JqZWN0KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xuICB9XG4gIGVuYWJsZVRlbXBQYXJlbnQoKSB7XG4gICAgY29uc3QgbXlQYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICB0aGlzLnBhcmVudCA9IHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xuICAgIHJldHVybiBteVBhcmVudDtcbiAgfVxuICBkaXNhYmxlVGVtcFBhcmVudChjYWNoZVBhcmVudCkge1xuICAgIHRoaXMucGFyZW50ID0gY2FjaGVQYXJlbnQ7XG4gIH1cbiAgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueDtcbiAgfVxuICBzZXQgeCh2YWx1ZSkge1xuICAgIHRoaXMudHJhbnNmb3JtLnBvc2l0aW9uLnggPSB2YWx1ZTtcbiAgfVxuICBnZXQgeSgpIHtcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi55O1xuICB9XG4gIHNldCB5KHZhbHVlKSB7XG4gICAgdGhpcy50cmFuc2Zvcm0ucG9zaXRpb24ueSA9IHZhbHVlO1xuICB9XG4gIGdldCB3b3JsZFRyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gIH1cbiAgZ2V0IGxvY2FsVHJhbnNmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5sb2NhbFRyYW5zZm9ybTtcbiAgfVxuICBnZXQgcG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnBvc2l0aW9uO1xuICB9XG4gIHNldCBwb3NpdGlvbih2YWx1ZSkge1xuICAgIHRoaXMudHJhbnNmb3JtLnBvc2l0aW9uLmNvcHlGcm9tKHZhbHVlKTtcbiAgfVxuICBnZXQgc2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnNjYWxlO1xuICB9XG4gIHNldCBzY2FsZSh2YWx1ZSkge1xuICAgIHRoaXMudHJhbnNmb3JtLnNjYWxlLmNvcHlGcm9tKHZhbHVlKTtcbiAgfVxuICBnZXQgcGl2b3QoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnBpdm90O1xuICB9XG4gIHNldCBwaXZvdCh2YWx1ZSkge1xuICAgIHRoaXMudHJhbnNmb3JtLnBpdm90LmNvcHlGcm9tKHZhbHVlKTtcbiAgfVxuICBnZXQgc2tldygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uc2tldztcbiAgfVxuICBzZXQgc2tldyh2YWx1ZSkge1xuICAgIHRoaXMudHJhbnNmb3JtLnNrZXcuY29weUZyb20odmFsdWUpO1xuICB9XG4gIGdldCByb3RhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucm90YXRpb247XG4gIH1cbiAgc2V0IHJvdGF0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy50cmFuc2Zvcm0ucm90YXRpb24gPSB2YWx1ZTtcbiAgfVxuICBnZXQgYW5nbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uICogUkFEX1RPX0RFRztcbiAgfVxuICBzZXQgYW5nbGUodmFsdWUpIHtcbiAgICB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbiA9IHZhbHVlICogREVHX1RPX1JBRDtcbiAgfVxuICBnZXQgekluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl96SW5kZXg7XG4gIH1cbiAgc2V0IHpJbmRleCh2YWx1ZSkge1xuICAgIHRoaXMuX3pJbmRleCA9IHZhbHVlO1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQuc29ydERpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgZ2V0IHdvcmxkVmlzaWJsZSgpIHtcbiAgICBsZXQgaXRlbSA9IHRoaXM7XG4gICAgZG8ge1xuICAgICAgaWYgKCFpdGVtLnZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaXRlbSA9IGl0ZW0ucGFyZW50O1xuICAgIH0gd2hpbGUgKGl0ZW0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldCBtYXNrKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXNrO1xuICB9XG4gIHNldCBtYXNrKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX21hc2sgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9tYXNrKSB7XG4gICAgICBjb25zdCBtYXNrT2JqZWN0ID0gdGhpcy5fbWFzay5pc01hc2tEYXRhID8gdGhpcy5fbWFzay5tYXNrT2JqZWN0IDogdGhpcy5fbWFzaztcbiAgICAgIGlmIChtYXNrT2JqZWN0KSB7XG4gICAgICAgIG1hc2tPYmplY3QuX21hc2tSZWZDb3VudC0tO1xuICAgICAgICBpZiAobWFza09iamVjdC5fbWFza1JlZkNvdW50ID09PSAwKSB7XG4gICAgICAgICAgbWFza09iamVjdC5yZW5kZXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgICBtYXNrT2JqZWN0LmlzTWFzayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX21hc2sgPSB2YWx1ZTtcbiAgICBpZiAodGhpcy5fbWFzaykge1xuICAgICAgY29uc3QgbWFza09iamVjdCA9IHRoaXMuX21hc2suaXNNYXNrRGF0YSA/IHRoaXMuX21hc2subWFza09iamVjdCA6IHRoaXMuX21hc2s7XG4gICAgICBpZiAobWFza09iamVjdCkge1xuICAgICAgICBpZiAobWFza09iamVjdC5fbWFza1JlZkNvdW50ID09PSAwKSB7XG4gICAgICAgICAgbWFza09iamVjdC5yZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgbWFza09iamVjdC5pc01hc2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG1hc2tPYmplY3QuX21hc2tSZWZDb3VudCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuY2xhc3MgVGVtcG9yYXJ5RGlzcGxheU9iamVjdCBleHRlbmRzIERpc3BsYXlPYmplY3Qge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuc29ydERpcnR5ID0gbnVsbDtcbiAgfVxufVxuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSA9IERpc3BsYXlPYmplY3QucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybTtcblxuZXhwb3J0IHsgRGlzcGxheU9iamVjdCwgVGVtcG9yYXJ5RGlzcGxheU9iamVjdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGlzcGxheU9iamVjdC5tanMubWFwXG4iLCJpbXBvcnQgeyBNYXRyaXgsIHV0aWxzLCBNQVNLX1RZUEVTIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBEaXNwbGF5T2JqZWN0IH0gZnJvbSAnLi9EaXNwbGF5T2JqZWN0Lm1qcyc7XG5cbmNvbnN0IHRlbXBNYXRyaXggPSBuZXcgTWF0cml4KCk7XG5mdW5jdGlvbiBzb3J0Q2hpbGRyZW4oYSwgYikge1xuICBpZiAoYS56SW5kZXggPT09IGIuekluZGV4KSB7XG4gICAgcmV0dXJuIGEuX2xhc3RTb3J0ZWRJbmRleCAtIGIuX2xhc3RTb3J0ZWRJbmRleDtcbiAgfVxuICByZXR1cm4gYS56SW5kZXggLSBiLnpJbmRleDtcbn1cbmNvbnN0IF9Db250YWluZXIgPSBjbGFzcyBleHRlbmRzIERpc3BsYXlPYmplY3Qge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLnNvcnRhYmxlQ2hpbGRyZW4gPSBfQ29udGFpbmVyLmRlZmF1bHRTb3J0YWJsZUNoaWxkcmVuO1xuICAgIHRoaXMuc29ydERpcnR5ID0gZmFsc2U7XG4gIH1cbiAgb25DaGlsZHJlbkNoYW5nZShfbGVuZ3RoKSB7XG4gIH1cbiAgYWRkQ2hpbGQoLi4uY2hpbGRyZW4pIHtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkZENoaWxkKGNoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlblswXTtcbiAgICAgIGlmIChjaGlsZC5wYXJlbnQpIHtcbiAgICAgICAgY2hpbGQucGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgICB0aGlzLnNvcnREaXJ0eSA9IHRydWU7XG4gICAgICBjaGlsZC50cmFuc2Zvcm0uX3BhcmVudElEID0gLTE7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgdGhpcy5fYm91bmRzSUQrKztcbiAgICAgIHRoaXMub25DaGlsZHJlbkNoYW5nZSh0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgICAgdGhpcy5lbWl0KFwiY2hpbGRBZGRlZFwiLCBjaGlsZCwgdGhpcywgdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICAgIGNoaWxkLmVtaXQoXCJhZGRlZFwiLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuWzBdO1xuICB9XG4gIGFkZENoaWxkQXQoY2hpbGQsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y2hpbGR9YWRkQ2hpbGRBdDogVGhlIGluZGV4ICR7aW5kZXh9IHN1cHBsaWVkIGlzIG91dCBvZiBib3VuZHMgJHt0aGlzLmNoaWxkcmVuLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkLnBhcmVudCkge1xuICAgICAgY2hpbGQucGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG4gICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICB0aGlzLnNvcnREaXJ0eSA9IHRydWU7XG4gICAgY2hpbGQudHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xO1xuICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBjaGlsZCk7XG4gICAgdGhpcy5fYm91bmRzSUQrKztcbiAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgpO1xuICAgIGNoaWxkLmVtaXQoXCJhZGRlZFwiLCB0aGlzKTtcbiAgICB0aGlzLmVtaXQoXCJjaGlsZEFkZGVkXCIsIGNoaWxkLCB0aGlzLCBpbmRleCk7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG4gIHN3YXBDaGlsZHJlbihjaGlsZCwgY2hpbGQyKSB7XG4gICAgaWYgKGNoaWxkID09PSBjaGlsZDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5kZXgxID0gdGhpcy5nZXRDaGlsZEluZGV4KGNoaWxkKTtcbiAgICBjb25zdCBpbmRleDIgPSB0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQyKTtcbiAgICB0aGlzLmNoaWxkcmVuW2luZGV4MV0gPSBjaGlsZDI7XG4gICAgdGhpcy5jaGlsZHJlbltpbmRleDJdID0gY2hpbGQ7XG4gICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGluZGV4MSA8IGluZGV4MiA/IGluZGV4MSA6IGluZGV4Mik7XG4gIH1cbiAgZ2V0Q2hpbGRJbmRleChjaGlsZCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3VwcGxpZWQgRGlzcGxheU9iamVjdCBtdXN0IGJlIGEgY2hpbGQgb2YgdGhlIGNhbGxlclwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG4gIHNldENoaWxkSW5kZXgoY2hpbGQsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgaW5kZXggJHtpbmRleH0gc3VwcGxpZWQgaXMgb3V0IG9mIGJvdW5kcyAke3RoaXMuY2hpbGRyZW4ubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQpO1xuICAgIHV0aWxzLnJlbW92ZUl0ZW1zKHRoaXMuY2hpbGRyZW4sIGN1cnJlbnRJbmRleCwgMSk7XG4gICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcbiAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgpO1xuICB9XG4gIGdldENoaWxkQXQoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGdldENoaWxkQXQ6IEluZGV4ICgke2luZGV4fSkgZG9lcyBub3QgZXhpc3QuYCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2luZGV4XTtcbiAgfVxuICByZW1vdmVDaGlsZCguLi5jaGlsZHJlbikge1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgICAgY2hpbGQudHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xO1xuICAgICAgdXRpbHMucmVtb3ZlSXRlbXModGhpcy5jaGlsZHJlbiwgaW5kZXgsIDEpO1xuICAgICAgdGhpcy5fYm91bmRzSUQrKztcbiAgICAgIHRoaXMub25DaGlsZHJlbkNoYW5nZShpbmRleCk7XG4gICAgICBjaGlsZC5lbWl0KFwicmVtb3ZlZFwiLCB0aGlzKTtcbiAgICAgIHRoaXMuZW1pdChcImNoaWxkUmVtb3ZlZFwiLCBjaGlsZCwgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW5bMF07XG4gIH1cbiAgcmVtb3ZlQ2hpbGRBdChpbmRleCkge1xuICAgIGNvbnN0IGNoaWxkID0gdGhpcy5nZXRDaGlsZEF0KGluZGV4KTtcbiAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgIGNoaWxkLnRyYW5zZm9ybS5fcGFyZW50SUQgPSAtMTtcbiAgICB1dGlscy5yZW1vdmVJdGVtcyh0aGlzLmNoaWxkcmVuLCBpbmRleCwgMSk7XG4gICAgdGhpcy5fYm91bmRzSUQrKztcbiAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgpO1xuICAgIGNoaWxkLmVtaXQoXCJyZW1vdmVkXCIsIHRoaXMpO1xuICAgIHRoaXMuZW1pdChcImNoaWxkUmVtb3ZlZFwiLCBjaGlsZCwgdGhpcywgaW5kZXgpO1xuICAgIHJldHVybiBjaGlsZDtcbiAgfVxuICByZW1vdmVDaGlsZHJlbihiZWdpbkluZGV4ID0gMCwgZW5kSW5kZXggPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGNvbnN0IGJlZ2luID0gYmVnaW5JbmRleDtcbiAgICBjb25zdCBlbmQgPSBlbmRJbmRleDtcbiAgICBjb25zdCByYW5nZSA9IGVuZCAtIGJlZ2luO1xuICAgIGxldCByZW1vdmVkO1xuICAgIGlmIChyYW5nZSA+IDAgJiYgcmFuZ2UgPD0gZW5kKSB7XG4gICAgICByZW1vdmVkID0gdGhpcy5jaGlsZHJlbi5zcGxpY2UoYmVnaW4sIHJhbmdlKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtb3ZlZC5sZW5ndGg7ICsraSkge1xuICAgICAgICByZW1vdmVkW2ldLnBhcmVudCA9IG51bGw7XG4gICAgICAgIGlmIChyZW1vdmVkW2ldLnRyYW5zZm9ybSkge1xuICAgICAgICAgIHJlbW92ZWRbaV0udHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9ib3VuZHNJRCsrO1xuICAgICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGJlZ2luSW5kZXgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJlbW92ZWRbaV0uZW1pdChcInJlbW92ZWRcIiwgdGhpcyk7XG4gICAgICAgIHRoaXMuZW1pdChcImNoaWxkUmVtb3ZlZFwiLCByZW1vdmVkW2ldLCB0aGlzLCBpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH0gZWxzZSBpZiAocmFuZ2UgPT09IDAgJiYgdGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJyZW1vdmVDaGlsZHJlbjogbnVtZXJpYyB2YWx1ZXMgYXJlIG91dHNpZGUgdGhlIGFjY2VwdGFibGUgcmFuZ2UuXCIpO1xuICB9XG4gIHNvcnRDaGlsZHJlbigpIHtcbiAgICBsZXQgc29ydFJlcXVpcmVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSkge1xuICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgY2hpbGQuX2xhc3RTb3J0ZWRJbmRleCA9IGk7XG4gICAgICBpZiAoIXNvcnRSZXF1aXJlZCAmJiBjaGlsZC56SW5kZXggIT09IDApIHtcbiAgICAgICAgc29ydFJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNvcnRSZXF1aXJlZCAmJiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4uc29ydChzb3J0Q2hpbGRyZW4pO1xuICAgIH1cbiAgICB0aGlzLnNvcnREaXJ0eSA9IGZhbHNlO1xuICB9XG4gIHVwZGF0ZVRyYW5zZm9ybSgpIHtcbiAgICBpZiAodGhpcy5zb3J0YWJsZUNoaWxkcmVuICYmIHRoaXMuc29ydERpcnR5KSB7XG4gICAgICB0aGlzLnNvcnRDaGlsZHJlbigpO1xuICAgIH1cbiAgICB0aGlzLl9ib3VuZHNJRCsrO1xuICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZVRyYW5zZm9ybSh0aGlzLnBhcmVudC50cmFuc2Zvcm0pO1xuICAgIHRoaXMud29ybGRBbHBoYSA9IHRoaXMuYWxwaGEgKiB0aGlzLnBhcmVudC53b3JsZEFscGhhO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyArK2kpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChjaGlsZC52aXNpYmxlKSB7XG4gICAgICAgIGNoaWxkLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgdGhpcy5fYm91bmRzLmNsZWFyKCk7XG4gICAgdGhpcy5fY2FsY3VsYXRlQm91bmRzKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICBpZiAoIWNoaWxkLnZpc2libGUgfHwgIWNoaWxkLnJlbmRlcmFibGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjaGlsZC5jYWxjdWxhdGVCb3VuZHMoKTtcbiAgICAgIGlmIChjaGlsZC5fbWFzaykge1xuICAgICAgICBjb25zdCBtYXNrT2JqZWN0ID0gY2hpbGQuX21hc2suaXNNYXNrRGF0YSA/IGNoaWxkLl9tYXNrLm1hc2tPYmplY3QgOiBjaGlsZC5fbWFzaztcbiAgICAgICAgaWYgKG1hc2tPYmplY3QpIHtcbiAgICAgICAgICBtYXNrT2JqZWN0LmNhbGN1bGF0ZUJvdW5kcygpO1xuICAgICAgICAgIHRoaXMuX2JvdW5kcy5hZGRCb3VuZHNNYXNrKGNoaWxkLl9ib3VuZHMsIG1hc2tPYmplY3QuX2JvdW5kcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fYm91bmRzLmFkZEJvdW5kcyhjaGlsZC5fYm91bmRzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGlsZC5maWx0ZXJBcmVhKSB7XG4gICAgICAgIHRoaXMuX2JvdW5kcy5hZGRCb3VuZHNBcmVhKGNoaWxkLl9ib3VuZHMsIGNoaWxkLmZpbHRlckFyZWEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYm91bmRzLmFkZEJvdW5kcyhjaGlsZC5fYm91bmRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fYm91bmRzLnVwZGF0ZUlEID0gdGhpcy5fYm91bmRzSUQ7XG4gIH1cbiAgZ2V0TG9jYWxCb3VuZHMocmVjdCwgc2tpcENoaWxkcmVuVXBkYXRlID0gZmFsc2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSBzdXBlci5nZXRMb2NhbEJvdW5kcyhyZWN0KTtcbiAgICBpZiAoIXNraXBDaGlsZHJlblVwZGF0ZSkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChjaGlsZC52aXNpYmxlKSB7XG4gICAgICAgICAgY2hpbGQudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBfY2FsY3VsYXRlQm91bmRzKCkge1xuICB9XG4gIF9yZW5kZXJXaXRoQ3VsbGluZyhyZW5kZXJlcikge1xuICAgIGNvbnN0IHNvdXJjZUZyYW1lID0gcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5zb3VyY2VGcmFtZTtcbiAgICBpZiAoIShzb3VyY2VGcmFtZS53aWR0aCA+IDAgJiYgc291cmNlRnJhbWUuaGVpZ2h0ID4gMCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGJvdW5kcztcbiAgICBsZXQgdHJhbnNmb3JtO1xuICAgIGlmICh0aGlzLmN1bGxBcmVhKSB7XG4gICAgICBib3VuZHMgPSB0aGlzLmN1bGxBcmVhO1xuICAgICAgdHJhbnNmb3JtID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3JlbmRlciAhPT0gX0NvbnRhaW5lci5wcm90b3R5cGUuX3JlbmRlcikge1xuICAgICAgYm91bmRzID0gdGhpcy5nZXRCb3VuZHModHJ1ZSk7XG4gICAgfVxuICAgIGNvbnN0IHByb2plY3Rpb25UcmFuc2Zvcm0gPSByZW5kZXJlci5wcm9qZWN0aW9uLnRyYW5zZm9ybTtcbiAgICBpZiAocHJvamVjdGlvblRyYW5zZm9ybSkge1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICB0cmFuc2Zvcm0gPSB0ZW1wTWF0cml4LmNvcHlGcm9tKHRyYW5zZm9ybSk7XG4gICAgICAgIHRyYW5zZm9ybS5wcmVwZW5kKHByb2plY3Rpb25UcmFuc2Zvcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNmb3JtID0gcHJvamVjdGlvblRyYW5zZm9ybTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJvdW5kcyAmJiBzb3VyY2VGcmFtZS5pbnRlcnNlY3RzKGJvdW5kcywgdHJhbnNmb3JtKSkge1xuICAgICAgdGhpcy5fcmVuZGVyKHJlbmRlcmVyKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VsbEFyZWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSkge1xuICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgY29uc3QgY2hpbGRDdWxsYWJsZSA9IGNoaWxkLmN1bGxhYmxlO1xuICAgICAgY2hpbGQuY3VsbGFibGUgPSBjaGlsZEN1bGxhYmxlIHx8ICF0aGlzLmN1bGxBcmVhO1xuICAgICAgY2hpbGQucmVuZGVyKHJlbmRlcmVyKTtcbiAgICAgIGNoaWxkLmN1bGxhYmxlID0gY2hpbGRDdWxsYWJsZTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgaWYgKCF0aGlzLnZpc2libGUgfHwgdGhpcy53b3JsZEFscGhhIDw9IDAgfHwgIXRoaXMucmVuZGVyYWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbWFzayB8fCB0aGlzLmZpbHRlcnM/Lmxlbmd0aCkge1xuICAgICAgdGhpcy5yZW5kZXJBZHZhbmNlZChyZW5kZXJlcik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1bGxhYmxlKSB7XG4gICAgICB0aGlzLl9yZW5kZXJXaXRoQ3VsbGluZyhyZW5kZXJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlbmRlcihyZW5kZXJlcik7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgKytpKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0ucmVuZGVyKHJlbmRlcmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVuZGVyQWR2YW5jZWQocmVuZGVyZXIpIHtcbiAgICBjb25zdCBmaWx0ZXJzID0gdGhpcy5maWx0ZXJzO1xuICAgIGNvbnN0IG1hc2sgPSB0aGlzLl9tYXNrO1xuICAgIGlmIChmaWx0ZXJzKSB7XG4gICAgICBpZiAoIXRoaXMuX2VuYWJsZWRGaWx0ZXJzKSB7XG4gICAgICAgIHRoaXMuX2VuYWJsZWRGaWx0ZXJzID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLl9lbmFibGVkRmlsdGVycy5sZW5ndGggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmaWx0ZXJzW2ldLmVuYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLl9lbmFibGVkRmlsdGVycy5wdXNoKGZpbHRlcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZsdXNoID0gZmlsdGVycyAmJiB0aGlzLl9lbmFibGVkRmlsdGVycz8ubGVuZ3RoIHx8IG1hc2sgJiYgKCFtYXNrLmlzTWFza0RhdGEgfHwgbWFzay5lbmFibGVkICYmIChtYXNrLmF1dG9EZXRlY3QgfHwgbWFzay50eXBlICE9PSBNQVNLX1RZUEVTLk5PTkUpKTtcbiAgICBpZiAoZmx1c2gpIHtcbiAgICAgIHJlbmRlcmVyLmJhdGNoLmZsdXNoKCk7XG4gICAgfVxuICAgIGlmIChmaWx0ZXJzICYmIHRoaXMuX2VuYWJsZWRGaWx0ZXJzPy5sZW5ndGgpIHtcbiAgICAgIHJlbmRlcmVyLmZpbHRlci5wdXNoKHRoaXMsIHRoaXMuX2VuYWJsZWRGaWx0ZXJzKTtcbiAgICB9XG4gICAgaWYgKG1hc2spIHtcbiAgICAgIHJlbmRlcmVyLm1hc2sucHVzaCh0aGlzLCB0aGlzLl9tYXNrKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY3VsbGFibGUpIHtcbiAgICAgIHRoaXMuX3JlbmRlcldpdGhDdWxsaW5nKHJlbmRlcmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVuZGVyKHJlbmRlcmVyKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5yZW5kZXIocmVuZGVyZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmx1c2gpIHtcbiAgICAgIHJlbmRlcmVyLmJhdGNoLmZsdXNoKCk7XG4gICAgfVxuICAgIGlmIChtYXNrKSB7XG4gICAgICByZW5kZXJlci5tYXNrLnBvcCh0aGlzKTtcbiAgICB9XG4gICAgaWYgKGZpbHRlcnMgJiYgdGhpcy5fZW5hYmxlZEZpbHRlcnM/Lmxlbmd0aCkge1xuICAgICAgcmVuZGVyZXIuZmlsdGVyLnBvcCgpO1xuICAgIH1cbiAgfVxuICBfcmVuZGVyKF9yZW5kZXJlcikge1xuICB9XG4gIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLnNvcnREaXJ0eSA9IGZhbHNlO1xuICAgIGNvbnN0IGRlc3Ryb3lDaGlsZHJlbiA9IHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIiA/IG9wdGlvbnMgOiBvcHRpb25zPy5jaGlsZHJlbjtcbiAgICBjb25zdCBvbGRDaGlsZHJlbiA9IHRoaXMucmVtb3ZlQ2hpbGRyZW4oMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIGlmIChkZXN0cm95Q2hpbGRyZW4pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2xkQ2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgb2xkQ2hpbGRyZW5baV0uZGVzdHJveShvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnNjYWxlLnggKiB0aGlzLmdldExvY2FsQm91bmRzKCkud2lkdGg7XG4gIH1cbiAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldExvY2FsQm91bmRzKCkud2lkdGg7XG4gICAgaWYgKHdpZHRoICE9PSAwKSB7XG4gICAgICB0aGlzLnNjYWxlLnggPSB2YWx1ZSAvIHdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNjYWxlLnggPSAxO1xuICAgIH1cbiAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xuICB9XG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGUueSAqIHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS5oZWlnaHQ7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS5oZWlnaHQ7XG4gICAgaWYgKGhlaWdodCAhPT0gMCkge1xuICAgICAgdGhpcy5zY2FsZS55ID0gdmFsdWUgLyBoZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2NhbGUueSA9IDE7XG4gICAgfVxuICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICB9XG59O1xubGV0IENvbnRhaW5lciA9IF9Db250YWluZXI7XG5Db250YWluZXIuZGVmYXVsdFNvcnRhYmxlQ2hpbGRyZW4gPSBmYWxzZTtcbkNvbnRhaW5lci5wcm90b3R5cGUuY29udGFpbmVyVXBkYXRlVHJhbnNmb3JtID0gQ29udGFpbmVyLnByb3RvdHlwZS51cGRhdGVUcmFuc2Zvcm07XG5cbmV4cG9ydCB7IENvbnRhaW5lciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29udGFpbmVyLm1qcy5tYXBcbiIsImltcG9ydCB7IHNldHRpbmdzLCB1dGlscyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuZXhwb3J0IHsgc2V0dGluZ3MgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJy4vQ29udGFpbmVyLm1qcyc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNldHRpbmdzLCB7XG4gIFNPUlRBQkxFX0NISUxEUkVOOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIENvbnRhaW5lci5kZWZhdWx0U29ydGFibGVDaGlsZHJlbjtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgdXRpbHMuZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLlNPUlRBQkxFX0NISUxEUkVOIGlzIGRlcHJlY2F0ZWQsIHVzZSBDb250YWluZXIuZGVmYXVsdFNvcnRhYmxlQ2hpbGRyZW5cIik7XG4gICAgICBDb250YWluZXIuZGVmYXVsdFNvcnRhYmxlQ2hpbGRyZW4gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0dGluZ3MubWpzLm1hcFxuIiwiaW1wb3J0ICcuL3NldHRpbmdzLm1qcyc7XG5leHBvcnQgeyBCb3VuZHMgfSBmcm9tICcuL0JvdW5kcy5tanMnO1xuZXhwb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnLi9Db250YWluZXIubWpzJztcbmV4cG9ydCB7IERpc3BsYXlPYmplY3QsIFRlbXBvcmFyeURpc3BsYXlPYmplY3QgfSBmcm9tICcuL0Rpc3BsYXlPYmplY3QubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IFBvaW50LCBPYnNlcnZhYmxlUG9pbnQsIENvbG9yLCBCTEVORF9NT0RFUywgVGV4dHVyZSwgc2V0dGluZ3MsIHV0aWxzLCBSZWN0YW5nbGUgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IENvbnRhaW5lciwgQm91bmRzIH0gZnJvbSAnQHBpeGkvZGlzcGxheSc7XG5cbmNvbnN0IHRlbXBQb2ludCA9IG5ldyBQb2ludCgpO1xuY29uc3QgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShbMCwgMSwgMiwgMCwgMiwgM10pO1xuY2xhc3MgU3ByaXRlIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3IodGV4dHVyZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fYW5jaG9yID0gbmV3IE9ic2VydmFibGVQb2ludCh0aGlzLl9vbkFuY2hvclVwZGF0ZSwgdGhpcywgdGV4dHVyZSA/IHRleHR1cmUuZGVmYXVsdEFuY2hvci54IDogMCwgdGV4dHVyZSA/IHRleHR1cmUuZGVmYXVsdEFuY2hvci55IDogMCk7XG4gICAgdGhpcy5fdGV4dHVyZSA9IG51bGw7XG4gICAgdGhpcy5fd2lkdGggPSAwO1xuICAgIHRoaXMuX2hlaWdodCA9IDA7XG4gICAgdGhpcy5fdGludENvbG9yID0gbmV3IENvbG9yKDE2Nzc3MjE1KTtcbiAgICB0aGlzLl90aW50UkdCID0gbnVsbDtcbiAgICB0aGlzLnRpbnQgPSAxNjc3NzIxNTtcbiAgICB0aGlzLmJsZW5kTW9kZSA9IEJMRU5EX01PREVTLk5PUk1BTDtcbiAgICB0aGlzLl9jYWNoZWRUaW50ID0gMTY3NzcyMTU7XG4gICAgdGhpcy51dnMgPSBudWxsO1xuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmUgfHwgVGV4dHVyZS5FTVBUWTtcbiAgICB0aGlzLnZlcnRleERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDgpO1xuICAgIHRoaXMudmVydGV4VHJpbW1lZERhdGEgPSBudWxsO1xuICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gLTE7XG4gICAgdGhpcy5fdGV4dHVyZUlEID0gLTE7XG4gICAgdGhpcy5fdHJhbnNmb3JtVHJpbW1lZElEID0gLTE7XG4gICAgdGhpcy5fdGV4dHVyZVRyaW1tZWRJRCA9IC0xO1xuICAgIHRoaXMuaW5kaWNlcyA9IGluZGljZXM7XG4gICAgdGhpcy5wbHVnaW5OYW1lID0gXCJiYXRjaFwiO1xuICAgIHRoaXMuaXNTcHJpdGUgPSB0cnVlO1xuICAgIHRoaXMuX3JvdW5kUGl4ZWxzID0gc2V0dGluZ3MuUk9VTkRfUElYRUxTO1xuICB9XG4gIF9vblRleHR1cmVVcGRhdGUoKSB7XG4gICAgdGhpcy5fdGV4dHVyZUlEID0gLTE7XG4gICAgdGhpcy5fdGV4dHVyZVRyaW1tZWRJRCA9IC0xO1xuICAgIHRoaXMuX2NhY2hlZFRpbnQgPSAxNjc3NzIxNTtcbiAgICBpZiAodGhpcy5fd2lkdGgpIHtcbiAgICAgIHRoaXMuc2NhbGUueCA9IHV0aWxzLnNpZ24odGhpcy5zY2FsZS54KSAqIHRoaXMuX3dpZHRoIC8gdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoO1xuICAgIH1cbiAgICBpZiAodGhpcy5faGVpZ2h0KSB7XG4gICAgICB0aGlzLnNjYWxlLnkgPSB1dGlscy5zaWduKHRoaXMuc2NhbGUueSkgKiB0aGlzLl9oZWlnaHQgLyB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0O1xuICAgIH1cbiAgfVxuICBfb25BbmNob3JVcGRhdGUoKSB7XG4gICAgdGhpcy5fdHJhbnNmb3JtSUQgPSAtMTtcbiAgICB0aGlzLl90cmFuc2Zvcm1UcmltbWVkSUQgPSAtMTtcbiAgfVxuICBjYWxjdWxhdGVWZXJ0aWNlcygpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZTtcbiAgICBpZiAodGhpcy5fdHJhbnNmb3JtSUQgPT09IHRoaXMudHJhbnNmb3JtLl93b3JsZElEICYmIHRoaXMuX3RleHR1cmVJRCA9PT0gdGV4dHVyZS5fdXBkYXRlSUQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3RleHR1cmVJRCAhPT0gdGV4dHVyZS5fdXBkYXRlSUQpIHtcbiAgICAgIHRoaXMudXZzID0gdGhpcy5fdGV4dHVyZS5fdXZzLnV2c0Zsb2F0MzI7XG4gICAgfVxuICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQ7XG4gICAgdGhpcy5fdGV4dHVyZUlEID0gdGV4dHVyZS5fdXBkYXRlSUQ7XG4gICAgY29uc3Qgd3QgPSB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgICBjb25zdCBhID0gd3QuYTtcbiAgICBjb25zdCBiID0gd3QuYjtcbiAgICBjb25zdCBjID0gd3QuYztcbiAgICBjb25zdCBkID0gd3QuZDtcbiAgICBjb25zdCB0eCA9IHd0LnR4O1xuICAgIGNvbnN0IHR5ID0gd3QudHk7XG4gICAgY29uc3QgdmVydGV4RGF0YSA9IHRoaXMudmVydGV4RGF0YTtcbiAgICBjb25zdCB0cmltID0gdGV4dHVyZS50cmltO1xuICAgIGNvbnN0IG9yaWcgPSB0ZXh0dXJlLm9yaWc7XG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5fYW5jaG9yO1xuICAgIGxldCB3MCA9IDA7XG4gICAgbGV0IHcxID0gMDtcbiAgICBsZXQgaDAgPSAwO1xuICAgIGxldCBoMSA9IDA7XG4gICAgaWYgKHRyaW0pIHtcbiAgICAgIHcxID0gdHJpbS54IC0gYW5jaG9yLl94ICogb3JpZy53aWR0aDtcbiAgICAgIHcwID0gdzEgKyB0cmltLndpZHRoO1xuICAgICAgaDEgPSB0cmltLnkgLSBhbmNob3IuX3kgKiBvcmlnLmhlaWdodDtcbiAgICAgIGgwID0gaDEgKyB0cmltLmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdzEgPSAtYW5jaG9yLl94ICogb3JpZy53aWR0aDtcbiAgICAgIHcwID0gdzEgKyBvcmlnLndpZHRoO1xuICAgICAgaDEgPSAtYW5jaG9yLl95ICogb3JpZy5oZWlnaHQ7XG4gICAgICBoMCA9IGgxICsgb3JpZy5oZWlnaHQ7XG4gICAgfVxuICAgIHZlcnRleERhdGFbMF0gPSBhICogdzEgKyBjICogaDEgKyB0eDtcbiAgICB2ZXJ0ZXhEYXRhWzFdID0gZCAqIGgxICsgYiAqIHcxICsgdHk7XG4gICAgdmVydGV4RGF0YVsyXSA9IGEgKiB3MCArIGMgKiBoMSArIHR4O1xuICAgIHZlcnRleERhdGFbM10gPSBkICogaDEgKyBiICogdzAgKyB0eTtcbiAgICB2ZXJ0ZXhEYXRhWzRdID0gYSAqIHcwICsgYyAqIGgwICsgdHg7XG4gICAgdmVydGV4RGF0YVs1XSA9IGQgKiBoMCArIGIgKiB3MCArIHR5O1xuICAgIHZlcnRleERhdGFbNl0gPSBhICogdzEgKyBjICogaDAgKyB0eDtcbiAgICB2ZXJ0ZXhEYXRhWzddID0gZCAqIGgwICsgYiAqIHcxICsgdHk7XG4gICAgaWYgKHRoaXMuX3JvdW5kUGl4ZWxzKSB7XG4gICAgICBjb25zdCByZXNvbHV0aW9uID0gc2V0dGluZ3MuUkVTT0xVVElPTjtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGV4RGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2ZXJ0ZXhEYXRhW2ldID0gTWF0aC5yb3VuZCh2ZXJ0ZXhEYXRhW2ldICogcmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxjdWxhdGVUcmltbWVkVmVydGljZXMoKSB7XG4gICAgaWYgKCF0aGlzLnZlcnRleFRyaW1tZWREYXRhKSB7XG4gICAgICB0aGlzLnZlcnRleFRyaW1tZWREYXRhID0gbmV3IEZsb2F0MzJBcnJheSg4KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3RyYW5zZm9ybVRyaW1tZWRJRCA9PT0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQgJiYgdGhpcy5fdGV4dHVyZVRyaW1tZWRJRCA9PT0gdGhpcy5fdGV4dHVyZS5fdXBkYXRlSUQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdHJhbnNmb3JtVHJpbW1lZElEID0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQ7XG4gICAgdGhpcy5fdGV4dHVyZVRyaW1tZWRJRCA9IHRoaXMuX3RleHR1cmUuX3VwZGF0ZUlEO1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlO1xuICAgIGNvbnN0IHZlcnRleERhdGEgPSB0aGlzLnZlcnRleFRyaW1tZWREYXRhO1xuICAgIGNvbnN0IG9yaWcgPSB0ZXh0dXJlLm9yaWc7XG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5fYW5jaG9yO1xuICAgIGNvbnN0IHd0ID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gICAgY29uc3QgYSA9IHd0LmE7XG4gICAgY29uc3QgYiA9IHd0LmI7XG4gICAgY29uc3QgYyA9IHd0LmM7XG4gICAgY29uc3QgZCA9IHd0LmQ7XG4gICAgY29uc3QgdHggPSB3dC50eDtcbiAgICBjb25zdCB0eSA9IHd0LnR5O1xuICAgIGNvbnN0IHcxID0gLWFuY2hvci5feCAqIG9yaWcud2lkdGg7XG4gICAgY29uc3QgdzAgPSB3MSArIG9yaWcud2lkdGg7XG4gICAgY29uc3QgaDEgPSAtYW5jaG9yLl95ICogb3JpZy5oZWlnaHQ7XG4gICAgY29uc3QgaDAgPSBoMSArIG9yaWcuaGVpZ2h0O1xuICAgIHZlcnRleERhdGFbMF0gPSBhICogdzEgKyBjICogaDEgKyB0eDtcbiAgICB2ZXJ0ZXhEYXRhWzFdID0gZCAqIGgxICsgYiAqIHcxICsgdHk7XG4gICAgdmVydGV4RGF0YVsyXSA9IGEgKiB3MCArIGMgKiBoMSArIHR4O1xuICAgIHZlcnRleERhdGFbM10gPSBkICogaDEgKyBiICogdzAgKyB0eTtcbiAgICB2ZXJ0ZXhEYXRhWzRdID0gYSAqIHcwICsgYyAqIGgwICsgdHg7XG4gICAgdmVydGV4RGF0YVs1XSA9IGQgKiBoMCArIGIgKiB3MCArIHR5O1xuICAgIHZlcnRleERhdGFbNl0gPSBhICogdzEgKyBjICogaDAgKyB0eDtcbiAgICB2ZXJ0ZXhEYXRhWzddID0gZCAqIGgwICsgYiAqIHcxICsgdHk7XG4gIH1cbiAgX3JlbmRlcihyZW5kZXJlcikge1xuICAgIHRoaXMuY2FsY3VsYXRlVmVydGljZXMoKTtcbiAgICByZW5kZXJlci5iYXRjaC5zZXRPYmplY3RSZW5kZXJlcihyZW5kZXJlci5wbHVnaW5zW3RoaXMucGx1Z2luTmFtZV0pO1xuICAgIHJlbmRlcmVyLnBsdWdpbnNbdGhpcy5wbHVnaW5OYW1lXS5yZW5kZXIodGhpcyk7XG4gIH1cbiAgX2NhbGN1bGF0ZUJvdW5kcygpIHtcbiAgICBjb25zdCB0cmltID0gdGhpcy5fdGV4dHVyZS50cmltO1xuICAgIGNvbnN0IG9yaWcgPSB0aGlzLl90ZXh0dXJlLm9yaWc7XG4gICAgaWYgKCF0cmltIHx8IHRyaW0ud2lkdGggPT09IG9yaWcud2lkdGggJiYgdHJpbS5oZWlnaHQgPT09IG9yaWcuaGVpZ2h0KSB7XG4gICAgICB0aGlzLmNhbGN1bGF0ZVZlcnRpY2VzKCk7XG4gICAgICB0aGlzLl9ib3VuZHMuYWRkUXVhZCh0aGlzLnZlcnRleERhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNhbGN1bGF0ZVRyaW1tZWRWZXJ0aWNlcygpO1xuICAgICAgdGhpcy5fYm91bmRzLmFkZFF1YWQodGhpcy52ZXJ0ZXhUcmltbWVkRGF0YSk7XG4gICAgfVxuICB9XG4gIGdldExvY2FsQm91bmRzKHJlY3QpIHtcbiAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmICghdGhpcy5fbG9jYWxCb3VuZHMpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9sb2NhbEJvdW5kcy5taW5YID0gdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoICogLXRoaXMuX2FuY2hvci5feDtcbiAgICAgIHRoaXMuX2xvY2FsQm91bmRzLm1pblkgPSB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0ICogLXRoaXMuX2FuY2hvci5feTtcbiAgICAgIHRoaXMuX2xvY2FsQm91bmRzLm1heFggPSB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGggKiAoMSAtIHRoaXMuX2FuY2hvci5feCk7XG4gICAgICB0aGlzLl9sb2NhbEJvdW5kcy5tYXhZID0gdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodCAqICgxIC0gdGhpcy5fYW5jaG9yLl95KTtcbiAgICAgIGlmICghcmVjdCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvY2FsQm91bmRzUmVjdCkge1xuICAgICAgICAgIHRoaXMuX2xvY2FsQm91bmRzUmVjdCA9IG5ldyBSZWN0YW5nbGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZWN0ID0gdGhpcy5fbG9jYWxCb3VuZHNSZWN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsQm91bmRzLmdldFJlY3RhbmdsZShyZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdldExvY2FsQm91bmRzLmNhbGwodGhpcywgcmVjdCk7XG4gIH1cbiAgY29udGFpbnNQb2ludChwb2ludCkge1xuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKHBvaW50LCB0ZW1wUG9pbnQpO1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQ7XG4gICAgY29uc3QgeDEgPSAtd2lkdGggKiB0aGlzLmFuY2hvci54O1xuICAgIGxldCB5MSA9IDA7XG4gICAgaWYgKHRlbXBQb2ludC54ID49IHgxICYmIHRlbXBQb2ludC54IDwgeDEgKyB3aWR0aCkge1xuICAgICAgeTEgPSAtaGVpZ2h0ICogdGhpcy5hbmNob3IueTtcbiAgICAgIGlmICh0ZW1wUG9pbnQueSA+PSB5MSAmJiB0ZW1wUG9pbnQueSA8IHkxICsgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgICB0aGlzLl90ZXh0dXJlLm9mZihcInVwZGF0ZVwiLCB0aGlzLl9vblRleHR1cmVVcGRhdGUsIHRoaXMpO1xuICAgIHRoaXMuX2FuY2hvciA9IG51bGw7XG4gICAgY29uc3QgZGVzdHJveVRleHR1cmUgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJib29sZWFuXCIgPyBvcHRpb25zIDogb3B0aW9ucz8udGV4dHVyZTtcbiAgICBpZiAoZGVzdHJveVRleHR1cmUpIHtcbiAgICAgIGNvbnN0IGRlc3Ryb3lCYXNlVGV4dHVyZSA9IHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIiA/IG9wdGlvbnMgOiBvcHRpb25zPy5iYXNlVGV4dHVyZTtcbiAgICAgIHRoaXMuX3RleHR1cmUuZGVzdHJveSghIWRlc3Ryb3lCYXNlVGV4dHVyZSk7XG4gICAgfVxuICAgIHRoaXMuX3RleHR1cmUgPSBudWxsO1xuICB9XG4gIHN0YXRpYyBmcm9tKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRleHR1cmUgPSBzb3VyY2UgaW5zdGFuY2VvZiBUZXh0dXJlID8gc291cmNlIDogVGV4dHVyZS5mcm9tKHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBTcHJpdGUodGV4dHVyZSk7XG4gIH1cbiAgc2V0IHJvdW5kUGl4ZWxzKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3JvdW5kUGl4ZWxzICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtSUQgPSAtMTtcbiAgICB9XG4gICAgdGhpcy5fcm91bmRQaXhlbHMgPSB2YWx1ZTtcbiAgfVxuICBnZXQgcm91bmRQaXhlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JvdW5kUGl4ZWxzO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zY2FsZS54KSAqIHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcbiAgfVxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICBjb25zdCBzID0gdXRpbHMuc2lnbih0aGlzLnNjYWxlLngpIHx8IDE7XG4gICAgdGhpcy5zY2FsZS54ID0gcyAqIHZhbHVlIC8gdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoO1xuICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gIH1cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zY2FsZS55KSAqIHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQ7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIGNvbnN0IHMgPSB1dGlscy5zaWduKHRoaXMuc2NhbGUueSkgfHwgMTtcbiAgICB0aGlzLnNjYWxlLnkgPSBzICogdmFsdWUgLyB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0O1xuICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICB9XG4gIGdldCBhbmNob3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FuY2hvcjtcbiAgfVxuICBzZXQgYW5jaG9yKHZhbHVlKSB7XG4gICAgdGhpcy5fYW5jaG9yLmNvcHlGcm9tKHZhbHVlKTtcbiAgfVxuICBnZXQgdGludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGludENvbG9yLnZhbHVlO1xuICB9XG4gIHNldCB0aW50KHZhbHVlKSB7XG4gICAgdGhpcy5fdGludENvbG9yLnNldFZhbHVlKHZhbHVlKTtcbiAgICB0aGlzLl90aW50UkdCID0gdGhpcy5fdGludENvbG9yLnRvTGl0dGxlRW5kaWFuTnVtYmVyKCk7XG4gIH1cbiAgZ2V0IHRpbnRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGludENvbG9yLnRvTnVtYmVyKCk7XG4gIH1cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmU7XG4gIH1cbiAgc2V0IHRleHR1cmUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fdGV4dHVyZSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3RleHR1cmUpIHtcbiAgICAgIHRoaXMuX3RleHR1cmUub2ZmKFwidXBkYXRlXCIsIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSwgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMuX3RleHR1cmUgPSB2YWx1ZSB8fCBUZXh0dXJlLkVNUFRZO1xuICAgIHRoaXMuX2NhY2hlZFRpbnQgPSAxNjc3NzIxNTtcbiAgICB0aGlzLl90ZXh0dXJlSUQgPSAtMTtcbiAgICB0aGlzLl90ZXh0dXJlVHJpbW1lZElEID0gLTE7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUuYmFzZVRleHR1cmUudmFsaWQpIHtcbiAgICAgICAgdGhpcy5fb25UZXh0dXJlVXBkYXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZS5vbmNlKFwidXBkYXRlXCIsIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IFNwcml0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3ByaXRlLm1qcy5tYXBcbiIsImV4cG9ydCB7IFNwcml0ZSB9IGZyb20gJy4vU3ByaXRlLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBNYXRyaXgsIHNldHRpbmdzLCBSZW5kZXJUZXh0dXJlLCB1dGlscywgQmFzZVRleHR1cmUsIFRleHR1cmUgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IERpc3BsYXlPYmplY3QgfSBmcm9tICdAcGl4aS9kaXNwbGF5JztcbmltcG9ydCB7IFNwcml0ZSB9IGZyb20gJ0BwaXhpL3Nwcml0ZSc7XG5cbmNvbnN0IF90ZW1wTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX2NhY2hlQXNCaXRtYXAgPSBmYWxzZTtcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9jYWNoZURhdGEgPSBudWxsO1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX2NhY2hlQXNCaXRtYXBSZXNvbHV0aW9uID0gbnVsbDtcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9jYWNoZUFzQml0bWFwTXVsdGlzYW1wbGUgPSBudWxsO1xuY2xhc3MgQ2FjaGVEYXRhIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy50ZXh0dXJlQ2FjaGVJZCA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5hbFJlbmRlciA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5hbFJlbmRlckNhbnZhcyA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5hbENhbGN1bGF0ZUJvdW5kcyA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5hbEdldExvY2FsQm91bmRzID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpbmFsVXBkYXRlVHJhbnNmb3JtID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpbmFsRGVzdHJveSA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5hbE1hc2sgPSBudWxsO1xuICAgIHRoaXMub3JpZ2luYWxGaWx0ZXJBcmVhID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpbmFsQ29udGFpbnNQb2ludCA9IG51bGw7XG4gICAgdGhpcy5zcHJpdGUgPSBudWxsO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhEaXNwbGF5T2JqZWN0LnByb3RvdHlwZSwge1xuICBjYWNoZUFzQml0bWFwUmVzb2x1dGlvbjoge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZUFzQml0bWFwUmVzb2x1dGlvbjtcbiAgICB9LFxuICAgIHNldChyZXNvbHV0aW9uKSB7XG4gICAgICBpZiAocmVzb2x1dGlvbiA9PT0gdGhpcy5fY2FjaGVBc0JpdG1hcFJlc29sdXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2FjaGVBc0JpdG1hcFJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgICAgaWYgKHRoaXMuY2FjaGVBc0JpdG1hcCkge1xuICAgICAgICB0aGlzLmNhY2hlQXNCaXRtYXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYWNoZUFzQml0bWFwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNhY2hlQXNCaXRtYXBNdWx0aXNhbXBsZToge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZUFzQml0bWFwTXVsdGlzYW1wbGU7XG4gICAgfSxcbiAgICBzZXQobXVsdGlzYW1wbGUpIHtcbiAgICAgIGlmIChtdWx0aXNhbXBsZSA9PT0gdGhpcy5fY2FjaGVBc0JpdG1hcE11bHRpc2FtcGxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhY2hlQXNCaXRtYXBNdWx0aXNhbXBsZSA9IG11bHRpc2FtcGxlO1xuICAgICAgaWYgKHRoaXMuY2FjaGVBc0JpdG1hcCkge1xuICAgICAgICB0aGlzLmNhY2hlQXNCaXRtYXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYWNoZUFzQml0bWFwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNhY2hlQXNCaXRtYXA6IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGVBc0JpdG1hcDtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuX2NhY2hlQXNCaXRtYXAgPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhY2hlQXNCaXRtYXAgPSB2YWx1ZTtcbiAgICAgIGxldCBkYXRhO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGVEYXRhKSB7XG4gICAgICAgICAgdGhpcy5fY2FjaGVEYXRhID0gbmV3IENhY2hlRGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSB0aGlzLl9jYWNoZURhdGE7XG4gICAgICAgIGRhdGEub3JpZ2luYWxSZW5kZXIgPSB0aGlzLnJlbmRlcjtcbiAgICAgICAgZGF0YS5vcmlnaW5hbFJlbmRlckNhbnZhcyA9IHRoaXMucmVuZGVyQ2FudmFzO1xuICAgICAgICBkYXRhLm9yaWdpbmFsVXBkYXRlVHJhbnNmb3JtID0gdGhpcy51cGRhdGVUcmFuc2Zvcm07XG4gICAgICAgIGRhdGEub3JpZ2luYWxDYWxjdWxhdGVCb3VuZHMgPSB0aGlzLmNhbGN1bGF0ZUJvdW5kcztcbiAgICAgICAgZGF0YS5vcmlnaW5hbEdldExvY2FsQm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcztcbiAgICAgICAgZGF0YS5vcmlnaW5hbERlc3Ryb3kgPSB0aGlzLmRlc3Ryb3k7XG4gICAgICAgIGRhdGEub3JpZ2luYWxDb250YWluc1BvaW50ID0gdGhpcy5jb250YWluc1BvaW50O1xuICAgICAgICBkYXRhLm9yaWdpbmFsTWFzayA9IHRoaXMuX21hc2s7XG4gICAgICAgIGRhdGEub3JpZ2luYWxGaWx0ZXJBcmVhID0gdGhpcy5maWx0ZXJBcmVhO1xuICAgICAgICB0aGlzLnJlbmRlciA9IHRoaXMuX3JlbmRlckNhY2hlZDtcbiAgICAgICAgdGhpcy5yZW5kZXJDYW52YXMgPSB0aGlzLl9yZW5kZXJDYWNoZWRDYW52YXM7XG4gICAgICAgIHRoaXMuZGVzdHJveSA9IHRoaXMuX2NhY2hlQXNCaXRtYXBEZXN0cm95O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IHRoaXMuX2NhY2hlRGF0YTtcbiAgICAgICAgaWYgKGRhdGEuc3ByaXRlKSB7XG4gICAgICAgICAgdGhpcy5fZGVzdHJveUNhY2hlZERpc3BsYXlPYmplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlciA9IGRhdGEub3JpZ2luYWxSZW5kZXI7XG4gICAgICAgIHRoaXMucmVuZGVyQ2FudmFzID0gZGF0YS5vcmlnaW5hbFJlbmRlckNhbnZhcztcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZHMgPSBkYXRhLm9yaWdpbmFsQ2FsY3VsYXRlQm91bmRzO1xuICAgICAgICB0aGlzLmdldExvY2FsQm91bmRzID0gZGF0YS5vcmlnaW5hbEdldExvY2FsQm91bmRzO1xuICAgICAgICB0aGlzLmRlc3Ryb3kgPSBkYXRhLm9yaWdpbmFsRGVzdHJveTtcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0gPSBkYXRhLm9yaWdpbmFsVXBkYXRlVHJhbnNmb3JtO1xuICAgICAgICB0aGlzLmNvbnRhaW5zUG9pbnQgPSBkYXRhLm9yaWdpbmFsQ29udGFpbnNQb2ludDtcbiAgICAgICAgdGhpcy5fbWFzayA9IGRhdGEub3JpZ2luYWxNYXNrO1xuICAgICAgICB0aGlzLmZpbHRlckFyZWEgPSBkYXRhLm9yaWdpbmFsRmlsdGVyQXJlYTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX3JlbmRlckNhY2hlZCA9IGZ1bmN0aW9uIF9yZW5kZXJDYWNoZWQocmVuZGVyZXIpIHtcbiAgaWYgKCF0aGlzLnZpc2libGUgfHwgdGhpcy53b3JsZEFscGhhIDw9IDAgfHwgIXRoaXMucmVuZGVyYWJsZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9pbml0Q2FjaGVkRGlzcGxheU9iamVjdChyZW5kZXJlcik7XG4gIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUudHJhbnNmb3JtLl93b3JsZElEID0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQ7XG4gIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUud29ybGRBbHBoYSA9IHRoaXMud29ybGRBbHBoYTtcbiAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS5fcmVuZGVyKHJlbmRlcmVyKTtcbn07XG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5faW5pdENhY2hlZERpc3BsYXlPYmplY3QgPSBmdW5jdGlvbiBfaW5pdENhY2hlZERpc3BsYXlPYmplY3QocmVuZGVyZXIpIHtcbiAgaWYgKHRoaXMuX2NhY2hlRGF0YT8uc3ByaXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNhY2hlQWxwaGEgPSB0aGlzLmFscGhhO1xuICB0aGlzLmFscGhhID0gMTtcbiAgcmVuZGVyZXIuYmF0Y2guZmx1c2goKTtcbiAgY29uc3QgYm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcyhudWxsLCB0cnVlKS5jbG9uZSgpO1xuICBpZiAodGhpcy5maWx0ZXJzPy5sZW5ndGgpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5maWx0ZXJzWzBdLnBhZGRpbmc7XG4gICAgYm91bmRzLnBhZChwYWRkaW5nKTtcbiAgfVxuICBib3VuZHMuY2VpbChzZXR0aW5ncy5SRVNPTFVUSU9OKTtcbiAgY29uc3QgY2FjaGVkUmVuZGVyVGV4dHVyZSA9IHJlbmRlcmVyLnJlbmRlclRleHR1cmUuY3VycmVudDtcbiAgY29uc3QgY2FjaGVkU291cmNlRnJhbWUgPSByZW5kZXJlci5yZW5kZXJUZXh0dXJlLnNvdXJjZUZyYW1lLmNsb25lKCk7XG4gIGNvbnN0IGNhY2hlZERlc3RpbmF0aW9uRnJhbWUgPSByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmRlc3RpbmF0aW9uRnJhbWUuY2xvbmUoKTtcbiAgY29uc3QgY2FjaGVkUHJvamVjdGlvblRyYW5zZm9ybSA9IHJlbmRlcmVyLnByb2plY3Rpb24udHJhbnNmb3JtO1xuICBjb25zdCByZW5kZXJUZXh0dXJlID0gUmVuZGVyVGV4dHVyZS5jcmVhdGUoe1xuICAgIHdpZHRoOiBib3VuZHMud2lkdGgsXG4gICAgaGVpZ2h0OiBib3VuZHMuaGVpZ2h0LFxuICAgIHJlc29sdXRpb246IHRoaXMuY2FjaGVBc0JpdG1hcFJlc29sdXRpb24gfHwgcmVuZGVyZXIucmVzb2x1dGlvbixcbiAgICBtdWx0aXNhbXBsZTogdGhpcy5jYWNoZUFzQml0bWFwTXVsdGlzYW1wbGUgPz8gcmVuZGVyZXIubXVsdGlzYW1wbGVcbiAgfSk7XG4gIGNvbnN0IHRleHR1cmVDYWNoZUlkID0gYGNhY2hlQXNCaXRtYXBfJHt1dGlscy51aWQoKX1gO1xuICB0aGlzLl9jYWNoZURhdGEudGV4dHVyZUNhY2hlSWQgPSB0ZXh0dXJlQ2FjaGVJZDtcbiAgQmFzZVRleHR1cmUuYWRkVG9DYWNoZShyZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlLCB0ZXh0dXJlQ2FjaGVJZCk7XG4gIFRleHR1cmUuYWRkVG9DYWNoZShyZW5kZXJUZXh0dXJlLCB0ZXh0dXJlQ2FjaGVJZCk7XG4gIGNvbnN0IG0gPSB0aGlzLnRyYW5zZm9ybS5sb2NhbFRyYW5zZm9ybS5jb3B5VG8oX3RlbXBNYXRyaXgpLmludmVydCgpLnRyYW5zbGF0ZSgtYm91bmRzLngsIC1ib3VuZHMueSk7XG4gIHRoaXMucmVuZGVyID0gdGhpcy5fY2FjaGVEYXRhLm9yaWdpbmFsUmVuZGVyO1xuICByZW5kZXJlci5yZW5kZXIodGhpcywgeyByZW5kZXJUZXh0dXJlLCBjbGVhcjogdHJ1ZSwgdHJhbnNmb3JtOiBtLCBza2lwVXBkYXRlVHJhbnNmb3JtOiBmYWxzZSB9KTtcbiAgcmVuZGVyZXIuZnJhbWVidWZmZXIuYmxpdCgpO1xuICByZW5kZXJlci5wcm9qZWN0aW9uLnRyYW5zZm9ybSA9IGNhY2hlZFByb2plY3Rpb25UcmFuc2Zvcm07XG4gIHJlbmRlcmVyLnJlbmRlclRleHR1cmUuYmluZChjYWNoZWRSZW5kZXJUZXh0dXJlLCBjYWNoZWRTb3VyY2VGcmFtZSwgY2FjaGVkRGVzdGluYXRpb25GcmFtZSk7XG4gIHRoaXMucmVuZGVyID0gdGhpcy5fcmVuZGVyQ2FjaGVkO1xuICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSA9IHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybTtcbiAgdGhpcy5jYWxjdWxhdGVCb3VuZHMgPSB0aGlzLl9jYWxjdWxhdGVDYWNoZWRCb3VuZHM7XG4gIHRoaXMuZ2V0TG9jYWxCb3VuZHMgPSB0aGlzLl9nZXRDYWNoZWRMb2NhbEJvdW5kcztcbiAgdGhpcy5fbWFzayA9IG51bGw7XG4gIHRoaXMuZmlsdGVyQXJlYSA9IG51bGw7XG4gIHRoaXMuYWxwaGEgPSBjYWNoZUFscGhhO1xuICBjb25zdCBjYWNoZWRTcHJpdGUgPSBuZXcgU3ByaXRlKHJlbmRlclRleHR1cmUpO1xuICBjYWNoZWRTcHJpdGUudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gIGNhY2hlZFNwcml0ZS5hbmNob3IueCA9IC0oYm91bmRzLnggLyBib3VuZHMud2lkdGgpO1xuICBjYWNoZWRTcHJpdGUuYW5jaG9yLnkgPSAtKGJvdW5kcy55IC8gYm91bmRzLmhlaWdodCk7XG4gIGNhY2hlZFNwcml0ZS5hbHBoYSA9IGNhY2hlQWxwaGE7XG4gIGNhY2hlZFNwcml0ZS5fYm91bmRzID0gdGhpcy5fYm91bmRzO1xuICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlID0gY2FjaGVkU3ByaXRlO1xuICB0aGlzLnRyYW5zZm9ybS5fcGFyZW50SUQgPSAtMTtcbiAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgIHRoaXMuZW5hYmxlVGVtcFBhcmVudCgpO1xuICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgdGhpcy5kaXNhYmxlVGVtcFBhcmVudChudWxsKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICB9XG4gIHRoaXMuY29udGFpbnNQb2ludCA9IGNhY2hlZFNwcml0ZS5jb250YWluc1BvaW50LmJpbmQoY2FjaGVkU3ByaXRlKTtcbn07XG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fcmVuZGVyQ2FjaGVkQ2FudmFzID0gZnVuY3Rpb24gX3JlbmRlckNhY2hlZENhbnZhcyhyZW5kZXJlcikge1xuICBpZiAoIXRoaXMudmlzaWJsZSB8fCB0aGlzLndvcmxkQWxwaGEgPD0gMCB8fCAhdGhpcy5yZW5kZXJhYmxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0Q2FudmFzKHJlbmRlcmVyKTtcbiAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS53b3JsZEFscGhhID0gdGhpcy53b3JsZEFscGhhO1xuICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlLl9yZW5kZXJDYW52YXMocmVuZGVyZXIpO1xufTtcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9pbml0Q2FjaGVkRGlzcGxheU9iamVjdENhbnZhcyA9IGZ1bmN0aW9uIF9pbml0Q2FjaGVkRGlzcGxheU9iamVjdENhbnZhcyhyZW5kZXJlcikge1xuICBpZiAodGhpcy5fY2FjaGVEYXRhPy5zcHJpdGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcyhudWxsLCB0cnVlKTtcbiAgY29uc3QgY2FjaGVBbHBoYSA9IHRoaXMuYWxwaGE7XG4gIHRoaXMuYWxwaGEgPSAxO1xuICBjb25zdCBjYWNoZWRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5jYW52YXNDb250ZXh0LmFjdGl2ZUNvbnRleHQ7XG4gIGNvbnN0IGNhY2hlZFByb2plY3Rpb25UcmFuc2Zvcm0gPSByZW5kZXJlci5fcHJvalRyYW5zZm9ybTtcbiAgYm91bmRzLmNlaWwoc2V0dGluZ3MuUkVTT0xVVElPTik7XG4gIGNvbnN0IHJlbmRlclRleHR1cmUgPSBSZW5kZXJUZXh0dXJlLmNyZWF0ZSh7IHdpZHRoOiBib3VuZHMud2lkdGgsIGhlaWdodDogYm91bmRzLmhlaWdodCB9KTtcbiAgY29uc3QgdGV4dHVyZUNhY2hlSWQgPSBgY2FjaGVBc0JpdG1hcF8ke3V0aWxzLnVpZCgpfWA7XG4gIHRoaXMuX2NhY2hlRGF0YS50ZXh0dXJlQ2FjaGVJZCA9IHRleHR1cmVDYWNoZUlkO1xuICBCYXNlVGV4dHVyZS5hZGRUb0NhY2hlKHJlbmRlclRleHR1cmUuYmFzZVRleHR1cmUsIHRleHR1cmVDYWNoZUlkKTtcbiAgVGV4dHVyZS5hZGRUb0NhY2hlKHJlbmRlclRleHR1cmUsIHRleHR1cmVDYWNoZUlkKTtcbiAgY29uc3QgbSA9IF90ZW1wTWF0cml4O1xuICB0aGlzLnRyYW5zZm9ybS5sb2NhbFRyYW5zZm9ybS5jb3B5VG8obSk7XG4gIG0uaW52ZXJ0KCk7XG4gIG0udHggLT0gYm91bmRzLng7XG4gIG0udHkgLT0gYm91bmRzLnk7XG4gIHRoaXMucmVuZGVyQ2FudmFzID0gdGhpcy5fY2FjaGVEYXRhLm9yaWdpbmFsUmVuZGVyQ2FudmFzO1xuICByZW5kZXJlci5yZW5kZXIodGhpcywgeyByZW5kZXJUZXh0dXJlLCBjbGVhcjogdHJ1ZSwgdHJhbnNmb3JtOiBtLCBza2lwVXBkYXRlVHJhbnNmb3JtOiBmYWxzZSB9KTtcbiAgcmVuZGVyZXIuY2FudmFzQ29udGV4dC5hY3RpdmVDb250ZXh0ID0gY2FjaGVkUmVuZGVyVGFyZ2V0O1xuICByZW5kZXJlci5fcHJvalRyYW5zZm9ybSA9IGNhY2hlZFByb2plY3Rpb25UcmFuc2Zvcm07XG4gIHRoaXMucmVuZGVyQ2FudmFzID0gdGhpcy5fcmVuZGVyQ2FjaGVkQ2FudmFzO1xuICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSA9IHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybTtcbiAgdGhpcy5jYWxjdWxhdGVCb3VuZHMgPSB0aGlzLl9jYWxjdWxhdGVDYWNoZWRCb3VuZHM7XG4gIHRoaXMuZ2V0TG9jYWxCb3VuZHMgPSB0aGlzLl9nZXRDYWNoZWRMb2NhbEJvdW5kcztcbiAgdGhpcy5fbWFzayA9IG51bGw7XG4gIHRoaXMuZmlsdGVyQXJlYSA9IG51bGw7XG4gIHRoaXMuYWxwaGEgPSBjYWNoZUFscGhhO1xuICBjb25zdCBjYWNoZWRTcHJpdGUgPSBuZXcgU3ByaXRlKHJlbmRlclRleHR1cmUpO1xuICBjYWNoZWRTcHJpdGUudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gIGNhY2hlZFNwcml0ZS5hbmNob3IueCA9IC0oYm91bmRzLnggLyBib3VuZHMud2lkdGgpO1xuICBjYWNoZWRTcHJpdGUuYW5jaG9yLnkgPSAtKGJvdW5kcy55IC8gYm91bmRzLmhlaWdodCk7XG4gIGNhY2hlZFNwcml0ZS5hbHBoYSA9IGNhY2hlQWxwaGE7XG4gIGNhY2hlZFNwcml0ZS5fYm91bmRzID0gdGhpcy5fYm91bmRzO1xuICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlID0gY2FjaGVkU3ByaXRlO1xuICB0aGlzLnRyYW5zZm9ybS5fcGFyZW50SUQgPSAtMTtcbiAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgIHRoaXMucGFyZW50ID0gcmVuZGVyZXIuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xuICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gIH1cbiAgdGhpcy5jb250YWluc1BvaW50ID0gY2FjaGVkU3ByaXRlLmNvbnRhaW5zUG9pbnQuYmluZChjYWNoZWRTcHJpdGUpO1xufTtcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9jYWxjdWxhdGVDYWNoZWRCb3VuZHMgPSBmdW5jdGlvbiBfY2FsY3VsYXRlQ2FjaGVkQm91bmRzKCkge1xuICB0aGlzLl9ib3VuZHMuY2xlYXIoKTtcbiAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS50cmFuc2Zvcm0uX3dvcmxkSUQgPSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRDtcbiAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS5fY2FsY3VsYXRlQm91bmRzKCk7XG4gIHRoaXMuX2JvdW5kcy51cGRhdGVJRCA9IHRoaXMuX2JvdW5kc0lEO1xufTtcbkRpc3BsYXlPYmplY3QucHJvdG90eXBlLl9nZXRDYWNoZWRMb2NhbEJvdW5kcyA9IGZ1bmN0aW9uIF9nZXRDYWNoZWRMb2NhbEJvdW5kcygpIHtcbiAgcmV0dXJuIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUuZ2V0TG9jYWxCb3VuZHMobnVsbCk7XG59O1xuRGlzcGxheU9iamVjdC5wcm90b3R5cGUuX2Rlc3Ryb3lDYWNoZWREaXNwbGF5T2JqZWN0ID0gZnVuY3Rpb24gX2Rlc3Ryb3lDYWNoZWREaXNwbGF5T2JqZWN0KCkge1xuICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlLl90ZXh0dXJlLmRlc3Ryb3kodHJ1ZSk7XG4gIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUgPSBudWxsO1xuICBCYXNlVGV4dHVyZS5yZW1vdmVGcm9tQ2FjaGUodGhpcy5fY2FjaGVEYXRhLnRleHR1cmVDYWNoZUlkKTtcbiAgVGV4dHVyZS5yZW1vdmVGcm9tQ2FjaGUodGhpcy5fY2FjaGVEYXRhLnRleHR1cmVDYWNoZUlkKTtcbiAgdGhpcy5fY2FjaGVEYXRhLnRleHR1cmVDYWNoZUlkID0gbnVsbDtcbn07XG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5fY2FjaGVBc0JpdG1hcERlc3Ryb3kgPSBmdW5jdGlvbiBfY2FjaGVBc0JpdG1hcERlc3Ryb3kob3B0aW9ucykge1xuICB0aGlzLmNhY2hlQXNCaXRtYXAgPSBmYWxzZTtcbiAgdGhpcy5kZXN0cm95KG9wdGlvbnMpO1xufTtcblxuZXhwb3J0IHsgQ2FjaGVEYXRhIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBEaXNwbGF5T2JqZWN0LCBDb250YWluZXIgfSBmcm9tICdAcGl4aS9kaXNwbGF5JztcblxuRGlzcGxheU9iamVjdC5wcm90b3R5cGUubmFtZSA9IG51bGw7XG5Db250YWluZXIucHJvdG90eXBlLmdldENoaWxkQnlOYW1lID0gZnVuY3Rpb24gZ2V0Q2hpbGRCeU5hbWUobmFtZSwgZGVlcCkge1xuICBmb3IgKGxldCBpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgaWYgKHRoaXMuY2hpbGRyZW5baV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baV07XG4gICAgfVxuICB9XG4gIGlmIChkZWVwKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKCFjaGlsZC5nZXRDaGlsZEJ5TmFtZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhcmdldCA9IGNoaWxkLmdldENoaWxkQnlOYW1lKG5hbWUsIHRydWUpO1xuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBQb2ludCB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgRGlzcGxheU9iamVjdCB9IGZyb20gJ0BwaXhpL2Rpc3BsYXknO1xuXG5EaXNwbGF5T2JqZWN0LnByb3RvdHlwZS5nZXRHbG9iYWxQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldEdsb2JhbFBvc2l0aW9uKHBvaW50ID0gbmV3IFBvaW50KCksIHNraXBVcGRhdGUgPSBmYWxzZSkge1xuICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICB0aGlzLnBhcmVudC50b0dsb2JhbCh0aGlzLnBvc2l0aW9uLCBwb2ludCwgc2tpcFVwZGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgcG9pbnQueCA9IHRoaXMucG9zaXRpb24ueDtcbiAgICBwb2ludC55ID0gdGhpcy5wb3NpdGlvbi55O1xuICB9XG4gIHJldHVybiBwb2ludDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJ2YXIgZnJhZ21lbnQgPSBcInZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gZmxvYXQgdUFscGhhO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogdUFscGhhO1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgZnJhZ21lbnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxwaGEubWpzLm1hcFxuIiwiaW1wb3J0IHsgRmlsdGVyLCBkZWZhdWx0VmVydGV4IH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSAnLi9hbHBoYS5tanMnO1xuXG5jbGFzcyBBbHBoYUZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yKGFscGhhID0gMSkge1xuICAgIHN1cGVyKGRlZmF1bHRWZXJ0ZXgsIGZyYWdtZW50LCB7IHVBbHBoYTogMSB9KTtcbiAgICB0aGlzLmFscGhhID0gYWxwaGE7XG4gIH1cbiAgZ2V0IGFscGhhKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVBbHBoYTtcbiAgfVxuICBzZXQgYWxwaGEodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVBbHBoYSA9IHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCB7IEFscGhhRmlsdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BbHBoYUZpbHRlci5tanMubWFwXG4iLCJleHBvcnQgeyBBbHBoYUZpbHRlciB9IGZyb20gJy4vQWxwaGFGaWx0ZXIubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImNvbnN0IEdBVVNTSUFOX1ZBTFVFUyA9IHtcbiAgNTogWzAuMTUzMzg4LCAwLjIyMTQ2MSwgMC4yNTAzMDFdLFxuICA3OiBbMC4wNzEzMDMsIDAuMTMxNTE0LCAwLjE4OTg3OSwgMC4yMTQ2MDddLFxuICA5OiBbMC4wMjg1MzIsIDAuMDY3MjM0LCAwLjEyNDAwOSwgMC4xNzkwNDQsIDAuMjAyMzZdLFxuICAxMTogWzkzZS00LCAwLjAyODAwMiwgMC4wNjU5ODQsIDAuMTIxNzAzLCAwLjE3NTcxMywgMC4xOTg1OTZdLFxuICAxMzogWzI0MDZlLTYsIDkyNTVlLTYsIDAuMDI3ODY3LCAwLjA2NTY2NiwgMC4xMjExMTcsIDAuMTc0ODY4LCAwLjE5NzY0MV0sXG4gIDE1OiBbNDg5ZS02LCAyNDAzZS02LCA5MjQ2ZS02LCAwLjAyNzg0LCAwLjA2NTYwMiwgMC4xMjA5OTksIDAuMTc0Njk3LCAwLjE5NzQ0OF1cbn07XG5jb25zdCBmcmFnVGVtcGxhdGUgPSBbXG4gIFwidmFyeWluZyB2ZWMyIHZCbHVyVGV4Q29vcmRzWyVzaXplJV07XCIsXG4gIFwidW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XCIsXG4gIFwidm9pZCBtYWluKHZvaWQpXCIsXG4gIFwie1wiLFxuICBcIiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCk7XCIsXG4gIFwiICAgICVibHVyJVwiLFxuICBcIn1cIlxuXS5qb2luKFwiXFxuXCIpO1xuZnVuY3Rpb24gZ2VuZXJhdGVCbHVyRnJhZ1NvdXJjZShrZXJuZWxTaXplKSB7XG4gIGNvbnN0IGtlcm5lbCA9IEdBVVNTSUFOX1ZBTFVFU1trZXJuZWxTaXplXTtcbiAgY29uc3QgaGFsZkxlbmd0aCA9IGtlcm5lbC5sZW5ndGg7XG4gIGxldCBmcmFnU291cmNlID0gZnJhZ1RlbXBsYXRlO1xuICBsZXQgYmx1ckxvb3AgPSBcIlwiO1xuICBjb25zdCB0ZW1wbGF0ZSA9IFwiZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdkJsdXJUZXhDb29yZHNbJWluZGV4JV0pICogJXZhbHVlJTtcIjtcbiAgbGV0IHZhbHVlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5lbFNpemU7IGkrKykge1xuICAgIGxldCBibHVyID0gdGVtcGxhdGUucmVwbGFjZShcIiVpbmRleCVcIiwgaS50b1N0cmluZygpKTtcbiAgICB2YWx1ZSA9IGk7XG4gICAgaWYgKGkgPj0gaGFsZkxlbmd0aCkge1xuICAgICAgdmFsdWUgPSBrZXJuZWxTaXplIC0gaSAtIDE7XG4gICAgfVxuICAgIGJsdXIgPSBibHVyLnJlcGxhY2UoXCIldmFsdWUlXCIsIGtlcm5lbFt2YWx1ZV0udG9TdHJpbmcoKSk7XG4gICAgYmx1ckxvb3AgKz0gYmx1cjtcbiAgICBibHVyTG9vcCArPSBcIlxcblwiO1xuICB9XG4gIGZyYWdTb3VyY2UgPSBmcmFnU291cmNlLnJlcGxhY2UoXCIlYmx1ciVcIiwgYmx1ckxvb3ApO1xuICBmcmFnU291cmNlID0gZnJhZ1NvdXJjZS5yZXBsYWNlKFwiJXNpemUlXCIsIGtlcm5lbFNpemUudG9TdHJpbmcoKSk7XG4gIHJldHVybiBmcmFnU291cmNlO1xufVxuXG5leHBvcnQgeyBnZW5lcmF0ZUJsdXJGcmFnU291cmNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0ZUJsdXJGcmFnU291cmNlLm1qcy5tYXBcbiIsImNvbnN0IHZlcnRUZW1wbGF0ZSA9IGBcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XG5cbiAgICB1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcblxuICAgIHVuaWZvcm0gZmxvYXQgc3RyZW5ndGg7XG5cbiAgICB2YXJ5aW5nIHZlYzIgdkJsdXJUZXhDb29yZHNbJXNpemUlXTtcblxuICAgIHVuaWZvcm0gdmVjNCBpbnB1dFNpemU7XG4gICAgdW5pZm9ybSB2ZWM0IG91dHB1dEZyYW1lO1xuXG4gICAgdmVjNCBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbiggdm9pZCApXG4gICAge1xuICAgICAgICB2ZWMyIHBvc2l0aW9uID0gYVZlcnRleFBvc2l0aW9uICogbWF4KG91dHB1dEZyYW1lLnp3LCB2ZWMyKDAuKSkgKyBvdXRwdXRGcmFtZS54eTtcblxuICAgICAgICByZXR1cm4gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMocG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XG4gICAgfVxuXG4gICAgdmVjMiBmaWx0ZXJUZXh0dXJlQ29vcmQoIHZvaWQgKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGFWZXJ0ZXhQb3NpdGlvbiAqIChvdXRwdXRGcmFtZS56dyAqIGlucHV0U2l6ZS56dyk7XG4gICAgfVxuXG4gICAgdm9pZCBtYWluKHZvaWQpXG4gICAge1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IGZpbHRlclZlcnRleFBvc2l0aW9uKCk7XG5cbiAgICAgICAgdmVjMiB0ZXh0dXJlQ29vcmQgPSBmaWx0ZXJUZXh0dXJlQ29vcmQoKTtcbiAgICAgICAgJWJsdXIlXG4gICAgfWA7XG5mdW5jdGlvbiBnZW5lcmF0ZUJsdXJWZXJ0U291cmNlKGtlcm5lbFNpemUsIHgpIHtcbiAgY29uc3QgaGFsZkxlbmd0aCA9IE1hdGguY2VpbChrZXJuZWxTaXplIC8gMik7XG4gIGxldCB2ZXJ0U291cmNlID0gdmVydFRlbXBsYXRlO1xuICBsZXQgYmx1ckxvb3AgPSBcIlwiO1xuICBsZXQgdGVtcGxhdGU7XG4gIGlmICh4KSB7XG4gICAgdGVtcGxhdGUgPSBcInZCbHVyVGV4Q29vcmRzWyVpbmRleCVdID0gIHRleHR1cmVDb29yZCArIHZlYzIoJXNhbXBsZUluZGV4JSAqIHN0cmVuZ3RoLCAwLjApO1wiO1xuICB9IGVsc2Uge1xuICAgIHRlbXBsYXRlID0gXCJ2Qmx1clRleENvb3Jkc1slaW5kZXglXSA9ICB0ZXh0dXJlQ29vcmQgKyB2ZWMyKDAuMCwgJXNhbXBsZUluZGV4JSAqIHN0cmVuZ3RoKTtcIjtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5lbFNpemU7IGkrKykge1xuICAgIGxldCBibHVyID0gdGVtcGxhdGUucmVwbGFjZShcIiVpbmRleCVcIiwgaS50b1N0cmluZygpKTtcbiAgICBibHVyID0gYmx1ci5yZXBsYWNlKFwiJXNhbXBsZUluZGV4JVwiLCBgJHtpIC0gKGhhbGZMZW5ndGggLSAxKX0uMGApO1xuICAgIGJsdXJMb29wICs9IGJsdXI7XG4gICAgYmx1ckxvb3AgKz0gXCJcXG5cIjtcbiAgfVxuICB2ZXJ0U291cmNlID0gdmVydFNvdXJjZS5yZXBsYWNlKFwiJWJsdXIlXCIsIGJsdXJMb29wKTtcbiAgdmVydFNvdXJjZSA9IHZlcnRTb3VyY2UucmVwbGFjZShcIiVzaXplJVwiLCBrZXJuZWxTaXplLnRvU3RyaW5nKCkpO1xuICByZXR1cm4gdmVydFNvdXJjZTtcbn1cblxuZXhwb3J0IHsgZ2VuZXJhdGVCbHVyVmVydFNvdXJjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2VuZXJhdGVCbHVyVmVydFNvdXJjZS5tanMubWFwXG4iLCJpbXBvcnQgeyBGaWx0ZXIsIENMRUFSX01PREVTIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBnZW5lcmF0ZUJsdXJGcmFnU291cmNlIH0gZnJvbSAnLi9nZW5lcmF0ZUJsdXJGcmFnU291cmNlLm1qcyc7XG5pbXBvcnQgeyBnZW5lcmF0ZUJsdXJWZXJ0U291cmNlIH0gZnJvbSAnLi9nZW5lcmF0ZUJsdXJWZXJ0U291cmNlLm1qcyc7XG5cbmNsYXNzIEJsdXJGaWx0ZXJQYXNzIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IoaG9yaXpvbnRhbCwgc3RyZW5ndGggPSA4LCBxdWFsaXR5ID0gNCwgcmVzb2x1dGlvbiA9IEZpbHRlci5kZWZhdWx0UmVzb2x1dGlvbiwga2VybmVsU2l6ZSA9IDUpIHtcbiAgICBjb25zdCB2ZXJ0U3JjID0gZ2VuZXJhdGVCbHVyVmVydFNvdXJjZShrZXJuZWxTaXplLCBob3Jpem9udGFsKTtcbiAgICBjb25zdCBmcmFnU3JjID0gZ2VuZXJhdGVCbHVyRnJhZ1NvdXJjZShrZXJuZWxTaXplKTtcbiAgICBzdXBlcih2ZXJ0U3JjLCBmcmFnU3JjKTtcbiAgICB0aGlzLmhvcml6b250YWwgPSBob3Jpem9udGFsO1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgdGhpcy5fcXVhbGl0eSA9IDA7XG4gICAgdGhpcy5xdWFsaXR5ID0gcXVhbGl0eTtcbiAgICB0aGlzLmJsdXIgPSBzdHJlbmd0aDtcbiAgfVxuICBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpIHtcbiAgICBpZiAob3V0cHV0KSB7XG4gICAgICBpZiAodGhpcy5ob3Jpem9udGFsKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuc3RyZW5ndGggPSAxIC8gb3V0cHV0LndpZHRoICogKG91dHB1dC53aWR0aCAvIGlucHV0LndpZHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuc3RyZW5ndGggPSAxIC8gb3V0cHV0LmhlaWdodCAqIChvdXRwdXQuaGVpZ2h0IC8gaW5wdXQuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuaG9yaXpvbnRhbCkge1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoID0gMSAvIGZpbHRlck1hbmFnZXIucmVuZGVyZXIud2lkdGggKiAoZmlsdGVyTWFuYWdlci5yZW5kZXJlci53aWR0aCAvIGlucHV0LndpZHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuc3RyZW5ndGggPSAxIC8gZmlsdGVyTWFuYWdlci5yZW5kZXJlci5oZWlnaHQgKiAoZmlsdGVyTWFuYWdlci5yZW5kZXJlci5oZWlnaHQgLyBpbnB1dC5oZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoICo9IHRoaXMuc3RyZW5ndGg7XG4gICAgdGhpcy51bmlmb3Jtcy5zdHJlbmd0aCAvPSB0aGlzLnBhc3NlcztcbiAgICBpZiAodGhpcy5wYXNzZXMgPT09IDEpIHtcbiAgICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gZmlsdGVyTWFuYWdlci5nZXRGaWx0ZXJUZXh0dXJlKCk7XG4gICAgICBjb25zdCByZW5kZXJlciA9IGZpbHRlck1hbmFnZXIucmVuZGVyZXI7XG4gICAgICBsZXQgZmxpcCA9IGlucHV0O1xuICAgICAgbGV0IGZsb3AgPSByZW5kZXJUYXJnZXQ7XG4gICAgICB0aGlzLnN0YXRlLmJsZW5kID0gZmFsc2U7XG4gICAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGZsaXAsIGZsb3AsIENMRUFSX01PREVTLkNMRUFSKTtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5wYXNzZXMgLSAxOyBpKyspIHtcbiAgICAgICAgZmlsdGVyTWFuYWdlci5iaW5kQW5kQ2xlYXIoZmxpcCwgQ0xFQVJfTU9ERVMuQkxJVCk7XG4gICAgICAgIHRoaXMudW5pZm9ybXMudVNhbXBsZXIgPSBmbG9wO1xuICAgICAgICBjb25zdCB0ZW1wID0gZmxvcDtcbiAgICAgICAgZmxvcCA9IGZsaXA7XG4gICAgICAgIGZsaXAgPSB0ZW1wO1xuICAgICAgICByZW5kZXJlci5zaGFkZXIuYmluZCh0aGlzKTtcbiAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuZHJhdyg1KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUuYmxlbmQgPSB0cnVlO1xuICAgICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBmbG9wLCBvdXRwdXQsIGNsZWFyTW9kZSk7XG4gICAgICBmaWx0ZXJNYW5hZ2VyLnJldHVybkZpbHRlclRleHR1cmUocmVuZGVyVGFyZ2V0KTtcbiAgICB9XG4gIH1cbiAgZ2V0IGJsdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZW5ndGg7XG4gIH1cbiAgc2V0IGJsdXIodmFsdWUpIHtcbiAgICB0aGlzLnBhZGRpbmcgPSAxICsgTWF0aC5hYnModmFsdWUpICogMjtcbiAgICB0aGlzLnN0cmVuZ3RoID0gdmFsdWU7XG4gIH1cbiAgZ2V0IHF1YWxpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1YWxpdHk7XG4gIH1cbiAgc2V0IHF1YWxpdHkodmFsdWUpIHtcbiAgICB0aGlzLl9xdWFsaXR5ID0gdmFsdWU7XG4gICAgdGhpcy5wYXNzZXMgPSB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgeyBCbHVyRmlsdGVyUGFzcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qmx1ckZpbHRlclBhc3MubWpzLm1hcFxuIiwiaW1wb3J0IHsgRmlsdGVyLCBDTEVBUl9NT0RFUyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgQmx1ckZpbHRlclBhc3MgfSBmcm9tICcuL0JsdXJGaWx0ZXJQYXNzLm1qcyc7XG5cbmNsYXNzIEJsdXJGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlbmd0aCA9IDgsIHF1YWxpdHkgPSA0LCByZXNvbHV0aW9uID0gRmlsdGVyLmRlZmF1bHRSZXNvbHV0aW9uLCBrZXJuZWxTaXplID0gNSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fcmVwZWF0RWRnZVBpeGVscyA9IGZhbHNlO1xuICAgIHRoaXMuYmx1clhGaWx0ZXIgPSBuZXcgQmx1ckZpbHRlclBhc3ModHJ1ZSwgc3RyZW5ndGgsIHF1YWxpdHksIHJlc29sdXRpb24sIGtlcm5lbFNpemUpO1xuICAgIHRoaXMuYmx1cllGaWx0ZXIgPSBuZXcgQmx1ckZpbHRlclBhc3MoZmFsc2UsIHN0cmVuZ3RoLCBxdWFsaXR5LCByZXNvbHV0aW9uLCBrZXJuZWxTaXplKTtcbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgIHRoaXMucXVhbGl0eSA9IHF1YWxpdHk7XG4gICAgdGhpcy5ibHVyID0gc3RyZW5ndGg7XG4gICAgdGhpcy5yZXBlYXRFZGdlUGl4ZWxzID0gZmFsc2U7XG4gIH1cbiAgYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKSB7XG4gICAgY29uc3QgeFN0cmVuZ3RoID0gTWF0aC5hYnModGhpcy5ibHVyWEZpbHRlci5zdHJlbmd0aCk7XG4gICAgY29uc3QgeVN0cmVuZ3RoID0gTWF0aC5hYnModGhpcy5ibHVyWUZpbHRlci5zdHJlbmd0aCk7XG4gICAgaWYgKHhTdHJlbmd0aCAmJiB5U3RyZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IGZpbHRlck1hbmFnZXIuZ2V0RmlsdGVyVGV4dHVyZSgpO1xuICAgICAgdGhpcy5ibHVyWEZpbHRlci5hcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgcmVuZGVyVGFyZ2V0LCBDTEVBUl9NT0RFUy5DTEVBUik7XG4gICAgICB0aGlzLmJsdXJZRmlsdGVyLmFwcGx5KGZpbHRlck1hbmFnZXIsIHJlbmRlclRhcmdldCwgb3V0cHV0LCBjbGVhck1vZGUpO1xuICAgICAgZmlsdGVyTWFuYWdlci5yZXR1cm5GaWx0ZXJUZXh0dXJlKHJlbmRlclRhcmdldCk7XG4gICAgfSBlbHNlIGlmICh5U3RyZW5ndGgpIHtcbiAgICAgIHRoaXMuYmx1cllGaWx0ZXIuYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ibHVyWEZpbHRlci5hcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVQYWRkaW5nKCkge1xuICAgIGlmICh0aGlzLl9yZXBlYXRFZGdlUGl4ZWxzKSB7XG4gICAgICB0aGlzLnBhZGRpbmcgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhZGRpbmcgPSBNYXRoLm1heChNYXRoLmFicyh0aGlzLmJsdXJYRmlsdGVyLnN0cmVuZ3RoKSwgTWF0aC5hYnModGhpcy5ibHVyWUZpbHRlci5zdHJlbmd0aCkpICogMjtcbiAgICB9XG4gIH1cbiAgZ2V0IGJsdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1clhGaWx0ZXIuYmx1cjtcbiAgfVxuICBzZXQgYmx1cih2YWx1ZSkge1xuICAgIHRoaXMuYmx1clhGaWx0ZXIuYmx1ciA9IHRoaXMuYmx1cllGaWx0ZXIuYmx1ciA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlUGFkZGluZygpO1xuICB9XG4gIGdldCBxdWFsaXR5KCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJYRmlsdGVyLnF1YWxpdHk7XG4gIH1cbiAgc2V0IHF1YWxpdHkodmFsdWUpIHtcbiAgICB0aGlzLmJsdXJYRmlsdGVyLnF1YWxpdHkgPSB0aGlzLmJsdXJZRmlsdGVyLnF1YWxpdHkgPSB2YWx1ZTtcbiAgfVxuICBnZXQgYmx1clgoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1clhGaWx0ZXIuYmx1cjtcbiAgfVxuICBzZXQgYmx1clgodmFsdWUpIHtcbiAgICB0aGlzLmJsdXJYRmlsdGVyLmJsdXIgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZVBhZGRpbmcoKTtcbiAgfVxuICBnZXQgYmx1clkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmx1cllGaWx0ZXIuYmx1cjtcbiAgfVxuICBzZXQgYmx1clkodmFsdWUpIHtcbiAgICB0aGlzLmJsdXJZRmlsdGVyLmJsdXIgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZVBhZGRpbmcoKTtcbiAgfVxuICBnZXQgYmxlbmRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmJsdXJZRmlsdGVyLmJsZW5kTW9kZTtcbiAgfVxuICBzZXQgYmxlbmRNb2RlKHZhbHVlKSB7XG4gICAgdGhpcy5ibHVyWUZpbHRlci5ibGVuZE1vZGUgPSB2YWx1ZTtcbiAgfVxuICBnZXQgcmVwZWF0RWRnZVBpeGVscygpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVwZWF0RWRnZVBpeGVscztcbiAgfVxuICBzZXQgcmVwZWF0RWRnZVBpeGVscyh2YWx1ZSkge1xuICAgIHRoaXMuX3JlcGVhdEVkZ2VQaXhlbHMgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZVBhZGRpbmcoKTtcbiAgfVxufVxuXG5leHBvcnQgeyBCbHVyRmlsdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CbHVyRmlsdGVyLm1qcy5tYXBcbiIsImV4cG9ydCB7IEJsdXJGaWx0ZXIgfSBmcm9tICcuL0JsdXJGaWx0ZXIubWpzJztcbmV4cG9ydCB7IEJsdXJGaWx0ZXJQYXNzIH0gZnJvbSAnLi9CbHVyRmlsdGVyUGFzcy5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXG51bmlmb3JtIGZsb2F0IG1bMjBdO1xcbnVuaWZvcm0gZmxvYXQgdUFscGhhO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgdmVjNCBjID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXG5cXG4gICAgaWYgKHVBbHBoYSA9PSAwLjApIHtcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGM7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgLy8gVW4tcHJlbXVsdGlwbHkgYWxwaGEgYmVmb3JlIGFwcGx5aW5nIHRoZSBjb2xvciBtYXRyaXguIFNlZSBpc3N1ZSAjMzUzOS5cXG4gICAgaWYgKGMuYSA+IDAuMCkge1xcbiAgICAgIGMucmdiIC89IGMuYTtcXG4gICAgfVxcblxcbiAgICB2ZWM0IHJlc3VsdDtcXG5cXG4gICAgcmVzdWx0LnIgPSAobVswXSAqIGMucik7XFxuICAgICAgICByZXN1bHQuciArPSAobVsxXSAqIGMuZyk7XFxuICAgICAgICByZXN1bHQuciArPSAobVsyXSAqIGMuYik7XFxuICAgICAgICByZXN1bHQuciArPSAobVszXSAqIGMuYSk7XFxuICAgICAgICByZXN1bHQuciArPSBtWzRdO1xcblxcbiAgICByZXN1bHQuZyA9IChtWzVdICogYy5yKTtcXG4gICAgICAgIHJlc3VsdC5nICs9IChtWzZdICogYy5nKTtcXG4gICAgICAgIHJlc3VsdC5nICs9IChtWzddICogYy5iKTtcXG4gICAgICAgIHJlc3VsdC5nICs9IChtWzhdICogYy5hKTtcXG4gICAgICAgIHJlc3VsdC5nICs9IG1bOV07XFxuXFxuICAgIHJlc3VsdC5iID0gKG1bMTBdICogYy5yKTtcXG4gICAgICAgcmVzdWx0LmIgKz0gKG1bMTFdICogYy5nKTtcXG4gICAgICAgcmVzdWx0LmIgKz0gKG1bMTJdICogYy5iKTtcXG4gICAgICAgcmVzdWx0LmIgKz0gKG1bMTNdICogYy5hKTtcXG4gICAgICAgcmVzdWx0LmIgKz0gbVsxNF07XFxuXFxuICAgIHJlc3VsdC5hID0gKG1bMTVdICogYy5yKTtcXG4gICAgICAgcmVzdWx0LmEgKz0gKG1bMTZdICogYy5nKTtcXG4gICAgICAgcmVzdWx0LmEgKz0gKG1bMTddICogYy5iKTtcXG4gICAgICAgcmVzdWx0LmEgKz0gKG1bMThdICogYy5hKTtcXG4gICAgICAgcmVzdWx0LmEgKz0gbVsxOV07XFxuXFxuICAgIHZlYzMgcmdiID0gbWl4KGMucmdiLCByZXN1bHQucmdiLCB1QWxwaGEpO1xcblxcbiAgICAvLyBQcmVtdWx0aXBseSBhbHBoYSBhZ2Fpbi5cXG4gICAgcmdiICo9IHJlc3VsdC5hO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHJnYiwgcmVzdWx0LmEpO1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgZnJhZ21lbnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sb3JNYXRyaXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgRmlsdGVyLCBkZWZhdWx0RmlsdGVyVmVydGV4LCBDb2xvciB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gJy4vY29sb3JNYXRyaXgubWpzJztcblxuY2xhc3MgQ29sb3JNYXRyaXhGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAgICAgIG06IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAxLFxuICAgICAgICAwXG4gICAgICBdKSxcbiAgICAgIHVBbHBoYTogMVxuICAgIH07XG4gICAgc3VwZXIoZGVmYXVsdEZpbHRlclZlcnRleCwgZnJhZ21lbnQsIHVuaWZvcm1zKTtcbiAgICB0aGlzLmFscGhhID0gMTtcbiAgfVxuICBfbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5ID0gZmFsc2UpIHtcbiAgICBsZXQgbmV3TWF0cml4ID0gbWF0cml4O1xuICAgIGlmIChtdWx0aXBseSkge1xuICAgICAgdGhpcy5fbXVsdGlwbHkobmV3TWF0cml4LCB0aGlzLnVuaWZvcm1zLm0sIG1hdHJpeCk7XG4gICAgICBuZXdNYXRyaXggPSB0aGlzLl9jb2xvck1hdHJpeChuZXdNYXRyaXgpO1xuICAgIH1cbiAgICB0aGlzLnVuaWZvcm1zLm0gPSBuZXdNYXRyaXg7XG4gIH1cbiAgX211bHRpcGx5KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbNV0gKyBhWzJdICogYlsxMF0gKyBhWzNdICogYlsxNV07XG4gICAgb3V0WzFdID0gYVswXSAqIGJbMV0gKyBhWzFdICogYls2XSArIGFbMl0gKiBiWzExXSArIGFbM10gKiBiWzE2XTtcbiAgICBvdXRbMl0gPSBhWzBdICogYlsyXSArIGFbMV0gKiBiWzddICsgYVsyXSAqIGJbMTJdICsgYVszXSAqIGJbMTddO1xuICAgIG91dFszXSA9IGFbMF0gKiBiWzNdICsgYVsxXSAqIGJbOF0gKyBhWzJdICogYlsxM10gKyBhWzNdICogYlsxOF07XG4gICAgb3V0WzRdID0gYVswXSAqIGJbNF0gKyBhWzFdICogYls5XSArIGFbMl0gKiBiWzE0XSArIGFbM10gKiBiWzE5XSArIGFbNF07XG4gICAgb3V0WzVdID0gYVs1XSAqIGJbMF0gKyBhWzZdICogYls1XSArIGFbN10gKiBiWzEwXSArIGFbOF0gKiBiWzE1XTtcbiAgICBvdXRbNl0gPSBhWzVdICogYlsxXSArIGFbNl0gKiBiWzZdICsgYVs3XSAqIGJbMTFdICsgYVs4XSAqIGJbMTZdO1xuICAgIG91dFs3XSA9IGFbNV0gKiBiWzJdICsgYVs2XSAqIGJbN10gKyBhWzddICogYlsxMl0gKyBhWzhdICogYlsxN107XG4gICAgb3V0WzhdID0gYVs1XSAqIGJbM10gKyBhWzZdICogYls4XSArIGFbN10gKiBiWzEzXSArIGFbOF0gKiBiWzE4XTtcbiAgICBvdXRbOV0gPSBhWzVdICogYls0XSArIGFbNl0gKiBiWzldICsgYVs3XSAqIGJbMTRdICsgYVs4XSAqIGJbMTldICsgYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF0gKiBiWzBdICsgYVsxMV0gKiBiWzVdICsgYVsxMl0gKiBiWzEwXSArIGFbMTNdICogYlsxNV07XG4gICAgb3V0WzExXSA9IGFbMTBdICogYlsxXSArIGFbMTFdICogYls2XSArIGFbMTJdICogYlsxMV0gKyBhWzEzXSAqIGJbMTZdO1xuICAgIG91dFsxMl0gPSBhWzEwXSAqIGJbMl0gKyBhWzExXSAqIGJbN10gKyBhWzEyXSAqIGJbMTJdICsgYVsxM10gKiBiWzE3XTtcbiAgICBvdXRbMTNdID0gYVsxMF0gKiBiWzNdICsgYVsxMV0gKiBiWzhdICsgYVsxMl0gKiBiWzEzXSArIGFbMTNdICogYlsxOF07XG4gICAgb3V0WzE0XSA9IGFbMTBdICogYls0XSArIGFbMTFdICogYls5XSArIGFbMTJdICogYlsxNF0gKyBhWzEzXSAqIGJbMTldICsgYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdICogYlswXSArIGFbMTZdICogYls1XSArIGFbMTddICogYlsxMF0gKyBhWzE4XSAqIGJbMTVdO1xuICAgIG91dFsxNl0gPSBhWzE1XSAqIGJbMV0gKyBhWzE2XSAqIGJbNl0gKyBhWzE3XSAqIGJbMTFdICsgYVsxOF0gKiBiWzE2XTtcbiAgICBvdXRbMTddID0gYVsxNV0gKiBiWzJdICsgYVsxNl0gKiBiWzddICsgYVsxN10gKiBiWzEyXSArIGFbMThdICogYlsxN107XG4gICAgb3V0WzE4XSA9IGFbMTVdICogYlszXSArIGFbMTZdICogYls4XSArIGFbMTddICogYlsxM10gKyBhWzE4XSAqIGJbMThdO1xuICAgIG91dFsxOV0gPSBhWzE1XSAqIGJbNF0gKyBhWzE2XSAqIGJbOV0gKyBhWzE3XSAqIGJbMTRdICsgYVsxOF0gKiBiWzE5XSArIGFbMTldO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgX2NvbG9yTWF0cml4KG1hdHJpeCkge1xuICAgIGNvbnN0IG0gPSBuZXcgRmxvYXQzMkFycmF5KG1hdHJpeCk7XG4gICAgbVs0XSAvPSAyNTU7XG4gICAgbVs5XSAvPSAyNTU7XG4gICAgbVsxNF0gLz0gMjU1O1xuICAgIG1bMTldIC89IDI1NTtcbiAgICByZXR1cm4gbTtcbiAgfVxuICBicmlnaHRuZXNzKGIsIG11bHRpcGx5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgYixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgYixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgYixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgdGludChjb2xvciwgbXVsdGlwbHkpIHtcbiAgICBjb25zdCBbciwgZywgYl0gPSBDb2xvci5zaGFyZWQuc2V0VmFsdWUoY29sb3IpLnRvQXJyYXkoKTtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICByLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBnLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBiLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICBncmV5c2NhbGUoc2NhbGUsIG11bHRpcGx5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgc2NhbGUsXG4gICAgICBzY2FsZSxcbiAgICAgIHNjYWxlLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBzY2FsZSxcbiAgICAgIHNjYWxlLFxuICAgICAgc2NhbGUsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIHNjYWxlLFxuICAgICAgc2NhbGUsXG4gICAgICBzY2FsZSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgYmxhY2tBbmRXaGl0ZShtdWx0aXBseSkge1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIDAuMyxcbiAgICAgIDAuNixcbiAgICAgIDAuMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMC4zLFxuICAgICAgMC42LFxuICAgICAgMC4xLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLjMsXG4gICAgICAwLjYsXG4gICAgICAwLjEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIGh1ZShyb3RhdGlvbiwgbXVsdGlwbHkpIHtcbiAgICByb3RhdGlvbiA9IChyb3RhdGlvbiB8fCAwKSAvIDE4MCAqIE1hdGguUEk7XG4gICAgY29uc3QgY29zUiA9IE1hdGguY29zKHJvdGF0aW9uKTtcbiAgICBjb25zdCBzaW5SID0gTWF0aC5zaW4ocm90YXRpb24pO1xuICAgIGNvbnN0IHNxcnQgPSBNYXRoLnNxcnQ7XG4gICAgY29uc3QgdyA9IDEgLyAzO1xuICAgIGNvbnN0IHNxclcgPSBzcXJ0KHcpO1xuICAgIGNvbnN0IGEwMCA9IGNvc1IgKyAoMSAtIGNvc1IpICogdztcbiAgICBjb25zdCBhMDEgPSB3ICogKDEgLSBjb3NSKSAtIHNxclcgKiBzaW5SO1xuICAgIGNvbnN0IGEwMiA9IHcgKiAoMSAtIGNvc1IpICsgc3FyVyAqIHNpblI7XG4gICAgY29uc3QgYTEwID0gdyAqICgxIC0gY29zUikgKyBzcXJXICogc2luUjtcbiAgICBjb25zdCBhMTEgPSBjb3NSICsgdyAqICgxIC0gY29zUik7XG4gICAgY29uc3QgYTEyID0gdyAqICgxIC0gY29zUikgLSBzcXJXICogc2luUjtcbiAgICBjb25zdCBhMjAgPSB3ICogKDEgLSBjb3NSKSAtIHNxclcgKiBzaW5SO1xuICAgIGNvbnN0IGEyMSA9IHcgKiAoMSAtIGNvc1IpICsgc3FyVyAqIHNpblI7XG4gICAgY29uc3QgYTIyID0gY29zUiArIHcgKiAoMSAtIGNvc1IpO1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIGEwMCxcbiAgICAgIGEwMSxcbiAgICAgIGEwMixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgYTEwLFxuICAgICAgYTExLFxuICAgICAgYTEyLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBhMjAsXG4gICAgICBhMjEsXG4gICAgICBhMjIsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIGNvbnRyYXN0KGFtb3VudCwgbXVsdGlwbHkpIHtcbiAgICBjb25zdCB2ID0gKGFtb3VudCB8fCAwKSArIDE7XG4gICAgY29uc3QgbyA9IC0wLjUgKiAodiAtIDEpO1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIHYsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBvLFxuICAgICAgMCxcbiAgICAgIHYsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIG8sXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIHYsXG4gICAgICAwLFxuICAgICAgbyxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIHNhdHVyYXRlKGFtb3VudCA9IDAsIG11bHRpcGx5KSB7XG4gICAgY29uc3QgeCA9IGFtb3VudCAqIDIgLyAzICsgMTtcbiAgICBjb25zdCB5ID0gKHggLSAxKSAqIC0wLjU7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB5LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICB5LFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIHksXG4gICAgICB5LFxuICAgICAgeCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgZGVzYXR1cmF0ZSgpIHtcbiAgICB0aGlzLnNhdHVyYXRlKC0xKTtcbiAgfVxuICBuZWdhdGl2ZShtdWx0aXBseSkge1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIC0xLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAtMSxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLTEsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIHNlcGlhKG11bHRpcGx5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgMC4zOTMsXG4gICAgICAwLjc2ODk5OTksXG4gICAgICAwLjE4ODk5OTk5LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLjM0OSxcbiAgICAgIDAuNjg1OTk5OSxcbiAgICAgIDAuMTY3OTk5OTksXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAuMjcyLFxuICAgICAgMC41MzM5OTk5LFxuICAgICAgMC4xMzA5OTk5OSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgdGVjaG5pY29sb3IobXVsdGlwbHkpIHtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICAxLjkxMjUyNzc4OTE0NTYwODMsXG4gICAgICAtMC44NTQ1MzQ0OTc2OTUxNjQ1LFxuICAgICAgLTAuMDkxNTU1MDg0ODI3NTU1ODUsXG4gICAgICAwLFxuICAgICAgMTEuNzkzNjAzNDM0Mzc3MzM3LFxuICAgICAgLTAuMzA4NzgzMzM4NTkyODA5NyxcbiAgICAgIDEuNzY1ODkwODU1NTQ1ODQyOCxcbiAgICAgIC0wLjEwNjAxNzQzMDc0NzIyMjQ1LFxuICAgICAgMCxcbiAgICAgIC03MC4zNTIwNTE2MTQ2MTM5OCxcbiAgICAgIC0wLjIzMTEwMzM3NzU0ODYxNixcbiAgICAgIC0wLjc1MDE4OTkxOTc0NDAyMTIsXG4gICAgICAxLjg0NzU5NzgxNjEwODE4OSxcbiAgICAgIDAsXG4gICAgICAzMC45NTA5NDA4Njk0OTExMzgsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICBwb2xhcm9pZChtdWx0aXBseSkge1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIDEuNDM4LFxuICAgICAgLTAuMDYyLFxuICAgICAgLTAuMDYyLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAtMC4xMjIsXG4gICAgICAxLjM3OCxcbiAgICAgIC0wLjEyMixcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLTAuMDE2LFxuICAgICAgLTAuMDE2LFxuICAgICAgMS40ODMsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIHRvQkdSKG11bHRpcGx5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAga29kYWNocm9tZShtdWx0aXBseSkge1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIDEuMTI4NTU4MjM5NjU5MzUyNSxcbiAgICAgIC0wLjM5NjczODIyODM2MDEzNDgsXG4gICAgICAtMC4wMzk5MjU1OTE3MjkyMTc5MyxcbiAgICAgIDAsXG4gICAgICA2My43Mjk1ODc2MjE5NjUwMixcbiAgICAgIC0wLjE2NDA0MzM5OTYyMjQ0NjE2LFxuICAgICAgMS4wODM1MjUxNTY2MjkxMzA0LFxuICAgICAgLTAuMDU0OTg4MDUxMTU2MzMxMzIsXG4gICAgICAwLFxuICAgICAgMjQuNzMyNDA3ODk2NzA2MjAzLFxuICAgICAgLTAuMTY3ODYwMTA3MDYxNTU3NjMsXG4gICAgICAtMC41NjAzNDE2Mjc3Njk1MjQ4LFxuICAgICAgMS42MDE0ODUwNzYxOTY0OTQzLFxuICAgICAgMCxcbiAgICAgIDM1LjYyOTgyODA3NDYwOTQ2LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgYnJvd25pKG11bHRpcGx5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgMC41OTk3MDIzNDk4MTU5NzE1LFxuICAgICAgMC4zNDU1MzI0MzA0ODM5MTI2MyxcbiAgICAgIC0wLjI3MDgyOTg2NzQ1MzgwNDIsXG4gICAgICAwLFxuICAgICAgNDcuNDMxOTI4NTU2MDA4NzMsXG4gICAgICAtMC4wMzc3MDMyNDk4Mzc3ODMxNTcsXG4gICAgICAwLjg2MDk1Nzc1ODc5OTI2NDEsXG4gICAgICAwLjE1MDU5NTUyMzg4NDU5OTEzLFxuICAgICAgMCxcbiAgICAgIC0zNi45Njg0MTQ5ODMxOTEyNyxcbiAgICAgIDAuMjQxMTM2MzUxMjgxNTMzMzUsXG4gICAgICAtMC4wNzQ0MTAzNzkwODQyMjQ5MixcbiAgICAgIDAuNDQ5NzIxODIwNjQ4NzcxNTMsXG4gICAgICAwLFxuICAgICAgLTcuNTYyMDc1Mjc3NTkxMjgzLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgdmludGFnZShtdWx0aXBseSkge1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIDAuNjI3OTM0NTYzNTYwNTk5NCxcbiAgICAgIDAuMzIwMjE4MzQyMDgxOTM2NyxcbiAgICAgIC0wLjAzOTY1NDA4MjExMzEyNDUzLFxuICAgICAgMCxcbiAgICAgIDkuNjUxMjg1ODM1Mjk0MTIzLFxuICAgICAgMC4wMjU3ODM5NzcwNDgwODg2OCxcbiAgICAgIDAuNjQ0MTE4ODY0NDM3NDc3MSxcbiAgICAgIDAuMDMyNTkxMjc2MTYxNDkyOTQsXG4gICAgICAwLFxuICAgICAgNy40NjI4MjkxNzY0NzA1OTEsXG4gICAgICAwLjA0NjYwNTU1NTY3ODI3MTksXG4gICAgICAtMC4wODUxMjMyOTg3MjQ3ODkxLFxuICAgICAgMC41MjQxNjQ4MDE4NzAwNDY1LFxuICAgICAgMCxcbiAgICAgIDUuMTU5MTkwNTg4MjM1Mjk2LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDBcbiAgICBdO1xuICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gIH1cbiAgY29sb3JUb25lKGRlc2F0dXJhdGlvbiwgdG9uZWQsIGxpZ2h0Q29sb3IsIGRhcmtDb2xvciwgbXVsdGlwbHkpIHtcbiAgICBkZXNhdHVyYXRpb24gPSBkZXNhdHVyYXRpb24gfHwgMC4yO1xuICAgIHRvbmVkID0gdG9uZWQgfHwgMC4xNTtcbiAgICBsaWdodENvbG9yID0gbGlnaHRDb2xvciB8fCAxNjc3MDQzMjtcbiAgICBkYXJrQ29sb3IgPSBkYXJrQ29sb3IgfHwgMzM3NTEwNDtcbiAgICBjb25zdCB0ZW1wID0gQ29sb3Iuc2hhcmVkO1xuICAgIGNvbnN0IFtsUiwgbEcsIGxCXSA9IHRlbXAuc2V0VmFsdWUobGlnaHRDb2xvcikudG9BcnJheSgpO1xuICAgIGNvbnN0IFtkUiwgZEcsIGRCXSA9IHRlbXAuc2V0VmFsdWUoZGFya0NvbG9yKS50b0FycmF5KCk7XG4gICAgY29uc3QgbWF0cml4ID0gW1xuICAgICAgMC4zLFxuICAgICAgMC41OSxcbiAgICAgIDAuMTEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIGxSLFxuICAgICAgbEcsXG4gICAgICBsQixcbiAgICAgIGRlc2F0dXJhdGlvbixcbiAgICAgIDAsXG4gICAgICBkUixcbiAgICAgIGRHLFxuICAgICAgZEIsXG4gICAgICB0b25lZCxcbiAgICAgIDAsXG4gICAgICBsUiAtIGRSLFxuICAgICAgbEcgLSBkRyxcbiAgICAgIGxCIC0gZEIsXG4gICAgICAwLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICBuaWdodChpbnRlbnNpdHksIG11bHRpcGx5KSB7XG4gICAgaW50ZW5zaXR5ID0gaW50ZW5zaXR5IHx8IDAuMTtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICBpbnRlbnNpdHkgKiAtMixcbiAgICAgIC1pbnRlbnNpdHksXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAtaW50ZW5zaXR5LFxuICAgICAgMCxcbiAgICAgIGludGVuc2l0eSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIGludGVuc2l0eSxcbiAgICAgIGludGVuc2l0eSAqIDIsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIHByZWRhdG9yKGFtb3VudCwgbXVsdGlwbHkpIHtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICAxMS4yMjQxMzA2MzA0OTMxNjQgKiBhbW91bnQsXG4gICAgICAtNC43OTQ0ODY5OTk1MTE3MTkgKiBhbW91bnQsXG4gICAgICAtMi44NzQ2MTE4NTQ1NTMyMjI3ICogYW1vdW50LFxuICAgICAgMCAqIGFtb3VudCxcbiAgICAgIDAuNDAzNDI0MzgyMjA5Nzc3ODMgKiBhbW91bnQsXG4gICAgICAtMy42MzMwNjk3NTM2NDY4NTA2ICogYW1vdW50LFxuICAgICAgOS4xOTMxNTcxOTYwNDQ5MjIgKiBhbW91bnQsXG4gICAgICAtMi45NTE4MTA4MzY3OTE5OTIgKiBhbW91bnQsXG4gICAgICAwICogYW1vdW50LFxuICAgICAgLTEuMzE2MTM1MDQ4ODY2MjcyICogYW1vdW50LFxuICAgICAgLTMuMjE4NDE5NzkwMjY3OTQ0MyAqIGFtb3VudCxcbiAgICAgIC00LjIzNzUwMzA1MTc1NzgxMjUgKiBhbW91bnQsXG4gICAgICA3LjQ3NjQ0ODA1OTA4MjAzMSAqIGFtb3VudCxcbiAgICAgIDAgKiBhbW91bnQsXG4gICAgICAwLjgwNDQ0NTkyMjM3NDcyNTMgKiBhbW91bnQsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMFxuICAgIF07XG4gICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgfVxuICBsc2QobXVsdGlwbHkpIHtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICAyLFxuICAgICAgLTAuNCxcbiAgICAgIDAuNSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLTAuNSxcbiAgICAgIDIsXG4gICAgICAtMC40LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAtMC40LFxuICAgICAgLTAuNSxcbiAgICAgIDMsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIGNvbnN0IG1hdHJpeCA9IFtcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwXG4gICAgXTtcbiAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgZmFsc2UpO1xuICB9XG4gIGdldCBtYXRyaXgoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubTtcbiAgfVxuICBzZXQgbWF0cml4KHZhbHVlKSB7XG4gICAgdGhpcy51bmlmb3Jtcy5tID0gdmFsdWU7XG4gIH1cbiAgZ2V0IGFscGhhKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVBbHBoYTtcbiAgfVxuICBzZXQgYWxwaGEodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVBbHBoYSA9IHZhbHVlO1xuICB9XG59XG5Db2xvck1hdHJpeEZpbHRlci5wcm90b3R5cGUuZ3JheXNjYWxlID0gQ29sb3JNYXRyaXhGaWx0ZXIucHJvdG90eXBlLmdyZXlzY2FsZTtcblxuZXhwb3J0IHsgQ29sb3JNYXRyaXhGaWx0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbG9yTWF0cml4RmlsdGVyLm1qcy5tYXBcbiIsImV4cG9ydCB7IENvbG9yTWF0cml4RmlsdGVyIH0gZnJvbSAnLi9Db2xvck1hdHJpeEZpbHRlci5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzIgdkZpbHRlckNvb3JkO1xcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gdmVjMiBzY2FsZTtcXG51bmlmb3JtIG1hdDIgcm90YXRpb247XFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxudW5pZm9ybSBzYW1wbGVyMkQgbWFwU2FtcGxlcjtcXG5cXG51bmlmb3JtIGhpZ2hwIHZlYzQgaW5wdXRTaXplO1xcbnVuaWZvcm0gdmVjNCBpbnB1dENsYW1wO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gIHZlYzQgbWFwID0gIHRleHR1cmUyRChtYXBTYW1wbGVyLCB2RmlsdGVyQ29vcmQpO1xcblxcbiAgbWFwIC09IDAuNTtcXG4gIG1hcC54eSA9IHNjYWxlICogaW5wdXRTaXplLnp3ICogKHJvdGF0aW9uICogbWFwLnh5KTtcXG5cXG4gIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgY2xhbXAodmVjMih2VGV4dHVyZUNvb3JkLnggKyBtYXAueCwgdlRleHR1cmVDb29yZC55ICsgbWFwLnkpLCBpbnB1dENsYW1wLnh5LCBpbnB1dENsYW1wLnp3KSk7XFxufVxcblwiO1xuXG5leHBvcnQgeyBmcmFnbWVudCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXNwbGFjZW1lbnQubWpzLm1hcFxuIiwidmFyIHZlcnRleCA9IFwiYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcblxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0MyBmaWx0ZXJNYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWMyIHZGaWx0ZXJDb29yZDtcXG5cXG51bmlmb3JtIHZlYzQgaW5wdXRTaXplO1xcbnVuaWZvcm0gdmVjNCBvdXRwdXRGcmFtZTtcXG5cXG52ZWM0IGZpbHRlclZlcnRleFBvc2l0aW9uKCB2b2lkIClcXG57XFxuICAgIHZlYzIgcG9zaXRpb24gPSBhVmVydGV4UG9zaXRpb24gKiBtYXgob3V0cHV0RnJhbWUuencsIHZlYzIoMC4pKSArIG91dHB1dEZyYW1lLnh5O1xcblxcbiAgICByZXR1cm4gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMocG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxufVxcblxcbnZlYzIgZmlsdGVyVGV4dHVyZUNvb3JkKCB2b2lkIClcXG57XFxuICAgIHJldHVybiBhVmVydGV4UG9zaXRpb24gKiAob3V0cHV0RnJhbWUuencgKiBpbnB1dFNpemUuencpO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuXFx0Z2xfUG9zaXRpb24gPSBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbigpO1xcblxcdHZUZXh0dXJlQ29vcmQgPSBmaWx0ZXJUZXh0dXJlQ29vcmQoKTtcXG5cXHR2RmlsdGVyQ29vcmQgPSAoIGZpbHRlck1hdHJpeCAqIHZlYzMoIHZUZXh0dXJlQ29vcmQsIDEuMCkgICkueHk7XFxufVxcblwiO1xuXG5leHBvcnQgeyB2ZXJ0ZXggYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzcGxhY2VtZW50Mi5tanMubWFwXG4iLCJpbXBvcnQgeyBGaWx0ZXIsIE1hdHJpeCwgUG9pbnQgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCBmcmFnbWVudCBmcm9tICcuL2Rpc3BsYWNlbWVudC5tanMnO1xuaW1wb3J0IHZlcnRleCBmcm9tICcuL2Rpc3BsYWNlbWVudDIubWpzJztcblxuY2xhc3MgRGlzcGxhY2VtZW50RmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3Ioc3ByaXRlLCBzY2FsZSkge1xuICAgIGNvbnN0IG1hc2tNYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgc3ByaXRlLnJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICBzdXBlcih2ZXJ0ZXgsIGZyYWdtZW50LCB7XG4gICAgICBtYXBTYW1wbGVyOiBzcHJpdGUuX3RleHR1cmUsXG4gICAgICBmaWx0ZXJNYXRyaXg6IG1hc2tNYXRyaXgsXG4gICAgICBzY2FsZTogeyB4OiAxLCB5OiAxIH0sXG4gICAgICByb3RhdGlvbjogbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMV0pXG4gICAgfSk7XG4gICAgdGhpcy5tYXNrU3ByaXRlID0gc3ByaXRlO1xuICAgIHRoaXMubWFza01hdHJpeCA9IG1hc2tNYXRyaXg7XG4gICAgaWYgKHNjYWxlID09PSBudWxsIHx8IHNjYWxlID09PSB2b2lkIDApIHtcbiAgICAgIHNjYWxlID0gMjA7XG4gICAgfVxuICAgIHRoaXMuc2NhbGUgPSBuZXcgUG9pbnQoc2NhbGUsIHNjYWxlKTtcbiAgfVxuICBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhck1vZGUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLmZpbHRlck1hdHJpeCA9IGZpbHRlck1hbmFnZXIuY2FsY3VsYXRlU3ByaXRlTWF0cml4KHRoaXMubWFza01hdHJpeCwgdGhpcy5tYXNrU3ByaXRlKTtcbiAgICB0aGlzLnVuaWZvcm1zLnNjYWxlLnggPSB0aGlzLnNjYWxlLng7XG4gICAgdGhpcy51bmlmb3Jtcy5zY2FsZS55ID0gdGhpcy5zY2FsZS55O1xuICAgIGNvbnN0IHd0ID0gdGhpcy5tYXNrU3ByaXRlLndvcmxkVHJhbnNmb3JtO1xuICAgIGNvbnN0IGxlblggPSBNYXRoLnNxcnQod3QuYSAqIHd0LmEgKyB3dC5iICogd3QuYik7XG4gICAgY29uc3QgbGVuWSA9IE1hdGguc3FydCh3dC5jICogd3QuYyArIHd0LmQgKiB3dC5kKTtcbiAgICBpZiAobGVuWCAhPT0gMCAmJiBsZW5ZICE9PSAwKSB7XG4gICAgICB0aGlzLnVuaWZvcm1zLnJvdGF0aW9uWzBdID0gd3QuYSAvIGxlblg7XG4gICAgICB0aGlzLnVuaWZvcm1zLnJvdGF0aW9uWzFdID0gd3QuYiAvIGxlblg7XG4gICAgICB0aGlzLnVuaWZvcm1zLnJvdGF0aW9uWzJdID0gd3QuYyAvIGxlblk7XG4gICAgICB0aGlzLnVuaWZvcm1zLnJvdGF0aW9uWzNdID0gd3QuZCAvIGxlblk7XG4gICAgfVxuICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgaW5wdXQsIG91dHB1dCwgY2xlYXJNb2RlKTtcbiAgfVxuICBnZXQgbWFwKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm1hcFNhbXBsZXI7XG4gIH1cbiAgc2V0IG1hcCh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMubWFwU2FtcGxlciA9IHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCB7IERpc3BsYWNlbWVudEZpbHRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGlzcGxhY2VtZW50RmlsdGVyLm1qcy5tYXBcbiIsImV4cG9ydCB7IERpc3BsYWNlbWVudEZpbHRlciB9IGZyb20gJy4vRGlzcGxhY2VtZW50RmlsdGVyLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJ2YXIgZnJhZ21lbnQgPSBcInZhcnlpbmcgdmVjMiB2X3JnYk5XO1xcbnZhcnlpbmcgdmVjMiB2X3JnYk5FO1xcbnZhcnlpbmcgdmVjMiB2X3JnYlNXO1xcbnZhcnlpbmcgdmVjMiB2X3JnYlNFO1xcbnZhcnlpbmcgdmVjMiB2X3JnYk07XFxuXFxudmFyeWluZyB2ZWMyIHZGcmFnQ29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxudW5pZm9ybSBoaWdocCB2ZWM0IGlucHV0U2l6ZTtcXG5cXG5cXG4vKipcXG4gQmFzaWMgRlhBQSBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiB0aGUgY29kZSBvbiBnZWVrczNkLmNvbSB3aXRoIHRoZVxcbiBtb2RpZmljYXRpb24gdGhhdCB0aGUgdGV4dHVyZTJETG9kIHN0dWZmIHdhcyByZW1vdmVkIHNpbmNlIGl0J3NcXG4gdW5zdXBwb3J0ZWQgYnkgV2ViR0wuXFxuXFxuIC0tXFxuXFxuIEZyb206XFxuIGh0dHBzOi8vZ2l0aHViLmNvbS9taXRzdWhpa28vd2ViZ2wtbWVpbmNyYWZ0XFxuXFxuIENvcHlyaWdodCAoYykgMjAxMSBieSBBcm1pbiBSb25hY2hlci5cXG5cXG4gU29tZSByaWdodHMgcmVzZXJ2ZWQuXFxuXFxuIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxcbiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXFxuIG1ldDpcXG5cXG4gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxcbiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXFxuXFxuICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxcbiBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xcbiBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcXG4gd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxcblxcbiAqIFRoZSBuYW1lcyBvZiB0aGUgY29udHJpYnV0b3JzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yXFxuIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xcbiBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXFxuXFxuIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcXG4gXFxcIkFTIElTXFxcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcXG4gTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXFxuIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXFxuIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxcbiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXFxuIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxcbiBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcXG4gVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxcbiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcXG4gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cXG4gKi9cXG5cXG4jaWZuZGVmIEZYQUFfUkVEVUNFX01JTlxcbiNkZWZpbmUgRlhBQV9SRURVQ0VfTUlOICAgKDEuMC8gMTI4LjApXFxuI2VuZGlmXFxuI2lmbmRlZiBGWEFBX1JFRFVDRV9NVUxcXG4jZGVmaW5lIEZYQUFfUkVEVUNFX01VTCAgICgxLjAgLyA4LjApXFxuI2VuZGlmXFxuI2lmbmRlZiBGWEFBX1NQQU5fTUFYXFxuI2RlZmluZSBGWEFBX1NQQU5fTUFYICAgICA4LjBcXG4jZW5kaWZcXG5cXG4vL29wdGltaXplZCB2ZXJzaW9uIGZvciBtb2JpbGUsIHdoZXJlIGRlcGVuZGVudFxcbi8vdGV4dHVyZSByZWFkcyBjYW4gYmUgYSBib3R0bGVuZWNrXFxudmVjNCBmeGFhKHNhbXBsZXIyRCB0ZXgsIHZlYzIgZnJhZ0Nvb3JkLCB2ZWMyIGludmVyc2VWUCxcXG4gICAgICAgICAgdmVjMiB2X3JnYk5XLCB2ZWMyIHZfcmdiTkUsXFxuICAgICAgICAgIHZlYzIgdl9yZ2JTVywgdmVjMiB2X3JnYlNFLFxcbiAgICAgICAgICB2ZWMyIHZfcmdiTSkge1xcbiAgICB2ZWM0IGNvbG9yO1xcbiAgICB2ZWMzIHJnYk5XID0gdGV4dHVyZTJEKHRleCwgdl9yZ2JOVykueHl6O1xcbiAgICB2ZWMzIHJnYk5FID0gdGV4dHVyZTJEKHRleCwgdl9yZ2JORSkueHl6O1xcbiAgICB2ZWMzIHJnYlNXID0gdGV4dHVyZTJEKHRleCwgdl9yZ2JTVykueHl6O1xcbiAgICB2ZWMzIHJnYlNFID0gdGV4dHVyZTJEKHRleCwgdl9yZ2JTRSkueHl6O1xcbiAgICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHRleCwgdl9yZ2JNKTtcXG4gICAgdmVjMyByZ2JNICA9IHRleENvbG9yLnh5ejtcXG4gICAgdmVjMyBsdW1hID0gdmVjMygwLjI5OSwgMC41ODcsIDAuMTE0KTtcXG4gICAgZmxvYXQgbHVtYU5XID0gZG90KHJnYk5XLCBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYU5FID0gZG90KHJnYk5FLCBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYVNXID0gZG90KHJnYlNXLCBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYVNFID0gZG90KHJnYlNFLCBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYU0gID0gZG90KHJnYk0sICBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYU1pbiA9IG1pbihsdW1hTSwgbWluKG1pbihsdW1hTlcsIGx1bWFORSksIG1pbihsdW1hU1csIGx1bWFTRSkpKTtcXG4gICAgZmxvYXQgbHVtYU1heCA9IG1heChsdW1hTSwgbWF4KG1heChsdW1hTlcsIGx1bWFORSksIG1heChsdW1hU1csIGx1bWFTRSkpKTtcXG5cXG4gICAgbWVkaXVtcCB2ZWMyIGRpcjtcXG4gICAgZGlyLnggPSAtKChsdW1hTlcgKyBsdW1hTkUpIC0gKGx1bWFTVyArIGx1bWFTRSkpO1xcbiAgICBkaXIueSA9ICAoKGx1bWFOVyArIGx1bWFTVykgLSAobHVtYU5FICsgbHVtYVNFKSk7XFxuXFxuICAgIGZsb2F0IGRpclJlZHVjZSA9IG1heCgobHVtYU5XICsgbHVtYU5FICsgbHVtYVNXICsgbHVtYVNFKSAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoMC4yNSAqIEZYQUFfUkVEVUNFX01VTCksIEZYQUFfUkVEVUNFX01JTik7XFxuXFxuICAgIGZsb2F0IHJjcERpck1pbiA9IDEuMCAvIChtaW4oYWJzKGRpci54KSwgYWJzKGRpci55KSkgKyBkaXJSZWR1Y2UpO1xcbiAgICBkaXIgPSBtaW4odmVjMihGWEFBX1NQQU5fTUFYLCBGWEFBX1NQQU5fTUFYKSxcXG4gICAgICAgICAgICAgIG1heCh2ZWMyKC1GWEFBX1NQQU5fTUFYLCAtRlhBQV9TUEFOX01BWCksXFxuICAgICAgICAgICAgICAgICAgZGlyICogcmNwRGlyTWluKSkgKiBpbnZlcnNlVlA7XFxuXFxuICAgIHZlYzMgcmdiQSA9IDAuNSAqIChcXG4gICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIGludmVyc2VWUCArIGRpciAqICgxLjAgLyAzLjAgLSAwLjUpKS54eXogK1xcbiAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogaW52ZXJzZVZQICsgZGlyICogKDIuMCAvIDMuMCAtIDAuNSkpLnh5eik7XFxuICAgIHZlYzMgcmdiQiA9IHJnYkEgKiAwLjUgKyAwLjI1ICogKFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgKiBpbnZlcnNlVlAgKyBkaXIgKiAtMC41KS54eXogK1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgKiBpbnZlcnNlVlAgKyBkaXIgKiAwLjUpLnh5eik7XFxuXFxuICAgIGZsb2F0IGx1bWFCID0gZG90KHJnYkIsIGx1bWEpO1xcbiAgICBpZiAoKGx1bWFCIDwgbHVtYU1pbikgfHwgKGx1bWFCID4gbHVtYU1heCkpXFxuICAgICAgICBjb2xvciA9IHZlYzQocmdiQSwgdGV4Q29sb3IuYSk7XFxuICAgIGVsc2VcXG4gICAgICAgIGNvbG9yID0gdmVjNChyZ2JCLCB0ZXhDb2xvci5hKTtcXG4gICAgcmV0dXJuIGNvbG9yO1xcbn1cXG5cXG52b2lkIG1haW4oKSB7XFxuXFxuICAgICAgdmVjNCBjb2xvcjtcXG5cXG4gICAgICBjb2xvciA9IGZ4YWEodVNhbXBsZXIsIHZGcmFnQ29vcmQsIGlucHV0U2l6ZS56dywgdl9yZ2JOVywgdl9yZ2JORSwgdl9yZ2JTVywgdl9yZ2JTRSwgdl9yZ2JNKTtcXG5cXG4gICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGZyYWdtZW50IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZ4YWEubWpzLm1hcFxuIiwidmFyIHZlcnRleCA9IFwiXFxuYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcblxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcblxcbnZhcnlpbmcgdmVjMiB2X3JnYk5XO1xcbnZhcnlpbmcgdmVjMiB2X3JnYk5FO1xcbnZhcnlpbmcgdmVjMiB2X3JnYlNXO1xcbnZhcnlpbmcgdmVjMiB2X3JnYlNFO1xcbnZhcnlpbmcgdmVjMiB2X3JnYk07XFxuXFxudmFyeWluZyB2ZWMyIHZGcmFnQ29vcmQ7XFxuXFxudW5pZm9ybSB2ZWM0IGlucHV0U2l6ZTtcXG51bmlmb3JtIHZlYzQgb3V0cHV0RnJhbWU7XFxuXFxudmVjNCBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbiggdm9pZCApXFxue1xcbiAgICB2ZWMyIHBvc2l0aW9uID0gYVZlcnRleFBvc2l0aW9uICogbWF4KG91dHB1dEZyYW1lLnp3LCB2ZWMyKDAuKSkgKyBvdXRwdXRGcmFtZS54eTtcXG5cXG4gICAgcmV0dXJuIHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKHBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcbn1cXG5cXG52b2lkIHRleGNvb3Jkcyh2ZWMyIGZyYWdDb29yZCwgdmVjMiBpbnZlcnNlVlAsXFxuICAgICAgICAgICAgICAgb3V0IHZlYzIgdl9yZ2JOVywgb3V0IHZlYzIgdl9yZ2JORSxcXG4gICAgICAgICAgICAgICBvdXQgdmVjMiB2X3JnYlNXLCBvdXQgdmVjMiB2X3JnYlNFLFxcbiAgICAgICAgICAgICAgIG91dCB2ZWMyIHZfcmdiTSkge1xcbiAgICB2X3JnYk5XID0gKGZyYWdDb29yZCArIHZlYzIoLTEuMCwgLTEuMCkpICogaW52ZXJzZVZQO1xcbiAgICB2X3JnYk5FID0gKGZyYWdDb29yZCArIHZlYzIoMS4wLCAtMS4wKSkgKiBpbnZlcnNlVlA7XFxuICAgIHZfcmdiU1cgPSAoZnJhZ0Nvb3JkICsgdmVjMigtMS4wLCAxLjApKSAqIGludmVyc2VWUDtcXG4gICAgdl9yZ2JTRSA9IChmcmFnQ29vcmQgKyB2ZWMyKDEuMCwgMS4wKSkgKiBpbnZlcnNlVlA7XFxuICAgIHZfcmdiTSA9IHZlYzIoZnJhZ0Nvb3JkICogaW52ZXJzZVZQKTtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG5cXG4gICBnbF9Qb3NpdGlvbiA9IGZpbHRlclZlcnRleFBvc2l0aW9uKCk7XFxuXFxuICAgdkZyYWdDb29yZCA9IGFWZXJ0ZXhQb3NpdGlvbiAqIG91dHB1dEZyYW1lLnp3O1xcblxcbiAgIHRleGNvb3Jkcyh2RnJhZ0Nvb3JkLCBpbnB1dFNpemUuencsIHZfcmdiTlcsIHZfcmdiTkUsIHZfcmdiU1csIHZfcmdiU0UsIHZfcmdiTSk7XFxufVxcblwiO1xuXG5leHBvcnQgeyB2ZXJ0ZXggYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnhhYTIubWpzLm1hcFxuIiwiaW1wb3J0IHsgRmlsdGVyIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSAnLi9meGFhLm1qcyc7XG5pbXBvcnQgdmVydGV4IGZyb20gJy4vZnhhYTIubWpzJztcblxuY2xhc3MgRlhBQUZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHZlcnRleCwgZnJhZ21lbnQpO1xuICB9XG59XG5cbmV4cG9ydCB7IEZYQUFGaWx0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZYQUFGaWx0ZXIubWpzLm1hcFxuIiwiZXhwb3J0IHsgRlhBQUZpbHRlciB9IGZyb20gJy4vRlhBQUZpbHRlci5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG5cXG51bmlmb3JtIGZsb2F0IHVOb2lzZTtcXG51bmlmb3JtIGZsb2F0IHVTZWVkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcblxcbmZsb2F0IHJhbmQodmVjMiBjbylcXG57XFxuICAgIHJldHVybiBmcmFjdChzaW4oZG90KGNvLnh5LCB2ZWMyKDEyLjk4OTgsIDc4LjIzMykpKSAqIDQzNzU4LjU0NTMpO1xcbn1cXG5cXG52b2lkIG1haW4oKVxcbntcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuICAgIGZsb2F0IHJhbmRvbVZhbHVlID0gcmFuZChnbF9GcmFnQ29vcmQueHkgKiB1U2VlZCk7XFxuICAgIGZsb2F0IGRpZmYgPSAocmFuZG9tVmFsdWUgLSAwLjUpICogdU5vaXNlO1xcblxcbiAgICAvLyBVbi1wcmVtdWx0aXBseSBhbHBoYSBiZWZvcmUgYXBwbHlpbmcgdGhlIGNvbG9yIG1hdHJpeC4gU2VlIGlzc3VlICMzNTM5LlxcbiAgICBpZiAoY29sb3IuYSA+IDAuMCkge1xcbiAgICAgICAgY29sb3IucmdiIC89IGNvbG9yLmE7XFxuICAgIH1cXG5cXG4gICAgY29sb3IuciArPSBkaWZmO1xcbiAgICBjb2xvci5nICs9IGRpZmY7XFxuICAgIGNvbG9yLmIgKz0gZGlmZjtcXG5cXG4gICAgLy8gUHJlbXVsdGlwbHkgYWxwaGEgYWdhaW4uXFxuICAgIGNvbG9yLnJnYiAqPSBjb2xvci5hO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGZyYWdtZW50IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vaXNlLm1qcy5tYXBcbiIsImltcG9ydCB7IEZpbHRlciwgZGVmYXVsdEZpbHRlclZlcnRleCB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gJy4vbm9pc2UubWpzJztcblxuY2xhc3MgTm9pc2VGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICBjb25zdHJ1Y3Rvcihub2lzZSA9IDAuNSwgc2VlZCA9IE1hdGgucmFuZG9tKCkpIHtcbiAgICBzdXBlcihkZWZhdWx0RmlsdGVyVmVydGV4LCBmcmFnbWVudCwge1xuICAgICAgdU5vaXNlOiAwLFxuICAgICAgdVNlZWQ6IDBcbiAgICB9KTtcbiAgICB0aGlzLm5vaXNlID0gbm9pc2U7XG4gICAgdGhpcy5zZWVkID0gc2VlZDtcbiAgfVxuICBnZXQgbm9pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudU5vaXNlO1xuICB9XG4gIHNldCBub2lzZSh2YWx1ZSkge1xuICAgIHRoaXMudW5pZm9ybXMudU5vaXNlID0gdmFsdWU7XG4gIH1cbiAgZ2V0IHNlZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudVNlZWQ7XG4gIH1cbiAgc2V0IHNlZWQodmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVTZWVkID0gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IHsgTm9pc2VGaWx0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5vaXNlRmlsdGVyLm1qcy5tYXBcbiIsImV4cG9ydCB7IE5vaXNlRmlsdGVyIH0gZnJvbSAnLi9Ob2lzZUZpbHRlci5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgdXRpbHMgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IEFscGhhRmlsdGVyIH0gZnJvbSAnQHBpeGkvZmlsdGVyLWFscGhhJztcbmltcG9ydCB7IEJsdXJGaWx0ZXIsIEJsdXJGaWx0ZXJQYXNzIH0gZnJvbSAnQHBpeGkvZmlsdGVyLWJsdXInO1xuaW1wb3J0IHsgQ29sb3JNYXRyaXhGaWx0ZXIgfSBmcm9tICdAcGl4aS9maWx0ZXItY29sb3ItbWF0cml4JztcbmltcG9ydCB7IERpc3BsYWNlbWVudEZpbHRlciB9IGZyb20gJ0BwaXhpL2ZpbHRlci1kaXNwbGFjZW1lbnQnO1xuaW1wb3J0IHsgRlhBQUZpbHRlciB9IGZyb20gJ0BwaXhpL2ZpbHRlci1meGFhJztcbmltcG9ydCB7IE5vaXNlRmlsdGVyIH0gZnJvbSAnQHBpeGkvZmlsdGVyLW5vaXNlJztcblxuY29uc3QgZmlsdGVycyA9IHtcbiAgQWxwaGFGaWx0ZXIsXG4gIEJsdXJGaWx0ZXIsXG4gIEJsdXJGaWx0ZXJQYXNzLFxuICBDb2xvck1hdHJpeEZpbHRlcixcbiAgRGlzcGxhY2VtZW50RmlsdGVyLFxuICBGWEFBRmlsdGVyLFxuICBOb2lzZUZpbHRlclxufTtcbk9iamVjdC5lbnRyaWVzKGZpbHRlcnMpLmZvckVhY2goKFtrZXksIEZpbHRlckNsYXNzXSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmlsdGVycywga2V5LCB7XG4gICAgZ2V0KCkge1xuICAgICAgdXRpbHMuZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBgZmlsdGVycy4ke2tleX0gaGFzIG1vdmVkIHRvICR7a2V5fWApO1xuICAgICAgcmV0dXJuIEZpbHRlckNsYXNzO1xuICAgIH1cbiAgfSk7XG59KTtcblxuZXhwb3J0IHsgZmlsdGVycyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVycy5tanMubWFwXG4iLCJpbXBvcnQgeyBUaWNrZXIsIFVQREFURV9QUklPUklUWSB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuXG5jbGFzcyBFdmVudHNUaWNrZXJDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaW50ZXJhY3Rpb25GcmVxdWVuY3kgPSAxMDtcbiAgICB0aGlzLl9kZWx0YVRpbWUgPSAwO1xuICAgIHRoaXMuX2RpZE1vdmUgPSBmYWxzZTtcbiAgICB0aGlzLnRpY2tlckFkZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcGF1c2VVcGRhdGUgPSB0cnVlO1xuICB9XG4gIGluaXQoZXZlbnRzKSB7XG4gICAgdGhpcy5yZW1vdmVUaWNrZXJMaXN0ZW5lcigpO1xuICAgIHRoaXMuZXZlbnRzID0gZXZlbnRzO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25GcmVxdWVuY3kgPSAxMDtcbiAgICB0aGlzLl9kZWx0YVRpbWUgPSAwO1xuICAgIHRoaXMuX2RpZE1vdmUgPSBmYWxzZTtcbiAgICB0aGlzLnRpY2tlckFkZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcGF1c2VVcGRhdGUgPSB0cnVlO1xuICB9XG4gIGdldCBwYXVzZVVwZGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGF1c2VVcGRhdGU7XG4gIH1cbiAgc2V0IHBhdXNlVXBkYXRlKHBhdXNlZCkge1xuICAgIHRoaXMuX3BhdXNlVXBkYXRlID0gcGF1c2VkO1xuICB9XG4gIGFkZFRpY2tlckxpc3RlbmVyKCkge1xuICAgIGlmICh0aGlzLnRpY2tlckFkZGVkIHx8ICF0aGlzLmRvbUVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgVGlja2VyLnN5c3RlbS5hZGQodGhpcy50aWNrZXJVcGRhdGUsIHRoaXMsIFVQREFURV9QUklPUklUWS5JTlRFUkFDVElPTik7XG4gICAgdGhpcy50aWNrZXJBZGRlZCA9IHRydWU7XG4gIH1cbiAgcmVtb3ZlVGlja2VyTGlzdGVuZXIoKSB7XG4gICAgaWYgKCF0aGlzLnRpY2tlckFkZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFRpY2tlci5zeXN0ZW0ucmVtb3ZlKHRoaXMudGlja2VyVXBkYXRlLCB0aGlzKTtcbiAgICB0aGlzLnRpY2tlckFkZGVkID0gZmFsc2U7XG4gIH1cbiAgcG9pbnRlck1vdmVkKCkge1xuICAgIHRoaXMuX2RpZE1vdmUgPSB0cnVlO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuZG9tRWxlbWVudCB8fCB0aGlzLl9wYXVzZVVwZGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZGlkTW92ZSkge1xuICAgICAgdGhpcy5fZGlkTW92ZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByb290UG9pbnRlckV2ZW50ID0gdGhpcy5ldmVudHNbXCJyb290UG9pbnRlckV2ZW50XCJdO1xuICAgIGlmICh0aGlzLmV2ZW50cy5zdXBwb3J0c1RvdWNoRXZlbnRzICYmIHJvb3RQb2ludGVyRXZlbnQucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBnbG9iYWxUaGlzLmRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IFBvaW50ZXJFdmVudChcInBvaW50ZXJtb3ZlXCIsIHtcbiAgICAgIGNsaWVudFg6IHJvb3RQb2ludGVyRXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFk6IHJvb3RQb2ludGVyRXZlbnQuY2xpZW50WVxuICAgIH0pKTtcbiAgfVxuICB0aWNrZXJVcGRhdGUoZGVsdGFUaW1lKSB7XG4gICAgdGhpcy5fZGVsdGFUaW1lICs9IGRlbHRhVGltZTtcbiAgICBpZiAodGhpcy5fZGVsdGFUaW1lIDwgdGhpcy5pbnRlcmFjdGlvbkZyZXF1ZW5jeSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kZWx0YVRpbWUgPSAwO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbn1cbmNvbnN0IEV2ZW50c1RpY2tlciA9IG5ldyBFdmVudHNUaWNrZXJDbGFzcygpO1xuXG5leHBvcnQgeyBFdmVudHNUaWNrZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50VGlja2VyLm1qcy5tYXBcbiIsImltcG9ydCB7IFBvaW50IH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmNsYXNzIEZlZGVyYXRlZEV2ZW50IHtcbiAgY29uc3RydWN0b3IobWFuYWdlcikge1xuICAgIHRoaXMuYnViYmxlcyA9IHRydWU7XG4gICAgdGhpcy5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIHRoaXMuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuY29tcG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmV2ZW50UGhhc2UgPSBGZWRlcmF0ZWRFdmVudC5wcm90b3R5cGUuTk9ORTtcbiAgICB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMucHJvcGFnYXRpb25JbW1lZGlhdGVseVN0b3BwZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxheWVyID0gbmV3IFBvaW50KCk7XG4gICAgdGhpcy5wYWdlID0gbmV3IFBvaW50KCk7XG4gICAgdGhpcy5OT05FID0gMDtcbiAgICB0aGlzLkNBUFRVUklOR19QSEFTRSA9IDE7XG4gICAgdGhpcy5BVF9UQVJHRVQgPSAyO1xuICAgIHRoaXMuQlVCQkxJTkdfUEhBU0UgPSAzO1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gIH1cbiAgZ2V0IGxheWVyWCgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXllci54O1xuICB9XG4gIGdldCBsYXllclkoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXIueTtcbiAgfVxuICBnZXQgcGFnZVgoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFnZS54O1xuICB9XG4gIGdldCBwYWdlWSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlLnk7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY29tcG9zZWRQYXRoKCkge1xuICAgIGlmICh0aGlzLm1hbmFnZXIgJiYgKCF0aGlzLnBhdGggfHwgdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXSAhPT0gdGhpcy50YXJnZXQpKSB7XG4gICAgICB0aGlzLnBhdGggPSB0aGlzLnRhcmdldCA/IHRoaXMubWFuYWdlci5wcm9wYWdhdGlvblBhdGgodGhpcy50YXJnZXQpIDogW107XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhdGg7XG4gIH1cbiAgaW5pdEV2ZW50KF90eXBlLCBfYnViYmxlcywgX2NhbmNlbGFibGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbml0RXZlbnQoKSBpcyBhIGxlZ2FjeSBET00gQVBJLiBJdCBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIEZlZGVyYXRlZCBFdmVudHMgQVBJLlwiKTtcbiAgfVxuICBpbml0VUlFdmVudChfdHlwZUFyZywgX2J1YmJsZXNBcmcsIF9jYW5jZWxhYmxlQXJnLCBfdmlld0FyZywgX2RldGFpbEFyZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcImluaXRVSUV2ZW50KCkgaXMgYSBsZWdhY3kgRE9NIEFQSS4gSXQgaXMgbm90IGltcGxlbWVudGVkIGluIHRoZSBGZWRlcmF0ZWQgRXZlbnRzIEFQSS5cIik7XG4gIH1cbiAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgaWYgKHRoaXMubmF0aXZlRXZlbnQgaW5zdGFuY2VvZiBFdmVudCAmJiB0aGlzLm5hdGl2ZUV2ZW50LmNhbmNlbGFibGUpIHtcbiAgICAgIHRoaXMubmF0aXZlRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgfVxuICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB7XG4gICAgdGhpcy5wcm9wYWdhdGlvbkltbWVkaWF0ZWx5U3RvcHBlZCA9IHRydWU7XG4gIH1cbiAgc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnQgeyBGZWRlcmF0ZWRFdmVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmVkZXJhdGVkRXZlbnQubWpzLm1hcFxuIiwiaW1wb3J0IHsgUG9pbnQgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IEZlZGVyYXRlZEV2ZW50IH0gZnJvbSAnLi9GZWRlcmF0ZWRFdmVudC5tanMnO1xuXG5jbGFzcyBGZWRlcmF0ZWRNb3VzZUV2ZW50IGV4dGVuZHMgRmVkZXJhdGVkRXZlbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuY2xpZW50ID0gbmV3IFBvaW50KCk7XG4gICAgdGhpcy5tb3ZlbWVudCA9IG5ldyBQb2ludCgpO1xuICAgIHRoaXMub2Zmc2V0ID0gbmV3IFBvaW50KCk7XG4gICAgdGhpcy5nbG9iYWwgPSBuZXcgUG9pbnQoKTtcbiAgICB0aGlzLnNjcmVlbiA9IG5ldyBQb2ludCgpO1xuICB9XG4gIGdldCBjbGllbnRYKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC54O1xuICB9XG4gIGdldCBjbGllbnRZKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC55O1xuICB9XG4gIGdldCB4KCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudFg7XG4gIH1cbiAgZ2V0IHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50WTtcbiAgfVxuICBnZXQgbW92ZW1lbnRYKCkge1xuICAgIHJldHVybiB0aGlzLm1vdmVtZW50Lng7XG4gIH1cbiAgZ2V0IG1vdmVtZW50WSgpIHtcbiAgICByZXR1cm4gdGhpcy5tb3ZlbWVudC55O1xuICB9XG4gIGdldCBvZmZzZXRYKCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldC54O1xuICB9XG4gIGdldCBvZmZzZXRZKCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldC55O1xuICB9XG4gIGdldCBnbG9iYWxYKCkge1xuICAgIHJldHVybiB0aGlzLmdsb2JhbC54O1xuICB9XG4gIGdldCBnbG9iYWxZKCkge1xuICAgIHJldHVybiB0aGlzLmdsb2JhbC55O1xuICB9XG4gIGdldCBzY3JlZW5YKCkge1xuICAgIHJldHVybiB0aGlzLnNjcmVlbi54O1xuICB9XG4gIGdldCBzY3JlZW5ZKCkge1xuICAgIHJldHVybiB0aGlzLnNjcmVlbi55O1xuICB9XG4gIGdldExvY2FsUG9zaXRpb24oZGlzcGxheU9iamVjdCwgcG9pbnQsIGdsb2JhbFBvcykge1xuICAgIHJldHVybiBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShnbG9iYWxQb3MgfHwgdGhpcy5nbG9iYWwsIHBvaW50KTtcbiAgfVxuICBnZXRNb2RpZmllclN0YXRlKGtleSkge1xuICAgIHJldHVybiBcImdldE1vZGlmaWVyU3RhdGVcIiBpbiB0aGlzLm5hdGl2ZUV2ZW50ICYmIHRoaXMubmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXkpO1xuICB9XG4gIGluaXRNb3VzZUV2ZW50KF90eXBlQXJnLCBfY2FuQnViYmxlQXJnLCBfY2FuY2VsYWJsZUFyZywgX3ZpZXdBcmcsIF9kZXRhaWxBcmcsIF9zY3JlZW5YQXJnLCBfc2NyZWVuWUFyZywgX2NsaWVudFhBcmcsIF9jbGllbnRZQXJnLCBfY3RybEtleUFyZywgX2FsdEtleUFyZywgX3NoaWZ0S2V5QXJnLCBfbWV0YUtleUFyZywgX2J1dHRvbkFyZywgX3JlbGF0ZWRUYXJnZXRBcmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgfVxufVxuXG5leHBvcnQgeyBGZWRlcmF0ZWRNb3VzZUV2ZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GZWRlcmF0ZWRNb3VzZUV2ZW50Lm1qcy5tYXBcbiIsImltcG9ydCB7IEZlZGVyYXRlZE1vdXNlRXZlbnQgfSBmcm9tICcuL0ZlZGVyYXRlZE1vdXNlRXZlbnQubWpzJztcblxuY2xhc3MgRmVkZXJhdGVkUG9pbnRlckV2ZW50IGV4dGVuZHMgRmVkZXJhdGVkTW91c2VFdmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgIHRoaXMuaXNQcmltYXJ5ID0gZmFsc2U7XG4gIH1cbiAgZ2V0Q29hbGVzY2VkRXZlbnRzKCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IFwicG9pbnRlcm1vdmVcIiB8fCB0aGlzLnR5cGUgPT09IFwibW91c2Vtb3ZlXCIgfHwgdGhpcy50eXBlID09PSBcInRvdWNobW92ZVwiKSB7XG4gICAgICByZXR1cm4gW3RoaXNdO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0UHJlZGljdGVkRXZlbnRzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImdldFByZWRpY3RlZEV2ZW50cyBpcyBub3Qgc3VwcG9ydGVkIVwiKTtcbiAgfVxufVxuXG5leHBvcnQgeyBGZWRlcmF0ZWRQb2ludGVyRXZlbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZlZGVyYXRlZFBvaW50ZXJFdmVudC5tanMubWFwXG4iLCJpbXBvcnQgeyBGZWRlcmF0ZWRNb3VzZUV2ZW50IH0gZnJvbSAnLi9GZWRlcmF0ZWRNb3VzZUV2ZW50Lm1qcyc7XG5cbmNsYXNzIEZlZGVyYXRlZFdoZWVsRXZlbnQgZXh0ZW5kcyBGZWRlcmF0ZWRNb3VzZUV2ZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLkRPTV9ERUxUQV9QSVhFTCA9IDA7XG4gICAgdGhpcy5ET01fREVMVEFfTElORSA9IDE7XG4gICAgdGhpcy5ET01fREVMVEFfUEFHRSA9IDI7XG4gIH1cbn1cbkZlZGVyYXRlZFdoZWVsRXZlbnQuRE9NX0RFTFRBX1BJWEVMID0gMDtcbkZlZGVyYXRlZFdoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkUgPSAxO1xuRmVkZXJhdGVkV2hlZWxFdmVudC5ET01fREVMVEFfUEFHRSA9IDI7XG5cbmV4cG9ydCB7IEZlZGVyYXRlZFdoZWVsRXZlbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZlZGVyYXRlZFdoZWVsRXZlbnQubWpzLm1hcFxuIiwiaW1wb3J0IHsgUG9pbnQsIHV0aWxzIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBFdmVudHNUaWNrZXIgfSBmcm9tICcuL0V2ZW50VGlja2VyLm1qcyc7XG5pbXBvcnQgeyBGZWRlcmF0ZWRNb3VzZUV2ZW50IH0gZnJvbSAnLi9GZWRlcmF0ZWRNb3VzZUV2ZW50Lm1qcyc7XG5pbXBvcnQgeyBGZWRlcmF0ZWRQb2ludGVyRXZlbnQgfSBmcm9tICcuL0ZlZGVyYXRlZFBvaW50ZXJFdmVudC5tanMnO1xuaW1wb3J0IHsgRmVkZXJhdGVkV2hlZWxFdmVudCB9IGZyb20gJy4vRmVkZXJhdGVkV2hlZWxFdmVudC5tanMnO1xuXG5jb25zdCBQUk9QQUdBVElPTl9MSU1JVCA9IDIwNDg7XG5jb25zdCB0ZW1wSGl0TG9jYXRpb24gPSBuZXcgUG9pbnQoKTtcbmNvbnN0IHRlbXBMb2NhbE1hcHBpbmcgPSBuZXcgUG9pbnQoKTtcbmNsYXNzIEV2ZW50Qm91bmRhcnkge1xuICBjb25zdHJ1Y3Rvcihyb290VGFyZ2V0KSB7XG4gICAgdGhpcy5kaXNwYXRjaCA9IG5ldyB1dGlscy5FdmVudEVtaXR0ZXIoKTtcbiAgICB0aGlzLm1vdmVPbkFsbCA9IGZhbHNlO1xuICAgIHRoaXMuZW5hYmxlR2xvYmFsTW92ZUV2ZW50cyA9IHRydWU7XG4gICAgdGhpcy5tYXBwaW5nU3RhdGUgPSB7XG4gICAgICB0cmFja2luZ0RhdGE6IHt9XG4gICAgfTtcbiAgICB0aGlzLmV2ZW50UG9vbCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5fYWxsSW50ZXJhY3RpdmVFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuX2hpdEVsZW1lbnRzID0gW107XG4gICAgdGhpcy5faXNQb2ludGVyTW92ZUV2ZW50ID0gZmFsc2U7XG4gICAgdGhpcy5yb290VGFyZ2V0ID0gcm9vdFRhcmdldDtcbiAgICB0aGlzLmhpdFBydW5lRm4gPSB0aGlzLmhpdFBydW5lRm4uYmluZCh0aGlzKTtcbiAgICB0aGlzLmhpdFRlc3RGbiA9IHRoaXMuaGl0VGVzdEZuLmJpbmQodGhpcyk7XG4gICAgdGhpcy5tYXBQb2ludGVyRG93biA9IHRoaXMubWFwUG9pbnRlckRvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLm1hcFBvaW50ZXJNb3ZlID0gdGhpcy5tYXBQb2ludGVyTW92ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMubWFwUG9pbnRlck91dCA9IHRoaXMubWFwUG9pbnRlck91dC5iaW5kKHRoaXMpO1xuICAgIHRoaXMubWFwUG9pbnRlck92ZXIgPSB0aGlzLm1hcFBvaW50ZXJPdmVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5tYXBQb2ludGVyVXAgPSB0aGlzLm1hcFBvaW50ZXJVcC5iaW5kKHRoaXMpO1xuICAgIHRoaXMubWFwUG9pbnRlclVwT3V0c2lkZSA9IHRoaXMubWFwUG9pbnRlclVwT3V0c2lkZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMubWFwV2hlZWwgPSB0aGlzLm1hcFdoZWVsLmJpbmQodGhpcyk7XG4gICAgdGhpcy5tYXBwaW5nVGFibGUgPSB7fTtcbiAgICB0aGlzLmFkZEV2ZW50TWFwcGluZyhcInBvaW50ZXJkb3duXCIsIHRoaXMubWFwUG9pbnRlckRvd24pO1xuICAgIHRoaXMuYWRkRXZlbnRNYXBwaW5nKFwicG9pbnRlcm1vdmVcIiwgdGhpcy5tYXBQb2ludGVyTW92ZSk7XG4gICAgdGhpcy5hZGRFdmVudE1hcHBpbmcoXCJwb2ludGVyb3V0XCIsIHRoaXMubWFwUG9pbnRlck91dCk7XG4gICAgdGhpcy5hZGRFdmVudE1hcHBpbmcoXCJwb2ludGVybGVhdmVcIiwgdGhpcy5tYXBQb2ludGVyT3V0KTtcbiAgICB0aGlzLmFkZEV2ZW50TWFwcGluZyhcInBvaW50ZXJvdmVyXCIsIHRoaXMubWFwUG9pbnRlck92ZXIpO1xuICAgIHRoaXMuYWRkRXZlbnRNYXBwaW5nKFwicG9pbnRlcnVwXCIsIHRoaXMubWFwUG9pbnRlclVwKTtcbiAgICB0aGlzLmFkZEV2ZW50TWFwcGluZyhcInBvaW50ZXJ1cG91dHNpZGVcIiwgdGhpcy5tYXBQb2ludGVyVXBPdXRzaWRlKTtcbiAgICB0aGlzLmFkZEV2ZW50TWFwcGluZyhcIndoZWVsXCIsIHRoaXMubWFwV2hlZWwpO1xuICB9XG4gIGFkZEV2ZW50TWFwcGluZyh0eXBlLCBmbikge1xuICAgIGlmICghdGhpcy5tYXBwaW5nVGFibGVbdHlwZV0pIHtcbiAgICAgIHRoaXMubWFwcGluZ1RhYmxlW3R5cGVdID0gW107XG4gICAgfVxuICAgIHRoaXMubWFwcGluZ1RhYmxlW3R5cGVdLnB1c2goe1xuICAgICAgZm4sXG4gICAgICBwcmlvcml0eTogMFxuICAgIH0pO1xuICAgIHRoaXMubWFwcGluZ1RhYmxlW3R5cGVdLnNvcnQoKGEsIGIpID0+IGEucHJpb3JpdHkgLSBiLnByaW9yaXR5KTtcbiAgfVxuICBkaXNwYXRjaEV2ZW50KGUsIHR5cGUpIHtcbiAgICBlLnByb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xuICAgIGUucHJvcGFnYXRpb25JbW1lZGlhdGVseVN0b3BwZWQgPSBmYWxzZTtcbiAgICB0aGlzLnByb3BhZ2F0ZShlLCB0eXBlKTtcbiAgICB0aGlzLmRpc3BhdGNoLmVtaXQodHlwZSB8fCBlLnR5cGUsIGUpO1xuICB9XG4gIG1hcEV2ZW50KGUpIHtcbiAgICBpZiAoIXRoaXMucm9vdFRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtYXBwZXJzID0gdGhpcy5tYXBwaW5nVGFibGVbZS50eXBlXTtcbiAgICBpZiAobWFwcGVycykge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSBtYXBwZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICBtYXBwZXJzW2ldLmZuKGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oYFtFdmVudEJvdW5kYXJ5XTogRXZlbnQgbWFwcGluZyBub3QgZGVmaW5lZCBmb3IgJHtlLnR5cGV9YCk7XG4gICAgfVxuICB9XG4gIGhpdFRlc3QoeCwgeSkge1xuICAgIEV2ZW50c1RpY2tlci5wYXVzZVVwZGF0ZSA9IHRydWU7XG4gICAgY29uc3QgdXNlTW92ZSA9IHRoaXMuX2lzUG9pbnRlck1vdmVFdmVudCAmJiB0aGlzLmVuYWJsZUdsb2JhbE1vdmVFdmVudHM7XG4gICAgY29uc3QgZm4gPSB1c2VNb3ZlID8gXCJoaXRUZXN0TW92ZVJlY3Vyc2l2ZVwiIDogXCJoaXRUZXN0UmVjdXJzaXZlXCI7XG4gICAgY29uc3QgaW52ZXJ0ZWRQYXRoID0gdGhpc1tmbl0odGhpcy5yb290VGFyZ2V0LCB0aGlzLnJvb3RUYXJnZXQuZXZlbnRNb2RlLCB0ZW1wSGl0TG9jYXRpb24uc2V0KHgsIHkpLCB0aGlzLmhpdFRlc3RGbiwgdGhpcy5oaXRQcnVuZUZuKTtcbiAgICByZXR1cm4gaW52ZXJ0ZWRQYXRoICYmIGludmVydGVkUGF0aFswXTtcbiAgfVxuICBwcm9wYWdhdGUoZSwgdHlwZSkge1xuICAgIGlmICghZS50YXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29tcG9zZWRQYXRoID0gZS5jb21wb3NlZFBhdGgoKTtcbiAgICBlLmV2ZW50UGhhc2UgPSBlLkNBUFRVUklOR19QSEFTRTtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IGNvbXBvc2VkUGF0aC5sZW5ndGggLSAxOyBpIDwgajsgaSsrKSB7XG4gICAgICBlLmN1cnJlbnRUYXJnZXQgPSBjb21wb3NlZFBhdGhbaV07XG4gICAgICB0aGlzLm5vdGlmeVRhcmdldChlLCB0eXBlKTtcbiAgICAgIGlmIChlLnByb3BhZ2F0aW9uU3RvcHBlZCB8fCBlLnByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGUuZXZlbnRQaGFzZSA9IGUuQVRfVEFSR0VUO1xuICAgIGUuY3VycmVudFRhcmdldCA9IGUudGFyZ2V0O1xuICAgIHRoaXMubm90aWZ5VGFyZ2V0KGUsIHR5cGUpO1xuICAgIGlmIChlLnByb3BhZ2F0aW9uU3RvcHBlZCB8fCBlLnByb3BhZ2F0aW9uSW1tZWRpYXRlbHlTdG9wcGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGUuZXZlbnRQaGFzZSA9IGUuQlVCQkxJTkdfUEhBU0U7XG4gICAgZm9yIChsZXQgaSA9IGNvbXBvc2VkUGF0aC5sZW5ndGggLSAyOyBpID49IDA7IGktLSkge1xuICAgICAgZS5jdXJyZW50VGFyZ2V0ID0gY29tcG9zZWRQYXRoW2ldO1xuICAgICAgdGhpcy5ub3RpZnlUYXJnZXQoZSwgdHlwZSk7XG4gICAgICBpZiAoZS5wcm9wYWdhdGlvblN0b3BwZWQgfHwgZS5wcm9wYWdhdGlvbkltbWVkaWF0ZWx5U3RvcHBlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBhbGwoZSwgdHlwZSwgdGFyZ2V0cyA9IHRoaXMuX2FsbEludGVyYWN0aXZlRWxlbWVudHMpIHtcbiAgICBpZiAodGFyZ2V0cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm47XG4gICAgZS5ldmVudFBoYXNlID0gZS5CVUJCTElOR19QSEFTRTtcbiAgICBjb25zdCBldmVudHMgPSBBcnJheS5pc0FycmF5KHR5cGUpID8gdHlwZSA6IFt0eXBlXTtcbiAgICBmb3IgKGxldCBpID0gdGFyZ2V0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgIGUuY3VycmVudFRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGUsIGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBwcm9wYWdhdGlvblBhdGgodGFyZ2V0KSB7XG4gICAgY29uc3QgcHJvcGFnYXRpb25QYXRoID0gW3RhcmdldF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBQUk9QQUdBVElPTl9MSU1JVCAmJiB0YXJnZXQgIT09IHRoaXMucm9vdFRhcmdldDsgaSsrKSB7XG4gICAgICBpZiAoIXRhcmdldC5wYXJlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgcHJvcGFnYXRpb24gcGF0aCB0byBkaXNjb25uZWN0ZWQgdGFyZ2V0XCIpO1xuICAgICAgfVxuICAgICAgcHJvcGFnYXRpb25QYXRoLnB1c2godGFyZ2V0LnBhcmVudCk7XG4gICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50O1xuICAgIH1cbiAgICBwcm9wYWdhdGlvblBhdGgucmV2ZXJzZSgpO1xuICAgIHJldHVybiBwcm9wYWdhdGlvblBhdGg7XG4gIH1cbiAgaGl0VGVzdE1vdmVSZWN1cnNpdmUoY3VycmVudFRhcmdldCwgZXZlbnRNb2RlLCBsb2NhdGlvbiwgdGVzdEZuLCBwcnVuZUZuLCBpZ25vcmUgPSBmYWxzZSkge1xuICAgIGxldCBzaG91bGRSZXR1cm4gPSBmYWxzZTtcbiAgICBpZiAodGhpcy5faW50ZXJhY3RpdmVQcnVuZShjdXJyZW50VGFyZ2V0KSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChjdXJyZW50VGFyZ2V0LmV2ZW50TW9kZSA9PT0gXCJkeW5hbWljXCIgfHwgZXZlbnRNb2RlID09PSBcImR5bmFtaWNcIikge1xuICAgICAgRXZlbnRzVGlja2VyLnBhdXNlVXBkYXRlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChjdXJyZW50VGFyZ2V0LmludGVyYWN0aXZlQ2hpbGRyZW4gJiYgY3VycmVudFRhcmdldC5jaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBjdXJyZW50VGFyZ2V0LmNoaWxkcmVuO1xuICAgICAgZm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIGNvbnN0IG5lc3RlZEhpdCA9IHRoaXMuaGl0VGVzdE1vdmVSZWN1cnNpdmUoY2hpbGQsIHRoaXMuX2lzSW50ZXJhY3RpdmUoZXZlbnRNb2RlKSA/IGV2ZW50TW9kZSA6IGNoaWxkLmV2ZW50TW9kZSwgbG9jYXRpb24sIHRlc3RGbiwgcHJ1bmVGbiwgaWdub3JlIHx8IHBydW5lRm4oY3VycmVudFRhcmdldCwgbG9jYXRpb24pKTtcbiAgICAgICAgaWYgKG5lc3RlZEhpdCkge1xuICAgICAgICAgIGlmIChuZXN0ZWRIaXQubGVuZ3RoID4gMCAmJiAhbmVzdGVkSGl0W25lc3RlZEhpdC5sZW5ndGggLSAxXS5wYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpc0ludGVyYWN0aXZlID0gY3VycmVudFRhcmdldC5pc0ludGVyYWN0aXZlKCk7XG4gICAgICAgICAgaWYgKG5lc3RlZEhpdC5sZW5ndGggPiAwIHx8IGlzSW50ZXJhY3RpdmUpIHtcbiAgICAgICAgICAgIGlmIChpc0ludGVyYWN0aXZlKVxuICAgICAgICAgICAgICB0aGlzLl9hbGxJbnRlcmFjdGl2ZUVsZW1lbnRzLnB1c2goY3VycmVudFRhcmdldCk7XG4gICAgICAgICAgICBuZXN0ZWRIaXQucHVzaChjdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX2hpdEVsZW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2hpdEVsZW1lbnRzID0gbmVzdGVkSGl0O1xuICAgICAgICAgIHNob3VsZFJldHVybiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaXNJbnRlcmFjdGl2ZU1vZGUgPSB0aGlzLl9pc0ludGVyYWN0aXZlKGV2ZW50TW9kZSk7XG4gICAgY29uc3QgaXNJbnRlcmFjdGl2ZVRhcmdldCA9IGN1cnJlbnRUYXJnZXQuaXNJbnRlcmFjdGl2ZSgpO1xuICAgIGlmIChpc0ludGVyYWN0aXZlVGFyZ2V0ICYmIGlzSW50ZXJhY3RpdmVUYXJnZXQpXG4gICAgICB0aGlzLl9hbGxJbnRlcmFjdGl2ZUVsZW1lbnRzLnB1c2goY3VycmVudFRhcmdldCk7XG4gICAgaWYgKGlnbm9yZSB8fCB0aGlzLl9oaXRFbGVtZW50cy5sZW5ndGggPiAwKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKHNob3VsZFJldHVybilcbiAgICAgIHJldHVybiB0aGlzLl9oaXRFbGVtZW50cztcbiAgICBpZiAoaXNJbnRlcmFjdGl2ZU1vZGUgJiYgKCFwcnVuZUZuKGN1cnJlbnRUYXJnZXQsIGxvY2F0aW9uKSAmJiB0ZXN0Rm4oY3VycmVudFRhcmdldCwgbG9jYXRpb24pKSkge1xuICAgICAgcmV0dXJuIGlzSW50ZXJhY3RpdmVUYXJnZXQgPyBbY3VycmVudFRhcmdldF0gOiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaGl0VGVzdFJlY3Vyc2l2ZShjdXJyZW50VGFyZ2V0LCBldmVudE1vZGUsIGxvY2F0aW9uLCB0ZXN0Rm4sIHBydW5lRm4pIHtcbiAgICBpZiAodGhpcy5faW50ZXJhY3RpdmVQcnVuZShjdXJyZW50VGFyZ2V0KSB8fCBwcnVuZUZuKGN1cnJlbnRUYXJnZXQsIGxvY2F0aW9uKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChjdXJyZW50VGFyZ2V0LmV2ZW50TW9kZSA9PT0gXCJkeW5hbWljXCIgfHwgZXZlbnRNb2RlID09PSBcImR5bmFtaWNcIikge1xuICAgICAgRXZlbnRzVGlja2VyLnBhdXNlVXBkYXRlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChjdXJyZW50VGFyZ2V0LmludGVyYWN0aXZlQ2hpbGRyZW4gJiYgY3VycmVudFRhcmdldC5jaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBjdXJyZW50VGFyZ2V0LmNoaWxkcmVuO1xuICAgICAgZm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIGNvbnN0IG5lc3RlZEhpdCA9IHRoaXMuaGl0VGVzdFJlY3Vyc2l2ZShjaGlsZCwgdGhpcy5faXNJbnRlcmFjdGl2ZShldmVudE1vZGUpID8gZXZlbnRNb2RlIDogY2hpbGQuZXZlbnRNb2RlLCBsb2NhdGlvbiwgdGVzdEZuLCBwcnVuZUZuKTtcbiAgICAgICAgaWYgKG5lc3RlZEhpdCkge1xuICAgICAgICAgIGlmIChuZXN0ZWRIaXQubGVuZ3RoID4gMCAmJiAhbmVzdGVkSGl0W25lc3RlZEhpdC5sZW5ndGggLSAxXS5wYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpc0ludGVyYWN0aXZlID0gY3VycmVudFRhcmdldC5pc0ludGVyYWN0aXZlKCk7XG4gICAgICAgICAgaWYgKG5lc3RlZEhpdC5sZW5ndGggPiAwIHx8IGlzSW50ZXJhY3RpdmUpXG4gICAgICAgICAgICBuZXN0ZWRIaXQucHVzaChjdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICByZXR1cm4gbmVzdGVkSGl0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGlzSW50ZXJhY3RpdmVNb2RlID0gdGhpcy5faXNJbnRlcmFjdGl2ZShldmVudE1vZGUpO1xuICAgIGNvbnN0IGlzSW50ZXJhY3RpdmVUYXJnZXQgPSBjdXJyZW50VGFyZ2V0LmlzSW50ZXJhY3RpdmUoKTtcbiAgICBpZiAoaXNJbnRlcmFjdGl2ZU1vZGUgJiYgdGVzdEZuKGN1cnJlbnRUYXJnZXQsIGxvY2F0aW9uKSkge1xuICAgICAgcmV0dXJuIGlzSW50ZXJhY3RpdmVUYXJnZXQgPyBbY3VycmVudFRhcmdldF0gOiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgX2lzSW50ZXJhY3RpdmUoaW50KSB7XG4gICAgcmV0dXJuIGludCA9PT0gXCJzdGF0aWNcIiB8fCBpbnQgPT09IFwiZHluYW1pY1wiO1xuICB9XG4gIF9pbnRlcmFjdGl2ZVBydW5lKGRpc3BsYXlPYmplY3QpIHtcbiAgICBpZiAoIWRpc3BsYXlPYmplY3QgfHwgZGlzcGxheU9iamVjdC5pc01hc2sgfHwgIWRpc3BsYXlPYmplY3QudmlzaWJsZSB8fCAhZGlzcGxheU9iamVjdC5yZW5kZXJhYmxlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGRpc3BsYXlPYmplY3QuZXZlbnRNb2RlID09PSBcIm5vbmVcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChkaXNwbGF5T2JqZWN0LmV2ZW50TW9kZSA9PT0gXCJwYXNzaXZlXCIgJiYgIWRpc3BsYXlPYmplY3QuaW50ZXJhY3RpdmVDaGlsZHJlbikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChkaXNwbGF5T2JqZWN0LmlzTWFzaykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBoaXRQcnVuZUZuKGRpc3BsYXlPYmplY3QsIGxvY2F0aW9uKSB7XG4gICAgaWYgKGRpc3BsYXlPYmplY3QuaGl0QXJlYSkge1xuICAgICAgZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UobG9jYXRpb24sIHRlbXBMb2NhbE1hcHBpbmcpO1xuICAgICAgaWYgKCFkaXNwbGF5T2JqZWN0LmhpdEFyZWEuY29udGFpbnModGVtcExvY2FsTWFwcGluZy54LCB0ZW1wTG9jYWxNYXBwaW5nLnkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGlzcGxheU9iamVjdC5fbWFzaykge1xuICAgICAgY29uc3QgbWFza09iamVjdCA9IGRpc3BsYXlPYmplY3QuX21hc2suaXNNYXNrRGF0YSA/IGRpc3BsYXlPYmplY3QuX21hc2subWFza09iamVjdCA6IGRpc3BsYXlPYmplY3QuX21hc2s7XG4gICAgICBpZiAobWFza09iamVjdCAmJiAhbWFza09iamVjdC5jb250YWluc1BvaW50Py4obG9jYXRpb24pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaGl0VGVzdEZuKGRpc3BsYXlPYmplY3QsIGxvY2F0aW9uKSB7XG4gICAgaWYgKGRpc3BsYXlPYmplY3QuZXZlbnRNb2RlID09PSBcInBhc3NpdmVcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGlzcGxheU9iamVjdC5oaXRBcmVhKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGRpc3BsYXlPYmplY3QuY29udGFpbnNQb2ludCkge1xuICAgICAgcmV0dXJuIGRpc3BsYXlPYmplY3QuY29udGFpbnNQb2ludChsb2NhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBub3RpZnlUYXJnZXQoZSwgdHlwZSkge1xuICAgIHR5cGUgPSB0eXBlID8/IGUudHlwZTtcbiAgICBjb25zdCBoYW5kbGVyS2V5ID0gYG9uJHt0eXBlfWA7XG4gICAgZS5jdXJyZW50VGFyZ2V0W2hhbmRsZXJLZXldPy4oZSk7XG4gICAgY29uc3Qga2V5ID0gZS5ldmVudFBoYXNlID09PSBlLkNBUFRVUklOR19QSEFTRSB8fCBlLmV2ZW50UGhhc2UgPT09IGUuQVRfVEFSR0VUID8gYCR7dHlwZX1jYXB0dXJlYCA6IHR5cGU7XG4gICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoZSwga2V5KTtcbiAgICBpZiAoZS5ldmVudFBoYXNlID09PSBlLkFUX1RBUkdFVCkge1xuICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoZSwgdHlwZSk7XG4gICAgfVxuICB9XG4gIG1hcFBvaW50ZXJEb3duKGZyb20pIHtcbiAgICBpZiAoIShmcm9tIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiRXZlbnRCb3VuZGFyeSBjYW5ub3QgbWFwIGEgbm9uLXBvaW50ZXIgZXZlbnQgYXMgYSBwb2ludGVyIGV2ZW50XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwicG9pbnRlcmRvd25cIik7XG4gICAgaWYgKGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwidG91Y2hzdGFydFwiKTtcbiAgICB9IGVsc2UgaWYgKGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInBlblwiKSB7XG4gICAgICBjb25zdCBpc1JpZ2h0QnV0dG9uID0gZS5idXR0b24gPT09IDI7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSwgaXNSaWdodEJ1dHRvbiA/IFwicmlnaHRkb3duXCIgOiBcIm1vdXNlZG93blwiKTtcbiAgICB9XG4gICAgY29uc3QgdHJhY2tpbmdEYXRhID0gdGhpcy50cmFja2luZ0RhdGEoZnJvbS5wb2ludGVySWQpO1xuICAgIHRyYWNraW5nRGF0YS5wcmVzc1RhcmdldHNCeUJ1dHRvbltmcm9tLmJ1dHRvbl0gPSBlLmNvbXBvc2VkUGF0aCgpO1xuICAgIHRoaXMuZnJlZUV2ZW50KGUpO1xuICB9XG4gIG1hcFBvaW50ZXJNb3ZlKGZyb20pIHtcbiAgICBpZiAoIShmcm9tIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiRXZlbnRCb3VuZGFyeSBjYW5ub3QgbWFwIGEgbm9uLXBvaW50ZXIgZXZlbnQgYXMgYSBwb2ludGVyIGV2ZW50XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9hbGxJbnRlcmFjdGl2ZUVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5faGl0RWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9pc1BvaW50ZXJNb3ZlRXZlbnQgPSB0cnVlO1xuICAgIGNvbnN0IGUgPSB0aGlzLmNyZWF0ZVBvaW50ZXJFdmVudChmcm9tKTtcbiAgICB0aGlzLl9pc1BvaW50ZXJNb3ZlRXZlbnQgPSBmYWxzZTtcbiAgICBjb25zdCBpc01vdXNlID0gZS5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiIHx8IGUucG9pbnRlclR5cGUgPT09IFwicGVuXCI7XG4gICAgY29uc3QgdHJhY2tpbmdEYXRhID0gdGhpcy50cmFja2luZ0RhdGEoZnJvbS5wb2ludGVySWQpO1xuICAgIGNvbnN0IG91dFRhcmdldCA9IHRoaXMuZmluZE1vdW50ZWRUYXJnZXQodHJhY2tpbmdEYXRhLm92ZXJUYXJnZXRzKTtcbiAgICBpZiAodHJhY2tpbmdEYXRhLm92ZXJUYXJnZXRzPy5sZW5ndGggPiAwICYmIG91dFRhcmdldCAhPT0gZS50YXJnZXQpIHtcbiAgICAgIGNvbnN0IG91dFR5cGUgPSBmcm9tLnR5cGUgPT09IFwibW91c2Vtb3ZlXCIgPyBcIm1vdXNlb3V0XCIgOiBcInBvaW50ZXJvdXRcIjtcbiAgICAgIGNvbnN0IG91dEV2ZW50ID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSwgb3V0VHlwZSwgb3V0VGFyZ2V0KTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChvdXRFdmVudCwgXCJwb2ludGVyb3V0XCIpO1xuICAgICAgaWYgKGlzTW91c2UpXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChvdXRFdmVudCwgXCJtb3VzZW91dFwiKTtcbiAgICAgIGlmICghZS5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhvdXRUYXJnZXQpKSB7XG4gICAgICAgIGNvbnN0IGxlYXZlRXZlbnQgPSB0aGlzLmNyZWF0ZVBvaW50ZXJFdmVudChmcm9tLCBcInBvaW50ZXJsZWF2ZVwiLCBvdXRUYXJnZXQpO1xuICAgICAgICBsZWF2ZUV2ZW50LmV2ZW50UGhhc2UgPSBsZWF2ZUV2ZW50LkFUX1RBUkdFVDtcbiAgICAgICAgd2hpbGUgKGxlYXZlRXZlbnQudGFyZ2V0ICYmICFlLmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKGxlYXZlRXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgIGxlYXZlRXZlbnQuY3VycmVudFRhcmdldCA9IGxlYXZlRXZlbnQudGFyZ2V0O1xuICAgICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGxlYXZlRXZlbnQpO1xuICAgICAgICAgIGlmIChpc01vdXNlKVxuICAgICAgICAgICAgdGhpcy5ub3RpZnlUYXJnZXQobGVhdmVFdmVudCwgXCJtb3VzZWxlYXZlXCIpO1xuICAgICAgICAgIGxlYXZlRXZlbnQudGFyZ2V0ID0gbGVhdmVFdmVudC50YXJnZXQucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJlZUV2ZW50KGxlYXZlRXZlbnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmVlRXZlbnQob3V0RXZlbnQpO1xuICAgIH1cbiAgICBpZiAob3V0VGFyZ2V0ICE9PSBlLnRhcmdldCkge1xuICAgICAgY29uc3Qgb3ZlclR5cGUgPSBmcm9tLnR5cGUgPT09IFwibW91c2Vtb3ZlXCIgPyBcIm1vdXNlb3ZlclwiIDogXCJwb2ludGVyb3ZlclwiO1xuICAgICAgY29uc3Qgb3ZlckV2ZW50ID0gdGhpcy5jbG9uZVBvaW50ZXJFdmVudChlLCBvdmVyVHlwZSk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQob3ZlckV2ZW50LCBcInBvaW50ZXJvdmVyXCIpO1xuICAgICAgaWYgKGlzTW91c2UpXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChvdmVyRXZlbnQsIFwibW91c2VvdmVyXCIpO1xuICAgICAgbGV0IG92ZXJUYXJnZXRBbmNlc3RvciA9IG91dFRhcmdldD8ucGFyZW50O1xuICAgICAgd2hpbGUgKG92ZXJUYXJnZXRBbmNlc3RvciAmJiBvdmVyVGFyZ2V0QW5jZXN0b3IgIT09IHRoaXMucm9vdFRhcmdldC5wYXJlbnQpIHtcbiAgICAgICAgaWYgKG92ZXJUYXJnZXRBbmNlc3RvciA9PT0gZS50YXJnZXQpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIG92ZXJUYXJnZXRBbmNlc3RvciA9IG92ZXJUYXJnZXRBbmNlc3Rvci5wYXJlbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCBkaWRQb2ludGVyRW50ZXIgPSAhb3ZlclRhcmdldEFuY2VzdG9yIHx8IG92ZXJUYXJnZXRBbmNlc3RvciA9PT0gdGhpcy5yb290VGFyZ2V0LnBhcmVudDtcbiAgICAgIGlmIChkaWRQb2ludGVyRW50ZXIpIHtcbiAgICAgICAgY29uc3QgZW50ZXJFdmVudCA9IHRoaXMuY2xvbmVQb2ludGVyRXZlbnQoZSwgXCJwb2ludGVyZW50ZXJcIik7XG4gICAgICAgIGVudGVyRXZlbnQuZXZlbnRQaGFzZSA9IGVudGVyRXZlbnQuQVRfVEFSR0VUO1xuICAgICAgICB3aGlsZSAoZW50ZXJFdmVudC50YXJnZXQgJiYgZW50ZXJFdmVudC50YXJnZXQgIT09IG91dFRhcmdldCAmJiBlbnRlckV2ZW50LnRhcmdldCAhPT0gdGhpcy5yb290VGFyZ2V0LnBhcmVudCkge1xuICAgICAgICAgIGVudGVyRXZlbnQuY3VycmVudFRhcmdldCA9IGVudGVyRXZlbnQudGFyZ2V0O1xuICAgICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGVudGVyRXZlbnQpO1xuICAgICAgICAgIGlmIChpc01vdXNlKVxuICAgICAgICAgICAgdGhpcy5ub3RpZnlUYXJnZXQoZW50ZXJFdmVudCwgXCJtb3VzZWVudGVyXCIpO1xuICAgICAgICAgIGVudGVyRXZlbnQudGFyZ2V0ID0gZW50ZXJFdmVudC50YXJnZXQucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJlZUV2ZW50KGVudGVyRXZlbnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmVlRXZlbnQob3ZlckV2ZW50KTtcbiAgICB9XG4gICAgY29uc3QgYWxsTWV0aG9kcyA9IFtdO1xuICAgIGNvbnN0IGFsbG93R2xvYmFsUG9pbnRlckV2ZW50cyA9IHRoaXMuZW5hYmxlR2xvYmFsTW92ZUV2ZW50cyA/PyB0cnVlO1xuICAgIHRoaXMubW92ZU9uQWxsID8gYWxsTWV0aG9kcy5wdXNoKFwicG9pbnRlcm1vdmVcIikgOiB0aGlzLmRpc3BhdGNoRXZlbnQoZSwgXCJwb2ludGVybW92ZVwiKTtcbiAgICBhbGxvd0dsb2JhbFBvaW50ZXJFdmVudHMgJiYgYWxsTWV0aG9kcy5wdXNoKFwiZ2xvYmFscG9pbnRlcm1vdmVcIik7XG4gICAgaWYgKGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgdGhpcy5tb3ZlT25BbGwgPyBhbGxNZXRob2RzLnNwbGljZSgxLCAwLCBcInRvdWNobW92ZVwiKSA6IHRoaXMuZGlzcGF0Y2hFdmVudChlLCBcInRvdWNobW92ZVwiKTtcbiAgICAgIGFsbG93R2xvYmFsUG9pbnRlckV2ZW50cyAmJiBhbGxNZXRob2RzLnB1c2goXCJnbG9iYWx0b3VjaG1vdmVcIik7XG4gICAgfVxuICAgIGlmIChpc01vdXNlKSB7XG4gICAgICB0aGlzLm1vdmVPbkFsbCA/IGFsbE1ldGhvZHMuc3BsaWNlKDEsIDAsIFwibW91c2Vtb3ZlXCIpIDogdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwibW91c2Vtb3ZlXCIpO1xuICAgICAgYWxsb3dHbG9iYWxQb2ludGVyRXZlbnRzICYmIGFsbE1ldGhvZHMucHVzaChcImdsb2JhbG1vdXNlbW92ZVwiKTtcbiAgICAgIHRoaXMuY3Vyc29yID0gZS50YXJnZXQ/LmN1cnNvcjtcbiAgICB9XG4gICAgaWYgKGFsbE1ldGhvZHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5hbGwoZSwgYWxsTWV0aG9kcyk7XG4gICAgfVxuICAgIHRoaXMuX2FsbEludGVyYWN0aXZlRWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9oaXRFbGVtZW50cy5sZW5ndGggPSAwO1xuICAgIHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cyA9IGUuY29tcG9zZWRQYXRoKCk7XG4gICAgdGhpcy5mcmVlRXZlbnQoZSk7XG4gIH1cbiAgbWFwUG9pbnRlck92ZXIoZnJvbSkge1xuICAgIGlmICghKGZyb20gaW5zdGFuY2VvZiBGZWRlcmF0ZWRQb2ludGVyRXZlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJFdmVudEJvdW5kYXJ5IGNhbm5vdCBtYXAgYSBub24tcG9pbnRlciBldmVudCBhcyBhIHBvaW50ZXIgZXZlbnRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRyYWNraW5nRGF0YSA9IHRoaXMudHJhY2tpbmdEYXRhKGZyb20ucG9pbnRlcklkKTtcbiAgICBjb25zdCBlID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSk7XG4gICAgY29uc3QgaXNNb3VzZSA9IGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInBlblwiO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlLCBcInBvaW50ZXJvdmVyXCIpO1xuICAgIGlmIChpc01vdXNlKVxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUsIFwibW91c2VvdmVyXCIpO1xuICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIpXG4gICAgICB0aGlzLmN1cnNvciA9IGUudGFyZ2V0Py5jdXJzb3I7XG4gICAgY29uc3QgZW50ZXJFdmVudCA9IHRoaXMuY2xvbmVQb2ludGVyRXZlbnQoZSwgXCJwb2ludGVyZW50ZXJcIik7XG4gICAgZW50ZXJFdmVudC5ldmVudFBoYXNlID0gZW50ZXJFdmVudC5BVF9UQVJHRVQ7XG4gICAgd2hpbGUgKGVudGVyRXZlbnQudGFyZ2V0ICYmIGVudGVyRXZlbnQudGFyZ2V0ICE9PSB0aGlzLnJvb3RUYXJnZXQucGFyZW50KSB7XG4gICAgICBlbnRlckV2ZW50LmN1cnJlbnRUYXJnZXQgPSBlbnRlckV2ZW50LnRhcmdldDtcbiAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGVudGVyRXZlbnQpO1xuICAgICAgaWYgKGlzTW91c2UpXG4gICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGVudGVyRXZlbnQsIFwibW91c2VlbnRlclwiKTtcbiAgICAgIGVudGVyRXZlbnQudGFyZ2V0ID0gZW50ZXJFdmVudC50YXJnZXQucGFyZW50O1xuICAgIH1cbiAgICB0cmFja2luZ0RhdGEub3ZlclRhcmdldHMgPSBlLmNvbXBvc2VkUGF0aCgpO1xuICAgIHRoaXMuZnJlZUV2ZW50KGUpO1xuICAgIHRoaXMuZnJlZUV2ZW50KGVudGVyRXZlbnQpO1xuICB9XG4gIG1hcFBvaW50ZXJPdXQoZnJvbSkge1xuICAgIGlmICghKGZyb20gaW5zdGFuY2VvZiBGZWRlcmF0ZWRQb2ludGVyRXZlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJFdmVudEJvdW5kYXJ5IGNhbm5vdCBtYXAgYSBub24tcG9pbnRlciBldmVudCBhcyBhIHBvaW50ZXIgZXZlbnRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRyYWNraW5nRGF0YSA9IHRoaXMudHJhY2tpbmdEYXRhKGZyb20ucG9pbnRlcklkKTtcbiAgICBpZiAodHJhY2tpbmdEYXRhLm92ZXJUYXJnZXRzKSB7XG4gICAgICBjb25zdCBpc01vdXNlID0gZnJvbS5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiIHx8IGZyb20ucG9pbnRlclR5cGUgPT09IFwicGVuXCI7XG4gICAgICBjb25zdCBvdXRUYXJnZXQgPSB0aGlzLmZpbmRNb3VudGVkVGFyZ2V0KHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cyk7XG4gICAgICBjb25zdCBvdXRFdmVudCA9IHRoaXMuY3JlYXRlUG9pbnRlckV2ZW50KGZyb20sIFwicG9pbnRlcm91dFwiLCBvdXRUYXJnZXQpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG91dEV2ZW50KTtcbiAgICAgIGlmIChpc01vdXNlKVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQob3V0RXZlbnQsIFwibW91c2VvdXRcIik7XG4gICAgICBjb25zdCBsZWF2ZUV2ZW50ID0gdGhpcy5jcmVhdGVQb2ludGVyRXZlbnQoZnJvbSwgXCJwb2ludGVybGVhdmVcIiwgb3V0VGFyZ2V0KTtcbiAgICAgIGxlYXZlRXZlbnQuZXZlbnRQaGFzZSA9IGxlYXZlRXZlbnQuQVRfVEFSR0VUO1xuICAgICAgd2hpbGUgKGxlYXZlRXZlbnQudGFyZ2V0ICYmIGxlYXZlRXZlbnQudGFyZ2V0ICE9PSB0aGlzLnJvb3RUYXJnZXQucGFyZW50KSB7XG4gICAgICAgIGxlYXZlRXZlbnQuY3VycmVudFRhcmdldCA9IGxlYXZlRXZlbnQudGFyZ2V0O1xuICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChsZWF2ZUV2ZW50KTtcbiAgICAgICAgaWYgKGlzTW91c2UpXG4gICAgICAgICAgdGhpcy5ub3RpZnlUYXJnZXQobGVhdmVFdmVudCwgXCJtb3VzZWxlYXZlXCIpO1xuICAgICAgICBsZWF2ZUV2ZW50LnRhcmdldCA9IGxlYXZlRXZlbnQudGFyZ2V0LnBhcmVudDtcbiAgICAgIH1cbiAgICAgIHRyYWNraW5nRGF0YS5vdmVyVGFyZ2V0cyA9IG51bGw7XG4gICAgICB0aGlzLmZyZWVFdmVudChvdXRFdmVudCk7XG4gICAgICB0aGlzLmZyZWVFdmVudChsZWF2ZUV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICB9XG4gIG1hcFBvaW50ZXJVcChmcm9tKSB7XG4gICAgaWYgKCEoZnJvbSBpbnN0YW5jZW9mIEZlZGVyYXRlZFBvaW50ZXJFdmVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkV2ZW50Qm91bmRhcnkgY2Fubm90IG1hcCBhIG5vbi1wb2ludGVyIGV2ZW50IGFzIGEgcG9pbnRlciBldmVudFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgZSA9IHRoaXMuY3JlYXRlUG9pbnRlckV2ZW50KGZyb20pO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlLCBcInBvaW50ZXJ1cFwiKTtcbiAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSwgXCJ0b3VjaGVuZFwiKTtcbiAgICB9IGVsc2UgaWYgKGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInBlblwiKSB7XG4gICAgICBjb25zdCBpc1JpZ2h0QnV0dG9uID0gZS5idXR0b24gPT09IDI7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSwgaXNSaWdodEJ1dHRvbiA/IFwicmlnaHR1cFwiIDogXCJtb3VzZXVwXCIpO1xuICAgIH1cbiAgICBjb25zdCB0cmFja2luZ0RhdGEgPSB0aGlzLnRyYWNraW5nRGF0YShmcm9tLnBvaW50ZXJJZCk7XG4gICAgY29uc3QgcHJlc3NUYXJnZXQgPSB0aGlzLmZpbmRNb3VudGVkVGFyZ2V0KHRyYWNraW5nRGF0YS5wcmVzc1RhcmdldHNCeUJ1dHRvbltmcm9tLmJ1dHRvbl0pO1xuICAgIGxldCBjbGlja1RhcmdldCA9IHByZXNzVGFyZ2V0O1xuICAgIGlmIChwcmVzc1RhcmdldCAmJiAhZS5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhwcmVzc1RhcmdldCkpIHtcbiAgICAgIGxldCBjdXJyZW50VGFyZ2V0ID0gcHJlc3NUYXJnZXQ7XG4gICAgICB3aGlsZSAoY3VycmVudFRhcmdldCAmJiAhZS5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhjdXJyZW50VGFyZ2V0KSkge1xuICAgICAgICBlLmN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0O1xuICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChlLCBcInBvaW50ZXJ1cG91dHNpZGVcIik7XG4gICAgICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChlLCBcInRvdWNoZW5kb3V0c2lkZVwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIgfHwgZS5wb2ludGVyVHlwZSA9PT0gXCJwZW5cIikge1xuICAgICAgICAgIGNvbnN0IGlzUmlnaHRCdXR0b24gPSBlLmJ1dHRvbiA9PT0gMjtcbiAgICAgICAgICB0aGlzLm5vdGlmeVRhcmdldChlLCBpc1JpZ2h0QnV0dG9uID8gXCJyaWdodHVwb3V0c2lkZVwiIDogXCJtb3VzZXVwb3V0c2lkZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldC5wYXJlbnQ7XG4gICAgICB9XG4gICAgICBkZWxldGUgdHJhY2tpbmdEYXRhLnByZXNzVGFyZ2V0c0J5QnV0dG9uW2Zyb20uYnV0dG9uXTtcbiAgICAgIGNsaWNrVGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbiAgICB9XG4gICAgaWYgKGNsaWNrVGFyZ2V0KSB7XG4gICAgICBjb25zdCBjbGlja0V2ZW50ID0gdGhpcy5jbG9uZVBvaW50ZXJFdmVudChlLCBcImNsaWNrXCIpO1xuICAgICAgY2xpY2tFdmVudC50YXJnZXQgPSBjbGlja1RhcmdldDtcbiAgICAgIGNsaWNrRXZlbnQucGF0aCA9IG51bGw7XG4gICAgICBpZiAoIXRyYWNraW5nRGF0YS5jbGlja3NCeUJ1dHRvbltmcm9tLmJ1dHRvbl0pIHtcbiAgICAgICAgdHJhY2tpbmdEYXRhLmNsaWNrc0J5QnV0dG9uW2Zyb20uYnV0dG9uXSA9IHtcbiAgICAgICAgICBjbGlja0NvdW50OiAwLFxuICAgICAgICAgIHRhcmdldDogY2xpY2tFdmVudC50YXJnZXQsXG4gICAgICAgICAgdGltZVN0YW1wOiBub3dcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNsaWNrSGlzdG9yeSA9IHRyYWNraW5nRGF0YS5jbGlja3NCeUJ1dHRvbltmcm9tLmJ1dHRvbl07XG4gICAgICBpZiAoY2xpY2tIaXN0b3J5LnRhcmdldCA9PT0gY2xpY2tFdmVudC50YXJnZXQgJiYgbm93IC0gY2xpY2tIaXN0b3J5LnRpbWVTdGFtcCA8IDIwMCkge1xuICAgICAgICArK2NsaWNrSGlzdG9yeS5jbGlja0NvdW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xpY2tIaXN0b3J5LmNsaWNrQ291bnQgPSAxO1xuICAgICAgfVxuICAgICAgY2xpY2tIaXN0b3J5LnRhcmdldCA9IGNsaWNrRXZlbnQudGFyZ2V0O1xuICAgICAgY2xpY2tIaXN0b3J5LnRpbWVTdGFtcCA9IG5vdztcbiAgICAgIGNsaWNrRXZlbnQuZGV0YWlsID0gY2xpY2tIaXN0b3J5LmNsaWNrQ291bnQ7XG4gICAgICBpZiAoY2xpY2tFdmVudC5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiKSB7XG4gICAgICAgIGNvbnN0IGlzUmlnaHRCdXR0b24gPSBjbGlja0V2ZW50LmJ1dHRvbiA9PT0gMjtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQsIGlzUmlnaHRCdXR0b24gPyBcInJpZ2h0Y2xpY2tcIiA6IFwiY2xpY2tcIik7XG4gICAgICB9IGVsc2UgaWYgKGNsaWNrRXZlbnQucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCwgXCJ0YXBcIik7XG4gICAgICB9XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCwgXCJwb2ludGVydGFwXCIpO1xuICAgICAgdGhpcy5mcmVlRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfVxuICAgIHRoaXMuZnJlZUV2ZW50KGUpO1xuICB9XG4gIG1hcFBvaW50ZXJVcE91dHNpZGUoZnJvbSkge1xuICAgIGlmICghKGZyb20gaW5zdGFuY2VvZiBGZWRlcmF0ZWRQb2ludGVyRXZlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJFdmVudEJvdW5kYXJ5IGNhbm5vdCBtYXAgYSBub24tcG9pbnRlciBldmVudCBhcyBhIHBvaW50ZXIgZXZlbnRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRyYWNraW5nRGF0YSA9IHRoaXMudHJhY2tpbmdEYXRhKGZyb20ucG9pbnRlcklkKTtcbiAgICBjb25zdCBwcmVzc1RhcmdldCA9IHRoaXMuZmluZE1vdW50ZWRUYXJnZXQodHJhY2tpbmdEYXRhLnByZXNzVGFyZ2V0c0J5QnV0dG9uW2Zyb20uYnV0dG9uXSk7XG4gICAgY29uc3QgZSA9IHRoaXMuY3JlYXRlUG9pbnRlckV2ZW50KGZyb20pO1xuICAgIGlmIChwcmVzc1RhcmdldCkge1xuICAgICAgbGV0IGN1cnJlbnRUYXJnZXQgPSBwcmVzc1RhcmdldDtcbiAgICAgIHdoaWxlIChjdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgIGUuY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGUsIFwicG9pbnRlcnVwb3V0c2lkZVwiKTtcbiAgICAgICAgaWYgKGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgICAgIHRoaXMubm90aWZ5VGFyZ2V0KGUsIFwidG91Y2hlbmRvdXRzaWRlXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiB8fCBlLnBvaW50ZXJUeXBlID09PSBcInBlblwiKSB7XG4gICAgICAgICAgdGhpcy5ub3RpZnlUYXJnZXQoZSwgZS5idXR0b24gPT09IDIgPyBcInJpZ2h0dXBvdXRzaWRlXCIgOiBcIm1vdXNldXBvdXRzaWRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0LnBhcmVudDtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0cmFja2luZ0RhdGEucHJlc3NUYXJnZXRzQnlCdXR0b25bZnJvbS5idXR0b25dO1xuICAgIH1cbiAgICB0aGlzLmZyZWVFdmVudChlKTtcbiAgfVxuICBtYXBXaGVlbChmcm9tKSB7XG4gICAgaWYgKCEoZnJvbSBpbnN0YW5jZW9mIEZlZGVyYXRlZFdoZWVsRXZlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJFdmVudEJvdW5kYXJ5IGNhbm5vdCBtYXAgYSBub24td2hlZWwgZXZlbnQgYXMgYSB3aGVlbCBldmVudFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgd2hlZWxFdmVudCA9IHRoaXMuY3JlYXRlV2hlZWxFdmVudChmcm9tKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQod2hlZWxFdmVudCk7XG4gICAgdGhpcy5mcmVlRXZlbnQod2hlZWxFdmVudCk7XG4gIH1cbiAgZmluZE1vdW50ZWRUYXJnZXQocHJvcGFnYXRpb25QYXRoKSB7XG4gICAgaWYgKCFwcm9wYWdhdGlvblBhdGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgY3VycmVudFRhcmdldCA9IHByb3BhZ2F0aW9uUGF0aFswXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHByb3BhZ2F0aW9uUGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHByb3BhZ2F0aW9uUGF0aFtpXS5wYXJlbnQgPT09IGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgY3VycmVudFRhcmdldCA9IHByb3BhZ2F0aW9uUGF0aFtpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VycmVudFRhcmdldDtcbiAgfVxuICBjcmVhdGVQb2ludGVyRXZlbnQoZnJvbSwgdHlwZSwgdGFyZ2V0KSB7XG4gICAgY29uc3QgZXZlbnQgPSB0aGlzLmFsbG9jYXRlRXZlbnQoRmVkZXJhdGVkUG9pbnRlckV2ZW50KTtcbiAgICB0aGlzLmNvcHlQb2ludGVyRGF0YShmcm9tLCBldmVudCk7XG4gICAgdGhpcy5jb3B5TW91c2VEYXRhKGZyb20sIGV2ZW50KTtcbiAgICB0aGlzLmNvcHlEYXRhKGZyb20sIGV2ZW50KTtcbiAgICBldmVudC5uYXRpdmVFdmVudCA9IGZyb20ubmF0aXZlRXZlbnQ7XG4gICAgZXZlbnQub3JpZ2luYWxFdmVudCA9IGZyb207XG4gICAgZXZlbnQudGFyZ2V0ID0gdGFyZ2V0ID8/IHRoaXMuaGl0VGVzdChldmVudC5nbG9iYWwueCwgZXZlbnQuZ2xvYmFsLnkpID8/IHRoaXMuX2hpdEVsZW1lbnRzWzBdO1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZXZlbnQudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIHJldHVybiBldmVudDtcbiAgfVxuICBjcmVhdGVXaGVlbEV2ZW50KGZyb20pIHtcbiAgICBjb25zdCBldmVudCA9IHRoaXMuYWxsb2NhdGVFdmVudChGZWRlcmF0ZWRXaGVlbEV2ZW50KTtcbiAgICB0aGlzLmNvcHlXaGVlbERhdGEoZnJvbSwgZXZlbnQpO1xuICAgIHRoaXMuY29weU1vdXNlRGF0YShmcm9tLCBldmVudCk7XG4gICAgdGhpcy5jb3B5RGF0YShmcm9tLCBldmVudCk7XG4gICAgZXZlbnQubmF0aXZlRXZlbnQgPSBmcm9tLm5hdGl2ZUV2ZW50O1xuICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQgPSBmcm9tO1xuICAgIGV2ZW50LnRhcmdldCA9IHRoaXMuaGl0VGVzdChldmVudC5nbG9iYWwueCwgZXZlbnQuZ2xvYmFsLnkpO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICBjbG9uZVBvaW50ZXJFdmVudChmcm9tLCB0eXBlKSB7XG4gICAgY29uc3QgZXZlbnQgPSB0aGlzLmFsbG9jYXRlRXZlbnQoRmVkZXJhdGVkUG9pbnRlckV2ZW50KTtcbiAgICBldmVudC5uYXRpdmVFdmVudCA9IGZyb20ubmF0aXZlRXZlbnQ7XG4gICAgZXZlbnQub3JpZ2luYWxFdmVudCA9IGZyb20ub3JpZ2luYWxFdmVudDtcbiAgICB0aGlzLmNvcHlQb2ludGVyRGF0YShmcm9tLCBldmVudCk7XG4gICAgdGhpcy5jb3B5TW91c2VEYXRhKGZyb20sIGV2ZW50KTtcbiAgICB0aGlzLmNvcHlEYXRhKGZyb20sIGV2ZW50KTtcbiAgICBldmVudC50YXJnZXQgPSBmcm9tLnRhcmdldDtcbiAgICBldmVudC5wYXRoID0gZnJvbS5jb21wb3NlZFBhdGgoKS5zbGljZSgpO1xuICAgIGV2ZW50LnR5cGUgPSB0eXBlID8/IGV2ZW50LnR5cGU7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIGNvcHlXaGVlbERhdGEoZnJvbSwgdG8pIHtcbiAgICB0by5kZWx0YU1vZGUgPSBmcm9tLmRlbHRhTW9kZTtcbiAgICB0by5kZWx0YVggPSBmcm9tLmRlbHRhWDtcbiAgICB0by5kZWx0YVkgPSBmcm9tLmRlbHRhWTtcbiAgICB0by5kZWx0YVogPSBmcm9tLmRlbHRhWjtcbiAgfVxuICBjb3B5UG9pbnRlckRhdGEoZnJvbSwgdG8pIHtcbiAgICBpZiAoIShmcm9tIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50ICYmIHRvIGluc3RhbmNlb2YgRmVkZXJhdGVkUG9pbnRlckV2ZW50KSlcbiAgICAgIHJldHVybjtcbiAgICB0by5wb2ludGVySWQgPSBmcm9tLnBvaW50ZXJJZDtcbiAgICB0by53aWR0aCA9IGZyb20ud2lkdGg7XG4gICAgdG8uaGVpZ2h0ID0gZnJvbS5oZWlnaHQ7XG4gICAgdG8uaXNQcmltYXJ5ID0gZnJvbS5pc1ByaW1hcnk7XG4gICAgdG8ucG9pbnRlclR5cGUgPSBmcm9tLnBvaW50ZXJUeXBlO1xuICAgIHRvLnByZXNzdXJlID0gZnJvbS5wcmVzc3VyZTtcbiAgICB0by50YW5nZW50aWFsUHJlc3N1cmUgPSBmcm9tLnRhbmdlbnRpYWxQcmVzc3VyZTtcbiAgICB0by50aWx0WCA9IGZyb20udGlsdFg7XG4gICAgdG8udGlsdFkgPSBmcm9tLnRpbHRZO1xuICAgIHRvLnR3aXN0ID0gZnJvbS50d2lzdDtcbiAgfVxuICBjb3B5TW91c2VEYXRhKGZyb20sIHRvKSB7XG4gICAgaWYgKCEoZnJvbSBpbnN0YW5jZW9mIEZlZGVyYXRlZE1vdXNlRXZlbnQgJiYgdG8gaW5zdGFuY2VvZiBGZWRlcmF0ZWRNb3VzZUV2ZW50KSlcbiAgICAgIHJldHVybjtcbiAgICB0by5hbHRLZXkgPSBmcm9tLmFsdEtleTtcbiAgICB0by5idXR0b24gPSBmcm9tLmJ1dHRvbjtcbiAgICB0by5idXR0b25zID0gZnJvbS5idXR0b25zO1xuICAgIHRvLmNsaWVudC5jb3B5RnJvbShmcm9tLmNsaWVudCk7XG4gICAgdG8uY3RybEtleSA9IGZyb20uY3RybEtleTtcbiAgICB0by5tZXRhS2V5ID0gZnJvbS5tZXRhS2V5O1xuICAgIHRvLm1vdmVtZW50LmNvcHlGcm9tKGZyb20ubW92ZW1lbnQpO1xuICAgIHRvLnNjcmVlbi5jb3B5RnJvbShmcm9tLnNjcmVlbik7XG4gICAgdG8uc2hpZnRLZXkgPSBmcm9tLnNoaWZ0S2V5O1xuICAgIHRvLmdsb2JhbC5jb3B5RnJvbShmcm9tLmdsb2JhbCk7XG4gIH1cbiAgY29weURhdGEoZnJvbSwgdG8pIHtcbiAgICB0by5pc1RydXN0ZWQgPSBmcm9tLmlzVHJ1c3RlZDtcbiAgICB0by5zcmNFbGVtZW50ID0gZnJvbS5zcmNFbGVtZW50O1xuICAgIHRvLnRpbWVTdGFtcCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRvLnR5cGUgPSBmcm9tLnR5cGU7XG4gICAgdG8uZGV0YWlsID0gZnJvbS5kZXRhaWw7XG4gICAgdG8udmlldyA9IGZyb20udmlldztcbiAgICB0by53aGljaCA9IGZyb20ud2hpY2g7XG4gICAgdG8ubGF5ZXIuY29weUZyb20oZnJvbS5sYXllcik7XG4gICAgdG8ucGFnZS5jb3B5RnJvbShmcm9tLnBhZ2UpO1xuICB9XG4gIHRyYWNraW5nRGF0YShpZCkge1xuICAgIGlmICghdGhpcy5tYXBwaW5nU3RhdGUudHJhY2tpbmdEYXRhW2lkXSkge1xuICAgICAgdGhpcy5tYXBwaW5nU3RhdGUudHJhY2tpbmdEYXRhW2lkXSA9IHtcbiAgICAgICAgcHJlc3NUYXJnZXRzQnlCdXR0b246IHt9LFxuICAgICAgICBjbGlja3NCeUJ1dHRvbjoge30sXG4gICAgICAgIG92ZXJUYXJnZXQ6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1hcHBpbmdTdGF0ZS50cmFja2luZ0RhdGFbaWRdO1xuICB9XG4gIGFsbG9jYXRlRXZlbnQoY29uc3RydWN0b3IpIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRQb29sLmhhcyhjb25zdHJ1Y3RvcikpIHtcbiAgICAgIHRoaXMuZXZlbnRQb29sLnNldChjb25zdHJ1Y3RvciwgW10pO1xuICAgIH1cbiAgICBjb25zdCBldmVudCA9IHRoaXMuZXZlbnRQb29sLmdldChjb25zdHJ1Y3RvcikucG9wKCkgfHwgbmV3IGNvbnN0cnVjdG9yKHRoaXMpO1xuICAgIGV2ZW50LmV2ZW50UGhhc2UgPSBldmVudC5OT05FO1xuICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgIGV2ZW50LnBhdGggPSBudWxsO1xuICAgIGV2ZW50LnRhcmdldCA9IG51bGw7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIGZyZWVFdmVudChldmVudCkge1xuICAgIGlmIChldmVudC5tYW5hZ2VyICE9PSB0aGlzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSXQgaXMgaWxsZWdhbCB0byBmcmVlIGFuIGV2ZW50IG5vdCBtYW5hZ2VkIGJ5IHRoaXMgRXZlbnRCb3VuZGFyeSFcIik7XG4gICAgY29uc3QgY29uc3RydWN0b3IgPSBldmVudC5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoIXRoaXMuZXZlbnRQb29sLmhhcyhjb25zdHJ1Y3RvcikpIHtcbiAgICAgIHRoaXMuZXZlbnRQb29sLnNldChjb25zdHJ1Y3RvciwgW10pO1xuICAgIH1cbiAgICB0aGlzLmV2ZW50UG9vbC5nZXQoY29uc3RydWN0b3IpLnB1c2goZXZlbnQpO1xuICB9XG4gIG5vdGlmeUxpc3RlbmVycyhlLCB0eXBlKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gZS5jdXJyZW50VGFyZ2V0Ll9ldmVudHNbdHlwZV07XG4gICAgaWYgKCFsaXN0ZW5lcnMpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFlLmN1cnJlbnRUYXJnZXQuaXNJbnRlcmFjdGl2ZSgpKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChcImZuXCIgaW4gbGlzdGVuZXJzKSB7XG4gICAgICBpZiAobGlzdGVuZXJzLm9uY2UpXG4gICAgICAgIGUuY3VycmVudFRhcmdldC5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMuZm4sIHZvaWQgMCwgdHJ1ZSk7XG4gICAgICBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGogJiYgIWUucHJvcGFnYXRpb25JbW1lZGlhdGVseVN0b3BwZWQ7IGkrKykge1xuICAgICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpXG4gICAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXS5mbiwgdm9pZCAwLCB0cnVlKTtcbiAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBFdmVudEJvdW5kYXJ5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudEJvdW5kYXJ5Lm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IEV2ZW50Qm91bmRhcnkgfSBmcm9tICcuL0V2ZW50Qm91bmRhcnkubWpzJztcbmltcG9ydCB7IEV2ZW50c1RpY2tlciB9IGZyb20gJy4vRXZlbnRUaWNrZXIubWpzJztcbmltcG9ydCB7IEZlZGVyYXRlZFBvaW50ZXJFdmVudCB9IGZyb20gJy4vRmVkZXJhdGVkUG9pbnRlckV2ZW50Lm1qcyc7XG5pbXBvcnQgeyBGZWRlcmF0ZWRXaGVlbEV2ZW50IH0gZnJvbSAnLi9GZWRlcmF0ZWRXaGVlbEV2ZW50Lm1qcyc7XG5cbmNvbnN0IE1PVVNFX1BPSU5URVJfSUQgPSAxO1xuY29uc3QgVE9VQ0hfVE9fUE9JTlRFUiA9IHtcbiAgdG91Y2hzdGFydDogXCJwb2ludGVyZG93blwiLFxuICB0b3VjaGVuZDogXCJwb2ludGVydXBcIixcbiAgdG91Y2hlbmRvdXRzaWRlOiBcInBvaW50ZXJ1cG91dHNpZGVcIixcbiAgdG91Y2htb3ZlOiBcInBvaW50ZXJtb3ZlXCIsXG4gIHRvdWNoY2FuY2VsOiBcInBvaW50ZXJjYW5jZWxcIlxufTtcbmNvbnN0IF9FdmVudFN5c3RlbSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICB0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMgPSBcIm9udG91Y2hzdGFydFwiIGluIGdsb2JhbFRoaXM7XG4gICAgdGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMgPSAhIWdsb2JhbFRoaXMuUG9pbnRlckV2ZW50O1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gMTtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5yb290Qm91bmRhcnkgPSBuZXcgRXZlbnRCb3VuZGFyeShudWxsKTtcbiAgICBFdmVudHNUaWNrZXIuaW5pdCh0aGlzKTtcbiAgICB0aGlzLmF1dG9QcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgdGhpcy5ldmVudHNBZGRlZCA9IGZhbHNlO1xuICAgIHRoaXMucm9vdFBvaW50ZXJFdmVudCA9IG5ldyBGZWRlcmF0ZWRQb2ludGVyRXZlbnQobnVsbCk7XG4gICAgdGhpcy5yb290V2hlZWxFdmVudCA9IG5ldyBGZWRlcmF0ZWRXaGVlbEV2ZW50KG51bGwpO1xuICAgIHRoaXMuY3Vyc29yU3R5bGVzID0ge1xuICAgICAgZGVmYXVsdDogXCJpbmhlcml0XCIsXG4gICAgICBwb2ludGVyOiBcInBvaW50ZXJcIlxuICAgIH07XG4gICAgdGhpcy5mZWF0dXJlcyA9IG5ldyBQcm94eSh7IC4uLl9FdmVudFN5c3RlbS5kZWZhdWx0RXZlbnRGZWF0dXJlcyB9LCB7XG4gICAgICBzZXQ6ICh0YXJnZXQsIGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJnbG9iYWxNb3ZlXCIpIHtcbiAgICAgICAgICB0aGlzLnJvb3RCb3VuZGFyeS5lbmFibGVHbG9iYWxNb3ZlRXZlbnRzID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5vblBvaW50ZXJEb3duID0gdGhpcy5vblBvaW50ZXJEb3duLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblBvaW50ZXJNb3ZlID0gdGhpcy5vblBvaW50ZXJNb3ZlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblBvaW50ZXJVcCA9IHRoaXMub25Qb2ludGVyVXAuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uUG9pbnRlck92ZXJPdXQgPSB0aGlzLm9uUG9pbnRlck92ZXJPdXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uV2hlZWwgPSB0aGlzLm9uV2hlZWwuYmluZCh0aGlzKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRFdmVudE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRFdmVudE1vZGU7XG4gIH1cbiAgaW5pdChvcHRpb25zKSB7XG4gICAgY29uc3QgeyB2aWV3LCByZXNvbHV0aW9uIH0gPSB0aGlzLnJlbmRlcmVyO1xuICAgIHRoaXMuc2V0VGFyZ2V0RWxlbWVudCh2aWV3KTtcbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgIF9FdmVudFN5c3RlbS5fZGVmYXVsdEV2ZW50TW9kZSA9IG9wdGlvbnMuZXZlbnRNb2RlID8/IFwiYXV0b1wiO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5mZWF0dXJlcywgb3B0aW9ucy5ldmVudEZlYXR1cmVzID8/IHt9KTtcbiAgICB0aGlzLnJvb3RCb3VuZGFyeS5lbmFibGVHbG9iYWxNb3ZlRXZlbnRzID0gdGhpcy5mZWF0dXJlcy5nbG9iYWxNb3ZlO1xuICB9XG4gIHJlc29sdXRpb25DaGFuZ2UocmVzb2x1dGlvbikge1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnNldFRhcmdldEVsZW1lbnQobnVsbCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gIH1cbiAgc2V0Q3Vyc29yKG1vZGUpIHtcbiAgICBtb2RlID0gbW9kZSB8fCBcImRlZmF1bHRcIjtcbiAgICBsZXQgYXBwbHlTdHlsZXMgPSB0cnVlO1xuICAgIGlmIChnbG9iYWxUaGlzLk9mZnNjcmVlbkNhbnZhcyAmJiB0aGlzLmRvbUVsZW1lbnQgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXMpIHtcbiAgICAgIGFwcGx5U3R5bGVzID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLmN1cnJlbnRDdXJzb3IgPT09IG1vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50Q3Vyc29yID0gbW9kZTtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuY3Vyc29yU3R5bGVzW21vZGVdO1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgc3dpdGNoICh0eXBlb2Ygc3R5bGUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIGlmIChhcHBseVN0eWxlcykge1xuICAgICAgICAgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLmN1cnNvciA9IHN0eWxlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgc3R5bGUobW9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICBpZiAoYXBwbHlTdHlsZXMpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5kb21FbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXBwbHlTdHlsZXMgJiYgdHlwZW9mIG1vZGUgPT09IFwic3RyaW5nXCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmN1cnNvclN0eWxlcywgbW9kZSkpIHtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5jdXJzb3IgPSBtb2RlO1xuICAgIH1cbiAgfVxuICBnZXQgcG9pbnRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5yb290UG9pbnRlckV2ZW50O1xuICB9XG4gIG9uUG9pbnRlckRvd24obmF0aXZlRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZmVhdHVyZXMuY2xpY2spXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yb290Qm91bmRhcnkucm9vdFRhcmdldCA9IHRoaXMucmVuZGVyZXIubGFzdE9iamVjdFJlbmRlcmVkO1xuICAgIGlmICh0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMgJiYgbmF0aXZlRXZlbnQucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLm5vcm1hbGl6ZVRvUG9pbnRlckRhdGEobmF0aXZlRXZlbnQpO1xuICAgIGlmICh0aGlzLmF1dG9QcmV2ZW50RGVmYXVsdCAmJiBldmVudHNbMF0uaXNOb3JtYWxpemVkKSB7XG4gICAgICBjb25zdCBjYW5jZWxhYmxlID0gbmF0aXZlRXZlbnQuY2FuY2VsYWJsZSB8fCAhKFwiY2FuY2VsYWJsZVwiIGluIG5hdGl2ZUV2ZW50KTtcbiAgICAgIGlmIChjYW5jZWxhYmxlKSB7XG4gICAgICAgIG5hdGl2ZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBqID0gZXZlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgY29uc3QgbmF0aXZlRXZlbnQyID0gZXZlbnRzW2ldO1xuICAgICAgY29uc3QgZmVkZXJhdGVkRXZlbnQgPSB0aGlzLmJvb3RzdHJhcEV2ZW50KHRoaXMucm9vdFBvaW50ZXJFdmVudCwgbmF0aXZlRXZlbnQyKTtcbiAgICAgIHRoaXMucm9vdEJvdW5kYXJ5Lm1hcEV2ZW50KGZlZGVyYXRlZEV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5zZXRDdXJzb3IodGhpcy5yb290Qm91bmRhcnkuY3Vyc29yKTtcbiAgfVxuICBvblBvaW50ZXJNb3ZlKG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzLm1vdmUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yb290Qm91bmRhcnkucm9vdFRhcmdldCA9IHRoaXMucmVuZGVyZXIubGFzdE9iamVjdFJlbmRlcmVkO1xuICAgIGlmICh0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMgJiYgbmF0aXZlRXZlbnQucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIilcbiAgICAgIHJldHVybjtcbiAgICBFdmVudHNUaWNrZXIucG9pbnRlck1vdmVkKCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZEV2ZW50cyA9IHRoaXMubm9ybWFsaXplVG9Qb2ludGVyRGF0YShuYXRpdmVFdmVudCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSBub3JtYWxpemVkRXZlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLmJvb3RzdHJhcEV2ZW50KHRoaXMucm9vdFBvaW50ZXJFdmVudCwgbm9ybWFsaXplZEV2ZW50c1tpXSk7XG4gICAgICB0aGlzLnJvb3RCb3VuZGFyeS5tYXBFdmVudChldmVudCk7XG4gICAgfVxuICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMucm9vdEJvdW5kYXJ5LmN1cnNvcik7XG4gIH1cbiAgb25Qb2ludGVyVXAobmF0aXZlRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZmVhdHVyZXMuY2xpY2spXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yb290Qm91bmRhcnkucm9vdFRhcmdldCA9IHRoaXMucmVuZGVyZXIubGFzdE9iamVjdFJlbmRlcmVkO1xuICAgIGlmICh0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMgJiYgbmF0aXZlRXZlbnQucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIilcbiAgICAgIHJldHVybjtcbiAgICBsZXQgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0O1xuICAgIGlmIChuYXRpdmVFdmVudC5jb21wb3NlZFBhdGggJiYgbmF0aXZlRXZlbnQuY29tcG9zZWRQYXRoKCkubGVuZ3RoID4gMCkge1xuICAgICAgdGFyZ2V0ID0gbmF0aXZlRXZlbnQuY29tcG9zZWRQYXRoKClbMF07XG4gICAgfVxuICAgIGNvbnN0IG91dHNpZGUgPSB0YXJnZXQgIT09IHRoaXMuZG9tRWxlbWVudCA/IFwib3V0c2lkZVwiIDogXCJcIjtcbiAgICBjb25zdCBub3JtYWxpemVkRXZlbnRzID0gdGhpcy5ub3JtYWxpemVUb1BvaW50ZXJEYXRhKG5hdGl2ZUV2ZW50KTtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IG5vcm1hbGl6ZWRFdmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBjb25zdCBldmVudCA9IHRoaXMuYm9vdHN0cmFwRXZlbnQodGhpcy5yb290UG9pbnRlckV2ZW50LCBub3JtYWxpemVkRXZlbnRzW2ldKTtcbiAgICAgIGV2ZW50LnR5cGUgKz0gb3V0c2lkZTtcbiAgICAgIHRoaXMucm9vdEJvdW5kYXJ5Lm1hcEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5zZXRDdXJzb3IodGhpcy5yb290Qm91bmRhcnkuY3Vyc29yKTtcbiAgfVxuICBvblBvaW50ZXJPdmVyT3V0KG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzLmNsaWNrKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMucm9vdEJvdW5kYXJ5LnJvb3RUYXJnZXQgPSB0aGlzLnJlbmRlcmVyLmxhc3RPYmplY3RSZW5kZXJlZDtcbiAgICBpZiAodGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzICYmIG5hdGl2ZUV2ZW50LnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgbm9ybWFsaXplZEV2ZW50cyA9IHRoaXMubm9ybWFsaXplVG9Qb2ludGVyRGF0YShuYXRpdmVFdmVudCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSBub3JtYWxpemVkRXZlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLmJvb3RzdHJhcEV2ZW50KHRoaXMucm9vdFBvaW50ZXJFdmVudCwgbm9ybWFsaXplZEV2ZW50c1tpXSk7XG4gICAgICB0aGlzLnJvb3RCb3VuZGFyeS5tYXBFdmVudChldmVudCk7XG4gICAgfVxuICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMucm9vdEJvdW5kYXJ5LmN1cnNvcik7XG4gIH1cbiAgb25XaGVlbChuYXRpdmVFdmVudCkge1xuICAgIGlmICghdGhpcy5mZWF0dXJlcy53aGVlbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB3aGVlbEV2ZW50ID0gdGhpcy5ub3JtYWxpemVXaGVlbEV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICB0aGlzLnJvb3RCb3VuZGFyeS5yb290VGFyZ2V0ID0gdGhpcy5yZW5kZXJlci5sYXN0T2JqZWN0UmVuZGVyZWQ7XG4gICAgdGhpcy5yb290Qm91bmRhcnkubWFwRXZlbnQod2hlZWxFdmVudCk7XG4gIH1cbiAgc2V0VGFyZ2V0RWxlbWVudChlbGVtZW50KSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudHMoKTtcbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBlbGVtZW50O1xuICAgIEV2ZW50c1RpY2tlci5kb21FbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmFkZEV2ZW50cygpO1xuICB9XG4gIGFkZEV2ZW50cygpIHtcbiAgICBpZiAodGhpcy5ldmVudHNBZGRlZCB8fCAhdGhpcy5kb21FbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIEV2ZW50c1RpY2tlci5hZGRUaWNrZXJMaXN0ZW5lcigpO1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5kb21FbGVtZW50LnN0eWxlO1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgaWYgKGdsb2JhbFRoaXMubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQpIHtcbiAgICAgICAgc3R5bGUubXNDb250ZW50Wm9vbWluZyA9IFwibm9uZVwiO1xuICAgICAgICBzdHlsZS5tc1RvdWNoQWN0aW9uID0gXCJub25lXCI7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzKSB7XG4gICAgICAgIHN0eWxlLnRvdWNoQWN0aW9uID0gXCJub25lXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnN1cHBvcnRzUG9pbnRlckV2ZW50cykge1xuICAgICAgZ2xvYmFsVGhpcy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgdGhpcy5vblBvaW50ZXJNb3ZlLCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy5vblBvaW50ZXJEb3duLCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmxlYXZlXCIsIHRoaXMub25Qb2ludGVyT3Zlck91dCwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJvdmVyXCIsIHRoaXMub25Qb2ludGVyT3Zlck91dCwgdHJ1ZSk7XG4gICAgICBnbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgdGhpcy5vblBvaW50ZXJVcCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsb2JhbFRoaXMuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm9uUG9pbnRlck1vdmUsIHRydWUpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5vblBvaW50ZXJEb3duLCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgdGhpcy5vblBvaW50ZXJPdmVyT3V0LCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIHRoaXMub25Qb2ludGVyT3Zlck91dCwgdHJ1ZSk7XG4gICAgICBnbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMub25Qb2ludGVyVXAsIHRydWUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzKSB7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5vblBvaW50ZXJEb3duLCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5vblBvaW50ZXJVcCwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLm9uUG9pbnRlck1vdmUsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMub25XaGVlbCwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmV2ZW50c0FkZGVkID0gdHJ1ZTtcbiAgfVxuICByZW1vdmVFdmVudHMoKSB7XG4gICAgaWYgKCF0aGlzLmV2ZW50c0FkZGVkIHx8ICF0aGlzLmRvbUVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgRXZlbnRzVGlja2VyLnJlbW92ZVRpY2tlckxpc3RlbmVyKCk7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLmRvbUVsZW1lbnQuc3R5bGU7XG4gICAgaWYgKGdsb2JhbFRoaXMubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQpIHtcbiAgICAgIHN0eWxlLm1zQ29udGVudFpvb21pbmcgPSBcIlwiO1xuICAgICAgc3R5bGUubXNUb3VjaEFjdGlvbiA9IFwiXCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN1cHBvcnRzUG9pbnRlckV2ZW50cykge1xuICAgICAgc3R5bGUudG91Y2hBY3Rpb24gPSBcIlwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMpIHtcbiAgICAgIGdsb2JhbFRoaXMuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHRoaXMub25Qb2ludGVyTW92ZSwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMub25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCB0aGlzLm9uUG9pbnRlck92ZXJPdXQsIHRydWUpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyb3ZlclwiLCB0aGlzLm9uUG9pbnRlck92ZXJPdXQsIHRydWUpO1xuICAgICAgZ2xvYmFsVGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHRoaXMub25Qb2ludGVyVXAsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbG9iYWxUaGlzLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5vblBvaW50ZXJNb3ZlLCB0cnVlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMub25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsIHRoaXMub25Qb2ludGVyT3Zlck91dCwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCB0aGlzLm9uUG9pbnRlck92ZXJPdXQsIHRydWUpO1xuICAgICAgZ2xvYmFsVGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLm9uUG9pbnRlclVwLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cykge1xuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMub25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMub25Qb2ludGVyVXAsIHRydWUpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5vblBvaW50ZXJNb3ZlLCB0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCB0aGlzLm9uV2hlZWwsIHRydWUpO1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5ldmVudHNBZGRlZCA9IGZhbHNlO1xuICB9XG4gIG1hcFBvc2l0aW9uVG9Qb2ludChwb2ludCwgeCwgeSkge1xuICAgIGxldCByZWN0O1xuICAgIGlmICghdGhpcy5kb21FbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIHJlY3QgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiB0aGlzLmRvbUVsZW1lbnQud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5kb21FbGVtZW50LmhlaWdodCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWN0ID0gdGhpcy5kb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHV0aW9uTXVsdGlwbGllciA9IDEgLyB0aGlzLnJlc29sdXRpb247XG4gICAgcG9pbnQueCA9ICh4IC0gcmVjdC5sZWZ0KSAqICh0aGlzLmRvbUVsZW1lbnQud2lkdGggLyByZWN0LndpZHRoKSAqIHJlc29sdXRpb25NdWx0aXBsaWVyO1xuICAgIHBvaW50LnkgPSAoeSAtIHJlY3QudG9wKSAqICh0aGlzLmRvbUVsZW1lbnQuaGVpZ2h0IC8gcmVjdC5oZWlnaHQpICogcmVzb2x1dGlvbk11bHRpcGxpZXI7XG4gIH1cbiAgbm9ybWFsaXplVG9Qb2ludGVyRGF0YShldmVudCkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRFdmVudHMgPSBbXTtcbiAgICBpZiAodGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzICYmIGV2ZW50IGluc3RhbmNlb2YgVG91Y2hFdmVudCkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxpID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyBpIDwgbGk7IGkrKykge1xuICAgICAgICBjb25zdCB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHRvdWNoLmJ1dHRvbiA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICB0b3VjaC5idXR0b24gPSAwO1xuICAgICAgICBpZiAodHlwZW9mIHRvdWNoLmJ1dHRvbnMgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgdG91Y2guYnV0dG9ucyA9IDE7XG4gICAgICAgIGlmICh0eXBlb2YgdG91Y2guaXNQcmltYXJ5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgdG91Y2guaXNQcmltYXJ5ID0gZXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDEgJiYgZXZlbnQudHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC53aWR0aCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICB0b3VjaC53aWR0aCA9IHRvdWNoLnJhZGl1c1ggfHwgMTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5oZWlnaHQgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgdG91Y2guaGVpZ2h0ID0gdG91Y2gucmFkaXVzWSB8fCAxO1xuICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnRpbHRYID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHRvdWNoLnRpbHRYID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC50aWx0WSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICB0b3VjaC50aWx0WSA9IDA7XG4gICAgICAgIGlmICh0eXBlb2YgdG91Y2gucG9pbnRlclR5cGUgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgdG91Y2gucG9pbnRlclR5cGUgPSBcInRvdWNoXCI7XG4gICAgICAgIGlmICh0eXBlb2YgdG91Y2gucG9pbnRlcklkID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHRvdWNoLnBvaW50ZXJJZCA9IHRvdWNoLmlkZW50aWZpZXIgfHwgMDtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5wcmVzc3VyZSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICB0b3VjaC5wcmVzc3VyZSA9IHRvdWNoLmZvcmNlIHx8IDAuNTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC50d2lzdCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICB0b3VjaC50d2lzdCA9IDA7XG4gICAgICAgIGlmICh0eXBlb2YgdG91Y2gudGFuZ2VudGlhbFByZXNzdXJlID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHRvdWNoLnRhbmdlbnRpYWxQcmVzc3VyZSA9IDA7XG4gICAgICAgIGlmICh0eXBlb2YgdG91Y2gubGF5ZXJYID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHRvdWNoLmxheWVyWCA9IHRvdWNoLm9mZnNldFggPSB0b3VjaC5jbGllbnRYO1xuICAgICAgICBpZiAodHlwZW9mIHRvdWNoLmxheWVyWSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICB0b3VjaC5sYXllclkgPSB0b3VjaC5vZmZzZXRZID0gdG91Y2guY2xpZW50WTtcbiAgICAgICAgdG91Y2guaXNOb3JtYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgdG91Y2gudHlwZSA9IGV2ZW50LnR5cGU7XG4gICAgICAgIG5vcm1hbGl6ZWRFdmVudHMucHVzaCh0b3VjaCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghZ2xvYmFsVGhpcy5Nb3VzZUV2ZW50IHx8IGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCAmJiAoIXRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzIHx8ICEoZXZlbnQgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLlBvaW50ZXJFdmVudCkpKSB7XG4gICAgICBjb25zdCB0ZW1wRXZlbnQgPSBldmVudDtcbiAgICAgIGlmICh0eXBlb2YgdGVtcEV2ZW50LmlzUHJpbWFyeSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgdGVtcEV2ZW50LmlzUHJpbWFyeSA9IHRydWU7XG4gICAgICBpZiAodHlwZW9mIHRlbXBFdmVudC53aWR0aCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgdGVtcEV2ZW50LndpZHRoID0gMTtcbiAgICAgIGlmICh0eXBlb2YgdGVtcEV2ZW50LmhlaWdodCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgdGVtcEV2ZW50LmhlaWdodCA9IDE7XG4gICAgICBpZiAodHlwZW9mIHRlbXBFdmVudC50aWx0WCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgdGVtcEV2ZW50LnRpbHRYID0gMDtcbiAgICAgIGlmICh0eXBlb2YgdGVtcEV2ZW50LnRpbHRZID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0ZW1wRXZlbnQudGlsdFkgPSAwO1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wRXZlbnQucG9pbnRlclR5cGUgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRlbXBFdmVudC5wb2ludGVyVHlwZSA9IFwibW91c2VcIjtcbiAgICAgIGlmICh0eXBlb2YgdGVtcEV2ZW50LnBvaW50ZXJJZCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgdGVtcEV2ZW50LnBvaW50ZXJJZCA9IE1PVVNFX1BPSU5URVJfSUQ7XG4gICAgICBpZiAodHlwZW9mIHRlbXBFdmVudC5wcmVzc3VyZSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgdGVtcEV2ZW50LnByZXNzdXJlID0gMC41O1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wRXZlbnQudHdpc3QgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRlbXBFdmVudC50d2lzdCA9IDA7XG4gICAgICBpZiAodHlwZW9mIHRlbXBFdmVudC50YW5nZW50aWFsUHJlc3N1cmUgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHRlbXBFdmVudC50YW5nZW50aWFsUHJlc3N1cmUgPSAwO1xuICAgICAgdGVtcEV2ZW50LmlzTm9ybWFsaXplZCA9IHRydWU7XG4gICAgICBub3JtYWxpemVkRXZlbnRzLnB1c2godGVtcEV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9ybWFsaXplZEV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRFdmVudHM7XG4gIH1cbiAgbm9ybWFsaXplV2hlZWxFdmVudChuYXRpdmVFdmVudCkge1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5yb290V2hlZWxFdmVudDtcbiAgICB0aGlzLnRyYW5zZmVyTW91c2VEYXRhKGV2ZW50LCBuYXRpdmVFdmVudCk7XG4gICAgZXZlbnQuZGVsdGFYID0gbmF0aXZlRXZlbnQuZGVsdGFYO1xuICAgIGV2ZW50LmRlbHRhWSA9IG5hdGl2ZUV2ZW50LmRlbHRhWTtcbiAgICBldmVudC5kZWx0YVogPSBuYXRpdmVFdmVudC5kZWx0YVo7XG4gICAgZXZlbnQuZGVsdGFNb2RlID0gbmF0aXZlRXZlbnQuZGVsdGFNb2RlO1xuICAgIHRoaXMubWFwUG9zaXRpb25Ub1BvaW50KGV2ZW50LnNjcmVlbiwgbmF0aXZlRXZlbnQuY2xpZW50WCwgbmF0aXZlRXZlbnQuY2xpZW50WSk7XG4gICAgZXZlbnQuZ2xvYmFsLmNvcHlGcm9tKGV2ZW50LnNjcmVlbik7XG4gICAgZXZlbnQub2Zmc2V0LmNvcHlGcm9tKGV2ZW50LnNjcmVlbik7XG4gICAgZXZlbnQubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICBldmVudC50eXBlID0gbmF0aXZlRXZlbnQudHlwZTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgYm9vdHN0cmFwRXZlbnQoZXZlbnQsIG5hdGl2ZUV2ZW50KSB7XG4gICAgZXZlbnQub3JpZ2luYWxFdmVudCA9IG51bGw7XG4gICAgZXZlbnQubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICBldmVudC5wb2ludGVySWQgPSBuYXRpdmVFdmVudC5wb2ludGVySWQ7XG4gICAgZXZlbnQud2lkdGggPSBuYXRpdmVFdmVudC53aWR0aDtcbiAgICBldmVudC5oZWlnaHQgPSBuYXRpdmVFdmVudC5oZWlnaHQ7XG4gICAgZXZlbnQuaXNQcmltYXJ5ID0gbmF0aXZlRXZlbnQuaXNQcmltYXJ5O1xuICAgIGV2ZW50LnBvaW50ZXJUeXBlID0gbmF0aXZlRXZlbnQucG9pbnRlclR5cGU7XG4gICAgZXZlbnQucHJlc3N1cmUgPSBuYXRpdmVFdmVudC5wcmVzc3VyZTtcbiAgICBldmVudC50YW5nZW50aWFsUHJlc3N1cmUgPSBuYXRpdmVFdmVudC50YW5nZW50aWFsUHJlc3N1cmU7XG4gICAgZXZlbnQudGlsdFggPSBuYXRpdmVFdmVudC50aWx0WDtcbiAgICBldmVudC50aWx0WSA9IG5hdGl2ZUV2ZW50LnRpbHRZO1xuICAgIGV2ZW50LnR3aXN0ID0gbmF0aXZlRXZlbnQudHdpc3Q7XG4gICAgdGhpcy50cmFuc2Zlck1vdXNlRGF0YShldmVudCwgbmF0aXZlRXZlbnQpO1xuICAgIHRoaXMubWFwUG9zaXRpb25Ub1BvaW50KGV2ZW50LnNjcmVlbiwgbmF0aXZlRXZlbnQuY2xpZW50WCwgbmF0aXZlRXZlbnQuY2xpZW50WSk7XG4gICAgZXZlbnQuZ2xvYmFsLmNvcHlGcm9tKGV2ZW50LnNjcmVlbik7XG4gICAgZXZlbnQub2Zmc2V0LmNvcHlGcm9tKGV2ZW50LnNjcmVlbik7XG4gICAgZXZlbnQuaXNUcnVzdGVkID0gbmF0aXZlRXZlbnQuaXNUcnVzdGVkO1xuICAgIGlmIChldmVudC50eXBlID09PSBcInBvaW50ZXJsZWF2ZVwiKSB7XG4gICAgICBldmVudC50eXBlID0gXCJwb2ludGVyb3V0XCI7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlLnN0YXJ0c1dpdGgoXCJtb3VzZVwiKSkge1xuICAgICAgZXZlbnQudHlwZSA9IGV2ZW50LnR5cGUucmVwbGFjZShcIm1vdXNlXCIsIFwicG9pbnRlclwiKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnR5cGUuc3RhcnRzV2l0aChcInRvdWNoXCIpKSB7XG4gICAgICBldmVudC50eXBlID0gVE9VQ0hfVE9fUE9JTlRFUltldmVudC50eXBlXSB8fCBldmVudC50eXBlO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgdHJhbnNmZXJNb3VzZURhdGEoZXZlbnQsIG5hdGl2ZUV2ZW50KSB7XG4gICAgZXZlbnQuaXNUcnVzdGVkID0gbmF0aXZlRXZlbnQuaXNUcnVzdGVkO1xuICAgIGV2ZW50LnNyY0VsZW1lbnQgPSBuYXRpdmVFdmVudC5zcmNFbGVtZW50O1xuICAgIGV2ZW50LnRpbWVTdGFtcCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGV2ZW50LnR5cGUgPSBuYXRpdmVFdmVudC50eXBlO1xuICAgIGV2ZW50LmFsdEtleSA9IG5hdGl2ZUV2ZW50LmFsdEtleTtcbiAgICBldmVudC5idXR0b24gPSBuYXRpdmVFdmVudC5idXR0b247XG4gICAgZXZlbnQuYnV0dG9ucyA9IG5hdGl2ZUV2ZW50LmJ1dHRvbnM7XG4gICAgZXZlbnQuY2xpZW50LnggPSBuYXRpdmVFdmVudC5jbGllbnRYO1xuICAgIGV2ZW50LmNsaWVudC55ID0gbmF0aXZlRXZlbnQuY2xpZW50WTtcbiAgICBldmVudC5jdHJsS2V5ID0gbmF0aXZlRXZlbnQuY3RybEtleTtcbiAgICBldmVudC5tZXRhS2V5ID0gbmF0aXZlRXZlbnQubWV0YUtleTtcbiAgICBldmVudC5tb3ZlbWVudC54ID0gbmF0aXZlRXZlbnQubW92ZW1lbnRYO1xuICAgIGV2ZW50Lm1vdmVtZW50LnkgPSBuYXRpdmVFdmVudC5tb3ZlbWVudFk7XG4gICAgZXZlbnQucGFnZS54ID0gbmF0aXZlRXZlbnQucGFnZVg7XG4gICAgZXZlbnQucGFnZS55ID0gbmF0aXZlRXZlbnQucGFnZVk7XG4gICAgZXZlbnQucmVsYXRlZFRhcmdldCA9IG51bGw7XG4gICAgZXZlbnQuc2hpZnRLZXkgPSBuYXRpdmVFdmVudC5zaGlmdEtleTtcbiAgfVxufTtcbmxldCBFdmVudFN5c3RlbSA9IF9FdmVudFN5c3RlbTtcbkV2ZW50U3lzdGVtLmV4dGVuc2lvbiA9IHtcbiAgbmFtZTogXCJldmVudHNcIixcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW0sXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNSZW5kZXJlclN5c3RlbVxuICBdXG59O1xuRXZlbnRTeXN0ZW0uZGVmYXVsdEV2ZW50RmVhdHVyZXMgPSB7XG4gIG1vdmU6IHRydWUsXG4gIGdsb2JhbE1vdmU6IHRydWUsXG4gIGNsaWNrOiB0cnVlLFxuICB3aGVlbDogdHJ1ZVxufTtcbmV4dGVuc2lvbnMuYWRkKEV2ZW50U3lzdGVtKTtcblxuZXhwb3J0IHsgRXZlbnRTeXN0ZW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50U3lzdGVtLm1qcy5tYXBcbiIsImltcG9ydCB7IHV0aWxzIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBEaXNwbGF5T2JqZWN0IH0gZnJvbSAnQHBpeGkvZGlzcGxheSc7XG5pbXBvcnQgeyBFdmVudFN5c3RlbSB9IGZyb20gJy4vRXZlbnRTeXN0ZW0ubWpzJztcbmltcG9ydCB7IEZlZGVyYXRlZEV2ZW50IH0gZnJvbSAnLi9GZWRlcmF0ZWRFdmVudC5tanMnO1xuXG5mdW5jdGlvbiBjb252ZXJ0RXZlbnRNb2RlVG9JbnRlcmFjdGl2ZU1vZGUobW9kZSkge1xuICByZXR1cm4gbW9kZSA9PT0gXCJkeW5hbWljXCIgfHwgbW9kZSA9PT0gXCJzdGF0aWNcIjtcbn1cbmNvbnN0IEZlZGVyYXRlZERpc3BsYXlPYmplY3QgPSB7XG4gIG9uY2xpY2s6IG51bGwsXG4gIG9ubW91c2Vkb3duOiBudWxsLFxuICBvbm1vdXNlZW50ZXI6IG51bGwsXG4gIG9ubW91c2VsZWF2ZTogbnVsbCxcbiAgb25tb3VzZW1vdmU6IG51bGwsXG4gIG9uZ2xvYmFsbW91c2Vtb3ZlOiBudWxsLFxuICBvbm1vdXNlb3V0OiBudWxsLFxuICBvbm1vdXNlb3ZlcjogbnVsbCxcbiAgb25tb3VzZXVwOiBudWxsLFxuICBvbm1vdXNldXBvdXRzaWRlOiBudWxsLFxuICBvbnBvaW50ZXJjYW5jZWw6IG51bGwsXG4gIG9ucG9pbnRlcmRvd246IG51bGwsXG4gIG9ucG9pbnRlcmVudGVyOiBudWxsLFxuICBvbnBvaW50ZXJsZWF2ZTogbnVsbCxcbiAgb25wb2ludGVybW92ZTogbnVsbCxcbiAgb25nbG9iYWxwb2ludGVybW92ZTogbnVsbCxcbiAgb25wb2ludGVyb3V0OiBudWxsLFxuICBvbnBvaW50ZXJvdmVyOiBudWxsLFxuICBvbnBvaW50ZXJ0YXA6IG51bGwsXG4gIG9ucG9pbnRlcnVwOiBudWxsLFxuICBvbnBvaW50ZXJ1cG91dHNpZGU6IG51bGwsXG4gIG9ucmlnaHRjbGljazogbnVsbCxcbiAgb25yaWdodGRvd246IG51bGwsXG4gIG9ucmlnaHR1cDogbnVsbCxcbiAgb25yaWdodHVwb3V0c2lkZTogbnVsbCxcbiAgb250YXA6IG51bGwsXG4gIG9udG91Y2hjYW5jZWw6IG51bGwsXG4gIG9udG91Y2hlbmQ6IG51bGwsXG4gIG9udG91Y2hlbmRvdXRzaWRlOiBudWxsLFxuICBvbnRvdWNobW92ZTogbnVsbCxcbiAgb25nbG9iYWx0b3VjaG1vdmU6IG51bGwsXG4gIG9udG91Y2hzdGFydDogbnVsbCxcbiAgb253aGVlbDogbnVsbCxcbiAgX2ludGVybmFsSW50ZXJhY3RpdmU6IHZvaWQgMCxcbiAgZ2V0IGludGVyYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbEludGVyYWN0aXZlID8/IGNvbnZlcnRFdmVudE1vZGVUb0ludGVyYWN0aXZlTW9kZShFdmVudFN5c3RlbS5kZWZhdWx0RXZlbnRNb2RlKTtcbiAgfSxcbiAgc2V0IGludGVyYWN0aXZlKHZhbHVlKSB7XG4gICAgdXRpbHMuZGVwcmVjYXRpb24oXCI3LjIuMFwiLCBgU2V0dGluZyBpbnRlcmFjdGl2ZSBpcyBkZXByZWNhdGVkLCB1c2UgZXZlbnRNb2RlID0gJ25vbmUnLydwYXNzaXZlJy8nYXV0bycvJ3N0YXRpYycvJ2R5bmFtaWMnIGluc3RlYWQuYCk7XG4gICAgdGhpcy5faW50ZXJuYWxJbnRlcmFjdGl2ZSA9IHZhbHVlO1xuICAgIHRoaXMuZXZlbnRNb2RlID0gdmFsdWUgPyBcInN0YXRpY1wiIDogXCJhdXRvXCI7XG4gIH0sXG4gIF9pbnRlcm5hbEV2ZW50TW9kZTogdm9pZCAwLFxuICBnZXQgZXZlbnRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbEV2ZW50TW9kZSA/PyBFdmVudFN5c3RlbS5kZWZhdWx0RXZlbnRNb2RlO1xuICB9LFxuICBzZXQgZXZlbnRNb2RlKHZhbHVlKSB7XG4gICAgdGhpcy5faW50ZXJuYWxJbnRlcmFjdGl2ZSA9IGNvbnZlcnRFdmVudE1vZGVUb0ludGVyYWN0aXZlTW9kZSh2YWx1ZSk7XG4gICAgdGhpcy5faW50ZXJuYWxFdmVudE1vZGUgPSB2YWx1ZTtcbiAgfSxcbiAgaXNJbnRlcmFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ldmVudE1vZGUgPT09IFwic3RhdGljXCIgfHwgdGhpcy5ldmVudE1vZGUgPT09IFwiZHluYW1pY1wiO1xuICB9LFxuICBpbnRlcmFjdGl2ZUNoaWxkcmVuOiB0cnVlLFxuICBoaXRBcmVhOiBudWxsLFxuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2FwdHVyZSA9IHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIiAmJiBvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuY2FwdHVyZTtcbiAgICBjb25zdCBjb250ZXh0ID0gdHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIgPyB2b2lkIDAgOiBsaXN0ZW5lcjtcbiAgICB0eXBlID0gY2FwdHVyZSA/IGAke3R5cGV9Y2FwdHVyZWAgOiB0eXBlO1xuICAgIGxpc3RlbmVyID0gdHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIgPyBsaXN0ZW5lciA6IGxpc3RlbmVyLmhhbmRsZUV2ZW50O1xuICAgIHRoaXMub24odHlwZSwgbGlzdGVuZXIsIGNvbnRleHQpO1xuICB9LFxuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2FwdHVyZSA9IHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIiAmJiBvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuY2FwdHVyZTtcbiAgICBjb25zdCBjb250ZXh0ID0gdHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIgPyB2b2lkIDAgOiBsaXN0ZW5lcjtcbiAgICB0eXBlID0gY2FwdHVyZSA/IGAke3R5cGV9Y2FwdHVyZWAgOiB0eXBlO1xuICAgIGxpc3RlbmVyID0gdHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIgPyBsaXN0ZW5lciA6IGxpc3RlbmVyLmhhbmRsZUV2ZW50O1xuICAgIHRoaXMub2ZmKHR5cGUsIGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgfSxcbiAgZGlzcGF0Y2hFdmVudChlKSB7XG4gICAgaWYgKCEoZSBpbnN0YW5jZW9mIEZlZGVyYXRlZEV2ZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzcGxheU9iamVjdCBjYW5ub3QgcHJvcGFnYXRlIGV2ZW50cyBvdXRzaWRlIG9mIHRoZSBGZWRlcmF0ZWQgRXZlbnRzIEFQSVwiKTtcbiAgICB9XG4gICAgZS5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG4gICAgZS5wYXRoID0gbnVsbDtcbiAgICBlLnRhcmdldCA9IHRoaXM7XG4gICAgZS5tYW5hZ2VyLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgcmV0dXJuICFlLmRlZmF1bHRQcmV2ZW50ZWQ7XG4gIH1cbn07XG5EaXNwbGF5T2JqZWN0Lm1peGluKEZlZGVyYXRlZERpc3BsYXlPYmplY3QpO1xuXG5leHBvcnQgeyBGZWRlcmF0ZWREaXNwbGF5T2JqZWN0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GZWRlcmF0ZWRFdmVudFRhcmdldC5tanMubWFwXG4iLCJleHBvcnQgeyBFdmVudEJvdW5kYXJ5IH0gZnJvbSAnLi9FdmVudEJvdW5kYXJ5Lm1qcyc7XG5leHBvcnQgeyBFdmVudFN5c3RlbSB9IGZyb20gJy4vRXZlbnRTeXN0ZW0ubWpzJztcbmV4cG9ydCB7IEZlZGVyYXRlZEV2ZW50IH0gZnJvbSAnLi9GZWRlcmF0ZWRFdmVudC5tanMnO1xuaW1wb3J0ICcuL0ZlZGVyYXRlZEV2ZW50TWFwLm1qcyc7XG5leHBvcnQgeyBGZWRlcmF0ZWREaXNwbGF5T2JqZWN0IH0gZnJvbSAnLi9GZWRlcmF0ZWRFdmVudFRhcmdldC5tanMnO1xuZXhwb3J0IHsgRmVkZXJhdGVkTW91c2VFdmVudCB9IGZyb20gJy4vRmVkZXJhdGVkTW91c2VFdmVudC5tanMnO1xuZXhwb3J0IHsgRmVkZXJhdGVkUG9pbnRlckV2ZW50IH0gZnJvbSAnLi9GZWRlcmF0ZWRQb2ludGVyRXZlbnQubWpzJztcbmV4cG9ydCB7IEZlZGVyYXRlZFdoZWVsRXZlbnQgfSBmcm9tICcuL0ZlZGVyYXRlZFdoZWVsRXZlbnQubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImNvbnN0IGFjY2Vzc2libGVUYXJnZXQgPSB7XG4gIGFjY2Vzc2libGU6IGZhbHNlLFxuICBhY2Nlc3NpYmxlVGl0bGU6IG51bGwsXG4gIGFjY2Vzc2libGVIaW50OiBudWxsLFxuICB0YWJJbmRleDogMCxcbiAgX2FjY2Vzc2libGVBY3RpdmU6IGZhbHNlLFxuICBfYWNjZXNzaWJsZURpdjogbnVsbCxcbiAgYWNjZXNzaWJsZVR5cGU6IFwiYnV0dG9uXCIsXG4gIGFjY2Vzc2libGVQb2ludGVyRXZlbnRzOiBcImF1dG9cIixcbiAgYWNjZXNzaWJsZUNoaWxkcmVuOiB0cnVlLFxuICByZW5kZXJJZDogLTFcbn07XG5cbmV4cG9ydCB7IGFjY2Vzc2libGVUYXJnZXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjY2Vzc2libGVUYXJnZXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgdXRpbHMsIEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IERpc3BsYXlPYmplY3QgfSBmcm9tICdAcGl4aS9kaXNwbGF5JztcbmltcG9ydCB7IEZlZGVyYXRlZEV2ZW50IH0gZnJvbSAnQHBpeGkvZXZlbnRzJztcbmltcG9ydCB7IGFjY2Vzc2libGVUYXJnZXQgfSBmcm9tICcuL2FjY2Vzc2libGVUYXJnZXQubWpzJztcblxuRGlzcGxheU9iamVjdC5taXhpbihhY2Nlc3NpYmxlVGFyZ2V0KTtcbmNvbnN0IEtFWV9DT0RFX1RBQiA9IDk7XG5jb25zdCBESVZfVE9VQ0hfU0laRSA9IDEwMDtcbmNvbnN0IERJVl9UT1VDSF9QT1NfWCA9IDA7XG5jb25zdCBESVZfVE9VQ0hfUE9TX1kgPSAwO1xuY29uc3QgRElWX1RPVUNIX1pJTkRFWCA9IDI7XG5jb25zdCBESVZfSE9PS19TSVpFID0gMTtcbmNvbnN0IERJVl9IT09LX1BPU19YID0gLTFlMztcbmNvbnN0IERJVl9IT09LX1BPU19ZID0gLTFlMztcbmNvbnN0IERJVl9IT09LX1pJTkRFWCA9IDI7XG5jbGFzcyBBY2Nlc3NpYmlsaXR5TWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5kZWJ1ZyA9IGZhbHNlO1xuICAgIHRoaXMuX2lzQWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5faXNNb2JpbGVBY2Nlc3NpYmlsaXR5ID0gZmFsc2U7XG4gICAgdGhpcy5wb29sID0gW107XG4gICAgdGhpcy5yZW5kZXJJZCA9IDA7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMuYW5kcm9pZFVwZGF0ZUNvdW50ID0gMDtcbiAgICB0aGlzLmFuZHJvaWRVcGRhdGVGcmVxdWVuY3kgPSA1MDA7XG4gICAgdGhpcy5faG9va0RpdiA9IG51bGw7XG4gICAgaWYgKHV0aWxzLmlzTW9iaWxlLnRhYmxldCB8fCB1dGlscy5pc01vYmlsZS5waG9uZSkge1xuICAgICAgdGhpcy5jcmVhdGVUb3VjaEhvb2soKTtcbiAgICB9XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuc3R5bGUud2lkdGggPSBgJHtESVZfVE9VQ0hfU0laRX1weGA7XG4gICAgZGl2LnN0eWxlLmhlaWdodCA9IGAke0RJVl9UT1VDSF9TSVpFfXB4YDtcbiAgICBkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgZGl2LnN0eWxlLnRvcCA9IGAke0RJVl9UT1VDSF9QT1NfWH1weGA7XG4gICAgZGl2LnN0eWxlLmxlZnQgPSBgJHtESVZfVE9VQ0hfUE9TX1l9cHhgO1xuICAgIGRpdi5zdHlsZS56SW5kZXggPSBESVZfVE9VQ0hfWklOREVYLnRvU3RyaW5nKCk7XG4gICAgdGhpcy5kaXYgPSBkaXY7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMuX29uS2V5RG93biA9IHRoaXMuX29uS2V5RG93bi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uTW91c2VNb3ZlID0gdGhpcy5fb25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICBnbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX29uS2V5RG93biwgZmFsc2UpO1xuICB9XG4gIGdldCBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNBY3RpdmU7XG4gIH1cbiAgZ2V0IGlzTW9iaWxlQWNjZXNzaWJpbGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNNb2JpbGVBY2Nlc3NpYmlsaXR5O1xuICB9XG4gIGNyZWF0ZVRvdWNoSG9vaygpIHtcbiAgICBjb25zdCBob29rRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBob29rRGl2LnN0eWxlLndpZHRoID0gYCR7RElWX0hPT0tfU0laRX1weGA7XG4gICAgaG9va0Rpdi5zdHlsZS5oZWlnaHQgPSBgJHtESVZfSE9PS19TSVpFfXB4YDtcbiAgICBob29rRGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIGhvb2tEaXYuc3R5bGUudG9wID0gYCR7RElWX0hPT0tfUE9TX1h9cHhgO1xuICAgIGhvb2tEaXYuc3R5bGUubGVmdCA9IGAke0RJVl9IT09LX1BPU19ZfXB4YDtcbiAgICBob29rRGl2LnN0eWxlLnpJbmRleCA9IERJVl9IT09LX1pJTkRFWC50b1N0cmluZygpO1xuICAgIGhvb2tEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCIjRkYwMDAwXCI7XG4gICAgaG9va0Rpdi50aXRsZSA9IFwic2VsZWN0IHRvIGVuYWJsZSBhY2Nlc3NpYmlsaXR5IGZvciB0aGlzIGNvbnRlbnRcIjtcbiAgICBob29rRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pc01vYmlsZUFjY2Vzc2liaWxpdHkgPSB0cnVlO1xuICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgdGhpcy5kZXN0cm95VG91Y2hIb29rKCk7XG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChob29rRGl2KTtcbiAgICB0aGlzLl9ob29rRGl2ID0gaG9va0RpdjtcbiAgfVxuICBkZXN0cm95VG91Y2hIb29rKCkge1xuICAgIGlmICghdGhpcy5faG9va0Rpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuX2hvb2tEaXYpO1xuICAgIHRoaXMuX2hvb2tEaXYgPSBudWxsO1xuICB9XG4gIGFjdGl2YXRlKCkge1xuICAgIGlmICh0aGlzLl9pc0FjdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9pc0FjdGl2ZSA9IHRydWU7XG4gICAgZ2xvYmFsVGhpcy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uTW91c2VNb3ZlLCB0cnVlKTtcbiAgICBnbG9iYWxUaGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX29uS2V5RG93biwgZmFsc2UpO1xuICAgIHRoaXMucmVuZGVyZXIub24oXCJwb3N0cmVuZGVyXCIsIHRoaXMudXBkYXRlLCB0aGlzKTtcbiAgICB0aGlzLnJlbmRlcmVyLnZpZXcucGFyZW50Tm9kZT8uYXBwZW5kQ2hpbGQodGhpcy5kaXYpO1xuICB9XG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgaWYgKCF0aGlzLl9pc0FjdGl2ZSB8fCB0aGlzLl9pc01vYmlsZUFjY2Vzc2liaWxpdHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faXNBY3RpdmUgPSBmYWxzZTtcbiAgICBnbG9iYWxUaGlzLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25Nb3VzZU1vdmUsIHRydWUpO1xuICAgIGdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fb25LZXlEb3duLCBmYWxzZSk7XG4gICAgdGhpcy5yZW5kZXJlci5vZmYoXCJwb3N0cmVuZGVyXCIsIHRoaXMudXBkYXRlKTtcbiAgICB0aGlzLmRpdi5wYXJlbnROb2RlPy5yZW1vdmVDaGlsZCh0aGlzLmRpdik7XG4gIH1cbiAgdXBkYXRlQWNjZXNzaWJsZU9iamVjdHMoZGlzcGxheU9iamVjdCkge1xuICAgIGlmICghZGlzcGxheU9iamVjdC52aXNpYmxlIHx8ICFkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVDaGlsZHJlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlICYmIGRpc3BsYXlPYmplY3QuaXNJbnRlcmFjdGl2ZSgpKSB7XG4gICAgICBpZiAoIWRpc3BsYXlPYmplY3QuX2FjY2Vzc2libGVBY3RpdmUpIHtcbiAgICAgICAgdGhpcy5hZGRDaGlsZChkaXNwbGF5T2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIGRpc3BsYXlPYmplY3QucmVuZGVySWQgPSB0aGlzLnJlbmRlcklkO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZHJlbiA9IGRpc3BsYXlPYmplY3QuY2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQWNjZXNzaWJsZU9iamVjdHMoY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgaWYgKHV0aWxzLmlzTW9iaWxlLmFuZHJvaWQuZGV2aWNlICYmIG5vdyA8IHRoaXMuYW5kcm9pZFVwZGF0ZUNvdW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYW5kcm9pZFVwZGF0ZUNvdW50ID0gbm93ICsgdGhpcy5hbmRyb2lkVXBkYXRlRnJlcXVlbmN5O1xuICAgIGlmICghdGhpcy5yZW5kZXJlci5yZW5kZXJpbmdUb1NjcmVlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZW5kZXJlci5sYXN0T2JqZWN0UmVuZGVyZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlQWNjZXNzaWJsZU9iamVjdHModGhpcy5yZW5kZXJlci5sYXN0T2JqZWN0UmVuZGVyZWQpO1xuICAgIH1cbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMucmVuZGVyZXIudmlldy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB7IHdpZHRoOiB2aWV3V2lkdGgsIGhlaWdodDogdmlld0hlaWdodCwgcmVzb2x1dGlvbiB9ID0gdGhpcy5yZW5kZXJlcjtcbiAgICBjb25zdCBzeCA9IHdpZHRoIC8gdmlld1dpZHRoICogcmVzb2x1dGlvbjtcbiAgICBjb25zdCBzeSA9IGhlaWdodCAvIHZpZXdIZWlnaHQgKiByZXNvbHV0aW9uO1xuICAgIGxldCBkaXYgPSB0aGlzLmRpdjtcbiAgICBkaXYuc3R5bGUubGVmdCA9IGAke3h9cHhgO1xuICAgIGRpdi5zdHlsZS50b3AgPSBgJHt5fXB4YDtcbiAgICBkaXYuc3R5bGUud2lkdGggPSBgJHt2aWV3V2lkdGh9cHhgO1xuICAgIGRpdi5zdHlsZS5oZWlnaHQgPSBgJHt2aWV3SGVpZ2h0fXB4YDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChjaGlsZC5yZW5kZXJJZCAhPT0gdGhpcy5yZW5kZXJJZCkge1xuICAgICAgICBjaGlsZC5fYWNjZXNzaWJsZUFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB1dGlscy5yZW1vdmVJdGVtcyh0aGlzLmNoaWxkcmVuLCBpLCAxKTtcbiAgICAgICAgdGhpcy5kaXYucmVtb3ZlQ2hpbGQoY2hpbGQuX2FjY2Vzc2libGVEaXYpO1xuICAgICAgICB0aGlzLnBvb2wucHVzaChjaGlsZC5fYWNjZXNzaWJsZURpdik7XG4gICAgICAgIGNoaWxkLl9hY2Nlc3NpYmxlRGl2ID0gbnVsbDtcbiAgICAgICAgaS0tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGl2ID0gY2hpbGQuX2FjY2Vzc2libGVEaXY7XG4gICAgICAgIGxldCBoaXRBcmVhID0gY2hpbGQuaGl0QXJlYTtcbiAgICAgICAgY29uc3Qgd3QgPSBjaGlsZC53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgaWYgKGNoaWxkLmhpdEFyZWEpIHtcbiAgICAgICAgICBkaXYuc3R5bGUubGVmdCA9IGAkeyh3dC50eCArIGhpdEFyZWEueCAqIHd0LmEpICogc3h9cHhgO1xuICAgICAgICAgIGRpdi5zdHlsZS50b3AgPSBgJHsod3QudHkgKyBoaXRBcmVhLnkgKiB3dC5kKSAqIHN5fXB4YDtcbiAgICAgICAgICBkaXYuc3R5bGUud2lkdGggPSBgJHtoaXRBcmVhLndpZHRoICogd3QuYSAqIHN4fXB4YDtcbiAgICAgICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gYCR7aGl0QXJlYS5oZWlnaHQgKiB3dC5kICogc3l9cHhgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhpdEFyZWEgPSBjaGlsZC5nZXRCb3VuZHMoKTtcbiAgICAgICAgICB0aGlzLmNhcEhpdEFyZWEoaGl0QXJlYSk7XG4gICAgICAgICAgZGl2LnN0eWxlLmxlZnQgPSBgJHtoaXRBcmVhLnggKiBzeH1weGA7XG4gICAgICAgICAgZGl2LnN0eWxlLnRvcCA9IGAke2hpdEFyZWEueSAqIHN5fXB4YDtcbiAgICAgICAgICBkaXYuc3R5bGUud2lkdGggPSBgJHtoaXRBcmVhLndpZHRoICogc3h9cHhgO1xuICAgICAgICAgIGRpdi5zdHlsZS5oZWlnaHQgPSBgJHtoaXRBcmVhLmhlaWdodCAqIHN5fXB4YDtcbiAgICAgICAgICBpZiAoZGl2LnRpdGxlICE9PSBjaGlsZC5hY2Nlc3NpYmxlVGl0bGUgJiYgY2hpbGQuYWNjZXNzaWJsZVRpdGxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkaXYudGl0bGUgPSBjaGlsZC5hY2Nlc3NpYmxlVGl0bGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkaXYuZ2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiKSAhPT0gY2hpbGQuYWNjZXNzaWJsZUhpbnQgJiYgY2hpbGQuYWNjZXNzaWJsZUhpbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIGNoaWxkLmFjY2Vzc2libGVIaW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkLmFjY2Vzc2libGVUaXRsZSAhPT0gZGl2LnRpdGxlIHx8IGNoaWxkLnRhYkluZGV4ICE9PSBkaXYudGFiSW5kZXgpIHtcbiAgICAgICAgICBkaXYudGl0bGUgPSBjaGlsZC5hY2Nlc3NpYmxlVGl0bGU7XG4gICAgICAgICAgZGl2LnRhYkluZGV4ID0gY2hpbGQudGFiSW5kZXg7XG4gICAgICAgICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZURlYnVnSFRNTChkaXYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVuZGVySWQrKztcbiAgfVxuICB1cGRhdGVEZWJ1Z0hUTUwoZGl2KSB7XG4gICAgZGl2LmlubmVySFRNTCA9IGB0eXBlOiAke2Rpdi50eXBlfTwvYnI+IHRpdGxlIDogJHtkaXYudGl0bGV9PC9icj4gdGFiSW5kZXg6ICR7ZGl2LnRhYkluZGV4fWA7XG4gIH1cbiAgY2FwSGl0QXJlYShoaXRBcmVhKSB7XG4gICAgaWYgKGhpdEFyZWEueCA8IDApIHtcbiAgICAgIGhpdEFyZWEud2lkdGggKz0gaGl0QXJlYS54O1xuICAgICAgaGl0QXJlYS54ID0gMDtcbiAgICB9XG4gICAgaWYgKGhpdEFyZWEueSA8IDApIHtcbiAgICAgIGhpdEFyZWEuaGVpZ2h0ICs9IGhpdEFyZWEueTtcbiAgICAgIGhpdEFyZWEueSA9IDA7XG4gICAgfVxuICAgIGNvbnN0IHsgd2lkdGg6IHZpZXdXaWR0aCwgaGVpZ2h0OiB2aWV3SGVpZ2h0IH0gPSB0aGlzLnJlbmRlcmVyO1xuICAgIGlmIChoaXRBcmVhLnggKyBoaXRBcmVhLndpZHRoID4gdmlld1dpZHRoKSB7XG4gICAgICBoaXRBcmVhLndpZHRoID0gdmlld1dpZHRoIC0gaGl0QXJlYS54O1xuICAgIH1cbiAgICBpZiAoaGl0QXJlYS55ICsgaGl0QXJlYS5oZWlnaHQgPiB2aWV3SGVpZ2h0KSB7XG4gICAgICBoaXRBcmVhLmhlaWdodCA9IHZpZXdIZWlnaHQgLSBoaXRBcmVhLnk7XG4gICAgfVxuICB9XG4gIGFkZENoaWxkKGRpc3BsYXlPYmplY3QpIHtcbiAgICBsZXQgZGl2ID0gdGhpcy5wb29sLnBvcCgpO1xuICAgIGlmICghZGl2KSB7XG4gICAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgZGl2LnN0eWxlLndpZHRoID0gYCR7RElWX1RPVUNIX1NJWkV9cHhgO1xuICAgICAgZGl2LnN0eWxlLmhlaWdodCA9IGAke0RJVl9UT1VDSF9TSVpFfXB4YDtcbiAgICAgIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmRlYnVnID8gXCJyZ2JhKDI1NSwyNTUsMjU1LDAuNSlcIiA6IFwidHJhbnNwYXJlbnRcIjtcbiAgICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgIGRpdi5zdHlsZS56SW5kZXggPSBESVZfVE9VQ0hfWklOREVYLnRvU3RyaW5nKCk7XG4gICAgICBkaXYuc3R5bGUuYm9yZGVyU3R5bGUgPSBcIm5vbmVcIjtcbiAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJjaHJvbWVcIikpIHtcbiAgICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLCBcIm9mZlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxpdmVcIiwgXCJwb2xpdGVcIik7XG4gICAgICB9XG4gICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvcnY6LipHZWNrb1xcLy8pKSB7XG4gICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLXJlbGV2YW50XCIsIFwiYWRkaXRpb25zXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtcmVsZXZhbnRcIiwgXCJ0ZXh0XCIpO1xuICAgICAgfVxuICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcykpO1xuICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLl9vbkZvY3VzLmJpbmQodGhpcykpO1xuICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCB0aGlzLl9vbkZvY3VzT3V0LmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBkaXYuc3R5bGUucG9pbnRlckV2ZW50cyA9IGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZVBvaW50ZXJFdmVudHM7XG4gICAgZGl2LnR5cGUgPSBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVUeXBlO1xuICAgIGlmIChkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVUaXRsZSAmJiBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVUaXRsZSAhPT0gbnVsbCkge1xuICAgICAgZGl2LnRpdGxlID0gZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlVGl0bGU7XG4gICAgfSBlbHNlIGlmICghZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlSGludCB8fCBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVIaW50ID09PSBudWxsKSB7XG4gICAgICBkaXYudGl0bGUgPSBgZGlzcGxheU9iamVjdCAke2Rpc3BsYXlPYmplY3QudGFiSW5kZXh9YDtcbiAgICB9XG4gICAgaWYgKGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZUhpbnQgJiYgZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlSGludCAhPT0gbnVsbCkge1xuICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlSGludCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlYnVnKVxuICAgICAgdGhpcy51cGRhdGVEZWJ1Z0hUTUwoZGl2KTtcbiAgICBkaXNwbGF5T2JqZWN0Ll9hY2Nlc3NpYmxlQWN0aXZlID0gdHJ1ZTtcbiAgICBkaXNwbGF5T2JqZWN0Ll9hY2Nlc3NpYmxlRGl2ID0gZGl2O1xuICAgIGRpdi5kaXNwbGF5T2JqZWN0ID0gZGlzcGxheU9iamVjdDtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goZGlzcGxheU9iamVjdCk7XG4gICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQoZGlzcGxheU9iamVjdC5fYWNjZXNzaWJsZURpdik7XG4gICAgZGlzcGxheU9iamVjdC5fYWNjZXNzaWJsZURpdi50YWJJbmRleCA9IGRpc3BsYXlPYmplY3QudGFiSW5kZXg7XG4gIH1cbiAgX2Rpc3BhdGNoRXZlbnQoZSwgdHlwZSkge1xuICAgIGNvbnN0IHsgZGlzcGxheU9iamVjdDogdGFyZ2V0IH0gPSBlLnRhcmdldDtcbiAgICBjb25zdCBib3VuZHJ5ID0gdGhpcy5yZW5kZXJlci5ldmVudHMucm9vdEJvdW5kYXJ5O1xuICAgIGNvbnN0IGV2ZW50ID0gT2JqZWN0LmFzc2lnbihuZXcgRmVkZXJhdGVkRXZlbnQoYm91bmRyeSksIHsgdGFyZ2V0IH0pO1xuICAgIGJvdW5kcnkucm9vdFRhcmdldCA9IHRoaXMucmVuZGVyZXIubGFzdE9iamVjdFJlbmRlcmVkO1xuICAgIHR5cGUuZm9yRWFjaCgodHlwZTIpID0+IGJvdW5kcnkuZGlzcGF0Y2hFdmVudChldmVudCwgdHlwZTIpKTtcbiAgfVxuICBfb25DbGljayhlKSB7XG4gICAgdGhpcy5fZGlzcGF0Y2hFdmVudChlLCBbXCJjbGlja1wiLCBcInBvaW50ZXJ0YXBcIiwgXCJ0YXBcIl0pO1xuICB9XG4gIF9vbkZvY3VzKGUpIHtcbiAgICBpZiAoIWUudGFyZ2V0LmdldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiKSkge1xuICAgICAgZS50YXJnZXQuc2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIsIFwiYXNzZXJ0aXZlXCIpO1xuICAgIH1cbiAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KGUsIFtcIm1vdXNlb3ZlclwiXSk7XG4gIH1cbiAgX29uRm9jdXNPdXQoZSkge1xuICAgIGlmICghZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIpKSB7XG4gICAgICBlLnRhcmdldC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxpdmVcIiwgXCJwb2xpdGVcIik7XG4gICAgfVxuICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnQoZSwgW1wibW91c2VvdXRcIl0pO1xuICB9XG4gIF9vbktleURvd24oZSkge1xuICAgIGlmIChlLmtleUNvZGUgIT09IEtFWV9DT0RFX1RBQikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2YXRlKCk7XG4gIH1cbiAgX29uTW91c2VNb3ZlKGUpIHtcbiAgICBpZiAoZS5tb3ZlbWVudFggPT09IDAgJiYgZS5tb3ZlbWVudFkgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kZWFjdGl2YXRlKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3lUb3VjaEhvb2soKTtcbiAgICB0aGlzLmRpdiA9IG51bGw7XG4gICAgZ2xvYmFsVGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uTW91c2VNb3ZlLCB0cnVlKTtcbiAgICBnbG9iYWxUaGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX29uS2V5RG93bik7XG4gICAgdGhpcy5wb29sID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkcmVuID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxufVxuQWNjZXNzaWJpbGl0eU1hbmFnZXIuZXh0ZW5zaW9uID0ge1xuICBuYW1lOiBcImFjY2Vzc2liaWxpdHlcIixcbiAgdHlwZTogW1xuICAgIEV4dGVuc2lvblR5cGUuUmVuZGVyZXJQbHVnaW4sXG4gICAgRXh0ZW5zaW9uVHlwZS5DYW52YXNSZW5kZXJlclBsdWdpblxuICBdXG59O1xuZXh0ZW5zaW9ucy5hZGQoQWNjZXNzaWJpbGl0eU1hbmFnZXIpO1xuXG5leHBvcnQgeyBBY2Nlc3NpYmlsaXR5TWFuYWdlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWNjZXNzaWJpbGl0eU1hbmFnZXIubWpzLm1hcFxuIiwiZXhwb3J0IHsgQWNjZXNzaWJpbGl0eU1hbmFnZXIgfSBmcm9tICcuL0FjY2Vzc2liaWxpdHlNYW5hZ2VyLm1qcyc7XG5leHBvcnQgeyBhY2Nlc3NpYmxlVGFyZ2V0IH0gZnJvbSAnLi9hY2Nlc3NpYmxlVGFyZ2V0Lm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBhdXRvRGV0ZWN0UmVuZGVyZXIsIGV4dGVuc2lvbnMsIEV4dGVuc2lvblR5cGUgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJ0BwaXhpL2Rpc3BsYXknO1xuXG5jb25zdCBfQXBwbGljYXRpb24gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnN0YWdlID0gbmV3IENvbnRhaW5lcigpO1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGZvcmNlQ2FudmFzOiBmYWxzZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHRoaXMucmVuZGVyZXIgPSBhdXRvRGV0ZWN0UmVuZGVyZXIob3B0aW9ucyk7XG4gICAgX0FwcGxpY2F0aW9uLl9wbHVnaW5zLmZvckVhY2goKHBsdWdpbikgPT4ge1xuICAgICAgcGx1Z2luLmluaXQuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zdGFnZSk7XG4gIH1cbiAgZ2V0IHZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXIudmlldztcbiAgfVxuICBnZXQgc2NyZWVuKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnNjcmVlbjtcbiAgfVxuICBkZXN0cm95KHJlbW92ZVZpZXcsIHN0YWdlT3B0aW9ucykge1xuICAgIGNvbnN0IHBsdWdpbnMgPSBfQXBwbGljYXRpb24uX3BsdWdpbnMuc2xpY2UoMCk7XG4gICAgcGx1Z2lucy5yZXZlcnNlKCk7XG4gICAgcGx1Z2lucy5mb3JFYWNoKChwbHVnaW4pID0+IHtcbiAgICAgIHBsdWdpbi5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfSk7XG4gICAgdGhpcy5zdGFnZS5kZXN0cm95KHN0YWdlT3B0aW9ucyk7XG4gICAgdGhpcy5zdGFnZSA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJlci5kZXN0cm95KHJlbW92ZVZpZXcpO1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICB9XG59O1xubGV0IEFwcGxpY2F0aW9uID0gX0FwcGxpY2F0aW9uO1xuQXBwbGljYXRpb24uX3BsdWdpbnMgPSBbXTtcbmV4dGVuc2lvbnMuaGFuZGxlQnlMaXN0KEV4dGVuc2lvblR5cGUuQXBwbGljYXRpb24sIEFwcGxpY2F0aW9uLl9wbHVnaW5zKTtcblxuZXhwb3J0IHsgQXBwbGljYXRpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFwcGxpY2F0aW9uLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIGV4dGVuc2lvbnMgfSBmcm9tICdAcGl4aS9jb3JlJztcblxuY2xhc3MgUmVzaXplUGx1Z2luIHtcbiAgc3RhdGljIGluaXQob3B0aW9ucykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc2l6ZVRvXCIsIHtcbiAgICAgIHNldChkb20pIHtcbiAgICAgICAgZ2xvYmFsVGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMucXVldWVSZXNpemUpO1xuICAgICAgICB0aGlzLl9yZXNpemVUbyA9IGRvbTtcbiAgICAgICAgaWYgKGRvbSkge1xuICAgICAgICAgIGdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLnF1ZXVlUmVzaXplKTtcbiAgICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzaXplVG87XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5xdWV1ZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fcmVzaXplVG8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5jYW5jZWxSZXNpemUoKTtcbiAgICAgIHRoaXMuX3Jlc2l6ZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMucmVzaXplKCkpO1xuICAgIH07XG4gICAgdGhpcy5jYW5jZWxSZXNpemUgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fcmVzaXplSWQpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVzaXplSWQpO1xuICAgICAgICB0aGlzLl9yZXNpemVJZCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fcmVzaXplVG8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5jYW5jZWxSZXNpemUoKTtcbiAgICAgIGxldCB3aWR0aDtcbiAgICAgIGxldCBoZWlnaHQ7XG4gICAgICBpZiAodGhpcy5fcmVzaXplVG8gPT09IGdsb2JhbFRoaXMud2luZG93KSB7XG4gICAgICAgIHdpZHRoID0gZ2xvYmFsVGhpcy5pbm5lcldpZHRoO1xuICAgICAgICBoZWlnaHQgPSBnbG9iYWxUaGlzLmlubmVySGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyBjbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0IH0gPSB0aGlzLl9yZXNpemVUbztcbiAgICAgICAgd2lkdGggPSBjbGllbnRXaWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gY2xpZW50SGVpZ2h0O1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJlci5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH07XG4gICAgdGhpcy5fcmVzaXplSWQgPSBudWxsO1xuICAgIHRoaXMuX3Jlc2l6ZVRvID0gbnVsbDtcbiAgICB0aGlzLnJlc2l6ZVRvID0gb3B0aW9ucy5yZXNpemVUbyB8fCBudWxsO1xuICB9XG4gIHN0YXRpYyBkZXN0cm95KCkge1xuICAgIGdsb2JhbFRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLnF1ZXVlUmVzaXplKTtcbiAgICB0aGlzLmNhbmNlbFJlc2l6ZSgpO1xuICAgIHRoaXMuY2FuY2VsUmVzaXplID0gbnVsbDtcbiAgICB0aGlzLnF1ZXVlUmVzaXplID0gbnVsbDtcbiAgICB0aGlzLnJlc2l6ZVRvID0gbnVsbDtcbiAgICB0aGlzLnJlc2l6ZSA9IG51bGw7XG4gIH1cbn1cblJlc2l6ZVBsdWdpbi5leHRlbnNpb24gPSBFeHRlbnNpb25UeXBlLkFwcGxpY2F0aW9uO1xuZXh0ZW5zaW9ucy5hZGQoUmVzaXplUGx1Z2luKTtcblxuZXhwb3J0IHsgUmVzaXplUGx1Z2luIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXNpemVQbHVnaW4ubWpzLm1hcFxuIiwiZXhwb3J0IHsgQXBwbGljYXRpb24gfSBmcm9tICcuL0FwcGxpY2F0aW9uLm1qcyc7XG5leHBvcnQgeyBSZXNpemVQbHVnaW4gfSBmcm9tICcuL1Jlc2l6ZVBsdWdpbi5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuXG5jb25zdCBhc3NldEtleU1hcCA9IHtcbiAgbG9hZGVyOiBFeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gIHJlc29sdmVyOiBFeHRlbnNpb25UeXBlLlJlc29sdmVQYXJzZXIsXG4gIGNhY2hlOiBFeHRlbnNpb25UeXBlLkNhY2hlUGFyc2VyLFxuICBkZXRlY3Rpb246IEV4dGVuc2lvblR5cGUuRGV0ZWN0aW9uUGFyc2VyXG59O1xuZXh0ZW5zaW9ucy5oYW5kbGUoRXh0ZW5zaW9uVHlwZS5Bc3NldCwgKGV4dGVuc2lvbikgPT4ge1xuICBjb25zdCByZWYgPSBleHRlbnNpb24ucmVmO1xuICBPYmplY3QuZW50cmllcyhhc3NldEtleU1hcCkuZmlsdGVyKChba2V5XSkgPT4gISFyZWZba2V5XSkuZm9yRWFjaCgoW2tleSwgdHlwZV0pID0+IGV4dGVuc2lvbnMuYWRkKE9iamVjdC5hc3NpZ24ocmVmW2tleV0sIHsgZXh0ZW5zaW9uOiByZWZba2V5XS5leHRlbnNpb24gPz8gdHlwZSB9KSkpO1xufSwgKGV4dGVuc2lvbikgPT4ge1xuICBjb25zdCByZWYgPSBleHRlbnNpb24ucmVmO1xuICBPYmplY3Qua2V5cyhhc3NldEtleU1hcCkuZmlsdGVyKChrZXkpID0+ICEhcmVmW2tleV0pLmZvckVhY2goKGtleSkgPT4gZXh0ZW5zaW9ucy5yZW1vdmUocmVmW2tleV0pKTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXNzZXRFeHRlbnNpb24ubWpzLm1hcFxuIiwiY2xhc3MgQmFja2dyb3VuZExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKGxvYWRlciwgdmVyYm9zZSA9IGZhbHNlKSB7XG4gICAgdGhpcy5fbG9hZGVyID0gbG9hZGVyO1xuICAgIHRoaXMuX2Fzc2V0TGlzdCA9IFtdO1xuICAgIHRoaXMuX2lzTG9hZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX21heENvbmN1cnJlbnQgPSAxO1xuICAgIHRoaXMudmVyYm9zZSA9IHZlcmJvc2U7XG4gIH1cbiAgYWRkKGFzc2V0VXJscykge1xuICAgIGFzc2V0VXJscy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICB0aGlzLl9hc3NldExpc3QucHVzaChhKTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy52ZXJib3NlKVxuICAgICAgY29uc29sZS5sb2coXCJbQmFja2dyb3VuZExvYWRlcl0gYXNzZXRzOiBcIiwgdGhpcy5fYXNzZXRMaXN0KTtcbiAgICBpZiAodGhpcy5faXNBY3RpdmUgJiYgIXRoaXMuX2lzTG9hZGluZykge1xuICAgICAgdGhpcy5fbmV4dCgpO1xuICAgIH1cbiAgfVxuICBhc3luYyBfbmV4dCgpIHtcbiAgICBpZiAodGhpcy5fYXNzZXRMaXN0Lmxlbmd0aCAmJiB0aGlzLl9pc0FjdGl2ZSkge1xuICAgICAgdGhpcy5faXNMb2FkaW5nID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHRvTG9hZCA9IFtdO1xuICAgICAgY29uc3QgdG9Mb2FkQW1vdW50ID0gTWF0aC5taW4odGhpcy5fYXNzZXRMaXN0Lmxlbmd0aCwgdGhpcy5fbWF4Q29uY3VycmVudCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvTG9hZEFtb3VudDsgaSsrKSB7XG4gICAgICAgIHRvTG9hZC5wdXNoKHRoaXMuX2Fzc2V0TGlzdC5wb3AoKSk7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLl9sb2FkZXIubG9hZCh0b0xvYWQpO1xuICAgICAgdGhpcy5faXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9uZXh0KCk7XG4gICAgfVxuICB9XG4gIGdldCBhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzQWN0aXZlO1xuICB9XG4gIHNldCBhY3RpdmUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5faXNBY3RpdmUgPT09IHZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2lzQWN0aXZlID0gdmFsdWU7XG4gICAgaWYgKHZhbHVlICYmICF0aGlzLl9pc0xvYWRpbmcpIHtcbiAgICAgIHRoaXMuX25leHQoKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgQmFja2dyb3VuZExvYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFja2dyb3VuZExvYWRlci5tanMubWFwXG4iLCJpbXBvcnQgeyB1dGlscyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuXG5mdW5jdGlvbiBjaGVja0V4dGVuc2lvbih1cmwsIGV4dGVuc2lvbikge1xuICBjb25zdCB0ZW1wVVJMID0gdXJsLnNwbGl0KFwiP1wiKVswXTtcbiAgY29uc3QgZXh0ID0gdXRpbHMucGF0aC5leHRuYW1lKHRlbXBVUkwpLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4dGVuc2lvbikpIHtcbiAgICByZXR1cm4gZXh0ZW5zaW9uLmluY2x1ZGVzKGV4dCk7XG4gIH1cbiAgcmV0dXJuIGV4dCA9PT0gZXh0ZW5zaW9uO1xufVxuXG5leHBvcnQgeyBjaGVja0V4dGVuc2lvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tFeHRlbnNpb24ubWpzLm1hcFxuIiwiZXhwb3J0IHsgY2hlY2tEYXRhVXJsIH0gZnJvbSAnLi9jaGVja0RhdGFVcmwubWpzJztcbmV4cG9ydCB7IGNoZWNrRXh0ZW5zaW9uIH0gZnJvbSAnLi9jaGVja0V4dGVuc2lvbi5tanMnO1xuZXhwb3J0IHsgY29udmVydFRvTGlzdCB9IGZyb20gJy4vY29udmVydFRvTGlzdC5tanMnO1xuZXhwb3J0IHsgY29weVNlYXJjaFBhcmFtcyB9IGZyb20gJy4vY29weVNlYXJjaFBhcmFtcy5tanMnO1xuZXhwb3J0IHsgY3JlYXRlU3RyaW5nVmFyaWF0aW9ucyB9IGZyb20gJy4vY3JlYXRlU3RyaW5nVmFyaWF0aW9ucy5tanMnO1xuZXhwb3J0IHsgaXNTaW5nbGVJdGVtIH0gZnJvbSAnLi9pc1NpbmdsZUl0ZW0ubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImNvbnN0IGNvbnZlcnRUb0xpc3QgPSAoaW5wdXQsIHRyYW5zZm9ybSkgPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgaW5wdXQgPSBbaW5wdXRdO1xuICB9XG4gIGlmICghdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIHJldHVybiBpbnB1dC5tYXAoKGl0ZW0pID0+IHtcbiAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm0oaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9KTtcbn07XG5cbmV4cG9ydCB7IGNvbnZlcnRUb0xpc3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZlcnRUb0xpc3QubWpzLm1hcFxuIiwiaW1wb3J0IHsgVGV4dHVyZSwgQmFzZVRleHR1cmUgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCAnLi4vdXRpbHMvaW5kZXgubWpzJztcbmltcG9ydCB7IGNvbnZlcnRUb0xpc3QgfSBmcm9tICcuLi91dGlscy9jb252ZXJ0VG9MaXN0Lm1qcyc7XG5cbmNsYXNzIENhY2hlQ2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9wYXJzZXJzID0gW107XG4gICAgdGhpcy5fY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2NhY2hlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLl9jYWNoZU1hcC5jbGVhcigpO1xuICAgIHRoaXMuX2NhY2hlLmNsZWFyKCk7XG4gIH1cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZS5oYXMoa2V5KTtcbiAgfVxuICBnZXQoa2V5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIGNvbnNvbGUud2FybihgW0Fzc2V0c10gQXNzZXQgaWQgJHtrZXl9IHdhcyBub3QgZm91bmQgaW4gdGhlIENhY2hlYCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBrZXlzID0gY29udmVydFRvTGlzdChrZXkpO1xuICAgIGxldCBjYWNoZWFibGVBc3NldHM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhcnNlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2Vyc1tpXTtcbiAgICAgIGlmIChwYXJzZXIudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgY2FjaGVhYmxlQXNzZXRzID0gcGFyc2VyLmdldENhY2hlYWJsZUFzc2V0cyhrZXlzLCB2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNhY2hlYWJsZUFzc2V0cykge1xuICAgICAgY2FjaGVhYmxlQXNzZXRzID0ge307XG4gICAgICBrZXlzLmZvckVhY2goKGtleTIpID0+IHtcbiAgICAgICAgY2FjaGVhYmxlQXNzZXRzW2tleTJdID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGVLZXlzID0gT2JqZWN0LmtleXMoY2FjaGVhYmxlQXNzZXRzKTtcbiAgICBjb25zdCBjYWNoZWRBc3NldHMgPSB7XG4gICAgICBjYWNoZUtleXMsXG4gICAgICBrZXlzXG4gICAgfTtcbiAgICBrZXlzLmZvckVhY2goKGtleTIpID0+IHtcbiAgICAgIHRoaXMuX2NhY2hlTWFwLnNldChrZXkyLCBjYWNoZWRBc3NldHMpO1xuICAgIH0pO1xuICAgIGNhY2hlS2V5cy5mb3JFYWNoKChrZXkyKSA9PiB7XG4gICAgICBpZiAodGhpcy5fY2FjaGUuaGFzKGtleTIpICYmIHRoaXMuX2NhY2hlLmdldChrZXkyKSAhPT0gdmFsdWUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW0NhY2hlXSBhbHJlYWR5IGhhcyBrZXk6XCIsIGtleTIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2FjaGUuc2V0KGtleTIsIGNhY2hlYWJsZUFzc2V0c1trZXkyXSk7XG4gICAgfSk7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgY29uc3QgdGV4dHVyZSA9IHZhbHVlO1xuICAgICAga2V5cy5mb3JFYWNoKChrZXkyKSA9PiB7XG4gICAgICAgIGlmICh0ZXh0dXJlLmJhc2VUZXh0dXJlICE9PSBUZXh0dXJlLkVNUFRZLmJhc2VUZXh0dXJlKSB7XG4gICAgICAgICAgQmFzZVRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLCBrZXkyKTtcbiAgICAgICAgfVxuICAgICAgICBUZXh0dXJlLmFkZFRvQ2FjaGUodGV4dHVyZSwga2V5Mik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlKGtleSkge1xuICAgIHRoaXMuX2NhY2hlTWFwLmdldChrZXkpO1xuICAgIGlmICghdGhpcy5fY2FjaGVNYXAuaGFzKGtleSkpIHtcbiAgICAgIGNvbnNvbGUud2FybihgW0Fzc2V0c10gQXNzZXQgaWQgJHtrZXl9IHdhcyBub3QgZm91bmQgaW4gdGhlIENhY2hlYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlTWFwID0gdGhpcy5fY2FjaGVNYXAuZ2V0KGtleSk7XG4gICAgY29uc3QgY2FjaGVLZXlzID0gY2FjaGVNYXAuY2FjaGVLZXlzO1xuICAgIGNhY2hlS2V5cy5mb3JFYWNoKChrZXkyKSA9PiB7XG4gICAgICB0aGlzLl9jYWNoZS5kZWxldGUoa2V5Mik7XG4gICAgfSk7XG4gICAgY2FjaGVNYXAua2V5cy5mb3JFYWNoKChrZXkyKSA9PiB7XG4gICAgICB0aGlzLl9jYWNoZU1hcC5kZWxldGUoa2V5Mik7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IHBhcnNlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlcnM7XG4gIH1cbn1cbmNvbnN0IENhY2hlID0gbmV3IENhY2hlQ2xhc3MoKTtcblxuZXhwb3J0IHsgQ2FjaGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhY2hlLm1qcy5tYXBcbiIsImNvbnN0IGlzU2luZ2xlSXRlbSA9IChpdGVtKSA9PiAhQXJyYXkuaXNBcnJheShpdGVtKTtcblxuZXhwb3J0IHsgaXNTaW5nbGVJdGVtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1NpbmdsZUl0ZW0ubWpzLm1hcFxuIiwiaW1wb3J0IHsgdXRpbHMgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCAnLi4vdXRpbHMvaW5kZXgubWpzJztcbmltcG9ydCB7IGlzU2luZ2xlSXRlbSB9IGZyb20gJy4uL3V0aWxzL2lzU2luZ2xlSXRlbS5tanMnO1xuaW1wb3J0IHsgY29udmVydFRvTGlzdCB9IGZyb20gJy4uL3V0aWxzL2NvbnZlcnRUb0xpc3QubWpzJztcblxuY2xhc3MgTG9hZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcGFyc2VycyA9IFtdO1xuICAgIHRoaXMuX3BhcnNlcnNWYWxpZGF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBhcnNlcnMgPSBuZXcgUHJveHkodGhpcy5fcGFyc2Vycywge1xuICAgICAgc2V0OiAodGFyZ2V0LCBrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuX3BhcnNlcnNWYWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5wcm9taXNlQ2FjaGUgPSB7fTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLl9wYXJzZXJzVmFsaWRhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5wcm9taXNlQ2FjaGUgPSB7fTtcbiAgfVxuICBfZ2V0TG9hZFByb21pc2VBbmRQYXJzZXIodXJsLCBkYXRhKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgcHJvbWlzZTogbnVsbCxcbiAgICAgIHBhcnNlcjogbnVsbFxuICAgIH07XG4gICAgcmVzdWx0LnByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IGFzc2V0ID0gbnVsbDtcbiAgICAgIGxldCBwYXJzZXIgPSBudWxsO1xuICAgICAgaWYgKGRhdGEubG9hZFBhcnNlcikge1xuICAgICAgICBwYXJzZXIgPSB0aGlzLl9wYXJzZXJIYXNoW2RhdGEubG9hZFBhcnNlcl07XG4gICAgICAgIGlmICghcGFyc2VyKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBbQXNzZXRzXSBzcGVjaWZpZWQgbG9hZCBwYXJzZXIgXCIke2RhdGEubG9hZFBhcnNlcn1cIiBub3QgZm91bmQgd2hpbGUgbG9hZGluZyAke3VybH1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFwYXJzZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhcnNlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBwYXJzZXJYID0gdGhpcy5wYXJzZXJzW2ldO1xuICAgICAgICAgIGlmIChwYXJzZXJYLmxvYWQgJiYgcGFyc2VyWC50ZXN0Py4odXJsLCBkYXRhLCB0aGlzKSkge1xuICAgICAgICAgICAgcGFyc2VyID0gcGFyc2VyWDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcnNlcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgW0Fzc2V0c10gJHt1cmx9IGNvdWxkIG5vdCBiZSBsb2FkZWQgYXMgd2UgZG9uJ3Qga25vdyBob3cgdG8gcGFyc2UgaXQsIGVuc3VyZSB0aGUgY29ycmVjdCBwYXJzZXIgaGFzIGJlZW4gYWRkZWRgKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXNzZXQgPSBhd2FpdCBwYXJzZXIubG9hZCh1cmwsIGRhdGEsIHRoaXMpO1xuICAgICAgcmVzdWx0LnBhcnNlciA9IHBhcnNlcjtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXJzZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlcjIgPSB0aGlzLnBhcnNlcnNbaV07XG4gICAgICAgIGlmIChwYXJzZXIyLnBhcnNlKSB7XG4gICAgICAgICAgaWYgKHBhcnNlcjIucGFyc2UgJiYgYXdhaXQgcGFyc2VyMi50ZXN0UGFyc2U/Lihhc3NldCwgZGF0YSwgdGhpcykpIHtcbiAgICAgICAgICAgIGFzc2V0ID0gYXdhaXQgcGFyc2VyMi5wYXJzZShhc3NldCwgZGF0YSwgdGhpcykgfHwgYXNzZXQ7XG4gICAgICAgICAgICByZXN1bHQucGFyc2VyID0gcGFyc2VyMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhc3NldDtcbiAgICB9KSgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgbG9hZChhc3NldHNUb0xvYWRJbiwgb25Qcm9ncmVzcykge1xuICAgIGlmICghdGhpcy5fcGFyc2Vyc1ZhbGlkYXRlZCkge1xuICAgICAgdGhpcy5fdmFsaWRhdGVQYXJzZXJzKCk7XG4gICAgfVxuICAgIGxldCBjb3VudCA9IDA7XG4gICAgY29uc3QgYXNzZXRzID0ge307XG4gICAgY29uc3Qgc2luZ2xlQXNzZXQgPSBpc1NpbmdsZUl0ZW0oYXNzZXRzVG9Mb2FkSW4pO1xuICAgIGNvbnN0IGFzc2V0c1RvTG9hZCA9IGNvbnZlcnRUb0xpc3QoYXNzZXRzVG9Mb2FkSW4sIChpdGVtKSA9PiAoe1xuICAgICAgc3JjOiBpdGVtXG4gICAgfSkpO1xuICAgIGNvbnN0IHRvdGFsID0gYXNzZXRzVG9Mb2FkLmxlbmd0aDtcbiAgICBjb25zdCBwcm9taXNlcyA9IGFzc2V0c1RvTG9hZC5tYXAoYXN5bmMgKGFzc2V0KSA9PiB7XG4gICAgICBjb25zdCB1cmwgPSB1dGlscy5wYXRoLnRvQWJzb2x1dGUoYXNzZXQuc3JjKTtcbiAgICAgIGlmICghYXNzZXRzW2Fzc2V0LnNyY10pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIXRoaXMucHJvbWlzZUNhY2hlW3VybF0pIHtcbiAgICAgICAgICAgIHRoaXMucHJvbWlzZUNhY2hlW3VybF0gPSB0aGlzLl9nZXRMb2FkUHJvbWlzZUFuZFBhcnNlcih1cmwsIGFzc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXNzZXRzW2Fzc2V0LnNyY10gPSBhd2FpdCB0aGlzLnByb21pc2VDYWNoZVt1cmxdLnByb21pc2U7XG4gICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpXG4gICAgICAgICAgICBvblByb2dyZXNzKCsrY291bnQgLyB0b3RhbCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5wcm9taXNlQ2FjaGVbdXJsXTtcbiAgICAgICAgICBkZWxldGUgYXNzZXRzW2Fzc2V0LnNyY107XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbTG9hZGVyLmxvYWRdIEZhaWxlZCB0byBsb2FkICR7dXJsfS5cbiR7ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICByZXR1cm4gc2luZ2xlQXNzZXQgPyBhc3NldHNbYXNzZXRzVG9Mb2FkWzBdLnNyY10gOiBhc3NldHM7XG4gIH1cbiAgYXN5bmMgdW5sb2FkKGFzc2V0c1RvVW5sb2FkSW4pIHtcbiAgICBjb25zdCBhc3NldHNUb1VubG9hZCA9IGNvbnZlcnRUb0xpc3QoYXNzZXRzVG9VbmxvYWRJbiwgKGl0ZW0pID0+ICh7XG4gICAgICBzcmM6IGl0ZW1cbiAgICB9KSk7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBhc3NldHNUb1VubG9hZC5tYXAoYXN5bmMgKGFzc2V0KSA9PiB7XG4gICAgICBjb25zdCB1cmwgPSB1dGlscy5wYXRoLnRvQWJzb2x1dGUoYXNzZXQuc3JjKTtcbiAgICAgIGNvbnN0IGxvYWRQcm9taXNlID0gdGhpcy5wcm9taXNlQ2FjaGVbdXJsXTtcbiAgICAgIGlmIChsb2FkUHJvbWlzZSkge1xuICAgICAgICBjb25zdCBsb2FkZWRBc3NldCA9IGF3YWl0IGxvYWRQcm9taXNlLnByb21pc2U7XG4gICAgICAgIGxvYWRQcm9taXNlLnBhcnNlcj8udW5sb2FkPy4obG9hZGVkQXNzZXQsIGFzc2V0LCB0aGlzKTtcbiAgICAgICAgZGVsZXRlIHRoaXMucHJvbWlzZUNhY2hlW3VybF07XG4gICAgICB9XG4gICAgfSk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICB9XG4gIF92YWxpZGF0ZVBhcnNlcnMoKSB7XG4gICAgdGhpcy5fcGFyc2Vyc1ZhbGlkYXRlZCA9IHRydWU7XG4gICAgdGhpcy5fcGFyc2VySGFzaCA9IHRoaXMuX3BhcnNlcnMuZmlsdGVyKChwYXJzZXIpID0+IHBhcnNlci5uYW1lKS5yZWR1Y2UoKGhhc2gsIHBhcnNlcikgPT4ge1xuICAgICAgaWYgKGhhc2hbcGFyc2VyLm5hbWVdKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgW0Fzc2V0c10gbG9hZFBhcnNlciBuYW1lIGNvbmZsaWN0IFwiJHtwYXJzZXIubmFtZX1cImApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgLi4uaGFzaCwgW3BhcnNlci5uYW1lXTogcGFyc2VyIH07XG4gICAgfSwge30pO1xuICB9XG59XG5cbmV4cG9ydCB7IExvYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9hZGVyLm1qcy5tYXBcbiIsInZhciBMb2FkZXJQYXJzZXJQcmlvcml0eSA9IC8qIEBfX1BVUkVfXyAqLyAoKExvYWRlclBhcnNlclByaW9yaXR5MikgPT4ge1xuICBMb2FkZXJQYXJzZXJQcmlvcml0eTJbTG9hZGVyUGFyc2VyUHJpb3JpdHkyW1wiTG93XCJdID0gMF0gPSBcIkxvd1wiO1xuICBMb2FkZXJQYXJzZXJQcmlvcml0eTJbTG9hZGVyUGFyc2VyUHJpb3JpdHkyW1wiTm9ybWFsXCJdID0gMV0gPSBcIk5vcm1hbFwiO1xuICBMb2FkZXJQYXJzZXJQcmlvcml0eTJbTG9hZGVyUGFyc2VyUHJpb3JpdHkyW1wiSGlnaFwiXSA9IDJdID0gXCJIaWdoXCI7XG4gIHJldHVybiBMb2FkZXJQYXJzZXJQcmlvcml0eTI7XG59KShMb2FkZXJQYXJzZXJQcmlvcml0eSB8fCB7fSk7XG5cbmV4cG9ydCB7IExvYWRlclBhcnNlclByaW9yaXR5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Mb2FkZXJQYXJzZXIubWpzLm1hcFxuIiwiZnVuY3Rpb24gY2hlY2tEYXRhVXJsKHVybCwgbWltZXMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWltZXMpKSB7XG4gICAgZm9yIChjb25zdCBtaW1lIG9mIG1pbWVzKSB7XG4gICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoYGRhdGE6JHttaW1lfWApKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB1cmwuc3RhcnRzV2l0aChgZGF0YToke21pbWVzfWApO1xufVxuXG5leHBvcnQgeyBjaGVja0RhdGFVcmwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrRGF0YVVybC5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBzZXR0aW5ncywgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgY2hlY2tEYXRhVXJsIH0gZnJvbSAnLi4vLi4vdXRpbHMvY2hlY2tEYXRhVXJsLm1qcyc7XG5pbXBvcnQgeyBjaGVja0V4dGVuc2lvbiB9IGZyb20gJy4uLy4uL3V0aWxzL2NoZWNrRXh0ZW5zaW9uLm1qcyc7XG5pbXBvcnQgeyBMb2FkZXJQYXJzZXJQcmlvcml0eSB9IGZyb20gJy4vTG9hZGVyUGFyc2VyLm1qcyc7XG5cbmNvbnN0IHZhbGlkSlNPTkV4dGVuc2lvbiA9IFwiLmpzb25cIjtcbmNvbnN0IHZhbGlkSlNPTk1JTUUgPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbmNvbnN0IGxvYWRKc29uID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBFeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gICAgcHJpb3JpdHk6IExvYWRlclBhcnNlclByaW9yaXR5Lkxvd1xuICB9LFxuICBuYW1lOiBcImxvYWRKc29uXCIsXG4gIHRlc3QodXJsKSB7XG4gICAgcmV0dXJuIGNoZWNrRGF0YVVybCh1cmwsIHZhbGlkSlNPTk1JTUUpIHx8IGNoZWNrRXh0ZW5zaW9uKHVybCwgdmFsaWRKU09ORXh0ZW5zaW9uKTtcbiAgfSxcbiAgYXN5bmMgbG9hZCh1cmwpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNldHRpbmdzLkFEQVBURVIuZmV0Y2godXJsKTtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHJldHVybiBqc29uO1xuICB9XG59O1xuZXh0ZW5zaW9ucy5hZGQobG9hZEpzb24pO1xuXG5leHBvcnQgeyBsb2FkSnNvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZEpzb24ubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgc2V0dGluZ3MsIGV4dGVuc2lvbnMgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IGNoZWNrRGF0YVVybCB9IGZyb20gJy4uLy4uL3V0aWxzL2NoZWNrRGF0YVVybC5tanMnO1xuaW1wb3J0IHsgY2hlY2tFeHRlbnNpb24gfSBmcm9tICcuLi8uLi91dGlscy9jaGVja0V4dGVuc2lvbi5tanMnO1xuaW1wb3J0IHsgTG9hZGVyUGFyc2VyUHJpb3JpdHkgfSBmcm9tICcuL0xvYWRlclBhcnNlci5tanMnO1xuXG5jb25zdCB2YWxpZFRYVEV4dGVuc2lvbiA9IFwiLnR4dFwiO1xuY29uc3QgdmFsaWRUWFRNSU1FID0gXCJ0ZXh0L3BsYWluXCI7XG5jb25zdCBsb2FkVHh0ID0ge1xuICBuYW1lOiBcImxvYWRUeHRcIixcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLFxuICAgIHByaW9yaXR5OiBMb2FkZXJQYXJzZXJQcmlvcml0eS5Mb3dcbiAgfSxcbiAgdGVzdCh1cmwpIHtcbiAgICByZXR1cm4gY2hlY2tEYXRhVXJsKHVybCwgdmFsaWRUWFRNSU1FKSB8fCBjaGVja0V4dGVuc2lvbih1cmwsIHZhbGlkVFhURXh0ZW5zaW9uKTtcbiAgfSxcbiAgYXN5bmMgbG9hZCh1cmwpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNldHRpbmdzLkFEQVBURVIuZmV0Y2godXJsKTtcbiAgICBjb25zdCB0eHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgcmV0dXJuIHR4dDtcbiAgfVxufTtcbmV4dGVuc2lvbnMuYWRkKGxvYWRUeHQpO1xuXG5leHBvcnQgeyBsb2FkVHh0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkVHh0Lm1qcy5tYXBcbiIsImltcG9ydCB7IHV0aWxzLCBFeHRlbnNpb25UeXBlLCBzZXR0aW5ncywgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgY2hlY2tEYXRhVXJsIH0gZnJvbSAnLi4vLi4vdXRpbHMvY2hlY2tEYXRhVXJsLm1qcyc7XG5pbXBvcnQgeyBjaGVja0V4dGVuc2lvbiB9IGZyb20gJy4uLy4uL3V0aWxzL2NoZWNrRXh0ZW5zaW9uLm1qcyc7XG5pbXBvcnQgeyBMb2FkZXJQYXJzZXJQcmlvcml0eSB9IGZyb20gJy4vTG9hZGVyUGFyc2VyLm1qcyc7XG5cbmNvbnN0IHZhbGlkV2VpZ2h0cyA9IFtcbiAgXCJub3JtYWxcIixcbiAgXCJib2xkXCIsXG4gIFwiMTAwXCIsXG4gIFwiMjAwXCIsXG4gIFwiMzAwXCIsXG4gIFwiNDAwXCIsXG4gIFwiNTAwXCIsXG4gIFwiNjAwXCIsXG4gIFwiNzAwXCIsXG4gIFwiODAwXCIsXG4gIFwiOTAwXCJcbl07XG5jb25zdCB2YWxpZEZvbnRFeHRlbnNpb25zID0gW1wiLnR0ZlwiLCBcIi5vdGZcIiwgXCIud29mZlwiLCBcIi53b2ZmMlwiXTtcbmNvbnN0IHZhbGlkRm9udE1JTUVzID0gW1xuICBcImZvbnQvdHRmXCIsXG4gIFwiZm9udC9vdGZcIixcbiAgXCJmb250L3dvZmZcIixcbiAgXCJmb250L3dvZmYyXCJcbl07XG5jb25zdCBDU1NfSURFTlRfVE9LRU5fUkVHRVggPSAvXigtLXwtP1tBLVpfXSlbMC05QS1aXy1dKiQvaTtcbmZ1bmN0aW9uIGdldEZvbnRGYW1pbHlOYW1lKHVybCkge1xuICBjb25zdCBleHQgPSB1dGlscy5wYXRoLmV4dG5hbWUodXJsKTtcbiAgY29uc3QgbmFtZSA9IHV0aWxzLnBhdGguYmFzZW5hbWUodXJsLCBleHQpO1xuICBjb25zdCBuYW1lV2l0aFNwYWNlcyA9IG5hbWUucmVwbGFjZSgvKC18XykvZywgXCIgXCIpO1xuICBjb25zdCBuYW1lVG9rZW5zID0gbmFtZVdpdGhTcGFjZXMudG9Mb3dlckNhc2UoKS5zcGxpdChcIiBcIikubWFwKCh3b3JkKSA9PiB3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKSk7XG4gIGxldCB2YWxpZCA9IG5hbWVUb2tlbnMubGVuZ3RoID4gMDtcbiAgZm9yIChjb25zdCB0b2tlbiBvZiBuYW1lVG9rZW5zKSB7XG4gICAgaWYgKCF0b2tlbi5tYXRjaChDU1NfSURFTlRfVE9LRU5fUkVHRVgpKSB7XG4gICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGxldCBmb250RmFtaWx5TmFtZSA9IG5hbWVUb2tlbnMuam9pbihcIiBcIik7XG4gIGlmICghdmFsaWQpIHtcbiAgICBmb250RmFtaWx5TmFtZSA9IGBcIiR7Zm9udEZhbWlseU5hbWUucmVwbGFjZSgvW1xcXFxcIl0vZywgXCJcXFxcJCZcIil9XCJgO1xuICB9XG4gIHJldHVybiBmb250RmFtaWx5TmFtZTtcbn1cbmNvbnN0IGxvYWRXZWJGb250ID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBFeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gICAgcHJpb3JpdHk6IExvYWRlclBhcnNlclByaW9yaXR5Lkxvd1xuICB9LFxuICBuYW1lOiBcImxvYWRXZWJGb250XCIsXG4gIHRlc3QodXJsKSB7XG4gICAgcmV0dXJuIGNoZWNrRGF0YVVybCh1cmwsIHZhbGlkRm9udE1JTUVzKSB8fCBjaGVja0V4dGVuc2lvbih1cmwsIHZhbGlkRm9udEV4dGVuc2lvbnMpO1xuICB9LFxuICBhc3luYyBsb2FkKHVybCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZvbnRzID0gc2V0dGluZ3MuQURBUFRFUi5nZXRGb250RmFjZVNldCgpO1xuICAgIGlmIChmb250cykge1xuICAgICAgY29uc3QgZm9udEZhY2VzID0gW107XG4gICAgICBjb25zdCBuYW1lID0gb3B0aW9ucy5kYXRhPy5mYW1pbHkgPz8gZ2V0Rm9udEZhbWlseU5hbWUodXJsKTtcbiAgICAgIGNvbnN0IHdlaWdodHMgPSBvcHRpb25zLmRhdGE/LndlaWdodHM/LmZpbHRlcigod2VpZ2h0KSA9PiB2YWxpZFdlaWdodHMuaW5jbHVkZXMod2VpZ2h0KSkgPz8gW1wibm9ybWFsXCJdO1xuICAgICAgY29uc3QgZGF0YSA9IG9wdGlvbnMuZGF0YSA/PyB7fTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2VpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB3ZWlnaHQgPSB3ZWlnaHRzW2ldO1xuICAgICAgICBjb25zdCBmb250ID0gbmV3IEZvbnRGYWNlKG5hbWUsIGB1cmwoJHtlbmNvZGVVUkkodXJsKX0pYCwge1xuICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgd2VpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBmb250LmxvYWQoKTtcbiAgICAgICAgZm9udHMuYWRkKGZvbnQpO1xuICAgICAgICBmb250RmFjZXMucHVzaChmb250KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmb250RmFjZXMubGVuZ3RoID09PSAxID8gZm9udEZhY2VzWzBdIDogZm9udEZhY2VzO1xuICAgIH1cbiAgICBjb25zb2xlLndhcm4oXCJbbG9hZFdlYkZvbnRdIEZvbnRGYWNlIEFQSSBpcyBub3Qgc3VwcG9ydGVkLiBTa2lwcGluZyBsb2FkaW5nIGZvbnRcIik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIHVubG9hZChmb250KSB7XG4gICAgKEFycmF5LmlzQXJyYXkoZm9udCkgPyBmb250IDogW2ZvbnRdKS5mb3JFYWNoKCh0KSA9PiBzZXR0aW5ncy5BREFQVEVSLmdldEZvbnRGYWNlU2V0KCkuZGVsZXRlKHQpKTtcbiAgfVxufTtcbmV4dGVuc2lvbnMuYWRkKGxvYWRXZWJGb250KTtcblxuZXhwb3J0IHsgZ2V0Rm9udEZhbWlseU5hbWUsIGxvYWRXZWJGb250IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkV2ViRm9udC5tanMubWFwXG4iLCJsZXQgVVVJRCA9IDA7XG5sZXQgTUFYX1dPUktFUlM7XG5jb25zdCBXSElURV9QTkcgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQUVBQUFBQkNBUUFBQUMxSEF3Q0FBQUFDMGxFUVZSNDJtUDgveDhBQXdNQ0FPK2lwMXNBQUFBQVNVVk9SSzVDWUlJPVwiO1xuY29uc3QgY2hlY2tJbWFnZUJpdG1hcENvZGUgPSB7XG4gIGlkOiBcImNoZWNrSW1hZ2VCaXRtYXBcIixcbiAgY29kZTogYFxuICAgIGFzeW5jIGZ1bmN0aW9uIGNoZWNrSW1hZ2VCaXRtYXAoKVxuICAgIHtcbiAgICAgICAgdHJ5XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnJHtXSElURV9QTkd9Jyk7XG4gICAgICAgICAgICBjb25zdCBpbWFnZUJsb2IgPSAgYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICAgICAgY29uc3QgaW1hZ2VCaXRtYXAgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChpbWFnZUJsb2IpO1xuXG4gICAgICAgICAgICByZXR1cm4gaW1hZ2VCaXRtYXAud2lkdGggPT09IDEgJiYgaW1hZ2VCaXRtYXAuaGVpZ2h0ID09PSAxO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tJbWFnZUJpdG1hcCgpLnRoZW4oKHJlc3VsdCkgPT4geyBzZWxmLnBvc3RNZXNzYWdlKHJlc3VsdCk7IH0pO1xuICAgIGBcbn07XG5jb25zdCB3b3JrZXJDb2RlID0ge1xuICBpZDogXCJsb2FkSW1hZ2VCaXRtYXBcIixcbiAgY29kZTogYFxuICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRJbWFnZUJpdG1hcCh1cmwpXG4gICAge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcYFtXb3JrZXJNYW5hZ2VyLmxvYWRJbWFnZUJpdG1hcF0gRmFpbGVkIHRvIGZldGNoIFxcJHt1cmx9OiBcXGBcbiAgICAgICAgICAgICAgICArIFxcYFxcJHtyZXNwb25zZS5zdGF0dXN9IFxcJHtyZXNwb25zZS5zdGF0dXNUZXh0fVxcYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbWFnZUJsb2IgPSAgYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICBjb25zdCBpbWFnZUJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGltYWdlQmxvYik7XG5cbiAgICAgICAgcmV0dXJuIGltYWdlQml0bWFwO1xuICAgIH1cbiAgICBzZWxmLm9ubWVzc2FnZSA9IGFzeW5jIChldmVudCkgPT5cbiAgICB7XG4gICAgICAgIHRyeVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBpbWFnZUJpdG1hcCA9IGF3YWl0IGxvYWRJbWFnZUJpdG1hcChldmVudC5kYXRhLmRhdGFbMF0pO1xuXG4gICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBpbWFnZUJpdG1hcCxcbiAgICAgICAgICAgICAgICB1dWlkOiBldmVudC5kYXRhLnV1aWQsXG4gICAgICAgICAgICAgICAgaWQ6IGV2ZW50LmRhdGEuaWQsXG4gICAgICAgICAgICB9LCBbaW1hZ2VCaXRtYXBdKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlKVxuICAgICAgICB7XG4gICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgICAgICB1dWlkOiBldmVudC5kYXRhLnV1aWQsXG4gICAgICAgICAgICAgICAgaWQ6IGV2ZW50LmRhdGEuaWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07YFxufTtcbmxldCB3b3JrZXJVUkw7XG5jbGFzcyBXb3JrZXJNYW5hZ2VyQ2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuX2NyZWF0ZWRXb3JrZXJzID0gMDtcbiAgICB0aGlzLndvcmtlclBvb2wgPSBbXTtcbiAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgdGhpcy5yZXNvbHZlSGFzaCA9IHt9O1xuICB9XG4gIGlzSW1hZ2VCaXRtYXBTdXBwb3J0ZWQoKSB7XG4gICAgaWYgKHRoaXMuX2lzSW1hZ2VCaXRtYXBTdXBwb3J0ZWQgIT09IHZvaWQgMClcbiAgICAgIHJldHVybiB0aGlzLl9pc0ltYWdlQml0bWFwU3VwcG9ydGVkO1xuICAgIHRoaXMuX2lzSW1hZ2VCaXRtYXBTdXBwb3J0ZWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3Qgd29ya2VyVVJMMiA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW2NoZWNrSW1hZ2VCaXRtYXBDb2RlLmNvZGVdLCB7IHR5cGU6IFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiIH0pKTtcbiAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyVVJMMik7XG4gICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh3b3JrZXJVUkwyKTtcbiAgICAgICAgcmVzb2x2ZShldmVudC5kYXRhKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9pc0ltYWdlQml0bWFwU3VwcG9ydGVkO1xuICB9XG4gIGxvYWRJbWFnZUJpdG1hcChzcmMpIHtcbiAgICByZXR1cm4gdGhpcy5fcnVuKFwibG9hZEltYWdlQml0bWFwXCIsIFtzcmNdKTtcbiAgfVxuICBhc3luYyBfaW5pdFdvcmtlcnMoKSB7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgfVxuICBnZXRXb3JrZXIoKSB7XG4gICAgaWYgKE1BWF9XT1JLRVJTID09PSB2b2lkIDApIHtcbiAgICAgIE1BWF9XT1JLRVJTID0gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kgfHwgNDtcbiAgICB9XG4gICAgbGV0IHdvcmtlciA9IHRoaXMud29ya2VyUG9vbC5wb3AoKTtcbiAgICBpZiAoIXdvcmtlciAmJiB0aGlzLl9jcmVhdGVkV29ya2VycyA8IE1BWF9XT1JLRVJTKSB7XG4gICAgICBpZiAoIXdvcmtlclVSTCkge1xuICAgICAgICB3b3JrZXJVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFt3b3JrZXJDb2RlLmNvZGVdLCB7IHR5cGU6IFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiIH0pKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NyZWF0ZWRXb3JrZXJzKys7XG4gICAgICB3b3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlclVSTCk7XG4gICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgIHRoaXMuY29tcGxldGUoZXZlbnQuZGF0YSk7XG4gICAgICAgIHRoaXMucmV0dXJuV29ya2VyKGV2ZW50LnRhcmdldCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB3b3JrZXI7XG4gIH1cbiAgcmV0dXJuV29ya2VyKHdvcmtlcikge1xuICAgIHRoaXMud29ya2VyUG9vbC5wdXNoKHdvcmtlcik7XG4gIH1cbiAgY29tcGxldGUoZGF0YSkge1xuICAgIGlmIChkYXRhLmVycm9yICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucmVzb2x2ZUhhc2hbZGF0YS51dWlkXS5yZWplY3QoZGF0YS5lcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzb2x2ZUhhc2hbZGF0YS51dWlkXS5yZXNvbHZlKGRhdGEuZGF0YSk7XG4gICAgfVxuICAgIHRoaXMucmVzb2x2ZUhhc2hbZGF0YS51dWlkXSA9IG51bGw7XG4gIH1cbiAgYXN5bmMgX3J1bihpZCwgYXJncykge1xuICAgIGF3YWl0IHRoaXMuX2luaXRXb3JrZXJzKCk7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucXVldWUucHVzaCh7IGlkLCBhcmd1bWVudHM6IGFyZ3MsIHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICB9KTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBuZXh0KCkge1xuICAgIGlmICghdGhpcy5xdWV1ZS5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgd29ya2VyID0gdGhpcy5nZXRXb3JrZXIoKTtcbiAgICBpZiAoIXdvcmtlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0b0RvID0gdGhpcy5xdWV1ZS5wb3AoKTtcbiAgICBjb25zdCBpZCA9IHRvRG8uaWQ7XG4gICAgdGhpcy5yZXNvbHZlSGFzaFtVVUlEXSA9IHsgcmVzb2x2ZTogdG9Eby5yZXNvbHZlLCByZWplY3Q6IHRvRG8ucmVqZWN0IH07XG4gICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgIGRhdGE6IHRvRG8uYXJndW1lbnRzLFxuICAgICAgdXVpZDogVVVJRCsrLFxuICAgICAgaWRcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgV29ya2VyTWFuYWdlciA9IG5ldyBXb3JrZXJNYW5hZ2VyQ2xhc3MoKTtcblxuZXhwb3J0IHsgV29ya2VyTWFuYWdlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V29ya2VyTWFuYWdlci5tanMubWFwXG4iLCJpbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHR1cmUoYmFzZSwgbG9hZGVyLCB1cmwpIHtcbiAgY29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGJhc2UpO1xuICB0ZXh0dXJlLmJhc2VUZXh0dXJlLm9uKFwiZGlzcG9zZVwiLCAoKSA9PiB7XG4gICAgZGVsZXRlIGxvYWRlci5wcm9taXNlQ2FjaGVbdXJsXTtcbiAgfSk7XG4gIHJldHVybiB0ZXh0dXJlO1xufVxuXG5leHBvcnQgeyBjcmVhdGVUZXh0dXJlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVUZXh0dXJlLm1qcy5tYXBcbiIsImltcG9ydCB7IHNldHRpbmdzLCBFeHRlbnNpb25UeXBlLCBCYXNlVGV4dHVyZSwgdXRpbHMsIGV4dGVuc2lvbnMgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IGNoZWNrRGF0YVVybCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NoZWNrRGF0YVVybC5tanMnO1xuaW1wb3J0IHsgY2hlY2tFeHRlbnNpb24gfSBmcm9tICcuLi8uLi8uLi91dGlscy9jaGVja0V4dGVuc2lvbi5tanMnO1xuaW1wb3J0IHsgTG9hZGVyUGFyc2VyUHJpb3JpdHkgfSBmcm9tICcuLi9Mb2FkZXJQYXJzZXIubWpzJztcbmltcG9ydCB7IFdvcmtlck1hbmFnZXIgfSBmcm9tICcuLi9Xb3JrZXJNYW5hZ2VyLm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVUZXh0dXJlIH0gZnJvbSAnLi91dGlscy9jcmVhdGVUZXh0dXJlLm1qcyc7XG5cbmNvbnN0IHZhbGlkSW1hZ2VFeHRlbnNpb25zID0gW1wiLmpwZWdcIiwgXCIuanBnXCIsIFwiLnBuZ1wiLCBcIi53ZWJwXCIsIFwiLmF2aWZcIl07XG5jb25zdCB2YWxpZEltYWdlTUlNRXMgPSBbXG4gIFwiaW1hZ2UvanBlZ1wiLFxuICBcImltYWdlL3BuZ1wiLFxuICBcImltYWdlL3dlYnBcIixcbiAgXCJpbWFnZS9hdmlmXCJcbl07XG5hc3luYyBmdW5jdGlvbiBsb2FkSW1hZ2VCaXRtYXAodXJsKSB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2V0dGluZ3MuQURBUFRFUi5mZXRjaCh1cmwpO1xuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBbbG9hZEltYWdlQml0bWFwXSBGYWlsZWQgdG8gZmV0Y2ggJHt1cmx9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICB9XG4gIGNvbnN0IGltYWdlQmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgY29uc3QgaW1hZ2VCaXRtYXAgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChpbWFnZUJsb2IpO1xuICByZXR1cm4gaW1hZ2VCaXRtYXA7XG59XG5jb25zdCBsb2FkVGV4dHVyZXMgPSB7XG4gIG5hbWU6IFwibG9hZFRleHR1cmVzXCIsXG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuTG9hZFBhcnNlcixcbiAgICBwcmlvcml0eTogTG9hZGVyUGFyc2VyUHJpb3JpdHkuSGlnaFxuICB9LFxuICBjb25maWc6IHtcbiAgICBwcmVmZXJXb3JrZXJzOiB0cnVlLFxuICAgIHByZWZlckNyZWF0ZUltYWdlQml0bWFwOiB0cnVlLFxuICAgIGNyb3NzT3JpZ2luOiBcImFub255bW91c1wiXG4gIH0sXG4gIHRlc3QodXJsKSB7XG4gICAgcmV0dXJuIGNoZWNrRGF0YVVybCh1cmwsIHZhbGlkSW1hZ2VNSU1FcykgfHwgY2hlY2tFeHRlbnNpb24odXJsLCB2YWxpZEltYWdlRXh0ZW5zaW9ucyk7XG4gIH0sXG4gIGFzeW5jIGxvYWQodXJsLCBhc3NldCwgbG9hZGVyKSB7XG4gICAgbGV0IHNyYyA9IG51bGw7XG4gICAgaWYgKGdsb2JhbFRoaXMuY3JlYXRlSW1hZ2VCaXRtYXAgJiYgdGhpcy5jb25maWcucHJlZmVyQ3JlYXRlSW1hZ2VCaXRtYXApIHtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5wcmVmZXJXb3JrZXJzICYmIGF3YWl0IFdvcmtlck1hbmFnZXIuaXNJbWFnZUJpdG1hcFN1cHBvcnRlZCgpKSB7XG4gICAgICAgIHNyYyA9IGF3YWl0IFdvcmtlck1hbmFnZXIubG9hZEltYWdlQml0bWFwKHVybCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcmMgPSBhd2FpdCBsb2FkSW1hZ2VCaXRtYXAodXJsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3JjID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgc3JjID0gbmV3IEltYWdlKCk7XG4gICAgICAgIHNyYy5jcm9zc09yaWdpbiA9IHRoaXMuY29uZmlnLmNyb3NzT3JpZ2luO1xuICAgICAgICBzcmMuc3JjID0gdXJsO1xuICAgICAgICBpZiAoc3JjLmNvbXBsZXRlKSB7XG4gICAgICAgICAgcmVzb2x2ZShzcmMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNyYy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKHNyYyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGJhc2UgPSBuZXcgQmFzZVRleHR1cmUoc3JjLCB7XG4gICAgICByZXNvbHV0aW9uOiB1dGlscy5nZXRSZXNvbHV0aW9uT2ZVcmwodXJsKSxcbiAgICAgIC4uLmFzc2V0LmRhdGFcbiAgICB9KTtcbiAgICBiYXNlLnJlc291cmNlLnNyYyA9IHVybDtcbiAgICByZXR1cm4gY3JlYXRlVGV4dHVyZShiYXNlLCBsb2FkZXIsIHVybCk7XG4gIH0sXG4gIHVubG9hZCh0ZXh0dXJlKSB7XG4gICAgdGV4dHVyZS5kZXN0cm95KHRydWUpO1xuICB9XG59O1xuZXh0ZW5zaW9ucy5hZGQobG9hZFRleHR1cmVzKTtcblxuZXhwb3J0IHsgbG9hZEltYWdlQml0bWFwLCBsb2FkVGV4dHVyZXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRUZXh0dXJlcy5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBTVkdSZXNvdXJjZSwgQmFzZVRleHR1cmUsIHV0aWxzLCBzZXR0aW5ncywgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgY2hlY2tEYXRhVXJsIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY2hlY2tEYXRhVXJsLm1qcyc7XG5pbXBvcnQgeyBjaGVja0V4dGVuc2lvbiB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NoZWNrRXh0ZW5zaW9uLm1qcyc7XG5pbXBvcnQgeyBMb2FkZXJQYXJzZXJQcmlvcml0eSB9IGZyb20gJy4uL0xvYWRlclBhcnNlci5tanMnO1xuaW1wb3J0IHsgbG9hZFRleHR1cmVzIH0gZnJvbSAnLi9sb2FkVGV4dHVyZXMubWpzJztcbmltcG9ydCB7IGNyZWF0ZVRleHR1cmUgfSBmcm9tICcuL3V0aWxzL2NyZWF0ZVRleHR1cmUubWpzJztcblxuY29uc3QgdmFsaWRTVkdFeHRlbnNpb24gPSBcIi5zdmdcIjtcbmNvbnN0IHZhbGlkU1ZHTUlNRSA9IFwiaW1hZ2Uvc3ZnK3htbFwiO1xuY29uc3QgbG9hZFNWRyA9IHtcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLFxuICAgIHByaW9yaXR5OiBMb2FkZXJQYXJzZXJQcmlvcml0eS5IaWdoXG4gIH0sXG4gIG5hbWU6IFwibG9hZFNWR1wiLFxuICB0ZXN0KHVybCkge1xuICAgIHJldHVybiBjaGVja0RhdGFVcmwodXJsLCB2YWxpZFNWR01JTUUpIHx8IGNoZWNrRXh0ZW5zaW9uKHVybCwgdmFsaWRTVkdFeHRlbnNpb24pO1xuICB9LFxuICBhc3luYyB0ZXN0UGFyc2UoZGF0YSkge1xuICAgIHJldHVybiBTVkdSZXNvdXJjZS50ZXN0KGRhdGEpO1xuICB9LFxuICBhc3luYyBwYXJzZShhc3NldCwgZGF0YSwgbG9hZGVyKSB7XG4gICAgY29uc3Qgc3JjID0gbmV3IFNWR1Jlc291cmNlKGFzc2V0LCBkYXRhPy5kYXRhPy5yZXNvdXJjZU9wdGlvbnMpO1xuICAgIGF3YWl0IHNyYy5sb2FkKCk7XG4gICAgY29uc3QgYmFzZSA9IG5ldyBCYXNlVGV4dHVyZShzcmMsIHtcbiAgICAgIHJlc29sdXRpb246IHV0aWxzLmdldFJlc29sdXRpb25PZlVybChhc3NldCksXG4gICAgICAuLi5kYXRhPy5kYXRhXG4gICAgfSk7XG4gICAgYmFzZS5yZXNvdXJjZS5zcmMgPSBhc3NldDtcbiAgICBjb25zdCB0ZXh0dXJlID0gY3JlYXRlVGV4dHVyZShiYXNlLCBsb2FkZXIsIGFzc2V0KTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfSxcbiAgYXN5bmMgbG9hZCh1cmwsIF9vcHRpb25zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZXR0aW5ncy5BREFQVEVSLmZldGNoKHVybCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgfSxcbiAgdW5sb2FkOiBsb2FkVGV4dHVyZXMudW5sb2FkXG59O1xuZXh0ZW5zaW9ucy5hZGQobG9hZFNWRyk7XG5cbmV4cG9ydCB7IGxvYWRTVkcgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRTVkcubWpzLm1hcFxuIiwiZXhwb3J0IHsgY3JlYXRlVGV4dHVyZSB9IGZyb20gJy4vY3JlYXRlVGV4dHVyZS5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiZXhwb3J0IHsgbG9hZFNWRyB9IGZyb20gJy4vbG9hZFNWRy5tanMnO1xuZXhwb3J0IHsgbG9hZEltYWdlQml0bWFwLCBsb2FkVGV4dHVyZXMgfSBmcm9tICcuL2xvYWRUZXh0dXJlcy5tanMnO1xuaW1wb3J0ICcuL3V0aWxzL2luZGV4Lm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJleHBvcnQgeyBMb2FkZXJQYXJzZXJQcmlvcml0eSB9IGZyb20gJy4vTG9hZGVyUGFyc2VyLm1qcyc7XG5leHBvcnQgeyBsb2FkSnNvbiB9IGZyb20gJy4vbG9hZEpzb24ubWpzJztcbmV4cG9ydCB7IGxvYWRUeHQgfSBmcm9tICcuL2xvYWRUeHQubWpzJztcbmV4cG9ydCB7IGdldEZvbnRGYW1pbHlOYW1lLCBsb2FkV2ViRm9udCB9IGZyb20gJy4vbG9hZFdlYkZvbnQubWpzJztcbmltcG9ydCAnLi90ZXh0dXJlcy9pbmRleC5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiZnVuY3Rpb24gcHJvY2Vzc1goYmFzZSwgaWRzLCBkZXB0aCwgcmVzdWx0LCB0YWdzKSB7XG4gIGNvbnN0IGlkID0gaWRzW2RlcHRoXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZhbHVlID0gaWRbaV07XG4gICAgaWYgKGRlcHRoIDwgaWRzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHByb2Nlc3NYKGJhc2UucmVwbGFjZShyZXN1bHRbZGVwdGhdLCB2YWx1ZSksIGlkcywgZGVwdGggKyAxLCByZXN1bHQsIHRhZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWdzLnB1c2goYmFzZS5yZXBsYWNlKHJlc3VsdFtkZXB0aF0sIHZhbHVlKSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVTdHJpbmdWYXJpYXRpb25zKHN0cmluZykge1xuICBjb25zdCByZWdleCA9IC9cXHsoLio/KVxcfS9nO1xuICBjb25zdCByZXN1bHQgPSBzdHJpbmcubWF0Y2gocmVnZXgpO1xuICBjb25zdCB0YWdzID0gW107XG4gIGlmIChyZXN1bHQpIHtcbiAgICBjb25zdCBpZHMgPSBbXTtcbiAgICByZXN1bHQuZm9yRWFjaCgodmFycykgPT4ge1xuICAgICAgY29uc3Qgc3BsaXQgPSB2YXJzLnN1YnN0cmluZygxLCB2YXJzLmxlbmd0aCAtIDEpLnNwbGl0KFwiLFwiKTtcbiAgICAgIGlkcy5wdXNoKHNwbGl0KTtcbiAgICB9KTtcbiAgICBwcm9jZXNzWChzdHJpbmcsIGlkcywgMCwgcmVzdWx0LCB0YWdzKTtcbiAgfSBlbHNlIHtcbiAgICB0YWdzLnB1c2goc3RyaW5nKTtcbiAgfVxuICByZXR1cm4gdGFncztcbn1cblxuZXhwb3J0IHsgY3JlYXRlU3RyaW5nVmFyaWF0aW9ucyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlU3RyaW5nVmFyaWF0aW9ucy5tanMubWFwXG4iLCJpbXBvcnQgeyB1dGlscyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgY29udmVydFRvTGlzdCB9IGZyb20gJy4uL3V0aWxzL2NvbnZlcnRUb0xpc3QubWpzJztcbmltcG9ydCB7IGNyZWF0ZVN0cmluZ1ZhcmlhdGlvbnMgfSBmcm9tICcuLi91dGlscy9jcmVhdGVTdHJpbmdWYXJpYXRpb25zLm1qcyc7XG5pbXBvcnQgeyBpc1NpbmdsZUl0ZW0gfSBmcm9tICcuLi91dGlscy9pc1NpbmdsZUl0ZW0ubWpzJztcblxuY2xhc3MgUmVzb2x2ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9kZWZhdWx0QnVuZGxlSWRlbnRpZmllck9wdGlvbnMgPSB7XG4gICAgICBjb25uZWN0b3I6IFwiLVwiLFxuICAgICAgY3JlYXRlQnVuZGxlQXNzZXRJZDogKGJ1bmRsZUlkLCBhc3NldElkKSA9PiBgJHtidW5kbGVJZH0ke3RoaXMuX2J1bmRsZUlkQ29ubmVjdG9yfSR7YXNzZXRJZH1gLFxuICAgICAgZXh0cmFjdEFzc2V0SWRGcm9tQnVuZGxlOiAoYnVuZGxlSWQsIGFzc2V0QnVuZGxlSWQpID0+IGFzc2V0QnVuZGxlSWQucmVwbGFjZShgJHtidW5kbGVJZH0ke3RoaXMuX2J1bmRsZUlkQ29ubmVjdG9yfWAsIFwiXCIpXG4gICAgfTtcbiAgICB0aGlzLl9idW5kbGVJZENvbm5lY3RvciA9IHRoaXMuX2RlZmF1bHRCdW5kbGVJZGVudGlmaWVyT3B0aW9ucy5jb25uZWN0b3I7XG4gICAgdGhpcy5fY3JlYXRlQnVuZGxlQXNzZXRJZCA9IHRoaXMuX2RlZmF1bHRCdW5kbGVJZGVudGlmaWVyT3B0aW9ucy5jcmVhdGVCdW5kbGVBc3NldElkO1xuICAgIHRoaXMuX2V4dHJhY3RBc3NldElkRnJvbUJ1bmRsZSA9IHRoaXMuX2RlZmF1bHRCdW5kbGVJZGVudGlmaWVyT3B0aW9ucy5leHRyYWN0QXNzZXRJZEZyb21CdW5kbGU7XG4gICAgdGhpcy5fYXNzZXRNYXAgPSB7fTtcbiAgICB0aGlzLl9wcmVmZXJyZWRPcmRlciA9IFtdO1xuICAgIHRoaXMuX3BhcnNlcnMgPSBbXTtcbiAgICB0aGlzLl9yZXNvbHZlckhhc2ggPSB7fTtcbiAgICB0aGlzLl9idW5kbGVzID0ge307XG4gIH1cbiAgc2V0QnVuZGxlSWRlbnRpZmllcihidW5kbGVJZGVudGlmaWVyKSB7XG4gICAgdGhpcy5fYnVuZGxlSWRDb25uZWN0b3IgPSBidW5kbGVJZGVudGlmaWVyLmNvbm5lY3RvciA/PyB0aGlzLl9idW5kbGVJZENvbm5lY3RvcjtcbiAgICB0aGlzLl9jcmVhdGVCdW5kbGVBc3NldElkID0gYnVuZGxlSWRlbnRpZmllci5jcmVhdGVCdW5kbGVBc3NldElkID8/IHRoaXMuX2NyZWF0ZUJ1bmRsZUFzc2V0SWQ7XG4gICAgdGhpcy5fZXh0cmFjdEFzc2V0SWRGcm9tQnVuZGxlID0gYnVuZGxlSWRlbnRpZmllci5leHRyYWN0QXNzZXRJZEZyb21CdW5kbGUgPz8gdGhpcy5fZXh0cmFjdEFzc2V0SWRGcm9tQnVuZGxlO1xuICAgIGlmICh0aGlzLl9leHRyYWN0QXNzZXRJZEZyb21CdW5kbGUoXCJmb29cIiwgdGhpcy5fY3JlYXRlQnVuZGxlQXNzZXRJZChcImZvb1wiLCBcImJhclwiKSkgIT09IFwiYmFyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltSZXNvbHZlcl0gR2VuZXJhdGVCdW5kbGVBc3NldElkIGFyZSBub3Qgd29ya2luZyBjb3JyZWN0bHlcIik7XG4gICAgfVxuICB9XG4gIHByZWZlciguLi5wcmVmZXJPcmRlcnMpIHtcbiAgICBwcmVmZXJPcmRlcnMuZm9yRWFjaCgocHJlZmVyKSA9PiB7XG4gICAgICB0aGlzLl9wcmVmZXJyZWRPcmRlci5wdXNoKHByZWZlcik7XG4gICAgICBpZiAoIXByZWZlci5wcmlvcml0eSkge1xuICAgICAgICBwcmVmZXIucHJpb3JpdHkgPSBPYmplY3Qua2V5cyhwcmVmZXIucGFyYW1zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9yZXNvbHZlckhhc2ggPSB7fTtcbiAgfVxuICBzZXQgYmFzZVBhdGgoYmFzZVBhdGgpIHtcbiAgICB0aGlzLl9iYXNlUGF0aCA9IGJhc2VQYXRoO1xuICB9XG4gIGdldCBiYXNlUGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFzZVBhdGg7XG4gIH1cbiAgc2V0IHJvb3RQYXRoKHJvb3RQYXRoKSB7XG4gICAgdGhpcy5fcm9vdFBhdGggPSByb290UGF0aDtcbiAgfVxuICBnZXQgcm9vdFBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3RQYXRoO1xuICB9XG4gIGdldCBwYXJzZXJzKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJzZXJzO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuc2V0QnVuZGxlSWRlbnRpZmllcih0aGlzLl9kZWZhdWx0QnVuZGxlSWRlbnRpZmllck9wdGlvbnMpO1xuICAgIHRoaXMuX2Fzc2V0TWFwID0ge307XG4gICAgdGhpcy5fcHJlZmVycmVkT3JkZXIgPSBbXTtcbiAgICB0aGlzLl9yZXNvbHZlckhhc2ggPSB7fTtcbiAgICB0aGlzLl9yb290UGF0aCA9IG51bGw7XG4gICAgdGhpcy5fYmFzZVBhdGggPSBudWxsO1xuICAgIHRoaXMuX21hbmlmZXN0ID0gbnVsbDtcbiAgICB0aGlzLl9idW5kbGVzID0ge307XG4gICAgdGhpcy5fZGVmYXVsdFNlYXJjaFBhcmFtcyA9IG51bGw7XG4gIH1cbiAgc2V0RGVmYXVsdFNlYXJjaFBhcmFtcyhzZWFyY2hQYXJhbXMpIHtcbiAgICBpZiAodHlwZW9mIHNlYXJjaFBhcmFtcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhpcy5fZGVmYXVsdFNlYXJjaFBhcmFtcyA9IHNlYXJjaFBhcmFtcztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcXVlcnlWYWx1ZXMgPSBzZWFyY2hQYXJhbXM7XG4gICAgICB0aGlzLl9kZWZhdWx0U2VhcmNoUGFyYW1zID0gT2JqZWN0LmtleXMocXVlcnlWYWx1ZXMpLm1hcCgoa2V5KSA9PiBgJHtlbmNvZGVVUklDb21wb25lbnQoa2V5KX09JHtlbmNvZGVVUklDb21wb25lbnQocXVlcnlWYWx1ZXNba2V5XSl9YCkuam9pbihcIiZcIik7XG4gICAgfVxuICB9XG4gIGFkZE1hbmlmZXN0KG1hbmlmZXN0KSB7XG4gICAgaWYgKHRoaXMuX21hbmlmZXN0KSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbUmVzb2x2ZXJdIE1hbmlmZXN0IGFscmVhZHkgZXhpc3RzLCB0aGlzIHdpbGwgYmUgb3ZlcndyaXR0ZW5cIik7XG4gICAgfVxuICAgIHRoaXMuX21hbmlmZXN0ID0gbWFuaWZlc3Q7XG4gICAgbWFuaWZlc3QuYnVuZGxlcy5mb3JFYWNoKChidW5kbGUpID0+IHtcbiAgICAgIHRoaXMuYWRkQnVuZGxlKGJ1bmRsZS5uYW1lLCBidW5kbGUuYXNzZXRzKTtcbiAgICB9KTtcbiAgfVxuICBhZGRCdW5kbGUoYnVuZGxlSWQsIGFzc2V0cykge1xuICAgIGNvbnN0IGFzc2V0TmFtZXMgPSBbXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhc3NldHMpKSB7XG4gICAgICBhc3NldHMuZm9yRWFjaCgoYXNzZXQpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBhc3NldC5uYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29uc3QgYnVuZGxlQXNzZXRJZCA9IHRoaXMuX2NyZWF0ZUJ1bmRsZUFzc2V0SWQoYnVuZGxlSWQsIGFzc2V0Lm5hbWUpO1xuICAgICAgICAgIGFzc2V0TmFtZXMucHVzaChidW5kbGVBc3NldElkKTtcbiAgICAgICAgICB0aGlzLmFkZChbYXNzZXQubmFtZSwgYnVuZGxlQXNzZXRJZF0sIGFzc2V0LnNyY3MsIGFzc2V0LmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGJ1bmRsZUlkcyA9IGFzc2V0Lm5hbWUubWFwKChuYW1lKSA9PiB0aGlzLl9jcmVhdGVCdW5kbGVBc3NldElkKGJ1bmRsZUlkLCBuYW1lKSk7XG4gICAgICAgICAgYnVuZGxlSWRzLmZvckVhY2goKGJ1bmRsZUlkMikgPT4ge1xuICAgICAgICAgICAgYXNzZXROYW1lcy5wdXNoKGJ1bmRsZUlkMik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5hZGQoWy4uLmFzc2V0Lm5hbWUsIC4uLmJ1bmRsZUlkc10sIGFzc2V0LnNyY3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmtleXMoYXNzZXRzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgYXNzZXROYW1lcy5wdXNoKHRoaXMuX2NyZWF0ZUJ1bmRsZUFzc2V0SWQoYnVuZGxlSWQsIGtleSkpO1xuICAgICAgICB0aGlzLmFkZChba2V5LCB0aGlzLl9jcmVhdGVCdW5kbGVBc3NldElkKGJ1bmRsZUlkLCBrZXkpXSwgYXNzZXRzW2tleV0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX2J1bmRsZXNbYnVuZGxlSWRdID0gYXNzZXROYW1lcztcbiAgfVxuICBhZGQoa2V5c0luLCBhc3NldHNJbiwgZGF0YSkge1xuICAgIGNvbnN0IGtleXMgPSBjb252ZXJ0VG9MaXN0KGtleXNJbik7XG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmICh0aGlzLmhhc0tleShrZXkpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgW1Jlc29sdmVyXSBhbHJlYWR5IGhhcyBrZXk6ICR7a2V5fSBvdmVyd3JpdGluZ2ApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhc3NldHNJbikpIHtcbiAgICAgIGlmICh0eXBlb2YgYXNzZXRzSW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgYXNzZXRzSW4gPSBjcmVhdGVTdHJpbmdWYXJpYXRpb25zKGFzc2V0c0luKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2V0c0luID0gW2Fzc2V0c0luXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYXNzZXRNYXAgPSBhc3NldHNJbi5tYXAoKGFzc2V0KSA9PiB7XG4gICAgICBsZXQgZm9ybWF0dGVkQXNzZXQgPSBhc3NldDtcbiAgICAgIGlmICh0eXBlb2YgYXNzZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbGV0IHBhcnNlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3BhcnNlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBwYXJzZXIgPSB0aGlzLl9wYXJzZXJzW2ldO1xuICAgICAgICAgIGlmIChwYXJzZXIudGVzdChhc3NldCkpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZEFzc2V0ID0gcGFyc2VyLnBhcnNlKGFzc2V0KTtcbiAgICAgICAgICAgIHBhcnNlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICBmb3JtYXR0ZWRBc3NldCA9IHtcbiAgICAgICAgICAgIHNyYzogYXNzZXRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWZvcm1hdHRlZEFzc2V0LmZvcm1hdCkge1xuICAgICAgICBmb3JtYXR0ZWRBc3NldC5mb3JtYXQgPSBmb3JtYXR0ZWRBc3NldC5zcmMuc3BsaXQoXCIuXCIpLnBvcCgpO1xuICAgICAgfVxuICAgICAgaWYgKCFmb3JtYXR0ZWRBc3NldC5hbGlhcykge1xuICAgICAgICBmb3JtYXR0ZWRBc3NldC5hbGlhcyA9IGtleXM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fYmFzZVBhdGggfHwgdGhpcy5fcm9vdFBhdGgpIHtcbiAgICAgICAgZm9ybWF0dGVkQXNzZXQuc3JjID0gdXRpbHMucGF0aC50b0Fic29sdXRlKGZvcm1hdHRlZEFzc2V0LnNyYywgdGhpcy5fYmFzZVBhdGgsIHRoaXMuX3Jvb3RQYXRoKTtcbiAgICAgIH1cbiAgICAgIGZvcm1hdHRlZEFzc2V0LnNyYyA9IHRoaXMuX2FwcGVuZERlZmF1bHRTZWFyY2hQYXJhbXMoZm9ybWF0dGVkQXNzZXQuc3JjKTtcbiAgICAgIGZvcm1hdHRlZEFzc2V0LmRhdGEgPSBmb3JtYXR0ZWRBc3NldC5kYXRhID8/IGRhdGE7XG4gICAgICByZXR1cm4gZm9ybWF0dGVkQXNzZXQ7XG4gICAgfSk7XG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHRoaXMuX2Fzc2V0TWFwW2tleV0gPSBhc3NldE1hcDtcbiAgICB9KTtcbiAgfVxuICByZXNvbHZlQnVuZGxlKGJ1bmRsZUlkcykge1xuICAgIGNvbnN0IHNpbmdsZUFzc2V0ID0gaXNTaW5nbGVJdGVtKGJ1bmRsZUlkcyk7XG4gICAgYnVuZGxlSWRzID0gY29udmVydFRvTGlzdChidW5kbGVJZHMpO1xuICAgIGNvbnN0IG91dCA9IHt9O1xuICAgIGJ1bmRsZUlkcy5mb3JFYWNoKChidW5kbGVJZCkgPT4ge1xuICAgICAgY29uc3QgYXNzZXROYW1lcyA9IHRoaXMuX2J1bmRsZXNbYnVuZGxlSWRdO1xuICAgICAgaWYgKGFzc2V0TmFtZXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IHRoaXMucmVzb2x2ZShhc3NldE5hbWVzKTtcbiAgICAgICAgY29uc3QgYXNzZXRzID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdHMpIHtcbiAgICAgICAgICBjb25zdCBhc3NldCA9IHJlc3VsdHNba2V5XTtcbiAgICAgICAgICBhc3NldHNbdGhpcy5fZXh0cmFjdEFzc2V0SWRGcm9tQnVuZGxlKGJ1bmRsZUlkLCBrZXkpXSA9IGFzc2V0O1xuICAgICAgICB9XG4gICAgICAgIG91dFtidW5kbGVJZF0gPSBhc3NldHM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNpbmdsZUFzc2V0ID8gb3V0W2J1bmRsZUlkc1swXV0gOiBvdXQ7XG4gIH1cbiAgcmVzb2x2ZVVybChrZXkpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlc29sdmUoa2V5KTtcbiAgICBpZiAodHlwZW9mIGtleSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3Qgb3V0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IGkgaW4gcmVzdWx0KSB7XG4gICAgICAgIG91dFtpXSA9IHJlc3VsdFtpXS5zcmM7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnNyYztcbiAgfVxuICByZXNvbHZlKGtleXMpIHtcbiAgICBjb25zdCBzaW5nbGVBc3NldCA9IGlzU2luZ2xlSXRlbShrZXlzKTtcbiAgICBrZXlzID0gY29udmVydFRvTGlzdChrZXlzKTtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9yZXNvbHZlckhhc2hba2V5XSkge1xuICAgICAgICBpZiAodGhpcy5fYXNzZXRNYXBba2V5XSkge1xuICAgICAgICAgIGxldCBhc3NldHMgPSB0aGlzLl9hc3NldE1hcFtrZXldO1xuICAgICAgICAgIGNvbnN0IHByZWZlcnJlZE9yZGVyID0gdGhpcy5fZ2V0UHJlZmVycmVkT3JkZXIoYXNzZXRzKTtcbiAgICAgICAgICBjb25zdCBiZXN0QXNzZXQgPSBhc3NldHNbMF07XG4gICAgICAgICAgcHJlZmVycmVkT3JkZXI/LnByaW9yaXR5LmZvckVhY2goKHByaW9yaXR5S2V5KSA9PiB7XG4gICAgICAgICAgICBwcmVmZXJyZWRPcmRlci5wYXJhbXNbcHJpb3JpdHlLZXldLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkQXNzZXRzID0gYXNzZXRzLmZpbHRlcigoYXNzZXQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXNzZXRbcHJpb3JpdHlLZXldKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYXNzZXRbcHJpb3JpdHlLZXldID09PSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGZpbHRlcmVkQXNzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFzc2V0cyA9IGZpbHRlcmVkQXNzZXRzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLl9yZXNvbHZlckhhc2hba2V5XSA9IGFzc2V0c1swXSA/PyBiZXN0QXNzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IHNyYyA9IGtleTtcbiAgICAgICAgICBpZiAodGhpcy5fYmFzZVBhdGggfHwgdGhpcy5fcm9vdFBhdGgpIHtcbiAgICAgICAgICAgIHNyYyA9IHV0aWxzLnBhdGgudG9BYnNvbHV0ZShzcmMsIHRoaXMuX2Jhc2VQYXRoLCB0aGlzLl9yb290UGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNyYyA9IHRoaXMuX2FwcGVuZERlZmF1bHRTZWFyY2hQYXJhbXMoc3JjKTtcbiAgICAgICAgICB0aGlzLl9yZXNvbHZlckhhc2hba2V5XSA9IHtcbiAgICAgICAgICAgIHNyY1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdFtrZXldID0gdGhpcy5fcmVzb2x2ZXJIYXNoW2tleV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHNpbmdsZUFzc2V0ID8gcmVzdWx0W2tleXNbMF1dIDogcmVzdWx0O1xuICB9XG4gIGhhc0tleShrZXkpIHtcbiAgICByZXR1cm4gISF0aGlzLl9hc3NldE1hcFtrZXldO1xuICB9XG4gIGhhc0J1bmRsZShrZXkpIHtcbiAgICByZXR1cm4gISF0aGlzLl9idW5kbGVzW2tleV07XG4gIH1cbiAgX2dldFByZWZlcnJlZE9yZGVyKGFzc2V0cykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXNzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBhc3NldCA9IGFzc2V0c1swXTtcbiAgICAgIGNvbnN0IHByZWZlcnJlZCA9IHRoaXMuX3ByZWZlcnJlZE9yZGVyLmZpbmQoKHByZWZlcmVuY2UpID0+IHByZWZlcmVuY2UucGFyYW1zLmZvcm1hdC5pbmNsdWRlcyhhc3NldC5mb3JtYXQpKTtcbiAgICAgIGlmIChwcmVmZXJyZWQpIHtcbiAgICAgICAgcmV0dXJuIHByZWZlcnJlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ByZWZlcnJlZE9yZGVyWzBdO1xuICB9XG4gIF9hcHBlbmREZWZhdWx0U2VhcmNoUGFyYW1zKHVybCkge1xuICAgIGlmICghdGhpcy5fZGVmYXVsdFNlYXJjaFBhcmFtcylcbiAgICAgIHJldHVybiB1cmw7XG4gICAgY29uc3QgcGFyYW1Db25uZWN0b3IgPSAvXFw/Ly50ZXN0KHVybCkgPyBcIiZcIiA6IFwiP1wiO1xuICAgIHJldHVybiBgJHt1cmx9JHtwYXJhbUNvbm5lY3Rvcn0ke3RoaXMuX2RlZmF1bHRTZWFyY2hQYXJhbXN9YDtcbiAgfVxufVxuXG5leHBvcnQgeyBSZXNvbHZlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVzb2x2ZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgdXRpbHMsIGV4dGVuc2lvbnMsIEV4dGVuc2lvblR5cGUgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IEJhY2tncm91bmRMb2FkZXIgfSBmcm9tICcuL0JhY2tncm91bmRMb2FkZXIubWpzJztcbmltcG9ydCB7IENhY2hlIH0gZnJvbSAnLi9jYWNoZS9DYWNoZS5tanMnO1xuaW1wb3J0IHsgTG9hZGVyIH0gZnJvbSAnLi9sb2FkZXIvTG9hZGVyLm1qcyc7XG5pbXBvcnQgJy4vbG9hZGVyL3BhcnNlcnMvaW5kZXgubWpzJztcbmltcG9ydCB7IFJlc29sdmVyIH0gZnJvbSAnLi9yZXNvbHZlci9SZXNvbHZlci5tanMnO1xuaW1wb3J0IHsgY29udmVydFRvTGlzdCB9IGZyb20gJy4vdXRpbHMvY29udmVydFRvTGlzdC5tanMnO1xuaW1wb3J0IHsgaXNTaW5nbGVJdGVtIH0gZnJvbSAnLi91dGlscy9pc1NpbmdsZUl0ZW0ubWpzJztcbmltcG9ydCB7IGxvYWRUZXh0dXJlcyB9IGZyb20gJy4vbG9hZGVyL3BhcnNlcnMvdGV4dHVyZXMvbG9hZFRleHR1cmVzLm1qcyc7XG5cbmNsYXNzIEFzc2V0c0NsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZGV0ZWN0aW9ucyA9IFtdO1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5yZXNvbHZlciA9IG5ldyBSZXNvbHZlcigpO1xuICAgIHRoaXMubG9hZGVyID0gbmV3IExvYWRlcigpO1xuICAgIHRoaXMuY2FjaGUgPSBDYWNoZTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kTG9hZGVyID0gbmV3IEJhY2tncm91bmRMb2FkZXIodGhpcy5sb2FkZXIpO1xuICAgIHRoaXMuX2JhY2tncm91bmRMb2FkZXIuYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cbiAgYXN5bmMgaW5pdChvcHRpb25zID0ge30pIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltBc3NldHNdQXNzZXRNYW5hZ2VyIGFscmVhZHkgaW5pdGlhbGl6ZWQsIGRpZCB5b3UgbG9hZCBiZWZvcmUgY2FsbGluZyB0aGlzIEFzc2V0LmluaXQoKT9cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICBpZiAob3B0aW9ucy5kZWZhdWx0U2VhcmNoUGFyYW1zKSB7XG4gICAgICB0aGlzLnJlc29sdmVyLnNldERlZmF1bHRTZWFyY2hQYXJhbXMob3B0aW9ucy5kZWZhdWx0U2VhcmNoUGFyYW1zKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYmFzZVBhdGgpIHtcbiAgICAgIHRoaXMucmVzb2x2ZXIuYmFzZVBhdGggPSBvcHRpb25zLmJhc2VQYXRoO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5idW5kbGVJZGVudGlmaWVyKSB7XG4gICAgICB0aGlzLnJlc29sdmVyLnNldEJ1bmRsZUlkZW50aWZpZXIob3B0aW9ucy5idW5kbGVJZGVudGlmaWVyKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubWFuaWZlc3QpIHtcbiAgICAgIGxldCBtYW5pZmVzdCA9IG9wdGlvbnMubWFuaWZlc3Q7XG4gICAgICBpZiAodHlwZW9mIG1hbmlmZXN0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1hbmlmZXN0ID0gYXdhaXQgdGhpcy5sb2FkKG1hbmlmZXN0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzb2x2ZXIuYWRkTWFuaWZlc3QobWFuaWZlc3QpO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHV0aW9uUHJlZiA9IG9wdGlvbnMudGV4dHVyZVByZWZlcmVuY2U/LnJlc29sdXRpb24gPz8gMTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdHlwZW9mIHJlc29sdXRpb25QcmVmID09PSBcIm51bWJlclwiID8gW3Jlc29sdXRpb25QcmVmXSA6IHJlc29sdXRpb25QcmVmO1xuICAgIGxldCBmb3JtYXRzID0gW107XG4gICAgaWYgKG9wdGlvbnMudGV4dHVyZVByZWZlcmVuY2U/LmZvcm1hdCkge1xuICAgICAgY29uc3QgZm9ybWF0UHJlZiA9IG9wdGlvbnMudGV4dHVyZVByZWZlcmVuY2U/LmZvcm1hdDtcbiAgICAgIGZvcm1hdHMgPSB0eXBlb2YgZm9ybWF0UHJlZiA9PT0gXCJzdHJpbmdcIiA/IFtmb3JtYXRQcmVmXSA6IGZvcm1hdFByZWY7XG4gICAgICBmb3IgKGNvbnN0IGRldGVjdGlvbiBvZiB0aGlzLl9kZXRlY3Rpb25zKSB7XG4gICAgICAgIGlmICghYXdhaXQgZGV0ZWN0aW9uLnRlc3QoKSkge1xuICAgICAgICAgIGZvcm1hdHMgPSBhd2FpdCBkZXRlY3Rpb24ucmVtb3ZlKGZvcm1hdHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgZGV0ZWN0aW9uIG9mIHRoaXMuX2RldGVjdGlvbnMpIHtcbiAgICAgICAgaWYgKGF3YWl0IGRldGVjdGlvbi50ZXN0KCkpIHtcbiAgICAgICAgICBmb3JtYXRzID0gYXdhaXQgZGV0ZWN0aW9uLmFkZChmb3JtYXRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlc29sdmVyLnByZWZlcih7XG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgZm9ybWF0OiBmb3JtYXRzLFxuICAgICAgICByZXNvbHV0aW9uXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMucHJlZmVyZW5jZXMpIHtcbiAgICAgIHRoaXMuc2V0UHJlZmVyZW5jZXMob3B0aW9ucy5wcmVmZXJlbmNlcyk7XG4gICAgfVxuICB9XG4gIGFkZChrZXlzSW4sIGFzc2V0c0luLCBkYXRhKSB7XG4gICAgdGhpcy5yZXNvbHZlci5hZGQoa2V5c0luLCBhc3NldHNJbiwgZGF0YSk7XG4gIH1cbiAgYXN5bmMgbG9hZCh1cmxzLCBvblByb2dyZXNzKSB7XG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgfVxuICAgIGNvbnN0IHNpbmdsZUFzc2V0ID0gaXNTaW5nbGVJdGVtKHVybHMpO1xuICAgIGNvbnN0IHVybEFycmF5ID0gY29udmVydFRvTGlzdCh1cmxzKS5tYXAoKHVybCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlci5hZGQodXJsLnNyYywgdXJsKTtcbiAgICAgICAgcmV0dXJuIHVybC5zcmM7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucmVzb2x2ZXIuaGFzS2V5KHVybCkpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlci5hZGQodXJsLCB1cmwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVybDtcbiAgICB9KTtcbiAgICBjb25zdCByZXNvbHZlUmVzdWx0cyA9IHRoaXMucmVzb2x2ZXIucmVzb2x2ZSh1cmxBcnJheSk7XG4gICAgY29uc3Qgb3V0ID0gYXdhaXQgdGhpcy5fbWFwTG9hZFRvUmVzb2x2ZShyZXNvbHZlUmVzdWx0cywgb25Qcm9ncmVzcyk7XG4gICAgcmV0dXJuIHNpbmdsZUFzc2V0ID8gb3V0W3VybEFycmF5WzBdXSA6IG91dDtcbiAgfVxuICBhZGRCdW5kbGUoYnVuZGxlSWQsIGFzc2V0cykge1xuICAgIHRoaXMucmVzb2x2ZXIuYWRkQnVuZGxlKGJ1bmRsZUlkLCBhc3NldHMpO1xuICB9XG4gIGFzeW5jIGxvYWRCdW5kbGUoYnVuZGxlSWRzLCBvblByb2dyZXNzKSB7XG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgfVxuICAgIGxldCBzaW5nbGVBc3NldCA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2YgYnVuZGxlSWRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBzaW5nbGVBc3NldCA9IHRydWU7XG4gICAgICBidW5kbGVJZHMgPSBbYnVuZGxlSWRzXTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZVJlc3VsdHMgPSB0aGlzLnJlc29sdmVyLnJlc29sdmVCdW5kbGUoYnVuZGxlSWRzKTtcbiAgICBjb25zdCBvdXQgPSB7fTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocmVzb2x2ZVJlc3VsdHMpO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBjb25zdCBfb25Qcm9ncmVzcyA9ICgpID0+IHtcbiAgICAgIG9uUHJvZ3Jlc3M/LigrK2NvdW50IC8gdG90YWwpO1xuICAgIH07XG4gICAgY29uc3QgcHJvbWlzZXMgPSBrZXlzLm1hcCgoYnVuZGxlSWQpID0+IHtcbiAgICAgIGNvbnN0IHJlc29sdmVSZXN1bHQgPSByZXNvbHZlUmVzdWx0c1tidW5kbGVJZF07XG4gICAgICB0b3RhbCArPSBPYmplY3Qua2V5cyhyZXNvbHZlUmVzdWx0KS5sZW5ndGg7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwTG9hZFRvUmVzb2x2ZShyZXNvbHZlUmVzdWx0LCBfb25Qcm9ncmVzcykudGhlbigocmVzb2x2ZVJlc3VsdDIpID0+IHtcbiAgICAgICAgb3V0W2J1bmRsZUlkXSA9IHJlc29sdmVSZXN1bHQyO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIHJldHVybiBzaW5nbGVBc3NldCA/IG91dFtidW5kbGVJZHNbMF1dIDogb3V0O1xuICB9XG4gIGFzeW5jIGJhY2tncm91bmRMb2FkKHVybHMpIHtcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB1cmxzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB1cmxzID0gW3VybHNdO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlUmVzdWx0cyA9IHRoaXMucmVzb2x2ZXIucmVzb2x2ZSh1cmxzKTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kTG9hZGVyLmFkZChPYmplY3QudmFsdWVzKHJlc29sdmVSZXN1bHRzKSk7XG4gIH1cbiAgYXN5bmMgYmFja2dyb3VuZExvYWRCdW5kbGUoYnVuZGxlSWRzKSB7XG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYnVuZGxlSWRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBidW5kbGVJZHMgPSBbYnVuZGxlSWRzXTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZVJlc3VsdHMgPSB0aGlzLnJlc29sdmVyLnJlc29sdmVCdW5kbGUoYnVuZGxlSWRzKTtcbiAgICBPYmplY3QudmFsdWVzKHJlc29sdmVSZXN1bHRzKS5mb3JFYWNoKChyZXNvbHZlUmVzdWx0KSA9PiB7XG4gICAgICB0aGlzLl9iYWNrZ3JvdW5kTG9hZGVyLmFkZChPYmplY3QudmFsdWVzKHJlc29sdmVSZXN1bHQpKTtcbiAgICB9KTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLnJlc29sdmVyLnJlc2V0KCk7XG4gICAgdGhpcy5sb2FkZXIucmVzZXQoKTtcbiAgICB0aGlzLmNhY2hlLnJlc2V0KCk7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgfVxuICBnZXQoa2V5cykge1xuICAgIGlmICh0eXBlb2Yga2V5cyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIENhY2hlLmdldChrZXlzKTtcbiAgICB9XG4gICAgY29uc3QgYXNzZXRzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhc3NldHNbaV0gPSBDYWNoZS5nZXQoa2V5c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBhc3NldHM7XG4gIH1cbiAgYXN5bmMgX21hcExvYWRUb1Jlc29sdmUocmVzb2x2ZVJlc3VsdHMsIG9uUHJvZ3Jlc3MpIHtcbiAgICBjb25zdCByZXNvbHZlQXJyYXkgPSBPYmplY3QudmFsdWVzKHJlc29sdmVSZXN1bHRzKTtcbiAgICBjb25zdCByZXNvbHZlS2V5cyA9IE9iamVjdC5rZXlzKHJlc29sdmVSZXN1bHRzKTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kTG9hZGVyLmFjdGl2ZSA9IGZhbHNlO1xuICAgIGNvbnN0IGxvYWRlZEFzc2V0cyA9IGF3YWl0IHRoaXMubG9hZGVyLmxvYWQocmVzb2x2ZUFycmF5LCBvblByb2dyZXNzKTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kTG9hZGVyLmFjdGl2ZSA9IHRydWU7XG4gICAgY29uc3Qgb3V0ID0ge307XG4gICAgcmVzb2x2ZUFycmF5LmZvckVhY2goKHJlc29sdmVSZXN1bHQsIGkpID0+IHtcbiAgICAgIGNvbnN0IGFzc2V0ID0gbG9hZGVkQXNzZXRzW3Jlc29sdmVSZXN1bHQuc3JjXTtcbiAgICAgIGNvbnN0IGtleXMgPSBbcmVzb2x2ZVJlc3VsdC5zcmNdO1xuICAgICAgaWYgKHJlc29sdmVSZXN1bHQuYWxpYXMpIHtcbiAgICAgICAga2V5cy5wdXNoKC4uLnJlc29sdmVSZXN1bHQuYWxpYXMpO1xuICAgICAgfVxuICAgICAgb3V0W3Jlc29sdmVLZXlzW2ldXSA9IGFzc2V0O1xuICAgICAgQ2FjaGUuc2V0KGtleXMsIGFzc2V0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGFzeW5jIHVubG9hZCh1cmxzKSB7XG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0KCk7XG4gICAgfVxuICAgIGNvbnN0IHVybEFycmF5ID0gY29udmVydFRvTGlzdCh1cmxzKS5tYXAoKHVybCkgPT4gdHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIiA/IHVybC5zcmMgOiB1cmwpO1xuICAgIGNvbnN0IHJlc29sdmVSZXN1bHRzID0gdGhpcy5yZXNvbHZlci5yZXNvbHZlKHVybEFycmF5KTtcbiAgICBhd2FpdCB0aGlzLl91bmxvYWRGcm9tUmVzb2x2ZWQocmVzb2x2ZVJlc3VsdHMpO1xuICB9XG4gIGFzeW5jIHVubG9hZEJ1bmRsZShidW5kbGVJZHMpIHtcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgYnVuZGxlSWRzID0gY29udmVydFRvTGlzdChidW5kbGVJZHMpO1xuICAgIGNvbnN0IHJlc29sdmVSZXN1bHRzID0gdGhpcy5yZXNvbHZlci5yZXNvbHZlQnVuZGxlKGJ1bmRsZUlkcyk7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBPYmplY3Qua2V5cyhyZXNvbHZlUmVzdWx0cykubWFwKChidW5kbGVJZCkgPT4gdGhpcy5fdW5sb2FkRnJvbVJlc29sdmVkKHJlc29sdmVSZXN1bHRzW2J1bmRsZUlkXSkpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgfVxuICBhc3luYyBfdW5sb2FkRnJvbVJlc29sdmVkKHJlc29sdmVSZXN1bHQpIHtcbiAgICBjb25zdCByZXNvbHZlQXJyYXkgPSBPYmplY3QudmFsdWVzKHJlc29sdmVSZXN1bHQpO1xuICAgIHJlc29sdmVBcnJheS5mb3JFYWNoKChyZXNvbHZlUmVzdWx0MikgPT4ge1xuICAgICAgQ2FjaGUucmVtb3ZlKHJlc29sdmVSZXN1bHQyLnNyYyk7XG4gICAgfSk7XG4gICAgYXdhaXQgdGhpcy5sb2FkZXIudW5sb2FkKHJlc29sdmVBcnJheSk7XG4gIH1cbiAgZ2V0IGRldGVjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RldGVjdGlvbnM7XG4gIH1cbiAgZ2V0IHByZWZlcldvcmtlcnMoKSB7XG4gICAgcmV0dXJuIGxvYWRUZXh0dXJlcy5jb25maWcucHJlZmVyV29ya2VycztcbiAgfVxuICBzZXQgcHJlZmVyV29ya2Vycyh2YWx1ZSkge1xuICAgIHV0aWxzLmRlcHJlY2F0aW9uKFwiNy4yLjBcIiwgXCJBc3NldHMucHJlZmVyc1dvcmtlcnMgaXMgZGVwcmVjYXRlZCwgdXNlIEFzc2V0cy5zZXRQcmVmZXJlbmNlcyh7IHByZWZlcldvcmtlcnM6IHRydWUgfSkgaW5zdGVhZC5cIik7XG4gICAgdGhpcy5zZXRQcmVmZXJlbmNlcyh7IHByZWZlcldvcmtlcnM6IHZhbHVlIH0pO1xuICB9XG4gIHNldFByZWZlcmVuY2VzKHByZWZlcmVuY2VzKSB7XG4gICAgdGhpcy5sb2FkZXIucGFyc2Vycy5mb3JFYWNoKChwYXJzZXIpID0+IHtcbiAgICAgIGlmICghcGFyc2VyLmNvbmZpZylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgT2JqZWN0LmtleXMocGFyc2VyLmNvbmZpZykuZmlsdGVyKChrZXkpID0+IGtleSBpbiBwcmVmZXJlbmNlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIHBhcnNlci5jb25maWdba2V5XSA9IHByZWZlcmVuY2VzW2tleV07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgQXNzZXRzID0gbmV3IEFzc2V0c0NsYXNzKCk7XG5leHRlbnNpb25zLmhhbmRsZUJ5TGlzdChFeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsIEFzc2V0cy5sb2FkZXIucGFyc2VycykuaGFuZGxlQnlMaXN0KEV4dGVuc2lvblR5cGUuUmVzb2x2ZVBhcnNlciwgQXNzZXRzLnJlc29sdmVyLnBhcnNlcnMpLmhhbmRsZUJ5TGlzdChFeHRlbnNpb25UeXBlLkNhY2hlUGFyc2VyLCBBc3NldHMuY2FjaGUucGFyc2VycykuaGFuZGxlQnlMaXN0KEV4dGVuc2lvblR5cGUuRGV0ZWN0aW9uUGFyc2VyLCBBc3NldHMuZGV0ZWN0aW9ucyk7XG5cbmV4cG9ydCB7IEFzc2V0cywgQXNzZXRzQ2xhc3MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzc2V0cy5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBUZXh0dXJlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmNvbnN0IGNhY2hlVGV4dHVyZUFycmF5ID0ge1xuICBleHRlbnNpb246IEV4dGVuc2lvblR5cGUuQ2FjaGVQYXJzZXIsXG4gIHRlc3Q6IChhc3NldCkgPT4gQXJyYXkuaXNBcnJheShhc3NldCkgJiYgYXNzZXQuZXZlcnkoKHQpID0+IHQgaW5zdGFuY2VvZiBUZXh0dXJlKSxcbiAgZ2V0Q2FjaGVhYmxlQXNzZXRzOiAoa2V5cywgYXNzZXQpID0+IHtcbiAgICBjb25zdCBvdXQgPSB7fTtcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgYXNzZXQuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICBvdXRba2V5ICsgKGkgPT09IDAgPyBcIlwiIDogaSArIDEpXSA9IGl0ZW07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG59O1xuZXh0ZW5zaW9ucy5hZGQoY2FjaGVUZXh0dXJlQXJyYXkpO1xuXG5leHBvcnQgeyBjYWNoZVRleHR1cmVBcnJheSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FjaGVUZXh0dXJlQXJyYXkubWpzLm1hcFxuIiwiZXhwb3J0IHsgY2FjaGVUZXh0dXJlQXJyYXkgfSBmcm9tICcuL2NhY2hlVGV4dHVyZUFycmF5Lm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJleHBvcnQgeyBDYWNoZSB9IGZyb20gJy4vQ2FjaGUubWpzJztcbmltcG9ydCAnLi9DYWNoZVBhcnNlci5tanMnO1xuaW1wb3J0ICcuL3BhcnNlcnMvaW5kZXgubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIHNldHRpbmdzLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmNvbnN0IGRldGVjdEF2aWYgPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuRGV0ZWN0aW9uUGFyc2VyLFxuICAgIHByaW9yaXR5OiAxXG4gIH0sXG4gIHRlc3Q6IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWdsb2JhbFRoaXMuY3JlYXRlSW1hZ2VCaXRtYXApXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgYXZpZkRhdGEgPSBcImRhdGE6aW1hZ2UvYXZpZjtiYXNlNjQsQUFBQUlHWjBlWEJoZG1sbUFBQUFBR0YyYVdadGFXWXhiV2xoWmsxQk1VSUFBQUR5YldWMFlRQUFBQUFBQUFBb2FHUnNjZ0FBQUFBQUFBQUFjR2xqZEFBQUFBQUFBQUFBQUFBQUFHeHBZbUYyYVdZQUFBQUFEbkJwZEcwQUFBQUFBQUVBQUFBZWFXeHZZd0FBQUFCRUFBQUJBQUVBQUFBQkFBQUJHZ0FBQUIwQUFBQW9hV2x1WmdBQUFBQUFBUUFBQUJwcGJtWmxBZ0FBQUFBQkFBQmhkakF4UTI5c2IzSUFBQUFBYW1sd2NuQUFBQUJMYVhCamJ3QUFBQlJwYzNCbEFBQUFBQUFBQUFJQUFBQUNBQUFBRUhCcGVHa0FBQUFBQXdnSUNBQUFBQXhoZGpGRGdRME1BQUFBQUJOamIyeHlibU5zZUFBQ0FBSUFBWUFBQUFBWGFYQnRZUUFBQUFBQUFBQUJBQUVFQVFLREJBQUFBQ1Z0WkdGMEVnQUtDQmdBTm9nUUVBd2dNZzhmOEQvLy84V2Zod0I4K0VySzQyQT1cIjtcbiAgICBjb25zdCBibG9iID0gYXdhaXQgc2V0dGluZ3MuQURBUFRFUi5mZXRjaChhdmlmRGF0YSkudGhlbigocikgPT4gci5ibG9iKCkpO1xuICAgIHJldHVybiBjcmVhdGVJbWFnZUJpdG1hcChibG9iKS50aGVuKCgpID0+IHRydWUsICgpID0+IGZhbHNlKTtcbiAgfSxcbiAgYWRkOiBhc3luYyAoZm9ybWF0cykgPT4gWy4uLmZvcm1hdHMsIFwiYXZpZlwiXSxcbiAgcmVtb3ZlOiBhc3luYyAoZm9ybWF0cykgPT4gZm9ybWF0cy5maWx0ZXIoKGYpID0+IGYgIT09IFwiYXZpZlwiKVxufTtcbmV4dGVuc2lvbnMuYWRkKGRldGVjdEF2aWYpO1xuXG5leHBvcnQgeyBkZXRlY3RBdmlmIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXRlY3RBdmlmLm1qcy5tYXBcbiIsImltcG9ydCB7IEV4dGVuc2lvblR5cGUsIHNldHRpbmdzLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmNvbnN0IGRldGVjdFdlYnAgPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuRGV0ZWN0aW9uUGFyc2VyLFxuICAgIHByaW9yaXR5OiAwXG4gIH0sXG4gIHRlc3Q6IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWdsb2JhbFRoaXMuY3JlYXRlSW1hZ2VCaXRtYXApXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3Qgd2VicERhdGEgPSBcImRhdGE6aW1hZ2Uvd2VicDtiYXNlNjQsVWtsR1JoNEFBQUJYUlVKUVZsQTRUQkVBQUFBdkFBQUFBQWZRLy83M3YvK0JpT2gvQUFBPVwiO1xuICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBzZXR0aW5ncy5BREFQVEVSLmZldGNoKHdlYnBEYXRhKS50aGVuKChyKSA9PiByLmJsb2IoKSk7XG4gICAgcmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKGJsb2IpLnRoZW4oKCkgPT4gdHJ1ZSwgKCkgPT4gZmFsc2UpO1xuICB9LFxuICBhZGQ6IGFzeW5jIChmb3JtYXRzKSA9PiBbLi4uZm9ybWF0cywgXCJ3ZWJwXCJdLFxuICByZW1vdmU6IGFzeW5jIChmb3JtYXRzKSA9PiBmb3JtYXRzLmZpbHRlcigoZikgPT4gZiAhPT0gXCJ3ZWJwXCIpXG59O1xuZXh0ZW5zaW9ucy5hZGQoZGV0ZWN0V2VicCk7XG5cbmV4cG9ydCB7IGRldGVjdFdlYnAgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGVjdFdlYnAubWpzLm1hcFxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuXG5jb25zdCBpbWFnZUZvcm1hdHMgPSBbXCJwbmdcIiwgXCJqcGdcIiwgXCJqcGVnXCJdO1xuY29uc3QgZGV0ZWN0RGVmYXVsdHMgPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuRGV0ZWN0aW9uUGFyc2VyLFxuICAgIHByaW9yaXR5OiAtMVxuICB9LFxuICB0ZXN0OiAoKSA9PiBQcm9taXNlLnJlc29sdmUodHJ1ZSksXG4gIGFkZDogYXN5bmMgKGZvcm1hdHMpID0+IFsuLi5mb3JtYXRzLCAuLi5pbWFnZUZvcm1hdHNdLFxuICByZW1vdmU6IGFzeW5jIChmb3JtYXRzKSA9PiBmb3JtYXRzLmZpbHRlcigoZikgPT4gIWltYWdlRm9ybWF0cy5pbmNsdWRlcyhmKSlcbn07XG5leHRlbnNpb25zLmFkZChkZXRlY3REZWZhdWx0cyk7XG5cbmV4cG9ydCB7IGRldGVjdERlZmF1bHRzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXRlY3REZWZhdWx0cy5tanMubWFwXG4iLCJleHBvcnQgeyBkZXRlY3RBdmlmIH0gZnJvbSAnLi9kZXRlY3RBdmlmLm1qcyc7XG5leHBvcnQgeyBkZXRlY3RXZWJwIH0gZnJvbSAnLi9kZXRlY3RXZWJwLm1qcyc7XG5leHBvcnQgeyBkZXRlY3REZWZhdWx0cyB9IGZyb20gJy4vZGV0ZWN0RGVmYXVsdHMubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCAnLi9wYXJzZXJzL2luZGV4Lm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgJy4vcGFyc2Vycy9pbmRleC5tanMnO1xuaW1wb3J0ICcuL3R5cGVzLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBzZXR0aW5ncywgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0ICcuLi8uLi9sb2FkZXIvaW5kZXgubWpzJztcbmltcG9ydCB7IGxvYWRUZXh0dXJlcyB9IGZyb20gJy4uLy4uL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL2xvYWRUZXh0dXJlcy5tanMnO1xuXG5jb25zdCByZXNvbHZlVGV4dHVyZVVybCA9IHtcbiAgZXh0ZW5zaW9uOiBFeHRlbnNpb25UeXBlLlJlc29sdmVQYXJzZXIsXG4gIHRlc3Q6IGxvYWRUZXh0dXJlcy50ZXN0LFxuICBwYXJzZTogKHZhbHVlKSA9PiAoe1xuICAgIHJlc29sdXRpb246IHBhcnNlRmxvYXQoc2V0dGluZ3MuUkVUSU5BX1BSRUZJWC5leGVjKHZhbHVlKT8uWzFdID8/IFwiMVwiKSxcbiAgICBmb3JtYXQ6IHZhbHVlLnNwbGl0KFwiLlwiKS5wb3AoKSxcbiAgICBzcmM6IHZhbHVlXG4gIH0pXG59O1xuZXh0ZW5zaW9ucy5hZGQocmVzb2x2ZVRleHR1cmVVcmwpO1xuXG5leHBvcnQgeyByZXNvbHZlVGV4dHVyZVVybCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZVRleHR1cmVVcmwubWpzLm1hcFxuIiwiZXhwb3J0IHsgcmVzb2x2ZVRleHR1cmVVcmwgfSBmcm9tICcuL3Jlc29sdmVUZXh0dXJlVXJsLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgJy4vcGFyc2Vycy9pbmRleC5tanMnO1xuaW1wb3J0ICcuL3R5cGVzLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJjb25zdCBjb3B5U2VhcmNoUGFyYW1zID0gKHRhcmdldFVybCwgc291cmNlVXJsKSA9PiB7XG4gIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHNvdXJjZVVybC5zcGxpdChcIj9cIilbMV07XG4gIGlmIChzZWFyY2hQYXJhbXMpIHtcbiAgICB0YXJnZXRVcmwgKz0gYD8ke3NlYXJjaFBhcmFtc31gO1xuICB9XG4gIHJldHVybiB0YXJnZXRVcmw7XG59O1xuXG5leHBvcnQgeyBjb3B5U2VhcmNoUGFyYW1zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3B5U2VhcmNoUGFyYW1zLm1qcy5tYXBcbiIsImltcG9ydCAnLi9Bc3NldEV4dGVuc2lvbi5tanMnO1xuZXhwb3J0IHsgQXNzZXRzLCBBc3NldHNDbGFzcyB9IGZyb20gJy4vQXNzZXRzLm1qcyc7XG5pbXBvcnQgJy4vY2FjaGUvaW5kZXgubWpzJztcbmltcG9ydCAnLi9kZXRlY3Rpb25zL2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vbG9hZGVyL2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vcmVzb2x2ZXIvaW5kZXgubWpzJztcbmltcG9ydCAnLi91dGlscy9pbmRleC5tanMnO1xuZXhwb3J0IHsgQ2FjaGUgfSBmcm9tICcuL2NhY2hlL0NhY2hlLm1qcyc7XG5leHBvcnQgeyBjYWNoZVRleHR1cmVBcnJheSB9IGZyb20gJy4vY2FjaGUvcGFyc2Vycy9jYWNoZVRleHR1cmVBcnJheS5tanMnO1xuZXhwb3J0IHsgZGV0ZWN0QXZpZiB9IGZyb20gJy4vZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdEF2aWYubWpzJztcbmV4cG9ydCB7IGRldGVjdFdlYnAgfSBmcm9tICcuL2RldGVjdGlvbnMvcGFyc2Vycy9kZXRlY3RXZWJwLm1qcyc7XG5leHBvcnQgeyBkZXRlY3REZWZhdWx0cyB9IGZyb20gJy4vZGV0ZWN0aW9ucy9wYXJzZXJzL2RldGVjdERlZmF1bHRzLm1qcyc7XG5leHBvcnQgeyBMb2FkZXJQYXJzZXJQcmlvcml0eSB9IGZyb20gJy4vbG9hZGVyL3BhcnNlcnMvTG9hZGVyUGFyc2VyLm1qcyc7XG5leHBvcnQgeyBsb2FkSnNvbiB9IGZyb20gJy4vbG9hZGVyL3BhcnNlcnMvbG9hZEpzb24ubWpzJztcbmV4cG9ydCB7IGxvYWRUeHQgfSBmcm9tICcuL2xvYWRlci9wYXJzZXJzL2xvYWRUeHQubWpzJztcbmV4cG9ydCB7IGdldEZvbnRGYW1pbHlOYW1lLCBsb2FkV2ViRm9udCB9IGZyb20gJy4vbG9hZGVyL3BhcnNlcnMvbG9hZFdlYkZvbnQubWpzJztcbmV4cG9ydCB7IGxvYWRTVkcgfSBmcm9tICcuL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL2xvYWRTVkcubWpzJztcbmV4cG9ydCB7IGxvYWRJbWFnZUJpdG1hcCwgbG9hZFRleHR1cmVzIH0gZnJvbSAnLi9sb2FkZXIvcGFyc2Vycy90ZXh0dXJlcy9sb2FkVGV4dHVyZXMubWpzJztcbmV4cG9ydCB7IGNyZWF0ZVRleHR1cmUgfSBmcm9tICcuL2xvYWRlci9wYXJzZXJzL3RleHR1cmVzL3V0aWxzL2NyZWF0ZVRleHR1cmUubWpzJztcbmV4cG9ydCB7IHJlc29sdmVUZXh0dXJlVXJsIH0gZnJvbSAnLi9yZXNvbHZlci9wYXJzZXJzL3Jlc29sdmVUZXh0dXJlVXJsLm1qcyc7XG5leHBvcnQgeyBjaGVja0RhdGFVcmwgfSBmcm9tICcuL3V0aWxzL2NoZWNrRGF0YVVybC5tanMnO1xuZXhwb3J0IHsgY2hlY2tFeHRlbnNpb24gfSBmcm9tICcuL3V0aWxzL2NoZWNrRXh0ZW5zaW9uLm1qcyc7XG5leHBvcnQgeyBjb252ZXJ0VG9MaXN0IH0gZnJvbSAnLi91dGlscy9jb252ZXJ0VG9MaXN0Lm1qcyc7XG5leHBvcnQgeyBjb3B5U2VhcmNoUGFyYW1zIH0gZnJvbSAnLi91dGlscy9jb3B5U2VhcmNoUGFyYW1zLm1qcyc7XG5leHBvcnQgeyBjcmVhdGVTdHJpbmdWYXJpYXRpb25zIH0gZnJvbSAnLi91dGlscy9jcmVhdGVTdHJpbmdWYXJpYXRpb25zLm1qcyc7XG5leHBvcnQgeyBpc1NpbmdsZUl0ZW0gfSBmcm9tICcuL3V0aWxzL2lzU2luZ2xlSXRlbS5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwidmFyIElOVEVSTkFMX0ZPUk1BVFMgPSAvKiBAX19QVVJFX18gKi8gKChJTlRFUk5BTF9GT1JNQVRTMikgPT4ge1xuICBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMltcIkNPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFRcIl0gPSAzMzc3Nl0gPSBcIkNPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFRcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVFwiXSA9IDMzNzc3XSA9IFwiQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFRcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVFwiXSA9IDMzNzc4XSA9IFwiQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFRcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVFwiXSA9IDMzNzc5XSA9IFwiQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFRcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQxX0VYVFwiXSA9IDM1OTE3XSA9IFwiQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUMV9FWFRcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQzX0VYVFwiXSA9IDM1OTE4XSA9IFwiQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUM19FWFRcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQ1X0VYVFwiXSA9IDM1OTE5XSA9IFwiQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUNV9FWFRcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1NSR0JfUzNUQ19EWFQxX0VYVFwiXSA9IDM1OTE2XSA9IFwiQ09NUFJFU1NFRF9TUkdCX1MzVENfRFhUMV9FWFRcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1IxMV9FQUNcIl0gPSAzNzQ4OF0gPSBcIkNPTVBSRVNTRURfUjExX0VBQ1wiO1xuICBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMltcIkNPTVBSRVNTRURfU0lHTkVEX1IxMV9FQUNcIl0gPSAzNzQ4OV0gPSBcIkNPTVBSRVNTRURfU0lHTkVEX1IxMV9FQUNcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1JHMTFfRUFDXCJdID0gMzc0OTBdID0gXCJDT01QUkVTU0VEX1JHMTFfRUFDXCI7XG4gIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyW1wiQ09NUFJFU1NFRF9TSUdORURfUkcxMV9FQUNcIl0gPSAzNzQ5MV0gPSBcIkNPTVBSRVNTRURfU0lHTkVEX1JHMTFfRUFDXCI7XG4gIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyW1wiQ09NUFJFU1NFRF9SR0I4X0VUQzJcIl0gPSAzNzQ5Ml0gPSBcIkNPTVBSRVNTRURfUkdCOF9FVEMyXCI7XG4gIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyW1wiQ09NUFJFU1NFRF9SR0JBOF9FVEMyX0VBQ1wiXSA9IDM3NDk2XSA9IFwiQ09NUFJFU1NFRF9SR0JBOF9FVEMyX0VBQ1wiO1xuICBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMltcIkNPTVBSRVNTRURfU1JHQjhfRVRDMlwiXSA9IDM3NDkzXSA9IFwiQ09NUFJFU1NFRF9TUkdCOF9FVEMyXCI7XG4gIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyW1wiQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfRVRDMl9FQUNcIl0gPSAzNzQ5N10gPSBcIkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0VUQzJfRUFDXCI7XG4gIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyW1wiQ09NUFJFU1NFRF9SR0I4X1BVTkNIVEhST1VHSF9BTFBIQTFfRVRDMlwiXSA9IDM3NDk0XSA9IFwiQ09NUFJFU1NFRF9SR0I4X1BVTkNIVEhST1VHSF9BTFBIQTFfRVRDMlwiO1xuICBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMltcIkNPTVBSRVNTRURfU1JHQjhfUFVOQ0hUSFJPVUdIX0FMUEhBMV9FVEMyXCJdID0gMzc0OTVdID0gXCJDT01QUkVTU0VEX1NSR0I4X1BVTkNIVEhST1VHSF9BTFBIQTFfRVRDMlwiO1xuICBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMltcIkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUdcIl0gPSAzNTg0MF0gPSBcIkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUdcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNR1wiXSA9IDM1ODQyXSA9IFwiQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUdcIjtcbiAgSU5URVJOQUxfRk9STUFUUzJbSU5URVJOQUxfRk9STUFUUzJbXCJDT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HXCJdID0gMzU4NDFdID0gXCJDT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HXCI7XG4gIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyW1wiQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUdcIl0gPSAzNTg0M10gPSBcIkNPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HXCI7XG4gIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyW1wiQ09NUFJFU1NFRF9SR0JfRVRDMV9XRUJHTFwiXSA9IDM2MTk2XSA9IFwiQ09NUFJFU1NFRF9SR0JfRVRDMV9XRUJHTFwiO1xuICBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMltcIkNPTVBSRVNTRURfUkdCX0FUQ19XRUJHTFwiXSA9IDM1OTg2XSA9IFwiQ09NUFJFU1NFRF9SR0JfQVRDX1dFQkdMXCI7XG4gIElOVEVSTkFMX0ZPUk1BVFMyW0lOVEVSTkFMX0ZPUk1BVFMyW1wiQ09NUFJFU1NFRF9SR0JBX0FUQ19FWFBMSUNJVF9BTFBIQV9XRUJHTFwiXSA9IDM1OTg2XSA9IFwiQ09NUFJFU1NFRF9SR0JBX0FUQ19FWFBMSUNJVF9BTFBIQV9XRUJHTFwiO1xuICBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMltcIkNPTVBSRVNTRURfUkdCQV9BVENfSU5URVJQT0xBVEVEX0FMUEhBX1dFQkdMXCJdID0gMzQ3OThdID0gXCJDT01QUkVTU0VEX1JHQkFfQVRDX0lOVEVSUE9MQVRFRF9BTFBIQV9XRUJHTFwiO1xuICBJTlRFUk5BTF9GT1JNQVRTMltJTlRFUk5BTF9GT1JNQVRTMltcIkNPTVBSRVNTRURfUkdCQV9BU1RDXzR4NF9LSFJcIl0gPSAzNzgwOF0gPSBcIkNPTVBSRVNTRURfUkdCQV9BU1RDXzR4NF9LSFJcIjtcbiAgcmV0dXJuIElOVEVSTkFMX0ZPUk1BVFMyO1xufSkoSU5URVJOQUxfRk9STUFUUyB8fCB7fSk7XG5jb25zdCBJTlRFUk5BTF9GT1JNQVRfVE9fQllURVNfUEVSX1BJWEVMID0ge1xuICBbMzM3NzYgLyogQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVCAqL106IDAuNSxcbiAgWzMzNzc3IC8qIENPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUICovXTogMC41LFxuICBbMzM3NzggLyogQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQgKi9dOiAxLFxuICBbMzM3NzkgLyogQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFQgKi9dOiAxLFxuICBbMzU5MTYgLyogQ09NUFJFU1NFRF9TUkdCX1MzVENfRFhUMV9FWFQgKi9dOiAwLjUsXG4gIFszNTkxNyAvKiBDT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQxX0VYVCAqL106IDAuNSxcbiAgWzM1OTE4IC8qIENPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDNfRVhUICovXTogMSxcbiAgWzM1OTE5IC8qIENPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDVfRVhUICovXTogMSxcbiAgWzM3NDg4IC8qIENPTVBSRVNTRURfUjExX0VBQyAqL106IDAuNSxcbiAgWzM3NDg5IC8qIENPTVBSRVNTRURfU0lHTkVEX1IxMV9FQUMgKi9dOiAwLjUsXG4gIFszNzQ5MCAvKiBDT01QUkVTU0VEX1JHMTFfRUFDICovXTogMSxcbiAgWzM3NDkxIC8qIENPTVBSRVNTRURfU0lHTkVEX1JHMTFfRUFDICovXTogMSxcbiAgWzM3NDkyIC8qIENPTVBSRVNTRURfUkdCOF9FVEMyICovXTogMC41LFxuICBbMzc0OTYgLyogQ09NUFJFU1NFRF9SR0JBOF9FVEMyX0VBQyAqL106IDEsXG4gIFszNzQ5MyAvKiBDT01QUkVTU0VEX1NSR0I4X0VUQzIgKi9dOiAwLjUsXG4gIFszNzQ5NyAvKiBDT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9FVEMyX0VBQyAqL106IDEsXG4gIFszNzQ5NCAvKiBDT01QUkVTU0VEX1JHQjhfUFVOQ0hUSFJPVUdIX0FMUEhBMV9FVEMyICovXTogMC41LFxuICBbMzc0OTUgLyogQ09NUFJFU1NFRF9TUkdCOF9QVU5DSFRIUk9VR0hfQUxQSEExX0VUQzIgKi9dOiAwLjUsXG4gIFszNTg0MCAvKiBDT01QUkVTU0VEX1JHQl9QVlJUQ180QlBQVjFfSU1HICovXTogMC41LFxuICBbMzU4NDIgLyogQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUcgKi9dOiAwLjUsXG4gIFszNTg0MSAvKiBDT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HICovXTogMC4yNSxcbiAgWzM1ODQzIC8qIENPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HICovXTogMC4yNSxcbiAgWzM2MTk2IC8qIENPTVBSRVNTRURfUkdCX0VUQzFfV0VCR0wgKi9dOiAwLjUsXG4gIFszNTk4NiAvKiBDT01QUkVTU0VEX1JHQl9BVENfV0VCR0wgKi9dOiAwLjUsXG4gIFszNTk4NiAvKiBDT01QUkVTU0VEX1JHQkFfQVRDX0VYUExJQ0lUX0FMUEhBX1dFQkdMICovXTogMSxcbiAgWzM0Nzk4IC8qIENPTVBSRVNTRURfUkdCQV9BVENfSU5URVJQT0xBVEVEX0FMUEhBX1dFQkdMICovXTogMSxcbiAgWzM3ODA4IC8qIENPTVBSRVNTRURfUkdCQV9BU1RDXzR4NF9LSFIgKi9dOiAxXG59O1xuXG5leHBvcnQgeyBJTlRFUk5BTF9GT1JNQVRTLCBJTlRFUk5BTF9GT1JNQVRfVE9fQllURVNfUEVSX1BJWEVMIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5tanMubWFwXG4iLCJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXByZXNzZWRUZXh0dXJlRXh0ZW5zaW9ucy5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBzZXR0aW5ncywgZXh0ZW5zaW9ucyBhcyBleHRlbnNpb25zJDEgfSBmcm9tICdAcGl4aS9jb3JlJztcblxubGV0IHN0b3JlZEdsO1xubGV0IGV4dGVuc2lvbnM7XG5mdW5jdGlvbiBnZXRDb21wcmVzc2VkVGV4dHVyZUV4dGVuc2lvbnMoKSB7XG4gIGV4dGVuc2lvbnMgPSB7XG4gICAgczN0Yzogc3RvcmVkR2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcIiksXG4gICAgczN0Y19zUkdCOiBzdG9yZWRHbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y19zcmdiXCIpLFxuICAgIGV0Yzogc3RvcmVkR2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0Y1wiKSxcbiAgICBldGMxOiBzdG9yZWRHbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMVwiKSxcbiAgICBwdnJ0Yzogc3RvcmVkR2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjXCIpIHx8IHN0b3JlZEdsLmdldEV4dGVuc2lvbihcIldFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcIiksXG4gICAgYXRjOiBzdG9yZWRHbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfYXRjXCIpLFxuICAgIGFzdGM6IHN0b3JlZEdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hc3RjXCIpXG4gIH07XG59XG5jb25zdCBkZXRlY3RDb21wcmVzc2VkVGV4dHVyZXMgPSB7XG4gIGV4dGVuc2lvbjoge1xuICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuRGV0ZWN0aW9uUGFyc2VyLFxuICAgIHByaW9yaXR5OiAyXG4gIH0sXG4gIHRlc3Q6IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBzZXR0aW5ncy5BREFQVEVSLmNyZWF0ZUNhbnZhcygpO1xuICAgIGNvbnN0IGdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiKTtcbiAgICBpZiAoIWdsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJXZWJHTCBub3QgYXZhaWxhYmxlIGZvciBjb21wcmVzc2VkIHRleHR1cmVzLlwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3RvcmVkR2wgPSBnbDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgYWRkOiBhc3luYyAoZm9ybWF0cykgPT4ge1xuICAgIGlmICghZXh0ZW5zaW9ucylcbiAgICAgIGdldENvbXByZXNzZWRUZXh0dXJlRXh0ZW5zaW9ucygpO1xuICAgIGNvbnN0IHRleHR1cmVGb3JtYXRzID0gW107XG4gICAgZm9yIChjb25zdCBleHRlbnNpb25OYW1lIGluIGV4dGVuc2lvbnMpIHtcbiAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV07XG4gICAgICBpZiAoIWV4dGVuc2lvbikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRleHR1cmVGb3JtYXRzLnB1c2goZXh0ZW5zaW9uTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBbLi4udGV4dHVyZUZvcm1hdHMsIC4uLmZvcm1hdHNdO1xuICB9LFxuICByZW1vdmU6IGFzeW5jIChmb3JtYXRzKSA9PiB7XG4gICAgaWYgKCFleHRlbnNpb25zKVxuICAgICAgZ2V0Q29tcHJlc3NlZFRleHR1cmVFeHRlbnNpb25zKCk7XG4gICAgcmV0dXJuIGZvcm1hdHMuZmlsdGVyKChmKSA9PiAhKGYgaW4gZXh0ZW5zaW9ucykpO1xuICB9XG59O1xuZXh0ZW5zaW9ucyQxLmFkZChkZXRlY3RDb21wcmVzc2VkVGV4dHVyZXMpO1xuXG5leHBvcnQgeyBkZXRlY3RDb21wcmVzc2VkVGV4dHVyZXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGVjdENvbXByZXNzZWRUZXh0dXJlcy5tanMubWFwXG4iLCJpbXBvcnQgeyBCdWZmZXJSZXNvdXJjZSwgVmlld2FibGVCdWZmZXIgfSBmcm9tICdAcGl4aS9jb3JlJztcblxuY2xhc3MgQmxvYlJlc291cmNlIGV4dGVuZHMgQnVmZmVyUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMgPSB7IHdpZHRoOiAxLCBoZWlnaHQ6IDEsIGF1dG9Mb2FkOiB0cnVlIH0pIHtcbiAgICBsZXQgb3JpZ2luO1xuICAgIGxldCBkYXRhO1xuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBvcmlnaW4gPSBzb3VyY2U7XG4gICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JpZ2luID0gbnVsbDtcbiAgICAgIGRhdGEgPSBzb3VyY2U7XG4gICAgfVxuICAgIHN1cGVyKGRhdGEsIG9wdGlvbnMpO1xuICAgIHRoaXMub3JpZ2luID0gb3JpZ2luO1xuICAgIHRoaXMuYnVmZmVyID0gZGF0YSA/IG5ldyBWaWV3YWJsZUJ1ZmZlcihkYXRhKSA6IG51bGw7XG4gICAgdGhpcy5fbG9hZCA9IG51bGw7XG4gICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5vcmlnaW4gIT09IG51bGwgJiYgb3B0aW9ucy5hdXRvTG9hZCAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMubG9hZCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcmlnaW4gPT09IG51bGwgJiYgdGhpcy5idWZmZXIpIHtcbiAgICAgIHRoaXMuX2xvYWQgPSBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgICB0aGlzLm9uQmxvYkxvYWRlZCh0aGlzLmJ1ZmZlci5yYXdCaW5hcnlEYXRhKTtcbiAgICB9XG4gIH1cbiAgb25CbG9iTG9hZGVkKF9kYXRhKSB7XG4gIH1cbiAgbG9hZCgpIHtcbiAgICBpZiAodGhpcy5fbG9hZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvYWQ7XG4gICAgfVxuICAgIHRoaXMuX2xvYWQgPSBmZXRjaCh0aGlzLm9yaWdpbikudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmJsb2IoKSkudGhlbigoYmxvYikgPT4gYmxvYi5hcnJheUJ1ZmZlcigpKS50aGVuKChhcnJheUJ1ZmZlcikgPT4ge1xuICAgICAgdGhpcy5kYXRhID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmZmVyKTtcbiAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFZpZXdhYmxlQnVmZmVyKGFycmF5QnVmZmVyKTtcbiAgICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMub25CbG9iTG9hZGVkKGFycmF5QnVmZmVyKTtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fbG9hZDtcbiAgfVxufVxuXG5leHBvcnQgeyBCbG9iUmVzb3VyY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJsb2JSZXNvdXJjZS5tanMubWFwXG4iLCJpbXBvcnQgeyBJTlRFUk5BTF9GT1JNQVRfVE9fQllURVNfUEVSX1BJWEVMIH0gZnJvbSAnLi4vY29uc3QubWpzJztcbmltcG9ydCB7IEJsb2JSZXNvdXJjZSB9IGZyb20gJy4vQmxvYlJlc291cmNlLm1qcyc7XG5cbmNsYXNzIENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UgZXh0ZW5kcyBCbG9iUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihzb3VyY2UsIG9wdGlvbnMpO1xuICAgIHRoaXMuZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQ7XG4gICAgdGhpcy5sZXZlbHMgPSBvcHRpb25zLmxldmVscyB8fCAxO1xuICAgIHRoaXMuX3dpZHRoID0gb3B0aW9ucy53aWR0aDtcbiAgICB0aGlzLl9oZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcbiAgICB0aGlzLl9leHRlbnNpb24gPSBDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlLl9mb3JtYXRUb0V4dGVuc2lvbih0aGlzLmZvcm1hdCk7XG4gICAgaWYgKG9wdGlvbnMubGV2ZWxCdWZmZXJzIHx8IHRoaXMuYnVmZmVyKSB7XG4gICAgICB0aGlzLl9sZXZlbEJ1ZmZlcnMgPSBvcHRpb25zLmxldmVsQnVmZmVycyB8fCBDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlLl9jcmVhdGVMZXZlbEJ1ZmZlcnMoc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSA/IHNvdXJjZSA6IHRoaXMuYnVmZmVyLnVpbnQ4VmlldywgdGhpcy5mb3JtYXQsIHRoaXMubGV2ZWxzLCA0LCA0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxuICB9XG4gIHVwbG9hZChyZW5kZXJlciwgX3RleHR1cmUsIF9nbFRleHR1cmUpIHtcbiAgICBjb25zdCBnbCA9IHJlbmRlcmVyLmdsO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHJlbmRlcmVyLmNvbnRleHQuZXh0ZW5zaW9uc1t0aGlzLl9leHRlbnNpb25dO1xuICAgIGlmICghZXh0ZW5zaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5fZXh0ZW5zaW9ufSB0ZXh0dXJlcyBhcmUgbm90IHN1cHBvcnRlZCBvbiB0aGUgY3VycmVudCBtYWNoaW5lYCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fbGV2ZWxCdWZmZXJzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBqID0gdGhpcy5sZXZlbHM7IGkgPCBqOyBpKyspIHtcbiAgICAgIGNvbnN0IHsgbGV2ZWxJRCwgbGV2ZWxXaWR0aCwgbGV2ZWxIZWlnaHQsIGxldmVsQnVmZmVyIH0gPSB0aGlzLl9sZXZlbEJ1ZmZlcnNbaV07XG4gICAgICBnbC5jb21wcmVzc2VkVGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCBsZXZlbElELCB0aGlzLmZvcm1hdCwgbGV2ZWxXaWR0aCwgbGV2ZWxIZWlnaHQsIDAsIGxldmVsQnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgb25CbG9iTG9hZGVkKCkge1xuICAgIHRoaXMuX2xldmVsQnVmZmVycyA9IENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UuX2NyZWF0ZUxldmVsQnVmZmVycyh0aGlzLmJ1ZmZlci51aW50OFZpZXcsIHRoaXMuZm9ybWF0LCB0aGlzLmxldmVscywgNCwgNCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICB9XG4gIHN0YXRpYyBfZm9ybWF0VG9FeHRlbnNpb24oZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA+PSAzMzc3NiAmJiBmb3JtYXQgPD0gMzM3NzkpIHtcbiAgICAgIHJldHVybiBcInMzdGNcIjtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA+PSAzNzQ4OCAmJiBmb3JtYXQgPD0gMzc0OTcpIHtcbiAgICAgIHJldHVybiBcImV0Y1wiO1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID49IDM1ODQwICYmIGZvcm1hdCA8PSAzNTg0Mykge1xuICAgICAgcmV0dXJuIFwicHZydGNcIjtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA+PSAzNjE5Nikge1xuICAgICAgcmV0dXJuIFwiZXRjMVwiO1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID49IDM1OTg2ICYmIGZvcm1hdCA8PSAzNDc5OCkge1xuICAgICAgcmV0dXJuIFwiYXRjXCI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgKGNvbXByZXNzZWQpIHRleHR1cmUgZm9ybWF0IGdpdmVuIVwiKTtcbiAgfVxuICBzdGF0aWMgX2NyZWF0ZUxldmVsQnVmZmVycyhidWZmZXIsIGZvcm1hdCwgbGV2ZWxzLCBibG9ja1dpZHRoLCBibG9ja0hlaWdodCwgaW1hZ2VXaWR0aCwgaW1hZ2VIZWlnaHQpIHtcbiAgICBjb25zdCBidWZmZXJzID0gbmV3IEFycmF5KGxldmVscyk7XG4gICAgbGV0IG9mZnNldCA9IGJ1ZmZlci5ieXRlT2Zmc2V0O1xuICAgIGxldCBsZXZlbFdpZHRoID0gaW1hZ2VXaWR0aDtcbiAgICBsZXQgbGV2ZWxIZWlnaHQgPSBpbWFnZUhlaWdodDtcbiAgICBsZXQgYWxpZ25lZExldmVsV2lkdGggPSBsZXZlbFdpZHRoICsgYmxvY2tXaWR0aCAtIDEgJiB+KGJsb2NrV2lkdGggLSAxKTtcbiAgICBsZXQgYWxpZ25lZExldmVsSGVpZ2h0ID0gbGV2ZWxIZWlnaHQgKyBibG9ja0hlaWdodCAtIDEgJiB+KGJsb2NrSGVpZ2h0IC0gMSk7XG4gICAgbGV0IGxldmVsU2l6ZSA9IGFsaWduZWRMZXZlbFdpZHRoICogYWxpZ25lZExldmVsSGVpZ2h0ICogSU5URVJOQUxfRk9STUFUX1RPX0JZVEVTX1BFUl9QSVhFTFtmb3JtYXRdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV2ZWxzOyBpKyspIHtcbiAgICAgIGJ1ZmZlcnNbaV0gPSB7XG4gICAgICAgIGxldmVsSUQ6IGksXG4gICAgICAgIGxldmVsV2lkdGg6IGxldmVscyA+IDEgPyBsZXZlbFdpZHRoIDogYWxpZ25lZExldmVsV2lkdGgsXG4gICAgICAgIGxldmVsSGVpZ2h0OiBsZXZlbHMgPiAxID8gbGV2ZWxIZWlnaHQgOiBhbGlnbmVkTGV2ZWxIZWlnaHQsXG4gICAgICAgIGxldmVsQnVmZmVyOiBuZXcgVWludDhBcnJheShidWZmZXIuYnVmZmVyLCBvZmZzZXQsIGxldmVsU2l6ZSlcbiAgICAgIH07XG4gICAgICBvZmZzZXQgKz0gbGV2ZWxTaXplO1xuICAgICAgbGV2ZWxXaWR0aCA9IGxldmVsV2lkdGggPj4gMSB8fCAxO1xuICAgICAgbGV2ZWxIZWlnaHQgPSBsZXZlbEhlaWdodCA+PiAxIHx8IDE7XG4gICAgICBhbGlnbmVkTGV2ZWxXaWR0aCA9IGxldmVsV2lkdGggKyBibG9ja1dpZHRoIC0gMSAmIH4oYmxvY2tXaWR0aCAtIDEpO1xuICAgICAgYWxpZ25lZExldmVsSGVpZ2h0ID0gbGV2ZWxIZWlnaHQgKyBibG9ja0hlaWdodCAtIDEgJiB+KGJsb2NrSGVpZ2h0IC0gMSk7XG4gICAgICBsZXZlbFNpemUgPSBhbGlnbmVkTGV2ZWxXaWR0aCAqIGFsaWduZWRMZXZlbEhlaWdodCAqIElOVEVSTkFMX0ZPUk1BVF9UT19CWVRFU19QRVJfUElYRUxbZm9ybWF0XTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcnM7XG4gIH1cbn1cblxuZXhwb3J0IHsgQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZS5tanMubWFwXG4iLCJleHBvcnQgeyBCbG9iUmVzb3VyY2UgfSBmcm9tICcuL0Jsb2JSZXNvdXJjZS5tanMnO1xuZXhwb3J0IHsgQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZSB9IGZyb20gJy4vQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZS5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgSU5URVJOQUxfRk9STUFUUywgSU5URVJOQUxfRk9STUFUX1RPX0JZVEVTX1BFUl9QSVhFTCB9IGZyb20gJy4uL2NvbnN0Lm1qcyc7XG5pbXBvcnQgJy4uL3Jlc291cmNlcy9pbmRleC5tanMnO1xuaW1wb3J0IHsgQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZSB9IGZyb20gJy4uL3Jlc291cmNlcy9Db21wcmVzc2VkVGV4dHVyZVJlc291cmNlLm1qcyc7XG5cbmNvbnN0IEREU19NQUdJQ19TSVpFID0gNDtcbmNvbnN0IEREU19IRUFERVJfU0laRSA9IDEyNDtcbmNvbnN0IEREU19IRUFERVJfUEZfU0laRSA9IDMyO1xuY29uc3QgRERTX0hFQURFUl9EWDEwX1NJWkUgPSAyMDtcbmNvbnN0IEREU19NQUdJQyA9IDU0MjMyNzg3NjtcbmNvbnN0IEREU19GSUVMRFMgPSB7XG4gIFNJWkU6IDEsXG4gIEZMQUdTOiAyLFxuICBIRUlHSFQ6IDMsXG4gIFdJRFRIOiA0LFxuICBNSVBNQVBfQ09VTlQ6IDcsXG4gIFBJWEVMX0ZPUk1BVDogMTlcbn07XG5jb25zdCBERFNfUEZfRklFTERTID0ge1xuICBTSVpFOiAwLFxuICBGTEFHUzogMSxcbiAgRk9VUkNDOiAyLFxuICBSR0JfQklUQ09VTlQ6IDMsXG4gIFJfQklUX01BU0s6IDQsXG4gIEdfQklUX01BU0s6IDUsXG4gIEJfQklUX01BU0s6IDYsXG4gIEFfQklUX01BU0s6IDdcbn07XG5jb25zdCBERFNfRFgxMF9GSUVMRFMgPSB7XG4gIERYR0lfRk9STUFUOiAwLFxuICBSRVNPVVJDRV9ESU1FTlNJT046IDEsXG4gIE1JU0NfRkxBRzogMixcbiAgQVJSQVlfU0laRTogMyxcbiAgTUlTQ19GTEFHUzI6IDRcbn07XG52YXIgRFhHSV9GT1JNQVQgPSAvKiBAX19QVVJFX18gKi8gKChEWEdJX0ZPUk1BVDIpID0+IHtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1VOS05PV05cIl0gPSAwXSA9IFwiRFhHSV9GT1JNQVRfVU5LTk9XTlwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjMyRzMyQjMyQTMyX1RZUEVMRVNTXCJdID0gMV0gPSBcIkRYR0lfRk9STUFUX1IzMkczMkIzMkEzMl9UWVBFTEVTU1wiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjMyRzMyQjMyQTMyX0ZMT0FUXCJdID0gMl0gPSBcIkRYR0lfRk9STUFUX1IzMkczMkIzMkEzMl9GTE9BVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjMyRzMyQjMyQTMyX1VJTlRcIl0gPSAzXSA9IFwiRFhHSV9GT1JNQVRfUjMyRzMyQjMyQTMyX1VJTlRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IzMkczMkIzMkEzMl9TSU5UXCJdID0gNF0gPSBcIkRYR0lfRk9STUFUX1IzMkczMkIzMkEzMl9TSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMzJHMzJCMzJfVFlQRUxFU1NcIl0gPSA1XSA9IFwiRFhHSV9GT1JNQVRfUjMyRzMyQjMyX1RZUEVMRVNTXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMzJHMzJCMzJfRkxPQVRcIl0gPSA2XSA9IFwiRFhHSV9GT1JNQVRfUjMyRzMyQjMyX0ZMT0FUXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMzJHMzJCMzJfVUlOVFwiXSA9IDddID0gXCJEWEdJX0ZPUk1BVF9SMzJHMzJCMzJfVUlOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjMyRzMyQjMyX1NJTlRcIl0gPSA4XSA9IFwiRFhHSV9GT1JNQVRfUjMyRzMyQjMyX1NJTlRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IxNkcxNkIxNkExNl9UWVBFTEVTU1wiXSA9IDldID0gXCJEWEdJX0ZPUk1BVF9SMTZHMTZCMTZBMTZfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IxNkcxNkIxNkExNl9GTE9BVFwiXSA9IDEwXSA9IFwiRFhHSV9GT1JNQVRfUjE2RzE2QjE2QTE2X0ZMT0FUXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTZHMTZCMTZBMTZfVU5PUk1cIl0gPSAxMV0gPSBcIkRYR0lfRk9STUFUX1IxNkcxNkIxNkExNl9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjE2RzE2QjE2QTE2X1VJTlRcIl0gPSAxMl0gPSBcIkRYR0lfRk9STUFUX1IxNkcxNkIxNkExNl9VSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTZHMTZCMTZBMTZfU05PUk1cIl0gPSAxM10gPSBcIkRYR0lfRk9STUFUX1IxNkcxNkIxNkExNl9TTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjE2RzE2QjE2QTE2X1NJTlRcIl0gPSAxNF0gPSBcIkRYR0lfRk9STUFUX1IxNkcxNkIxNkExNl9TSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMzJHMzJfVFlQRUxFU1NcIl0gPSAxNV0gPSBcIkRYR0lfRk9STUFUX1IzMkczMl9UWVBFTEVTU1wiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjMyRzMyX0ZMT0FUXCJdID0gMTZdID0gXCJEWEdJX0ZPUk1BVF9SMzJHMzJfRkxPQVRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IzMkczMl9VSU5UXCJdID0gMTddID0gXCJEWEdJX0ZPUk1BVF9SMzJHMzJfVUlOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjMyRzMyX1NJTlRcIl0gPSAxOF0gPSBcIkRYR0lfRk9STUFUX1IzMkczMl9TSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMzJHOFgyNF9UWVBFTEVTU1wiXSA9IDE5XSA9IFwiRFhHSV9GT1JNQVRfUjMyRzhYMjRfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0QzMl9GTE9BVF9TOFgyNF9VSU5UXCJdID0gMjBdID0gXCJEWEdJX0ZPUk1BVF9EMzJfRkxPQVRfUzhYMjRfVUlOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjMyX0ZMT0FUX1g4WDI0X1RZUEVMRVNTXCJdID0gMjFdID0gXCJEWEdJX0ZPUk1BVF9SMzJfRkxPQVRfWDhYMjRfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1gzMl9UWVBFTEVTU19HOFgyNF9VSU5UXCJdID0gMjJdID0gXCJEWEdJX0ZPUk1BVF9YMzJfVFlQRUxFU1NfRzhYMjRfVUlOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjEwRzEwQjEwQTJfVFlQRUxFU1NcIl0gPSAyM10gPSBcIkRYR0lfRk9STUFUX1IxMEcxMEIxMEEyX1RZUEVMRVNTXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTBHMTBCMTBBMl9VTk9STVwiXSA9IDI0XSA9IFwiRFhHSV9GT1JNQVRfUjEwRzEwQjEwQTJfVU5PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IxMEcxMEIxMEEyX1VJTlRcIl0gPSAyNV0gPSBcIkRYR0lfRk9STUFUX1IxMEcxMEIxMEEyX1VJTlRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IxMUcxMUIxMF9GTE9BVFwiXSA9IDI2XSA9IFwiRFhHSV9GT1JNQVRfUjExRzExQjEwX0ZMT0FUXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SOEc4QjhBOF9UWVBFTEVTU1wiXSA9IDI3XSA9IFwiRFhHSV9GT1JNQVRfUjhHOEI4QThfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1I4RzhCOEE4X1VOT1JNXCJdID0gMjhdID0gXCJEWEdJX0ZPUk1BVF9SOEc4QjhBOF9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjhHOEI4QThfVU5PUk1fU1JHQlwiXSA9IDI5XSA9IFwiRFhHSV9GT1JNQVRfUjhHOEI4QThfVU5PUk1fU1JHQlwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjhHOEI4QThfVUlOVFwiXSA9IDMwXSA9IFwiRFhHSV9GT1JNQVRfUjhHOEI4QThfVUlOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjhHOEI4QThfU05PUk1cIl0gPSAzMV0gPSBcIkRYR0lfRk9STUFUX1I4RzhCOEE4X1NOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SOEc4QjhBOF9TSU5UXCJdID0gMzJdID0gXCJEWEdJX0ZPUk1BVF9SOEc4QjhBOF9TSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTZHMTZfVFlQRUxFU1NcIl0gPSAzM10gPSBcIkRYR0lfRk9STUFUX1IxNkcxNl9UWVBFTEVTU1wiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjE2RzE2X0ZMT0FUXCJdID0gMzRdID0gXCJEWEdJX0ZPUk1BVF9SMTZHMTZfRkxPQVRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IxNkcxNl9VTk9STVwiXSA9IDM1XSA9IFwiRFhHSV9GT1JNQVRfUjE2RzE2X1VOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTZHMTZfVUlOVFwiXSA9IDM2XSA9IFwiRFhHSV9GT1JNQVRfUjE2RzE2X1VJTlRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IxNkcxNl9TTk9STVwiXSA9IDM3XSA9IFwiRFhHSV9GT1JNQVRfUjE2RzE2X1NOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTZHMTZfU0lOVFwiXSA9IDM4XSA9IFwiRFhHSV9GT1JNQVRfUjE2RzE2X1NJTlRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IzMl9UWVBFTEVTU1wiXSA9IDM5XSA9IFwiRFhHSV9GT1JNQVRfUjMyX1RZUEVMRVNTXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9EMzJfRkxPQVRcIl0gPSA0MF0gPSBcIkRYR0lfRk9STUFUX0QzMl9GTE9BVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjMyX0ZMT0FUXCJdID0gNDFdID0gXCJEWEdJX0ZPUk1BVF9SMzJfRkxPQVRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IzMl9VSU5UXCJdID0gNDJdID0gXCJEWEdJX0ZPUk1BVF9SMzJfVUlOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjMyX1NJTlRcIl0gPSA0M10gPSBcIkRYR0lfRk9STUFUX1IzMl9TSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMjRHOF9UWVBFTEVTU1wiXSA9IDQ0XSA9IFwiRFhHSV9GT1JNQVRfUjI0RzhfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0QyNF9VTk9STV9TOF9VSU5UXCJdID0gNDVdID0gXCJEWEdJX0ZPUk1BVF9EMjRfVU5PUk1fUzhfVUlOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjI0X1VOT1JNX1g4X1RZUEVMRVNTXCJdID0gNDZdID0gXCJEWEdJX0ZPUk1BVF9SMjRfVU5PUk1fWDhfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1gyNF9UWVBFTEVTU19HOF9VSU5UXCJdID0gNDddID0gXCJEWEdJX0ZPUk1BVF9YMjRfVFlQRUxFU1NfRzhfVUlOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjhHOF9UWVBFTEVTU1wiXSA9IDQ4XSA9IFwiRFhHSV9GT1JNQVRfUjhHOF9UWVBFTEVTU1wiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjhHOF9VTk9STVwiXSA9IDQ5XSA9IFwiRFhHSV9GT1JNQVRfUjhHOF9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjhHOF9VSU5UXCJdID0gNTBdID0gXCJEWEdJX0ZPUk1BVF9SOEc4X1VJTlRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1I4RzhfU05PUk1cIl0gPSA1MV0gPSBcIkRYR0lfRk9STUFUX1I4RzhfU05PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1I4RzhfU0lOVFwiXSA9IDUyXSA9IFwiRFhHSV9GT1JNQVRfUjhHOF9TSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTZfVFlQRUxFU1NcIl0gPSA1M10gPSBcIkRYR0lfRk9STUFUX1IxNl9UWVBFTEVTU1wiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjE2X0ZMT0FUXCJdID0gNTRdID0gXCJEWEdJX0ZPUk1BVF9SMTZfRkxPQVRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0QxNl9VTk9STVwiXSA9IDU1XSA9IFwiRFhHSV9GT1JNQVRfRDE2X1VOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTZfVU5PUk1cIl0gPSA1Nl0gPSBcIkRYR0lfRk9STUFUX1IxNl9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjE2X1VJTlRcIl0gPSA1N10gPSBcIkRYR0lfRk9STUFUX1IxNl9VSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SMTZfU05PUk1cIl0gPSA1OF0gPSBcIkRYR0lfRk9STUFUX1IxNl9TTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjE2X1NJTlRcIl0gPSA1OV0gPSBcIkRYR0lfRk9STUFUX1IxNl9TSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SOF9UWVBFTEVTU1wiXSA9IDYwXSA9IFwiRFhHSV9GT1JNQVRfUjhfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1I4X1VOT1JNXCJdID0gNjFdID0gXCJEWEdJX0ZPUk1BVF9SOF9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjhfVUlOVFwiXSA9IDYyXSA9IFwiRFhHSV9GT1JNQVRfUjhfVUlOVFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjhfU05PUk1cIl0gPSA2M10gPSBcIkRYR0lfRk9STUFUX1I4X1NOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9SOF9TSU5UXCJdID0gNjRdID0gXCJEWEdJX0ZPUk1BVF9SOF9TSU5UXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9BOF9VTk9STVwiXSA9IDY1XSA9IFwiRFhHSV9GT1JNQVRfQThfVU5PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IxX1VOT1JNXCJdID0gNjZdID0gXCJEWEdJX0ZPUk1BVF9SMV9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUjlHOUI5RTVfU0hBUkVERVhQXCJdID0gNjddID0gXCJEWEdJX0ZPUk1BVF9SOUc5QjlFNV9TSEFSRURFWFBcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1I4RzhfQjhHOF9VTk9STVwiXSA9IDY4XSA9IFwiRFhHSV9GT1JNQVRfUjhHOF9COEc4X1VOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9HOFI4X0c4QjhfVU5PUk1cIl0gPSA2OV0gPSBcIkRYR0lfRk9STUFUX0c4UjhfRzhCOF9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQkMxX1RZUEVMRVNTXCJdID0gNzBdID0gXCJEWEdJX0ZPUk1BVF9CQzFfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0JDMV9VTk9STVwiXSA9IDcxXSA9IFwiRFhHSV9GT1JNQVRfQkMxX1VOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9CQzFfVU5PUk1fU1JHQlwiXSA9IDcyXSA9IFwiRFhHSV9GT1JNQVRfQkMxX1VOT1JNX1NSR0JcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0JDMl9UWVBFTEVTU1wiXSA9IDczXSA9IFwiRFhHSV9GT1JNQVRfQkMyX1RZUEVMRVNTXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9CQzJfVU5PUk1cIl0gPSA3NF0gPSBcIkRYR0lfRk9STUFUX0JDMl9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQkMyX1VOT1JNX1NSR0JcIl0gPSA3NV0gPSBcIkRYR0lfRk9STUFUX0JDMl9VTk9STV9TUkdCXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9CQzNfVFlQRUxFU1NcIl0gPSA3Nl0gPSBcIkRYR0lfRk9STUFUX0JDM19UWVBFTEVTU1wiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQkMzX1VOT1JNXCJdID0gNzddID0gXCJEWEdJX0ZPUk1BVF9CQzNfVU5PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0JDM19VTk9STV9TUkdCXCJdID0gNzhdID0gXCJEWEdJX0ZPUk1BVF9CQzNfVU5PUk1fU1JHQlwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQkM0X1RZUEVMRVNTXCJdID0gNzldID0gXCJEWEdJX0ZPUk1BVF9CQzRfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0JDNF9VTk9STVwiXSA9IDgwXSA9IFwiRFhHSV9GT1JNQVRfQkM0X1VOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9CQzRfU05PUk1cIl0gPSA4MV0gPSBcIkRYR0lfRk9STUFUX0JDNF9TTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQkM1X1RZUEVMRVNTXCJdID0gODJdID0gXCJEWEdJX0ZPUk1BVF9CQzVfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0JDNV9VTk9STVwiXSA9IDgzXSA9IFwiRFhHSV9GT1JNQVRfQkM1X1VOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9CQzVfU05PUk1cIl0gPSA4NF0gPSBcIkRYR0lfRk9STUFUX0JDNV9TTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQjVHNlI1X1VOT1JNXCJdID0gODVdID0gXCJEWEdJX0ZPUk1BVF9CNUc2UjVfVU5PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0I1RzVSNUExX1VOT1JNXCJdID0gODZdID0gXCJEWEdJX0ZPUk1BVF9CNUc1UjVBMV9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQjhHOFI4QThfVU5PUk1cIl0gPSA4N10gPSBcIkRYR0lfRk9STUFUX0I4RzhSOEE4X1VOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9COEc4UjhYOF9VTk9STVwiXSA9IDg4XSA9IFwiRFhHSV9GT1JNQVRfQjhHOFI4WDhfVU5PUk1cIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1IxMEcxMEIxMF9YUl9CSUFTX0EyX1VOT1JNXCJdID0gODldID0gXCJEWEdJX0ZPUk1BVF9SMTBHMTBCMTBfWFJfQklBU19BMl9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQjhHOFI4QThfVFlQRUxFU1NcIl0gPSA5MF0gPSBcIkRYR0lfRk9STUFUX0I4RzhSOEE4X1RZUEVMRVNTXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9COEc4UjhBOF9VTk9STV9TUkdCXCJdID0gOTFdID0gXCJEWEdJX0ZPUk1BVF9COEc4UjhBOF9VTk9STV9TUkdCXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9COEc4UjhYOF9UWVBFTEVTU1wiXSA9IDkyXSA9IFwiRFhHSV9GT1JNQVRfQjhHOFI4WDhfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0I4RzhSOFg4X1VOT1JNX1NSR0JcIl0gPSA5M10gPSBcIkRYR0lfRk9STUFUX0I4RzhSOFg4X1VOT1JNX1NSR0JcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0JDNkhfVFlQRUxFU1NcIl0gPSA5NF0gPSBcIkRYR0lfRk9STUFUX0JDNkhfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0JDNkhfVUYxNlwiXSA9IDk1XSA9IFwiRFhHSV9GT1JNQVRfQkM2SF9VRjE2XCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9CQzZIX1NGMTZcIl0gPSA5Nl0gPSBcIkRYR0lfRk9STUFUX0JDNkhfU0YxNlwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQkM3X1RZUEVMRVNTXCJdID0gOTddID0gXCJEWEdJX0ZPUk1BVF9CQzdfVFlQRUxFU1NcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0JDN19VTk9STVwiXSA9IDk4XSA9IFwiRFhHSV9GT1JNQVRfQkM3X1VOT1JNXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9CQzdfVU5PUk1fU1JHQlwiXSA9IDk5XSA9IFwiRFhHSV9GT1JNQVRfQkM3X1VOT1JNX1NSR0JcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0FZVVZcIl0gPSAxMDBdID0gXCJEWEdJX0ZPUk1BVF9BWVVWXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9ZNDEwXCJdID0gMTAxXSA9IFwiRFhHSV9GT1JNQVRfWTQxMFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfWTQxNlwiXSA9IDEwMl0gPSBcIkRYR0lfRk9STUFUX1k0MTZcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX05WMTJcIl0gPSAxMDNdID0gXCJEWEdJX0ZPUk1BVF9OVjEyXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9QMDEwXCJdID0gMTA0XSA9IFwiRFhHSV9GT1JNQVRfUDAxMFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUDAxNlwiXSA9IDEwNV0gPSBcIkRYR0lfRk9STUFUX1AwMTZcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUXzQyMF9PUEFRVUVcIl0gPSAxMDZdID0gXCJEWEdJX0ZPUk1BVF80MjBfT1BBUVVFXCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9ZVVkyXCJdID0gMTA3XSA9IFwiRFhHSV9GT1JNQVRfWVVZMlwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfWTIxMFwiXSA9IDEwOF0gPSBcIkRYR0lfRk9STUFUX1kyMTBcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1kyMTZcIl0gPSAxMDldID0gXCJEWEdJX0ZPUk1BVF9ZMjE2XCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9OVjExXCJdID0gMTEwXSA9IFwiRFhHSV9GT1JNQVRfTlYxMVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQUk0NFwiXSA9IDExMV0gPSBcIkRYR0lfRk9STUFUX0FJNDRcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX0lBNDRcIl0gPSAxMTJdID0gXCJEWEdJX0ZPUk1BVF9JQTQ0XCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9QOFwiXSA9IDExM10gPSBcIkRYR0lfRk9STUFUX1A4XCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9BOFA4XCJdID0gMTE0XSA9IFwiRFhHSV9GT1JNQVRfQThQOFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfQjRHNFI0QTRfVU5PUk1cIl0gPSAxMTVdID0gXCJEWEdJX0ZPUk1BVF9CNEc0UjRBNF9VTk9STVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfUDIwOFwiXSA9IDExNl0gPSBcIkRYR0lfRk9STUFUX1AyMDhcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1YyMDhcIl0gPSAxMTddID0gXCJEWEdJX0ZPUk1BVF9WMjA4XCI7XG4gIERYR0lfRk9STUFUMltEWEdJX0ZPUk1BVDJbXCJEWEdJX0ZPUk1BVF9WNDA4XCJdID0gMTE4XSA9IFwiRFhHSV9GT1JNQVRfVjQwOFwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfU0FNUExFUl9GRUVEQkFDS19NSU5fTUlQX09QQVFVRVwiXSA9IDExOV0gPSBcIkRYR0lfRk9STUFUX1NBTVBMRVJfRkVFREJBQ0tfTUlOX01JUF9PUEFRVUVcIjtcbiAgRFhHSV9GT1JNQVQyW0RYR0lfRk9STUFUMltcIkRYR0lfRk9STUFUX1NBTVBMRVJfRkVFREJBQ0tfTUlQX1JFR0lPTl9VU0VEX09QQVFVRVwiXSA9IDEyMF0gPSBcIkRYR0lfRk9STUFUX1NBTVBMRVJfRkVFREJBQ0tfTUlQX1JFR0lPTl9VU0VEX09QQVFVRVwiO1xuICBEWEdJX0ZPUk1BVDJbRFhHSV9GT1JNQVQyW1wiRFhHSV9GT1JNQVRfRk9SQ0VfVUlOVFwiXSA9IDEyMV0gPSBcIkRYR0lfRk9STUFUX0ZPUkNFX1VJTlRcIjtcbiAgcmV0dXJuIERYR0lfRk9STUFUMjtcbn0pKERYR0lfRk9STUFUIHx8IHt9KTtcbnZhciBEM0QxMF9SRVNPVVJDRV9ESU1FTlNJT04gPSAvKiBAX19QVVJFX18gKi8gKChEM0QxMF9SRVNPVVJDRV9ESU1FTlNJT04yKSA9PiB7XG4gIEQzRDEwX1JFU09VUkNFX0RJTUVOU0lPTjJbRDNEMTBfUkVTT1VSQ0VfRElNRU5TSU9OMltcIkREU19ESU1FTlNJT05fVEVYVFVSRTFEXCJdID0gMl0gPSBcIkREU19ESU1FTlNJT05fVEVYVFVSRTFEXCI7XG4gIEQzRDEwX1JFU09VUkNFX0RJTUVOU0lPTjJbRDNEMTBfUkVTT1VSQ0VfRElNRU5TSU9OMltcIkREU19ESU1FTlNJT05fVEVYVFVSRTJEXCJdID0gM10gPSBcIkREU19ESU1FTlNJT05fVEVYVFVSRTJEXCI7XG4gIEQzRDEwX1JFU09VUkNFX0RJTUVOU0lPTjJbRDNEMTBfUkVTT1VSQ0VfRElNRU5TSU9OMltcIkREU19ESU1FTlNJT05fVEVYVFVSRTNEXCJdID0gNl0gPSBcIkREU19ESU1FTlNJT05fVEVYVFVSRTNEXCI7XG4gIHJldHVybiBEM0QxMF9SRVNPVVJDRV9ESU1FTlNJT04yO1xufSkoRDNEMTBfUkVTT1VSQ0VfRElNRU5TSU9OIHx8IHt9KTtcbmNvbnN0IFBGX0ZMQUdTID0gMTtcbmNvbnN0IEREUEZfQUxQSEEgPSAyO1xuY29uc3QgRERQRl9GT1VSQ0MgPSA0O1xuY29uc3QgRERQRl9SR0IgPSA2NDtcbmNvbnN0IEREUEZfWVVWID0gNTEyO1xuY29uc3QgRERQRl9MVU1JTkFOQ0UgPSAxMzEwNzI7XG5jb25zdCBGT1VSQ0NfRFhUMSA9IDgyNzYxMTIwNDtcbmNvbnN0IEZPVVJDQ19EWFQzID0gODYxMTY1NjM2O1xuY29uc3QgRk9VUkNDX0RYVDUgPSA4OTQ3MjAwNjg7XG5jb25zdCBGT1VSQ0NfRFgxMCA9IDgwODU0MDIyODtcbmNvbnN0IEREU19SRVNPVVJDRV9NSVNDX1RFWFRVUkVDVUJFID0gNDtcbmNvbnN0IEZPVVJDQ19UT19GT1JNQVQgPSB7XG4gIFtGT1VSQ0NfRFhUMV06IElOVEVSTkFMX0ZPUk1BVFMuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQsXG4gIFtGT1VSQ0NfRFhUM106IElOVEVSTkFMX0ZPUk1BVFMuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQsXG4gIFtGT1VSQ0NfRFhUNV06IElOVEVSTkFMX0ZPUk1BVFMuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFRcbn07XG5jb25zdCBEWEdJX1RPX0ZPUk1BVCA9IHtcbiAgWzcwIC8qIERYR0lfRk9STUFUX0JDMV9UWVBFTEVTUyAqL106IElOVEVSTkFMX0ZPUk1BVFMuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQsXG4gIFs3MSAvKiBEWEdJX0ZPUk1BVF9CQzFfVU5PUk0gKi9dOiBJTlRFUk5BTF9GT1JNQVRTLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhULFxuICBbNzMgLyogRFhHSV9GT1JNQVRfQkMyX1RZUEVMRVNTICovXTogSU5URVJOQUxfRk9STUFUUy5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVCxcbiAgWzc0IC8qIERYR0lfRk9STUFUX0JDMl9VTk9STSAqL106IElOVEVSTkFMX0ZPUk1BVFMuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQsXG4gIFs3NiAvKiBEWEdJX0ZPUk1BVF9CQzNfVFlQRUxFU1MgKi9dOiBJTlRFUk5BTF9GT1JNQVRTLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhULFxuICBbNzcgLyogRFhHSV9GT1JNQVRfQkMzX1VOT1JNICovXTogSU5URVJOQUxfRk9STUFUUy5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVCxcbiAgWzcyIC8qIERYR0lfRk9STUFUX0JDMV9VTk9STV9TUkdCICovXTogSU5URVJOQUxfRk9STUFUUy5DT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQxX0VYVCxcbiAgWzc1IC8qIERYR0lfRk9STUFUX0JDMl9VTk9STV9TUkdCICovXTogSU5URVJOQUxfRk9STUFUUy5DT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQzX0VYVCxcbiAgWzc4IC8qIERYR0lfRk9STUFUX0JDM19VTk9STV9TUkdCICovXTogSU5URVJOQUxfRk9STUFUUy5DT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQ1X0VYVFxufTtcbmZ1bmN0aW9uIHBhcnNlRERTKGFycmF5QnVmZmVyKSB7XG4gIGNvbnN0IGRhdGEgPSBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWZmZXIpO1xuICBjb25zdCBtYWdpY1dvcmQgPSBkYXRhWzBdO1xuICBpZiAobWFnaWNXb3JkICE9PSBERFNfTUFHSUMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEREUyBmaWxlIG1hZ2ljIHdvcmRcIik7XG4gIH1cbiAgY29uc3QgaGVhZGVyID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmZmVyLCAwLCBERFNfSEVBREVSX1NJWkUgLyBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCk7XG4gIGNvbnN0IGhlaWdodCA9IGhlYWRlcltERFNfRklFTERTLkhFSUdIVF07XG4gIGNvbnN0IHdpZHRoID0gaGVhZGVyW0REU19GSUVMRFMuV0lEVEhdO1xuICBjb25zdCBtaXBtYXBDb3VudCA9IGhlYWRlcltERFNfRklFTERTLk1JUE1BUF9DT1VOVF07XG4gIGNvbnN0IHBpeGVsRm9ybWF0ID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmZmVyLCBERFNfRklFTERTLlBJWEVMX0ZPUk1BVCAqIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULCBERFNfSEVBREVSX1BGX1NJWkUgLyBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCk7XG4gIGNvbnN0IGZvcm1hdEZsYWdzID0gcGl4ZWxGb3JtYXRbUEZfRkxBR1NdO1xuICBpZiAoZm9ybWF0RmxhZ3MgJiBERFBGX0ZPVVJDQykge1xuICAgIGNvbnN0IGZvdXJDQyA9IHBpeGVsRm9ybWF0W0REU19QRl9GSUVMRFMuRk9VUkNDXTtcbiAgICBpZiAoZm91ckNDICE9PSBGT1VSQ0NfRFgxMCkge1xuICAgICAgY29uc3QgaW50ZXJuYWxGb3JtYXQyID0gRk9VUkNDX1RPX0ZPUk1BVFtmb3VyQ0NdO1xuICAgICAgY29uc3QgZGF0YU9mZnNldDIgPSBERFNfTUFHSUNfU0laRSArIEREU19IRUFERVJfU0laRTtcbiAgICAgIGNvbnN0IHRleERhdGEgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciwgZGF0YU9mZnNldDIpO1xuICAgICAgY29uc3QgcmVzb3VyY2UgPSBuZXcgQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZSh0ZXhEYXRhLCB7XG4gICAgICAgIGZvcm1hdDogaW50ZXJuYWxGb3JtYXQyLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBsZXZlbHM6IG1pcG1hcENvdW50XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBbcmVzb3VyY2VdO1xuICAgIH1cbiAgICBjb25zdCBkeDEwT2Zmc2V0ID0gRERTX01BR0lDX1NJWkUgKyBERFNfSEVBREVSX1NJWkU7XG4gICAgY29uc3QgZHgxMEhlYWRlciA9IG5ldyBVaW50MzJBcnJheShkYXRhLmJ1ZmZlciwgZHgxME9mZnNldCwgRERTX0hFQURFUl9EWDEwX1NJWkUgLyBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCk7XG4gICAgY29uc3QgZHhnaUZvcm1hdCA9IGR4MTBIZWFkZXJbRERTX0RYMTBfRklFTERTLkRYR0lfRk9STUFUXTtcbiAgICBjb25zdCByZXNvdXJjZURpbWVuc2lvbiA9IGR4MTBIZWFkZXJbRERTX0RYMTBfRklFTERTLlJFU09VUkNFX0RJTUVOU0lPTl07XG4gICAgY29uc3QgbWlzY0ZsYWcgPSBkeDEwSGVhZGVyW0REU19EWDEwX0ZJRUxEUy5NSVNDX0ZMQUddO1xuICAgIGNvbnN0IGFycmF5U2l6ZSA9IGR4MTBIZWFkZXJbRERTX0RYMTBfRklFTERTLkFSUkFZX1NJWkVdO1xuICAgIGNvbnN0IGludGVybmFsRm9ybWF0ID0gRFhHSV9UT19GT1JNQVRbZHhnaUZvcm1hdF07XG4gICAgaWYgKGludGVybmFsRm9ybWF0ID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRERTUGFyc2VyIGNhbm5vdCBwYXJzZSB0ZXh0dXJlIGRhdGEgd2l0aCBEWEdJIGZvcm1hdCAke2R4Z2lGb3JtYXR9YCk7XG4gICAgfVxuICAgIGlmIChtaXNjRmxhZyA9PT0gRERTX1JFU09VUkNFX01JU0NfVEVYVFVSRUNVQkUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkREU1BhcnNlciBkb2VzIG5vdCBzdXBwb3J0IGN1YmVtYXAgdGV4dHVyZXNcIik7XG4gICAgfVxuICAgIGlmIChyZXNvdXJjZURpbWVuc2lvbiA9PT0gNiAvKiBERFNfRElNRU5TSU9OX1RFWFRVUkUzRCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRERTUGFyc2VyIGRvZXMgbm90IHN1cHBvcnRlZCAzRCB0ZXh0dXJlIGRhdGFcIik7XG4gICAgfVxuICAgIGNvbnN0IGltYWdlQnVmZmVycyA9IG5ldyBBcnJheSgpO1xuICAgIGNvbnN0IGRhdGFPZmZzZXQgPSBERFNfTUFHSUNfU0laRSArIEREU19IRUFERVJfU0laRSArIEREU19IRUFERVJfRFgxMF9TSVpFO1xuICAgIGlmIChhcnJheVNpemUgPT09IDEpIHtcbiAgICAgIGltYWdlQnVmZmVycy5wdXNoKG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLCBkYXRhT2Zmc2V0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBpeGVsU2l6ZSA9IElOVEVSTkFMX0ZPUk1BVF9UT19CWVRFU19QRVJfUElYRUxbaW50ZXJuYWxGb3JtYXRdO1xuICAgICAgbGV0IGltYWdlU2l6ZSA9IDA7XG4gICAgICBsZXQgbGV2ZWxXaWR0aCA9IHdpZHRoO1xuICAgICAgbGV0IGxldmVsSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaXBtYXBDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFsaWduZWRMZXZlbFdpZHRoID0gTWF0aC5tYXgoMSwgbGV2ZWxXaWR0aCArIDMgJiB+Myk7XG4gICAgICAgIGNvbnN0IGFsaWduZWRMZXZlbEhlaWdodCA9IE1hdGgubWF4KDEsIGxldmVsSGVpZ2h0ICsgMyAmIH4zKTtcbiAgICAgICAgY29uc3QgbGV2ZWxTaXplID0gYWxpZ25lZExldmVsV2lkdGggKiBhbGlnbmVkTGV2ZWxIZWlnaHQgKiBwaXhlbFNpemU7XG4gICAgICAgIGltYWdlU2l6ZSArPSBsZXZlbFNpemU7XG4gICAgICAgIGxldmVsV2lkdGggPSBsZXZlbFdpZHRoID4+PiAxO1xuICAgICAgICBsZXZlbEhlaWdodCA9IGxldmVsSGVpZ2h0ID4+PiAxO1xuICAgICAgfVxuICAgICAgbGV0IGltYWdlT2Zmc2V0ID0gZGF0YU9mZnNldDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlTaXplOyBpKyspIHtcbiAgICAgICAgaW1hZ2VCdWZmZXJzLnB1c2gobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIGltYWdlT2Zmc2V0LCBpbWFnZVNpemUpKTtcbiAgICAgICAgaW1hZ2VPZmZzZXQgKz0gaW1hZ2VTaXplO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW1hZ2VCdWZmZXJzLm1hcCgoYnVmZmVyKSA9PiBuZXcgQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZShidWZmZXIsIHtcbiAgICAgIGZvcm1hdDogaW50ZXJuYWxGb3JtYXQsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGxldmVsczogbWlwbWFwQ291bnRcbiAgICB9KSk7XG4gIH1cbiAgaWYgKGZvcm1hdEZsYWdzICYgRERQRl9SR0IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJERFNQYXJzZXIgZG9lcyBub3Qgc3VwcG9ydCB1bmNvbXByZXNzZWQgdGV4dHVyZSBkYXRhLlwiKTtcbiAgfVxuICBpZiAoZm9ybWF0RmxhZ3MgJiBERFBGX1lVVikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkREU1BhcnNlciBkb2VzIG5vdCBzdXBwb3J0ZWQgWVVWIHVuY29tcHJlc3NlZCB0ZXh0dXJlIGRhdGEuXCIpO1xuICB9XG4gIGlmIChmb3JtYXRGbGFncyAmIEREUEZfTFVNSU5BTkNFKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRERTUGFyc2VyIGRvZXMgbm90IHN1cHBvcnQgc2luZ2xlLWNoYW5uZWwgKGx1bW5pbmFuY2UpIHRleHR1cmUgZGF0YSFcIik7XG4gIH1cbiAgaWYgKGZvcm1hdEZsYWdzICYgRERQRl9BTFBIQSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkREU1BhcnNlciBkb2VzIG5vdCBzdXBwb3J0IHNpbmdsZS1jaGFubmVsIChhbHBoYSkgdGV4dHVyZSBkYXRhIVwiKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJERFNQYXJzZXIgZmFpbGVkIHRvIGxvYWQgYSB0ZXh0dXJlIGZpbGUgZHVlIHRvIGFuIHVua25vd24gcmVhc29uIVwiKTtcbn1cblxuZXhwb3J0IHsgcGFyc2VERFMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlRERTLm1qcy5tYXBcbiIsImltcG9ydCB7IFRZUEVTLCBGT1JNQVRTLCBCdWZmZXJSZXNvdXJjZSB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgSU5URVJOQUxfRk9STUFUX1RPX0JZVEVTX1BFUl9QSVhFTCB9IGZyb20gJy4uL2NvbnN0Lm1qcyc7XG5pbXBvcnQgJy4uL3Jlc291cmNlcy9pbmRleC5tanMnO1xuaW1wb3J0IHsgQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZSB9IGZyb20gJy4uL3Jlc291cmNlcy9Db21wcmVzc2VkVGV4dHVyZVJlc291cmNlLm1qcyc7XG5cbmNvbnN0IEZJTEVfSURFTlRJRklFUiA9IFsxNzEsIDc1LCA4NCwgODgsIDMyLCA0OSwgNDksIDE4NywgMTMsIDEwLCAyNiwgMTBdO1xuY29uc3QgRU5ESUFOTkVTUyA9IDY3MzA1OTg1O1xuY29uc3QgS1RYX0ZJRUxEUyA9IHtcbiAgRklMRV9JREVOVElGSUVSOiAwLFxuICBFTkRJQU5ORVNTOiAxMixcbiAgR0xfVFlQRTogMTYsXG4gIEdMX1RZUEVfU0laRTogMjAsXG4gIEdMX0ZPUk1BVDogMjQsXG4gIEdMX0lOVEVSTkFMX0ZPUk1BVDogMjgsXG4gIEdMX0JBU0VfSU5URVJOQUxfRk9STUFUOiAzMixcbiAgUElYRUxfV0lEVEg6IDM2LFxuICBQSVhFTF9IRUlHSFQ6IDQwLFxuICBQSVhFTF9ERVBUSDogNDQsXG4gIE5VTUJFUl9PRl9BUlJBWV9FTEVNRU5UUzogNDgsXG4gIE5VTUJFUl9PRl9GQUNFUzogNTIsXG4gIE5VTUJFUl9PRl9NSVBNQVBfTEVWRUxTOiA1NixcbiAgQllURVNfT0ZfS0VZX1ZBTFVFX0RBVEE6IDYwXG59O1xuY29uc3QgRklMRV9IRUFERVJfU0laRSA9IDY0O1xuY29uc3QgVFlQRVNfVE9fQllURVNfUEVSX0NPTVBPTkVOVCA9IHtcbiAgW1RZUEVTLlVOU0lHTkVEX0JZVEVdOiAxLFxuICBbVFlQRVMuVU5TSUdORURfU0hPUlRdOiAyLFxuICBbVFlQRVMuSU5UXTogNCxcbiAgW1RZUEVTLlVOU0lHTkVEX0lOVF06IDQsXG4gIFtUWVBFUy5GTE9BVF06IDQsXG4gIFtUWVBFUy5IQUxGX0ZMT0FUXTogOFxufTtcbmNvbnN0IEZPUk1BVFNfVE9fQ09NUE9ORU5UUyA9IHtcbiAgW0ZPUk1BVFMuUkdCQV06IDQsXG4gIFtGT1JNQVRTLlJHQl06IDMsXG4gIFtGT1JNQVRTLlJHXTogMixcbiAgW0ZPUk1BVFMuUkVEXTogMSxcbiAgW0ZPUk1BVFMuTFVNSU5BTkNFXTogMSxcbiAgW0ZPUk1BVFMuTFVNSU5BTkNFX0FMUEhBXTogMixcbiAgW0ZPUk1BVFMuQUxQSEFdOiAxXG59O1xuY29uc3QgVFlQRVNfVE9fQllURVNfUEVSX1BJWEVMID0ge1xuICBbVFlQRVMuVU5TSUdORURfU0hPUlRfNF80XzRfNF06IDIsXG4gIFtUWVBFUy5VTlNJR05FRF9TSE9SVF81XzVfNV8xXTogMixcbiAgW1RZUEVTLlVOU0lHTkVEX1NIT1JUXzVfNl81XTogMlxufTtcbmZ1bmN0aW9uIHBhcnNlS1RYKHVybCwgYXJyYXlCdWZmZXIsIGxvYWRLZXlWYWx1ZURhdGEgPSBmYWxzZSkge1xuICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gIGlmICghdmFsaWRhdGUodXJsLCBkYXRhVmlldykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBsaXR0bGVFbmRpYW4gPSBkYXRhVmlldy5nZXRVaW50MzIoS1RYX0ZJRUxEUy5FTkRJQU5ORVNTLCB0cnVlKSA9PT0gRU5ESUFOTkVTUztcbiAgY29uc3QgZ2xUeXBlID0gZGF0YVZpZXcuZ2V0VWludDMyKEtUWF9GSUVMRFMuR0xfVFlQRSwgbGl0dGxlRW5kaWFuKTtcbiAgY29uc3QgZ2xGb3JtYXQgPSBkYXRhVmlldy5nZXRVaW50MzIoS1RYX0ZJRUxEUy5HTF9GT1JNQVQsIGxpdHRsZUVuZGlhbik7XG4gIGNvbnN0IGdsSW50ZXJuYWxGb3JtYXQgPSBkYXRhVmlldy5nZXRVaW50MzIoS1RYX0ZJRUxEUy5HTF9JTlRFUk5BTF9GT1JNQVQsIGxpdHRsZUVuZGlhbik7XG4gIGNvbnN0IHBpeGVsV2lkdGggPSBkYXRhVmlldy5nZXRVaW50MzIoS1RYX0ZJRUxEUy5QSVhFTF9XSURUSCwgbGl0dGxlRW5kaWFuKTtcbiAgY29uc3QgcGl4ZWxIZWlnaHQgPSBkYXRhVmlldy5nZXRVaW50MzIoS1RYX0ZJRUxEUy5QSVhFTF9IRUlHSFQsIGxpdHRsZUVuZGlhbikgfHwgMTtcbiAgY29uc3QgcGl4ZWxEZXB0aCA9IGRhdGFWaWV3LmdldFVpbnQzMihLVFhfRklFTERTLlBJWEVMX0RFUFRILCBsaXR0bGVFbmRpYW4pIHx8IDE7XG4gIGNvbnN0IG51bWJlck9mQXJyYXlFbGVtZW50cyA9IGRhdGFWaWV3LmdldFVpbnQzMihLVFhfRklFTERTLk5VTUJFUl9PRl9BUlJBWV9FTEVNRU5UUywgbGl0dGxlRW5kaWFuKSB8fCAxO1xuICBjb25zdCBudW1iZXJPZkZhY2VzID0gZGF0YVZpZXcuZ2V0VWludDMyKEtUWF9GSUVMRFMuTlVNQkVSX09GX0ZBQ0VTLCBsaXR0bGVFbmRpYW4pO1xuICBjb25zdCBudW1iZXJPZk1pcG1hcExldmVscyA9IGRhdGFWaWV3LmdldFVpbnQzMihLVFhfRklFTERTLk5VTUJFUl9PRl9NSVBNQVBfTEVWRUxTLCBsaXR0bGVFbmRpYW4pO1xuICBjb25zdCBieXRlc09mS2V5VmFsdWVEYXRhID0gZGF0YVZpZXcuZ2V0VWludDMyKEtUWF9GSUVMRFMuQllURVNfT0ZfS0VZX1ZBTFVFX0RBVEEsIGxpdHRsZUVuZGlhbik7XG4gIGlmIChwaXhlbEhlaWdodCA9PT0gMCB8fCBwaXhlbERlcHRoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSAyRCB0ZXh0dXJlcyBhcmUgc3VwcG9ydGVkXCIpO1xuICB9XG4gIGlmIChudW1iZXJPZkZhY2VzICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ3ViZVRleHR1cmVzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IEtUWExvYWRlciB5ZXQhXCIpO1xuICB9XG4gIGlmIChudW1iZXJPZkFycmF5RWxlbWVudHMgIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBkb2VzIG5vdCBzdXBwb3J0IGFycmF5IHRleHR1cmVzXCIpO1xuICB9XG4gIGNvbnN0IGJsb2NrV2lkdGggPSA0O1xuICBjb25zdCBibG9ja0hlaWdodCA9IDQ7XG4gIGNvbnN0IGFsaWduZWRXaWR0aCA9IHBpeGVsV2lkdGggKyAzICYgfjM7XG4gIGNvbnN0IGFsaWduZWRIZWlnaHQgPSBwaXhlbEhlaWdodCArIDMgJiB+MztcbiAgY29uc3QgaW1hZ2VCdWZmZXJzID0gbmV3IEFycmF5KG51bWJlck9mQXJyYXlFbGVtZW50cyk7XG4gIGxldCBpbWFnZVBpeGVscyA9IHBpeGVsV2lkdGggKiBwaXhlbEhlaWdodDtcbiAgaWYgKGdsVHlwZSA9PT0gMCkge1xuICAgIGltYWdlUGl4ZWxzID0gYWxpZ25lZFdpZHRoICogYWxpZ25lZEhlaWdodDtcbiAgfVxuICBsZXQgaW1hZ2VQaXhlbEJ5dGVTaXplO1xuICBpZiAoZ2xUeXBlICE9PSAwKSB7XG4gICAgaWYgKFRZUEVTX1RPX0JZVEVTX1BFUl9DT01QT05FTlRbZ2xUeXBlXSkge1xuICAgICAgaW1hZ2VQaXhlbEJ5dGVTaXplID0gVFlQRVNfVE9fQllURVNfUEVSX0NPTVBPTkVOVFtnbFR5cGVdICogRk9STUFUU19UT19DT01QT05FTlRTW2dsRm9ybWF0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW1hZ2VQaXhlbEJ5dGVTaXplID0gVFlQRVNfVE9fQllURVNfUEVSX1BJWEVMW2dsVHlwZV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGltYWdlUGl4ZWxCeXRlU2l6ZSA9IElOVEVSTkFMX0ZPUk1BVF9UT19CWVRFU19QRVJfUElYRUxbZ2xJbnRlcm5hbEZvcm1hdF07XG4gIH1cbiAgaWYgKGltYWdlUGl4ZWxCeXRlU2l6ZSA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJlc29sdmUgdGhlIHBpeGVsIGZvcm1hdCBzdG9yZWQgaW4gdGhlICoua3R4IGZpbGUhXCIpO1xuICB9XG4gIGNvbnN0IGt2RGF0YSA9IGxvYWRLZXlWYWx1ZURhdGEgPyBwYXJzZUt2RGF0YShkYXRhVmlldywgYnl0ZXNPZktleVZhbHVlRGF0YSwgbGl0dGxlRW5kaWFuKSA6IG51bGw7XG4gIGNvbnN0IGltYWdlQnl0ZVNpemUgPSBpbWFnZVBpeGVscyAqIGltYWdlUGl4ZWxCeXRlU2l6ZTtcbiAgbGV0IG1pcEJ5dGVTaXplID0gaW1hZ2VCeXRlU2l6ZTtcbiAgbGV0IG1pcFdpZHRoID0gcGl4ZWxXaWR0aDtcbiAgbGV0IG1pcEhlaWdodCA9IHBpeGVsSGVpZ2h0O1xuICBsZXQgYWxpZ25lZE1pcFdpZHRoID0gYWxpZ25lZFdpZHRoO1xuICBsZXQgYWxpZ25lZE1pcEhlaWdodCA9IGFsaWduZWRIZWlnaHQ7XG4gIGxldCBpbWFnZU9mZnNldCA9IEZJTEVfSEVBREVSX1NJWkUgKyBieXRlc09mS2V5VmFsdWVEYXRhO1xuICBmb3IgKGxldCBtaXBtYXBMZXZlbCA9IDA7IG1pcG1hcExldmVsIDwgbnVtYmVyT2ZNaXBtYXBMZXZlbHM7IG1pcG1hcExldmVsKyspIHtcbiAgICBjb25zdCBpbWFnZVNpemUgPSBkYXRhVmlldy5nZXRVaW50MzIoaW1hZ2VPZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gICAgbGV0IGVsZW1lbnRPZmZzZXQgPSBpbWFnZU9mZnNldCArIDQ7XG4gICAgZm9yIChsZXQgYXJyYXlFbGVtZW50ID0gMDsgYXJyYXlFbGVtZW50IDwgbnVtYmVyT2ZBcnJheUVsZW1lbnRzOyBhcnJheUVsZW1lbnQrKykge1xuICAgICAgbGV0IG1pcHMgPSBpbWFnZUJ1ZmZlcnNbYXJyYXlFbGVtZW50XTtcbiAgICAgIGlmICghbWlwcykge1xuICAgICAgICBtaXBzID0gaW1hZ2VCdWZmZXJzW2FycmF5RWxlbWVudF0gPSBuZXcgQXJyYXkobnVtYmVyT2ZNaXBtYXBMZXZlbHMpO1xuICAgICAgfVxuICAgICAgbWlwc1ttaXBtYXBMZXZlbF0gPSB7XG4gICAgICAgIGxldmVsSUQ6IG1pcG1hcExldmVsLFxuICAgICAgICBsZXZlbFdpZHRoOiBudW1iZXJPZk1pcG1hcExldmVscyA+IDEgfHwgZ2xUeXBlICE9PSAwID8gbWlwV2lkdGggOiBhbGlnbmVkTWlwV2lkdGgsXG4gICAgICAgIGxldmVsSGVpZ2h0OiBudW1iZXJPZk1pcG1hcExldmVscyA+IDEgfHwgZ2xUeXBlICE9PSAwID8gbWlwSGVpZ2h0IDogYWxpZ25lZE1pcEhlaWdodCxcbiAgICAgICAgbGV2ZWxCdWZmZXI6IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLCBlbGVtZW50T2Zmc2V0LCBtaXBCeXRlU2l6ZSlcbiAgICAgIH07XG4gICAgICBlbGVtZW50T2Zmc2V0ICs9IG1pcEJ5dGVTaXplO1xuICAgIH1cbiAgICBpbWFnZU9mZnNldCArPSBpbWFnZVNpemUgKyA0O1xuICAgIGltYWdlT2Zmc2V0ID0gaW1hZ2VPZmZzZXQgJSA0ICE9PSAwID8gaW1hZ2VPZmZzZXQgKyA0IC0gaW1hZ2VPZmZzZXQgJSA0IDogaW1hZ2VPZmZzZXQ7XG4gICAgbWlwV2lkdGggPSBtaXBXaWR0aCA+PiAxIHx8IDE7XG4gICAgbWlwSGVpZ2h0ID0gbWlwSGVpZ2h0ID4+IDEgfHwgMTtcbiAgICBhbGlnbmVkTWlwV2lkdGggPSBtaXBXaWR0aCArIGJsb2NrV2lkdGggLSAxICYgfihibG9ja1dpZHRoIC0gMSk7XG4gICAgYWxpZ25lZE1pcEhlaWdodCA9IG1pcEhlaWdodCArIGJsb2NrSGVpZ2h0IC0gMSAmIH4oYmxvY2tIZWlnaHQgLSAxKTtcbiAgICBtaXBCeXRlU2l6ZSA9IGFsaWduZWRNaXBXaWR0aCAqIGFsaWduZWRNaXBIZWlnaHQgKiBpbWFnZVBpeGVsQnl0ZVNpemU7XG4gIH1cbiAgaWYgKGdsVHlwZSAhPT0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICB1bmNvbXByZXNzZWQ6IGltYWdlQnVmZmVycy5tYXAoKGxldmVsQnVmZmVycykgPT4ge1xuICAgICAgICBsZXQgYnVmZmVyID0gbGV2ZWxCdWZmZXJzWzBdLmxldmVsQnVmZmVyO1xuICAgICAgICBsZXQgY29udmVydFRvSW50ID0gZmFsc2U7XG4gICAgICAgIGlmIChnbFR5cGUgPT09IFRZUEVTLkZMT0FUKSB7XG4gICAgICAgICAgYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShsZXZlbEJ1ZmZlcnNbMF0ubGV2ZWxCdWZmZXIuYnVmZmVyLCBsZXZlbEJ1ZmZlcnNbMF0ubGV2ZWxCdWZmZXIuYnl0ZU9mZnNldCwgbGV2ZWxCdWZmZXJzWzBdLmxldmVsQnVmZmVyLmJ5dGVMZW5ndGggLyA0KTtcbiAgICAgICAgfSBlbHNlIGlmIChnbFR5cGUgPT09IFRZUEVTLlVOU0lHTkVEX0lOVCkge1xuICAgICAgICAgIGNvbnZlcnRUb0ludCA9IHRydWU7XG4gICAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQzMkFycmF5KGxldmVsQnVmZmVyc1swXS5sZXZlbEJ1ZmZlci5idWZmZXIsIGxldmVsQnVmZmVyc1swXS5sZXZlbEJ1ZmZlci5ieXRlT2Zmc2V0LCBsZXZlbEJ1ZmZlcnNbMF0ubGV2ZWxCdWZmZXIuYnl0ZUxlbmd0aCAvIDQpO1xuICAgICAgICB9IGVsc2UgaWYgKGdsVHlwZSA9PT0gVFlQRVMuSU5UKSB7XG4gICAgICAgICAgY29udmVydFRvSW50ID0gdHJ1ZTtcbiAgICAgICAgICBidWZmZXIgPSBuZXcgSW50MzJBcnJheShsZXZlbEJ1ZmZlcnNbMF0ubGV2ZWxCdWZmZXIuYnVmZmVyLCBsZXZlbEJ1ZmZlcnNbMF0ubGV2ZWxCdWZmZXIuYnl0ZU9mZnNldCwgbGV2ZWxCdWZmZXJzWzBdLmxldmVsQnVmZmVyLmJ5dGVMZW5ndGggLyA0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc291cmNlOiBuZXcgQnVmZmVyUmVzb3VyY2UoYnVmZmVyLCB7XG4gICAgICAgICAgICB3aWR0aDogbGV2ZWxCdWZmZXJzWzBdLmxldmVsV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGxldmVsQnVmZmVyc1swXS5sZXZlbEhlaWdodFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHR5cGU6IGdsVHlwZSxcbiAgICAgICAgICBmb3JtYXQ6IGNvbnZlcnRUb0ludCA/IGNvbnZlcnRGb3JtYXRUb0ludGVnZXIoZ2xGb3JtYXQpIDogZ2xGb3JtYXRcbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAga3ZEYXRhXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGNvbXByZXNzZWQ6IGltYWdlQnVmZmVycy5tYXAoKGxldmVsQnVmZmVycykgPT4gbmV3IENvbXByZXNzZWRUZXh0dXJlUmVzb3VyY2UobnVsbCwge1xuICAgICAgZm9ybWF0OiBnbEludGVybmFsRm9ybWF0LFxuICAgICAgd2lkdGg6IHBpeGVsV2lkdGgsXG4gICAgICBoZWlnaHQ6IHBpeGVsSGVpZ2h0LFxuICAgICAgbGV2ZWxzOiBudW1iZXJPZk1pcG1hcExldmVscyxcbiAgICAgIGxldmVsQnVmZmVyc1xuICAgIH0pKSxcbiAgICBrdkRhdGFcbiAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlKHVybCwgZGF0YVZpZXcpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBGSUxFX0lERU5USUZJRVIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDgoaSkgIT09IEZJTEVfSURFTlRJRklFUltpXSkge1xuICAgICAgY29uc29sZS5lcnJvcihgJHt1cmx9IGlzIG5vdCBhIHZhbGlkICoua3R4IGZpbGUhYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY29udmVydEZvcm1hdFRvSW50ZWdlcihmb3JtYXQpIHtcbiAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICBjYXNlIEZPUk1BVFMuUkdCQTpcbiAgICAgIHJldHVybiBGT1JNQVRTLlJHQkFfSU5URUdFUjtcbiAgICBjYXNlIEZPUk1BVFMuUkdCOlxuICAgICAgcmV0dXJuIEZPUk1BVFMuUkdCX0lOVEVHRVI7XG4gICAgY2FzZSBGT1JNQVRTLlJHOlxuICAgICAgcmV0dXJuIEZPUk1BVFMuUkdfSU5URUdFUjtcbiAgICBjYXNlIEZPUk1BVFMuUkVEOlxuICAgICAgcmV0dXJuIEZPUk1BVFMuUkVEX0lOVEVHRVI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmb3JtYXQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlS3ZEYXRhKGRhdGFWaWV3LCBieXRlc09mS2V5VmFsdWVEYXRhLCBsaXR0bGVFbmRpYW4pIHtcbiAgY29uc3Qga3ZEYXRhID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IGJ5dGVzSW50b0tleVZhbHVlRGF0YSA9IDA7XG4gIHdoaWxlIChieXRlc0ludG9LZXlWYWx1ZURhdGEgPCBieXRlc09mS2V5VmFsdWVEYXRhKSB7XG4gICAgY29uc3Qga2V5QW5kVmFsdWVCeXRlU2l6ZSA9IGRhdGFWaWV3LmdldFVpbnQzMihGSUxFX0hFQURFUl9TSVpFICsgYnl0ZXNJbnRvS2V5VmFsdWVEYXRhLCBsaXR0bGVFbmRpYW4pO1xuICAgIGNvbnN0IGtleUFuZFZhbHVlQnl0ZU9mZnNldCA9IEZJTEVfSEVBREVSX1NJWkUgKyBieXRlc0ludG9LZXlWYWx1ZURhdGEgKyA0O1xuICAgIGNvbnN0IHZhbHVlUGFkZGluZyA9IDMgLSAoa2V5QW5kVmFsdWVCeXRlU2l6ZSArIDMpICUgNDtcbiAgICBpZiAoa2V5QW5kVmFsdWVCeXRlU2l6ZSA9PT0gMCB8fCBrZXlBbmRWYWx1ZUJ5dGVTaXplID4gYnl0ZXNPZktleVZhbHVlRGF0YSAtIGJ5dGVzSW50b0tleVZhbHVlRGF0YSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIktUWExvYWRlcjoga2V5QW5kVmFsdWVCeXRlU2l6ZSBvdXQgb2YgYm91bmRzXCIpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCBrZXlOdWxCeXRlID0gMDtcbiAgICBmb3IgKDsga2V5TnVsQnl0ZSA8IGtleUFuZFZhbHVlQnl0ZVNpemU7IGtleU51bEJ5dGUrKykge1xuICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQ4KGtleUFuZFZhbHVlQnl0ZU9mZnNldCArIGtleU51bEJ5dGUpID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5TnVsQnl0ZSA9PT0gLTEpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJLVFhMb2FkZXI6IEZhaWxlZCB0byBmaW5kIG51bGwgYnl0ZSB0ZXJtaW5hdGluZyBrdkRhdGEga2V5XCIpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShuZXcgVWludDhBcnJheShkYXRhVmlldy5idWZmZXIsIGtleUFuZFZhbHVlQnl0ZU9mZnNldCwga2V5TnVsQnl0ZSkpO1xuICAgIGNvbnN0IHZhbHVlID0gbmV3IERhdGFWaWV3KGRhdGFWaWV3LmJ1ZmZlciwga2V5QW5kVmFsdWVCeXRlT2Zmc2V0ICsga2V5TnVsQnl0ZSArIDEsIGtleUFuZFZhbHVlQnl0ZVNpemUgLSBrZXlOdWxCeXRlIC0gMSk7XG4gICAga3ZEYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICBieXRlc0ludG9LZXlWYWx1ZURhdGEgKz0gNCArIGtleUFuZFZhbHVlQnl0ZVNpemUgKyB2YWx1ZVBhZGRpbmc7XG4gIH1cbiAgcmV0dXJuIGt2RGF0YTtcbn1cblxuZXhwb3J0IHsgRk9STUFUU19UT19DT01QT05FTlRTLCBUWVBFU19UT19CWVRFU19QRVJfQ09NUE9ORU5ULCBUWVBFU19UT19CWVRFU19QRVJfUElYRUwsIHBhcnNlS1RYIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZUtUWC5tanMubWFwXG4iLCJleHBvcnQgeyBwYXJzZUREUyB9IGZyb20gJy4vcGFyc2VERFMubWpzJztcbmV4cG9ydCB7IEZPUk1BVFNfVE9fQ09NUE9ORU5UUywgVFlQRVNfVE9fQllURVNfUEVSX0NPTVBPTkVOVCwgVFlQRVNfVE9fQllURVNfUEVSX1BJWEVMLCBwYXJzZUtUWCB9IGZyb20gJy4vcGFyc2VLVFgubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IExvYWRlclBhcnNlclByaW9yaXR5LCBjaGVja0V4dGVuc2lvbiwgY3JlYXRlVGV4dHVyZSB9IGZyb20gJ0BwaXhpL2Fzc2V0cyc7XG5pbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBzZXR0aW5ncywgQmFzZVRleHR1cmUsIE1JUE1BUF9NT0RFUywgQUxQSEFfTU9ERVMsIHV0aWxzLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgJy4uL3BhcnNlcnMvaW5kZXgubWpzJztcbmltcG9ydCB7IHBhcnNlRERTIH0gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZUREUy5tanMnO1xuXG5jb25zdCBsb2FkRERTID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBFeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gICAgcHJpb3JpdHk6IExvYWRlclBhcnNlclByaW9yaXR5LkhpZ2hcbiAgfSxcbiAgbmFtZTogXCJsb2FkRERTXCIsXG4gIHRlc3QodXJsKSB7XG4gICAgcmV0dXJuIGNoZWNrRXh0ZW5zaW9uKHVybCwgXCIuZGRzXCIpO1xuICB9LFxuICBhc3luYyBsb2FkKHVybCwgYXNzZXQsIGxvYWRlcikge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2V0dGluZ3MuQURBUFRFUi5mZXRjaCh1cmwpO1xuICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICBjb25zdCByZXNvdXJjZXMgPSBwYXJzZUREUyhhcnJheUJ1ZmZlcik7XG4gICAgY29uc3QgdGV4dHVyZXMgPSByZXNvdXJjZXMubWFwKChyZXNvdXJjZSkgPT4ge1xuICAgICAgY29uc3QgYmFzZSA9IG5ldyBCYXNlVGV4dHVyZShyZXNvdXJjZSwge1xuICAgICAgICBtaXBtYXA6IE1JUE1BUF9NT0RFUy5PRkYsXG4gICAgICAgIGFscGhhTW9kZTogQUxQSEFfTU9ERVMuTk9fUFJFTVVMVElQTElFRF9BTFBIQSxcbiAgICAgICAgcmVzb2x1dGlvbjogdXRpbHMuZ2V0UmVzb2x1dGlvbk9mVXJsKHVybCksXG4gICAgICAgIC4uLmFzc2V0LmRhdGFcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNyZWF0ZVRleHR1cmUoYmFzZSwgbG9hZGVyLCB1cmwpO1xuICAgIH0pO1xuICAgIHJldHVybiB0ZXh0dXJlcy5sZW5ndGggPT09IDEgPyB0ZXh0dXJlc1swXSA6IHRleHR1cmVzO1xuICB9LFxuICB1bmxvYWQodGV4dHVyZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRleHR1cmUpKSB7XG4gICAgICB0ZXh0dXJlLmZvckVhY2goKHQpID0+IHQuZGVzdHJveSh0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRleHR1cmUuZGVzdHJveSh0cnVlKTtcbiAgICB9XG4gIH1cbn07XG5leHRlbnNpb25zLmFkZChsb2FkRERTKTtcblxuZXhwb3J0IHsgbG9hZEREUyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZEREUy5tanMubWFwXG4iLCJpbXBvcnQgeyBMb2FkZXJQYXJzZXJQcmlvcml0eSwgY2hlY2tFeHRlbnNpb24sIGNyZWF0ZVRleHR1cmUgfSBmcm9tICdAcGl4aS9hc3NldHMnO1xuaW1wb3J0IHsgRXh0ZW5zaW9uVHlwZSwgc2V0dGluZ3MsIE1JUE1BUF9NT0RFUywgQUxQSEFfTU9ERVMsIHV0aWxzLCBCYXNlVGV4dHVyZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0ICcuLi9wYXJzZXJzL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBwYXJzZUtUWCB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2VLVFgubWpzJztcblxuY29uc3QgbG9hZEtUWCA9IHtcbiAgZXh0ZW5zaW9uOiB7XG4gICAgdHlwZTogRXh0ZW5zaW9uVHlwZS5Mb2FkUGFyc2VyLFxuICAgIHByaW9yaXR5OiBMb2FkZXJQYXJzZXJQcmlvcml0eS5IaWdoXG4gIH0sXG4gIG5hbWU6IFwibG9hZEtUWFwiLFxuICB0ZXN0KHVybCkge1xuICAgIHJldHVybiBjaGVja0V4dGVuc2lvbih1cmwsIFwiLmt0eFwiKTtcbiAgfSxcbiAgYXN5bmMgbG9hZCh1cmwsIGFzc2V0LCBsb2FkZXIpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNldHRpbmdzLkFEQVBURVIuZmV0Y2godXJsKTtcbiAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgY29uc3QgeyBjb21wcmVzc2VkLCB1bmNvbXByZXNzZWQsIGt2RGF0YSB9ID0gcGFyc2VLVFgodXJsLCBhcnJheUJ1ZmZlcik7XG4gICAgY29uc3QgcmVzb3VyY2VzID0gY29tcHJlc3NlZCA/PyB1bmNvbXByZXNzZWQ7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIG1pcG1hcDogTUlQTUFQX01PREVTLk9GRixcbiAgICAgIGFscGhhTW9kZTogQUxQSEFfTU9ERVMuTk9fUFJFTVVMVElQTElFRF9BTFBIQSxcbiAgICAgIHJlc29sdXRpb246IHV0aWxzLmdldFJlc29sdXRpb25PZlVybCh1cmwpLFxuICAgICAgLi4uYXNzZXQuZGF0YVxuICAgIH07XG4gICAgY29uc3QgdGV4dHVyZXMgPSByZXNvdXJjZXMubWFwKChyZXNvdXJjZSkgPT4ge1xuICAgICAgaWYgKHJlc291cmNlcyA9PT0gdW5jb21wcmVzc2VkKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywge1xuICAgICAgICAgIHR5cGU6IHJlc291cmNlLnR5cGUsXG4gICAgICAgICAgZm9ybWF0OiByZXNvdXJjZS5mb3JtYXRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBiYXNlID0gbmV3IEJhc2VUZXh0dXJlKHJlc291cmNlLCBvcHRpb25zKTtcbiAgICAgIGJhc2Uua3R4S2V5VmFsdWVEYXRhID0ga3ZEYXRhO1xuICAgICAgcmV0dXJuIGNyZWF0ZVRleHR1cmUoYmFzZSwgbG9hZGVyLCB1cmwpO1xuICAgIH0pO1xuICAgIHJldHVybiB0ZXh0dXJlcy5sZW5ndGggPT09IDEgPyB0ZXh0dXJlc1swXSA6IHRleHR1cmVzO1xuICB9LFxuICB1bmxvYWQodGV4dHVyZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRleHR1cmUpKSB7XG4gICAgICB0ZXh0dXJlLmZvckVhY2goKHQpID0+IHQuZGVzdHJveSh0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRleHR1cmUuZGVzdHJveSh0cnVlKTtcbiAgICB9XG4gIH1cbn07XG5leHRlbnNpb25zLmFkZChsb2FkS1RYKTtcblxuZXhwb3J0IHsgbG9hZEtUWCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZEtUWC5tanMubWFwXG4iLCJpbXBvcnQgeyBFeHRlbnNpb25UeXBlLCBzZXR0aW5ncywgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuXG5jb25zdCByZXNvbHZlQ29tcHJlc3NlZFRleHR1cmVVcmwgPSB7XG4gIGV4dGVuc2lvbjogRXh0ZW5zaW9uVHlwZS5SZXNvbHZlUGFyc2VyLFxuICB0ZXN0OiAodmFsdWUpID0+IHtcbiAgICBjb25zdCB0ZW1wID0gdmFsdWUuc3BsaXQoXCI/XCIpWzBdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRlbXAuc3BsaXQoXCIuXCIpLnBvcCgpO1xuICAgIHJldHVybiBbXCJiYXNpc1wiLCBcImt0eFwiLCBcImRkc1wiXS5pbmNsdWRlcyhleHRlbnNpb24pO1xuICB9LFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgdGVtcCA9IHZhbHVlLnNwbGl0KFwiP1wiKVswXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSB0ZW1wLnNwbGl0KFwiLlwiKS5wb3AoKTtcbiAgICBpZiAoZXh0ZW5zaW9uID09PSBcImt0eFwiKSB7XG4gICAgICBjb25zdCBleHRlbnNpb25zMiA9IFtcbiAgICAgICAgXCIuczN0Yy5rdHhcIixcbiAgICAgICAgXCIuczN0Y19zUkdCLmt0eFwiLFxuICAgICAgICBcIi5ldGMua3R4XCIsXG4gICAgICAgIFwiLmV0YzEua3R4XCIsXG4gICAgICAgIFwiLnB2cnQua3R4XCIsXG4gICAgICAgIFwiLmF0Yy5rdHhcIixcbiAgICAgICAgXCIuYXN0Yy5rdHhcIlxuICAgICAgXTtcbiAgICAgIGlmIChleHRlbnNpb25zMi5zb21lKChleHQpID0+IHZhbHVlLmVuZHNXaXRoKGV4dCkpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzb2x1dGlvbjogcGFyc2VGbG9hdChzZXR0aW5ncy5SRVRJTkFfUFJFRklYLmV4ZWModmFsdWUpPy5bMV0gPz8gXCIxXCIpLFxuICAgICAgICAgIGZvcm1hdDogZXh0ZW5zaW9uczIuZmluZCgoZXh0KSA9PiB2YWx1ZS5lbmRzV2l0aChleHQpKSxcbiAgICAgICAgICBzcmM6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZXNvbHV0aW9uOiBwYXJzZUZsb2F0KHNldHRpbmdzLlJFVElOQV9QUkVGSVguZXhlYyh2YWx1ZSk/LlsxXSA/PyBcIjFcIiksXG4gICAgICBmb3JtYXQ6IHZhbHVlLnNwbGl0KFwiLlwiKS5wb3AoKSxcbiAgICAgIHNyYzogdmFsdWVcbiAgICB9O1xuICB9XG59O1xuZXh0ZW5zaW9ucy5hZGQocmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsKTtcblxuZXhwb3J0IHsgcmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlQ29tcHJlc3NlZFRleHR1cmVVcmwubWpzLm1hcFxuIiwiaW1wb3J0ICcuL2NvbXByZXNzZWRUZXh0dXJlRXh0ZW5zaW9ucy5tanMnO1xuZXhwb3J0IHsgZGV0ZWN0Q29tcHJlc3NlZFRleHR1cmVzIH0gZnJvbSAnLi9kZXRlY3RDb21wcmVzc2VkVGV4dHVyZXMubWpzJztcbmV4cG9ydCB7IGxvYWRERFMgfSBmcm9tICcuL2xvYWRERFMubWpzJztcbmV4cG9ydCB7IGxvYWRLVFggfSBmcm9tICcuL2xvYWRLVFgubWpzJztcbmV4cG9ydCB7IHJlc29sdmVDb21wcmVzc2VkVGV4dHVyZVVybCB9IGZyb20gJy4vcmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJleHBvcnQgeyBJTlRFUk5BTF9GT1JNQVRTLCBJTlRFUk5BTF9GT1JNQVRfVE9fQllURVNfUEVSX1BJWEVMIH0gZnJvbSAnLi9jb25zdC5tanMnO1xuaW1wb3J0ICcuL2xvYWRlcnMvaW5kZXgubWpzJztcbmltcG9ydCAnLi9wYXJzZXJzL2luZGV4Lm1qcyc7XG5pbXBvcnQgJy4vcmVzb3VyY2VzL2luZGV4Lm1qcyc7XG5leHBvcnQgeyBkZXRlY3RDb21wcmVzc2VkVGV4dHVyZXMgfSBmcm9tICcuL2xvYWRlcnMvZGV0ZWN0Q29tcHJlc3NlZFRleHR1cmVzLm1qcyc7XG5leHBvcnQgeyBsb2FkRERTIH0gZnJvbSAnLi9sb2FkZXJzL2xvYWRERFMubWpzJztcbmV4cG9ydCB7IGxvYWRLVFggfSBmcm9tICcuL2xvYWRlcnMvbG9hZEtUWC5tanMnO1xuZXhwb3J0IHsgcmVzb2x2ZUNvbXByZXNzZWRUZXh0dXJlVXJsIH0gZnJvbSAnLi9sb2FkZXJzL3Jlc29sdmVDb21wcmVzc2VkVGV4dHVyZVVybC5tanMnO1xuZXhwb3J0IHsgcGFyc2VERFMgfSBmcm9tICcuL3BhcnNlcnMvcGFyc2VERFMubWpzJztcbmV4cG9ydCB7IEZPUk1BVFNfVE9fQ09NUE9ORU5UUywgVFlQRVNfVE9fQllURVNfUEVSX0NPTVBPTkVOVCwgVFlQRVNfVE9fQllURVNfUEVSX1BJWEVMLCBwYXJzZUtUWCB9IGZyb20gJy4vcGFyc2Vycy9wYXJzZUtUWC5tanMnO1xuZXhwb3J0IHsgQmxvYlJlc291cmNlIH0gZnJvbSAnLi9yZXNvdXJjZXMvQmxvYlJlc291cmNlLm1qcyc7XG5leHBvcnQgeyBDb21wcmVzc2VkVGV4dHVyZVJlc291cmNlIH0gZnJvbSAnLi9yZXNvdXJjZXMvQ29tcHJlc3NlZFRleHR1cmVSZXNvdXJjZS5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgUmVjdGFuZ2xlLCB1dGlscywgUmVuZGVyVGV4dHVyZSwgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuXG5jb25zdCBURU1QX1JFQ1QgPSBuZXcgUmVjdGFuZ2xlKCk7XG5jb25zdCBCWVRFU19QRVJfUElYRUwgPSA0O1xuY29uc3QgX0V4dHJhY3QgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB9XG4gIGFzeW5jIGltYWdlKHRhcmdldCwgZm9ybWF0LCBxdWFsaXR5KSB7XG4gICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWFnZS5zcmMgPSBhd2FpdCB0aGlzLmJhc2U2NCh0YXJnZXQsIGZvcm1hdCwgcXVhbGl0eSk7XG4gICAgcmV0dXJuIGltYWdlO1xuICB9XG4gIGFzeW5jIGJhc2U2NCh0YXJnZXQsIGZvcm1hdCwgcXVhbGl0eSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzKHRhcmdldCk7XG4gICAgaWYgKGNhbnZhcy50b0Jsb2IgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY2FudmFzLnRvQmxvYigoYmxvYikgPT4ge1xuICAgICAgICAgIGlmICghYmxvYikge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIklDYW52YXMudG9CbG9iIGZhaWxlZCFcIikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICAgICAgICB9LCBmb3JtYXQsIHF1YWxpdHkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChjYW52YXMudG9EYXRhVVJMICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKGZvcm1hdCwgcXVhbGl0eSk7XG4gICAgfVxuICAgIGlmIChjYW52YXMuY29udmVydFRvQmxvYiAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBibG9iID0gYXdhaXQgY2FudmFzLmNvbnZlcnRUb0Jsb2IoeyB0eXBlOiBmb3JtYXQsIHF1YWxpdHkgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4gcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkV4dHJhY3QuYmFzZTY0KCkgcmVxdWlyZXMgSUNhbnZhcy50b0RhdGFVUkwsIElDYW52YXMudG9CbG9iLCBvciBJQ2FudmFzLmNvbnZlcnRUb0Jsb2IgdG8gYmUgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgY2FudmFzKHRhcmdldCwgZnJhbWUpIHtcbiAgICBjb25zdCB7IHBpeGVscywgd2lkdGgsIGhlaWdodCwgZmxpcFkgfSA9IHRoaXMuX3Jhd1BpeGVscyh0YXJnZXQsIGZyYW1lKTtcbiAgICBpZiAoZmxpcFkpIHtcbiAgICAgIF9FeHRyYWN0Ll9mbGlwWShwaXhlbHMsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICBfRXh0cmFjdC5fdW5wcmVtdWx0aXBseUFscGhhKHBpeGVscyk7XG4gICAgY29uc3QgY2FudmFzQnVmZmVyID0gbmV3IHV0aWxzLkNhbnZhc1JlbmRlclRhcmdldCh3aWR0aCwgaGVpZ2h0LCAxKTtcbiAgICBjb25zdCBpbWFnZURhdGEgPSBuZXcgSW1hZ2VEYXRhKG5ldyBVaW50OENsYW1wZWRBcnJheShwaXhlbHMuYnVmZmVyKSwgd2lkdGgsIGhlaWdodCk7XG4gICAgY2FudmFzQnVmZmVyLmNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgcmV0dXJuIGNhbnZhc0J1ZmZlci5jYW52YXM7XG4gIH1cbiAgcGl4ZWxzKHRhcmdldCwgZnJhbWUpIHtcbiAgICBjb25zdCB7IHBpeGVscywgd2lkdGgsIGhlaWdodCwgZmxpcFkgfSA9IHRoaXMuX3Jhd1BpeGVscyh0YXJnZXQsIGZyYW1lKTtcbiAgICBpZiAoZmxpcFkpIHtcbiAgICAgIF9FeHRyYWN0Ll9mbGlwWShwaXhlbHMsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICBfRXh0cmFjdC5fdW5wcmVtdWx0aXBseUFscGhhKHBpeGVscyk7XG4gICAgcmV0dXJuIHBpeGVscztcbiAgfVxuICBfcmF3UGl4ZWxzKHRhcmdldCwgZnJhbWUpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgaWYgKCFyZW5kZXJlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIEV4dHJhY3QgaGFzIGFscmVhZHkgYmVlbiBkZXN0cm95ZWRcIik7XG4gICAgfVxuICAgIGxldCByZXNvbHV0aW9uO1xuICAgIGxldCBmbGlwWSA9IGZhbHNlO1xuICAgIGxldCByZW5kZXJUZXh0dXJlO1xuICAgIGxldCBnZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgUmVuZGVyVGV4dHVyZSkge1xuICAgICAgICByZW5kZXJUZXh0dXJlID0gdGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyVGV4dHVyZSA9IHJlbmRlcmVyLmdlbmVyYXRlVGV4dHVyZSh0YXJnZXQsIHtcbiAgICAgICAgICByZXNvbHV0aW9uOiByZW5kZXJlci5yZXNvbHV0aW9uLFxuICAgICAgICAgIG11bHRpc2FtcGxlOiByZW5kZXJlci5tdWx0aXNhbXBsZVxuICAgICAgICB9KTtcbiAgICAgICAgZ2VuZXJhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlbmRlclRleHR1cmUpIHtcbiAgICAgIHJlc29sdXRpb24gPSByZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlLnJlc29sdXRpb247XG4gICAgICBmcmFtZSA9IGZyYW1lID8/IHJlbmRlclRleHR1cmUuZnJhbWU7XG4gICAgICBmbGlwWSA9IGZhbHNlO1xuICAgICAgaWYgKCFnZW5lcmF0ZWQpIHtcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5iaW5kKHJlbmRlclRleHR1cmUpO1xuICAgICAgICBjb25zdCBmYm8gPSByZW5kZXJUZXh0dXJlLmZyYW1lYnVmZmVyLmdsRnJhbWVidWZmZXJzW3JlbmRlcmVyLkNPTlRFWFRfVUlEXTtcbiAgICAgICAgaWYgKGZiby5ibGl0RnJhbWVidWZmZXIpIHtcbiAgICAgICAgICByZW5kZXJlci5mcmFtZWJ1ZmZlci5iaW5kKGZiby5ibGl0RnJhbWVidWZmZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgICAgaWYgKCFmcmFtZSkge1xuICAgICAgICBmcmFtZSA9IFRFTVBfUkVDVDtcbiAgICAgICAgZnJhbWUud2lkdGggPSByZW5kZXJlci53aWR0aCAvIHJlc29sdXRpb247XG4gICAgICAgIGZyYW1lLmhlaWdodCA9IHJlbmRlcmVyLmhlaWdodCAvIHJlc29sdXRpb247XG4gICAgICB9XG4gICAgICBmbGlwWSA9IHRydWU7XG4gICAgICByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmJpbmQoKTtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLnJvdW5kKGZyYW1lLndpZHRoICogcmVzb2x1dGlvbik7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5yb3VuZChmcmFtZS5oZWlnaHQgKiByZXNvbHV0aW9uKTtcbiAgICBjb25zdCBwaXhlbHMgPSBuZXcgVWludDhBcnJheShCWVRFU19QRVJfUElYRUwgKiB3aWR0aCAqIGhlaWdodCk7XG4gICAgY29uc3QgZ2wgPSByZW5kZXJlci5nbDtcbiAgICBnbC5yZWFkUGl4ZWxzKE1hdGgucm91bmQoZnJhbWUueCAqIHJlc29sdXRpb24pLCBNYXRoLnJvdW5kKGZyYW1lLnkgKiByZXNvbHV0aW9uKSwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcGl4ZWxzKTtcbiAgICBpZiAoZ2VuZXJhdGVkKSB7XG4gICAgICByZW5kZXJUZXh0dXJlPy5kZXN0cm95KHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4geyBwaXhlbHMsIHdpZHRoLCBoZWlnaHQsIGZsaXBZIH07XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgX2ZsaXBZKHBpeGVscywgd2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHcgPSB3aWR0aCA8PCAyO1xuICAgIGNvbnN0IGggPSBoZWlnaHQgPj4gMTtcbiAgICBjb25zdCB0ZW1wID0gbmV3IFVpbnQ4QXJyYXkodyk7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoOyB5KyspIHtcbiAgICAgIGNvbnN0IHQgPSB5ICogdztcbiAgICAgIGNvbnN0IGIgPSAoaGVpZ2h0IC0geSAtIDEpICogdztcbiAgICAgIHRlbXAuc2V0KHBpeGVscy5zdWJhcnJheSh0LCB0ICsgdykpO1xuICAgICAgcGl4ZWxzLmNvcHlXaXRoaW4odCwgYiwgYiArIHcpO1xuICAgICAgcGl4ZWxzLnNldCh0ZW1wLCBiKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIF91bnByZW11bHRpcGx5QWxwaGEocGl4ZWxzKSB7XG4gICAgaWYgKHBpeGVscyBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB7XG4gICAgICBwaXhlbHMgPSBuZXcgVWludDhBcnJheShwaXhlbHMuYnVmZmVyKTtcbiAgICB9XG4gICAgY29uc3QgbiA9IHBpeGVscy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpICs9IDQpIHtcbiAgICAgIGNvbnN0IGFscGhhID0gcGl4ZWxzW2kgKyAzXTtcbiAgICAgIGlmIChhbHBoYSAhPT0gMCkge1xuICAgICAgICBjb25zdCBhID0gMjU1LjAwMSAvIGFscGhhO1xuICAgICAgICBwaXhlbHNbaV0gPSBwaXhlbHNbaV0gKiBhICsgMC41O1xuICAgICAgICBwaXhlbHNbaSArIDFdID0gcGl4ZWxzW2kgKyAxXSAqIGEgKyAwLjU7XG4gICAgICAgIHBpeGVsc1tpICsgMl0gPSBwaXhlbHNbaSArIDJdICogYSArIDAuNTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5sZXQgRXh0cmFjdCA9IF9FeHRyYWN0O1xuRXh0cmFjdC5leHRlbnNpb24gPSB7XG4gIG5hbWU6IFwiZXh0cmFjdFwiLFxuICB0eXBlOiBFeHRlbnNpb25UeXBlLlJlbmRlcmVyU3lzdGVtXG59O1xuZXh0ZW5zaW9ucy5hZGQoRXh0cmFjdCk7XG5cbmV4cG9ydCB7IEV4dHJhY3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV4dHJhY3QubWpzLm1hcFxuIiwiZXhwb3J0IHsgRXh0cmFjdCB9IGZyb20gJy4vRXh0cmFjdC5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgU0hBUEVTIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmNvbnN0IGJ1aWxkQ2lyY2xlID0ge1xuICBidWlsZChncmFwaGljc0RhdGEpIHtcbiAgICBjb25zdCBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xuICAgIGxldCB4O1xuICAgIGxldCB5O1xuICAgIGxldCBkeDtcbiAgICBsZXQgZHk7XG4gICAgbGV0IHJ4O1xuICAgIGxldCByeTtcbiAgICBpZiAoZ3JhcGhpY3NEYXRhLnR5cGUgPT09IFNIQVBFUy5DSVJDKSB7XG4gICAgICBjb25zdCBjaXJjbGUgPSBncmFwaGljc0RhdGEuc2hhcGU7XG4gICAgICB4ID0gY2lyY2xlLng7XG4gICAgICB5ID0gY2lyY2xlLnk7XG4gICAgICByeCA9IHJ5ID0gY2lyY2xlLnJhZGl1cztcbiAgICAgIGR4ID0gZHkgPSAwO1xuICAgIH0gZWxzZSBpZiAoZ3JhcGhpY3NEYXRhLnR5cGUgPT09IFNIQVBFUy5FTElQKSB7XG4gICAgICBjb25zdCBlbGxpcHNlID0gZ3JhcGhpY3NEYXRhLnNoYXBlO1xuICAgICAgeCA9IGVsbGlwc2UueDtcbiAgICAgIHkgPSBlbGxpcHNlLnk7XG4gICAgICByeCA9IGVsbGlwc2Uud2lkdGg7XG4gICAgICByeSA9IGVsbGlwc2UuaGVpZ2h0O1xuICAgICAgZHggPSBkeSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJvdW5kZWRSZWN0ID0gZ3JhcGhpY3NEYXRhLnNoYXBlO1xuICAgICAgY29uc3QgaGFsZldpZHRoID0gcm91bmRlZFJlY3Qud2lkdGggLyAyO1xuICAgICAgY29uc3QgaGFsZkhlaWdodCA9IHJvdW5kZWRSZWN0LmhlaWdodCAvIDI7XG4gICAgICB4ID0gcm91bmRlZFJlY3QueCArIGhhbGZXaWR0aDtcbiAgICAgIHkgPSByb3VuZGVkUmVjdC55ICsgaGFsZkhlaWdodDtcbiAgICAgIHJ4ID0gcnkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyb3VuZGVkUmVjdC5yYWRpdXMsIE1hdGgubWluKGhhbGZXaWR0aCwgaGFsZkhlaWdodCkpKTtcbiAgICAgIGR4ID0gaGFsZldpZHRoIC0gcng7XG4gICAgICBkeSA9IGhhbGZIZWlnaHQgLSByeTtcbiAgICB9XG4gICAgaWYgKCEocnggPj0gMCAmJiByeSA+PSAwICYmIGR4ID49IDAgJiYgZHkgPj0gMCkpIHtcbiAgICAgIHBvaW50cy5sZW5ndGggPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuID0gTWF0aC5jZWlsKDIuMyAqIE1hdGguc3FydChyeCArIHJ5KSk7XG4gICAgY29uc3QgbSA9IG4gKiA4ICsgKGR4ID8gNCA6IDApICsgKGR5ID8gNCA6IDApO1xuICAgIHBvaW50cy5sZW5ndGggPSBtO1xuICAgIGlmIChtID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBwb2ludHMubGVuZ3RoID0gODtcbiAgICAgIHBvaW50c1swXSA9IHBvaW50c1s2XSA9IHggKyBkeDtcbiAgICAgIHBvaW50c1sxXSA9IHBvaW50c1szXSA9IHkgKyBkeTtcbiAgICAgIHBvaW50c1syXSA9IHBvaW50c1s0XSA9IHggLSBkeDtcbiAgICAgIHBvaW50c1s1XSA9IHBvaW50c1s3XSA9IHkgLSBkeTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGoxID0gMDtcbiAgICBsZXQgajIgPSBuICogNCArIChkeCA/IDIgOiAwKSArIDI7XG4gICAgbGV0IGozID0gajI7XG4gICAgbGV0IGo0ID0gbTtcbiAgICB7XG4gICAgICBjb25zdCB4MCA9IGR4ICsgcng7XG4gICAgICBjb25zdCB5MCA9IGR5O1xuICAgICAgY29uc3QgeDEgPSB4ICsgeDA7XG4gICAgICBjb25zdCB4MiA9IHggLSB4MDtcbiAgICAgIGNvbnN0IHkxID0geSArIHkwO1xuICAgICAgcG9pbnRzW2oxKytdID0geDE7XG4gICAgICBwb2ludHNbajErK10gPSB5MTtcbiAgICAgIHBvaW50c1stLWoyXSA9IHkxO1xuICAgICAgcG9pbnRzWy0tajJdID0geDI7XG4gICAgICBpZiAoZHkpIHtcbiAgICAgICAgY29uc3QgeTIgPSB5IC0geTA7XG4gICAgICAgIHBvaW50c1tqMysrXSA9IHgyO1xuICAgICAgICBwb2ludHNbajMrK10gPSB5MjtcbiAgICAgICAgcG9pbnRzWy0tajRdID0geTI7XG4gICAgICAgIHBvaW50c1stLWo0XSA9IHgxO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgY29uc3QgYSA9IE1hdGguUEkgLyAyICogKGkgLyBuKTtcbiAgICAgIGNvbnN0IHgwID0gZHggKyBNYXRoLmNvcyhhKSAqIHJ4O1xuICAgICAgY29uc3QgeTAgPSBkeSArIE1hdGguc2luKGEpICogcnk7XG4gICAgICBjb25zdCB4MSA9IHggKyB4MDtcbiAgICAgIGNvbnN0IHgyID0geCAtIHgwO1xuICAgICAgY29uc3QgeTEgPSB5ICsgeTA7XG4gICAgICBjb25zdCB5MiA9IHkgLSB5MDtcbiAgICAgIHBvaW50c1tqMSsrXSA9IHgxO1xuICAgICAgcG9pbnRzW2oxKytdID0geTE7XG4gICAgICBwb2ludHNbLS1qMl0gPSB5MTtcbiAgICAgIHBvaW50c1stLWoyXSA9IHgyO1xuICAgICAgcG9pbnRzW2ozKytdID0geDI7XG4gICAgICBwb2ludHNbajMrK10gPSB5MjtcbiAgICAgIHBvaW50c1stLWo0XSA9IHkyO1xuICAgICAgcG9pbnRzWy0tajRdID0geDE7XG4gICAgfVxuICAgIHtcbiAgICAgIGNvbnN0IHgwID0gZHg7XG4gICAgICBjb25zdCB5MCA9IGR5ICsgcnk7XG4gICAgICBjb25zdCB4MSA9IHggKyB4MDtcbiAgICAgIGNvbnN0IHgyID0geCAtIHgwO1xuICAgICAgY29uc3QgeTEgPSB5ICsgeTA7XG4gICAgICBjb25zdCB5MiA9IHkgLSB5MDtcbiAgICAgIHBvaW50c1tqMSsrXSA9IHgxO1xuICAgICAgcG9pbnRzW2oxKytdID0geTE7XG4gICAgICBwb2ludHNbLS1qNF0gPSB5MjtcbiAgICAgIHBvaW50c1stLWo0XSA9IHgxO1xuICAgICAgaWYgKGR4KSB7XG4gICAgICAgIHBvaW50c1tqMSsrXSA9IHgyO1xuICAgICAgICBwb2ludHNbajErK10gPSB5MTtcbiAgICAgICAgcG9pbnRzWy0tajRdID0geTI7XG4gICAgICAgIHBvaW50c1stLWo0XSA9IHgyO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgdHJpYW5ndWxhdGUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KSB7XG4gICAgY29uc3QgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcbiAgICBjb25zdCB2ZXJ0cyA9IGdyYXBoaWNzR2VvbWV0cnkucG9pbnRzO1xuICAgIGNvbnN0IGluZGljZXMgPSBncmFwaGljc0dlb21ldHJ5LmluZGljZXM7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHZlcnRQb3MgPSB2ZXJ0cy5sZW5ndGggLyAyO1xuICAgIGNvbnN0IGNlbnRlciA9IHZlcnRQb3M7XG4gICAgbGV0IHg7XG4gICAgbGV0IHk7XG4gICAgaWYgKGdyYXBoaWNzRGF0YS50eXBlICE9PSBTSEFQRVMuUlJFQykge1xuICAgICAgY29uc3QgY2lyY2xlID0gZ3JhcGhpY3NEYXRhLnNoYXBlO1xuICAgICAgeCA9IGNpcmNsZS54O1xuICAgICAgeSA9IGNpcmNsZS55O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByb3VuZGVkUmVjdCA9IGdyYXBoaWNzRGF0YS5zaGFwZTtcbiAgICAgIHggPSByb3VuZGVkUmVjdC54ICsgcm91bmRlZFJlY3Qud2lkdGggLyAyO1xuICAgICAgeSA9IHJvdW5kZWRSZWN0LnkgKyByb3VuZGVkUmVjdC5oZWlnaHQgLyAyO1xuICAgIH1cbiAgICBjb25zdCBtYXRyaXggPSBncmFwaGljc0RhdGEubWF0cml4O1xuICAgIHZlcnRzLnB1c2goZ3JhcGhpY3NEYXRhLm1hdHJpeCA/IG1hdHJpeC5hICogeCArIG1hdHJpeC5jICogeSArIG1hdHJpeC50eCA6IHgsIGdyYXBoaWNzRGF0YS5tYXRyaXggPyBtYXRyaXguYiAqIHggKyBtYXRyaXguZCAqIHkgKyBtYXRyaXgudHkgOiB5KTtcbiAgICB2ZXJ0UG9zKys7XG4gICAgdmVydHMucHVzaChwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgZm9yIChsZXQgaSA9IDI7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHZlcnRzLnB1c2gocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKTtcbiAgICAgIGluZGljZXMucHVzaCh2ZXJ0UG9zKyssIGNlbnRlciwgdmVydFBvcyk7XG4gICAgfVxuICAgIGluZGljZXMucHVzaChjZW50ZXIgKyAxLCBjZW50ZXIsIHZlcnRQb3MpO1xuICB9XG59O1xuXG5leHBvcnQgeyBidWlsZENpcmNsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRDaXJjbGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgdXRpbHMgfSBmcm9tICdAcGl4aS9jb3JlJztcblxuZnVuY3Rpb24gZml4T3JpZW50YXRpb24ocG9pbnRzLCBob2xlID0gZmFsc2UpIHtcbiAgY29uc3QgbSA9IHBvaW50cy5sZW5ndGg7XG4gIGlmIChtIDwgNikge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgYXJlYSA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCB4MSA9IHBvaW50c1ttIC0gMl0sIHkxID0gcG9pbnRzW20gLSAxXTsgaSA8IG07IGkgKz0gMikge1xuICAgIGNvbnN0IHgyID0gcG9pbnRzW2ldO1xuICAgIGNvbnN0IHkyID0gcG9pbnRzW2kgKyAxXTtcbiAgICBhcmVhICs9ICh4MiAtIHgxKSAqICh5MiArIHkxKTtcbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gIH1cbiAgaWYgKCFob2xlICYmIGFyZWEgPiAwIHx8IGhvbGUgJiYgYXJlYSA8PSAwKSB7XG4gICAgY29uc3QgbiA9IG0gLyAyO1xuICAgIGZvciAobGV0IGkgPSBuICsgbiAlIDI7IGkgPCBtOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IGkxID0gbSAtIGkgLSAyO1xuICAgICAgY29uc3QgaTIgPSBtIC0gaSAtIDE7XG4gICAgICBjb25zdCBpMyA9IGk7XG4gICAgICBjb25zdCBpNCA9IGkgKyAxO1xuICAgICAgW3BvaW50c1tpMV0sIHBvaW50c1tpM11dID0gW3BvaW50c1tpM10sIHBvaW50c1tpMV1dO1xuICAgICAgW3BvaW50c1tpMl0sIHBvaW50c1tpNF1dID0gW3BvaW50c1tpNF0sIHBvaW50c1tpMl1dO1xuICAgIH1cbiAgfVxufVxuY29uc3QgYnVpbGRQb2x5ID0ge1xuICBidWlsZChncmFwaGljc0RhdGEpIHtcbiAgICBncmFwaGljc0RhdGEucG9pbnRzID0gZ3JhcGhpY3NEYXRhLnNoYXBlLnBvaW50cy5zbGljZSgpO1xuICB9LFxuICB0cmlhbmd1bGF0ZShncmFwaGljc0RhdGEsIGdyYXBoaWNzR2VvbWV0cnkpIHtcbiAgICBsZXQgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcbiAgICBjb25zdCBob2xlcyA9IGdyYXBoaWNzRGF0YS5ob2xlcztcbiAgICBjb25zdCB2ZXJ0cyA9IGdyYXBoaWNzR2VvbWV0cnkucG9pbnRzO1xuICAgIGNvbnN0IGluZGljZXMgPSBncmFwaGljc0dlb21ldHJ5LmluZGljZXM7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPj0gNikge1xuICAgICAgZml4T3JpZW50YXRpb24ocG9pbnRzLCBmYWxzZSk7XG4gICAgICBjb25zdCBob2xlQXJyYXkgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaG9sZSA9IGhvbGVzW2ldO1xuICAgICAgICBmaXhPcmllbnRhdGlvbihob2xlLnBvaW50cywgdHJ1ZSk7XG4gICAgICAgIGhvbGVBcnJheS5wdXNoKHBvaW50cy5sZW5ndGggLyAyKTtcbiAgICAgICAgcG9pbnRzID0gcG9pbnRzLmNvbmNhdChob2xlLnBvaW50cyk7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmlhbmdsZXMgPSB1dGlscy5lYXJjdXQocG9pbnRzLCBob2xlQXJyYXksIDIpO1xuICAgICAgaWYgKCF0cmlhbmdsZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdmVydFBvcyA9IHZlcnRzLmxlbmd0aCAvIDI7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2ldICsgdmVydFBvcyk7XG4gICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSArIDFdICsgdmVydFBvcyk7XG4gICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSArIDJdICsgdmVydFBvcyk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2ZXJ0cy5wdXNoKHBvaW50c1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgeyBidWlsZFBvbHkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkUG9seS5tanMubWFwXG4iLCJjb25zdCBidWlsZFJlY3RhbmdsZSA9IHtcbiAgYnVpbGQoZ3JhcGhpY3NEYXRhKSB7XG4gICAgY29uc3QgcmVjdERhdGEgPSBncmFwaGljc0RhdGEuc2hhcGU7XG4gICAgY29uc3QgeCA9IHJlY3REYXRhLng7XG4gICAgY29uc3QgeSA9IHJlY3REYXRhLnk7XG4gICAgY29uc3Qgd2lkdGggPSByZWN0RGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSByZWN0RGF0YS5oZWlnaHQ7XG4gICAgY29uc3QgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcbiAgICBwb2ludHMubGVuZ3RoID0gMDtcbiAgICBpZiAoISh3aWR0aCA+PSAwICYmIGhlaWdodCA+PSAwKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwb2ludHMucHVzaCh4LCB5LCB4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCk7XG4gIH0sXG4gIHRyaWFuZ3VsYXRlKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSkge1xuICAgIGNvbnN0IHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG4gICAgY29uc3QgdmVydHMgPSBncmFwaGljc0dlb21ldHJ5LnBvaW50cztcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2ZXJ0UG9zID0gdmVydHMubGVuZ3RoIC8gMjtcbiAgICB2ZXJ0cy5wdXNoKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgcG9pbnRzWzZdLCBwb2ludHNbN10sIHBvaW50c1s0XSwgcG9pbnRzWzVdKTtcbiAgICBncmFwaGljc0dlb21ldHJ5LmluZGljZXMucHVzaCh2ZXJ0UG9zLCB2ZXJ0UG9zICsgMSwgdmVydFBvcyArIDIsIHZlcnRQb3MgKyAxLCB2ZXJ0UG9zICsgMiwgdmVydFBvcyArIDMpO1xuICB9XG59O1xuXG5leHBvcnQgeyBidWlsZFJlY3RhbmdsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRSZWN0YW5nbGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgYnVpbGRDaXJjbGUgfSBmcm9tICcuL2J1aWxkQ2lyY2xlLm1qcyc7XG5cbmNvbnN0IGJ1aWxkUm91bmRlZFJlY3RhbmdsZSA9IHtcbiAgYnVpbGQoZ3JhcGhpY3NEYXRhKSB7XG4gICAgYnVpbGRDaXJjbGUuYnVpbGQoZ3JhcGhpY3NEYXRhKTtcbiAgfSxcbiAgdHJpYW5ndWxhdGUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KSB7XG4gICAgYnVpbGRDaXJjbGUudHJpYW5ndWxhdGUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KTtcbiAgfVxufTtcblxuZXhwb3J0IHsgYnVpbGRSb3VuZGVkUmVjdGFuZ2xlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZFJvdW5kZWRSZWN0YW5nbGUubWpzLm1hcFxuIiwidmFyIExJTkVfSk9JTiA9IC8qIEBfX1BVUkVfXyAqLyAoKExJTkVfSk9JTjIpID0+IHtcbiAgTElORV9KT0lOMltcIk1JVEVSXCJdID0gXCJtaXRlclwiO1xuICBMSU5FX0pPSU4yW1wiQkVWRUxcIl0gPSBcImJldmVsXCI7XG4gIExJTkVfSk9JTjJbXCJST1VORFwiXSA9IFwicm91bmRcIjtcbiAgcmV0dXJuIExJTkVfSk9JTjI7XG59KShMSU5FX0pPSU4gfHwge30pO1xudmFyIExJTkVfQ0FQID0gLyogQF9fUFVSRV9fICovICgoTElORV9DQVAyKSA9PiB7XG4gIExJTkVfQ0FQMltcIkJVVFRcIl0gPSBcImJ1dHRcIjtcbiAgTElORV9DQVAyW1wiUk9VTkRcIl0gPSBcInJvdW5kXCI7XG4gIExJTkVfQ0FQMltcIlNRVUFSRVwiXSA9IFwic3F1YXJlXCI7XG4gIHJldHVybiBMSU5FX0NBUDI7XG59KShMSU5FX0NBUCB8fCB7fSk7XG5jb25zdCBjdXJ2ZXMgPSB7XG4gIGFkYXB0aXZlOiB0cnVlLFxuICBtYXhMZW5ndGg6IDEwLFxuICBtaW5TZWdtZW50czogOCxcbiAgbWF4U2VnbWVudHM6IDIwNDgsXG4gIGVwc2lsb246IDFlLTQsXG4gIF9zZWdtZW50c0NvdW50KGxlbmd0aCwgZGVmYXVsdFNlZ21lbnRzID0gMjApIHtcbiAgICBpZiAoIXRoaXMuYWRhcHRpdmUgfHwgIWxlbmd0aCB8fCBpc05hTihsZW5ndGgpKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFNlZ21lbnRzO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gTWF0aC5jZWlsKGxlbmd0aCAvIHRoaXMubWF4TGVuZ3RoKTtcbiAgICBpZiAocmVzdWx0IDwgdGhpcy5taW5TZWdtZW50cykge1xuICAgICAgcmVzdWx0ID0gdGhpcy5taW5TZWdtZW50cztcbiAgICB9IGVsc2UgaWYgKHJlc3VsdCA+IHRoaXMubWF4U2VnbWVudHMpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMubWF4U2VnbWVudHM7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5jb25zdCBHUkFQSElDU19DVVJWRVMgPSBjdXJ2ZXM7XG5cbmV4cG9ydCB7IEdSQVBISUNTX0NVUlZFUywgTElORV9DQVAsIExJTkVfSk9JTiwgY3VydmVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5tanMubWFwXG4iLCJpbXBvcnQgeyBQSV8yIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBjdXJ2ZXMgfSBmcm9tICcuLi9jb25zdC5tanMnO1xuXG5jbGFzcyBBcmNVdGlscyB7XG4gIHN0YXRpYyBjdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMsIHBvaW50cykge1xuICAgIGNvbnN0IGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXTtcbiAgICBjb25zdCBmcm9tWSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgYTEgPSBmcm9tWSAtIHkxO1xuICAgIGNvbnN0IGIxID0gZnJvbVggLSB4MTtcbiAgICBjb25zdCBhMiA9IHkyIC0geTE7XG4gICAgY29uc3QgYjIgPSB4MiAtIHgxO1xuICAgIGNvbnN0IG1tID0gTWF0aC5hYnMoYTEgKiBiMiAtIGIxICogYTIpO1xuICAgIGlmIChtbSA8IDFlLTggfHwgcmFkaXVzID09PSAwKSB7XG4gICAgICBpZiAocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSAhPT0geDEgfHwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSAhPT0geTEpIHtcbiAgICAgICAgcG9pbnRzLnB1c2goeDEsIHkxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkZCA9IGExICogYTEgKyBiMSAqIGIxO1xuICAgIGNvbnN0IGNjID0gYTIgKiBhMiArIGIyICogYjI7XG4gICAgY29uc3QgdHQgPSBhMSAqIGEyICsgYjEgKiBiMjtcbiAgICBjb25zdCBrMSA9IHJhZGl1cyAqIE1hdGguc3FydChkZCkgLyBtbTtcbiAgICBjb25zdCBrMiA9IHJhZGl1cyAqIE1hdGguc3FydChjYykgLyBtbTtcbiAgICBjb25zdCBqMSA9IGsxICogdHQgLyBkZDtcbiAgICBjb25zdCBqMiA9IGsyICogdHQgLyBjYztcbiAgICBjb25zdCBjeCA9IGsxICogYjIgKyBrMiAqIGIxO1xuICAgIGNvbnN0IGN5ID0gazEgKiBhMiArIGsyICogYTE7XG4gICAgY29uc3QgcHggPSBiMSAqIChrMiArIGoxKTtcbiAgICBjb25zdCBweSA9IGExICogKGsyICsgajEpO1xuICAgIGNvbnN0IHF4ID0gYjIgKiAoazEgKyBqMik7XG4gICAgY29uc3QgcXkgPSBhMiAqIChrMSArIGoyKTtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gTWF0aC5hdGFuMihweSAtIGN5LCBweCAtIGN4KTtcbiAgICBjb25zdCBlbmRBbmdsZSA9IE1hdGguYXRhbjIocXkgLSBjeSwgcXggLSBjeCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN4OiBjeCArIHgxLFxuICAgICAgY3k6IGN5ICsgeTEsXG4gICAgICByYWRpdXMsXG4gICAgICBzdGFydEFuZ2xlLFxuICAgICAgZW5kQW5nbGUsXG4gICAgICBhbnRpY2xvY2t3aXNlOiBiMSAqIGEyID4gYjIgKiBhMVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGFyYyhfc3RhcnRYLCBfc3RhcnRZLCBjeCwgY3ksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIF9hbnRpY2xvY2t3aXNlLCBwb2ludHMpIHtcbiAgICBjb25zdCBzd2VlcCA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZTtcbiAgICBjb25zdCBuID0gY3VydmVzLl9zZWdtZW50c0NvdW50KE1hdGguYWJzKHN3ZWVwKSAqIHJhZGl1cywgTWF0aC5jZWlsKE1hdGguYWJzKHN3ZWVwKSAvIFBJXzIpICogNDApO1xuICAgIGNvbnN0IHRoZXRhID0gc3dlZXAgLyAobiAqIDIpO1xuICAgIGNvbnN0IHRoZXRhMiA9IHRoZXRhICogMjtcbiAgICBjb25zdCBjVGhldGEgPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgY29uc3Qgc1RoZXRhID0gTWF0aC5zaW4odGhldGEpO1xuICAgIGNvbnN0IHNlZ01pbnVzID0gbiAtIDE7XG4gICAgY29uc3QgcmVtYWluZGVyID0gc2VnTWludXMgJSAxIC8gc2VnTWludXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gc2VnTWludXM7ICsraSkge1xuICAgICAgY29uc3QgcmVhbCA9IGkgKyByZW1haW5kZXIgKiBpO1xuICAgICAgY29uc3QgYW5nbGUgPSB0aGV0YSArIHN0YXJ0QW5nbGUgKyB0aGV0YTIgKiByZWFsO1xuICAgICAgY29uc3QgYyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgIGNvbnN0IHMgPSAtTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgcG9pbnRzLnB1c2goKGNUaGV0YSAqIGMgKyBzVGhldGEgKiBzKSAqIHJhZGl1cyArIGN4LCAoY1RoZXRhICogLXMgKyBzVGhldGEgKiBjKSAqIHJhZGl1cyArIGN5KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgQXJjVXRpbHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFyY1V0aWxzLm1qcy5tYXBcbiIsImltcG9ydCB7IGN1cnZlcyB9IGZyb20gJy4uL2NvbnN0Lm1qcyc7XG5cbmNsYXNzIEJlemllclV0aWxzIHtcbiAgc3RhdGljIGN1cnZlTGVuZ3RoKGZyb21YLCBmcm9tWSwgY3BYLCBjcFksIGNwWDIsIGNwWTIsIHRvWCwgdG9ZKSB7XG4gICAgY29uc3QgbiA9IDEwO1xuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIGxldCB0ID0gMDtcbiAgICBsZXQgdDIgPSAwO1xuICAgIGxldCB0MyA9IDA7XG4gICAgbGV0IG50ID0gMDtcbiAgICBsZXQgbnQyID0gMDtcbiAgICBsZXQgbnQzID0gMDtcbiAgICBsZXQgeCA9IDA7XG4gICAgbGV0IHkgPSAwO1xuICAgIGxldCBkeCA9IDA7XG4gICAgbGV0IGR5ID0gMDtcbiAgICBsZXQgcHJldlggPSBmcm9tWDtcbiAgICBsZXQgcHJldlkgPSBmcm9tWTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBuOyArK2kpIHtcbiAgICAgIHQgPSBpIC8gbjtcbiAgICAgIHQyID0gdCAqIHQ7XG4gICAgICB0MyA9IHQyICogdDtcbiAgICAgIG50ID0gMSAtIHQ7XG4gICAgICBudDIgPSBudCAqIG50O1xuICAgICAgbnQzID0gbnQyICogbnQ7XG4gICAgICB4ID0gbnQzICogZnJvbVggKyAzICogbnQyICogdCAqIGNwWCArIDMgKiBudCAqIHQyICogY3BYMiArIHQzICogdG9YO1xuICAgICAgeSA9IG50MyAqIGZyb21ZICsgMyAqIG50MiAqIHQgKiBjcFkgKyAzICogbnQgKiB0MiAqIGNwWTIgKyB0MyAqIHRvWTtcbiAgICAgIGR4ID0gcHJldlggLSB4O1xuICAgICAgZHkgPSBwcmV2WSAtIHk7XG4gICAgICBwcmV2WCA9IHg7XG4gICAgICBwcmV2WSA9IHk7XG4gICAgICByZXN1bHQgKz0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzdGF0aWMgY3VydmVUbyhjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1ksIHBvaW50cykge1xuICAgIGNvbnN0IGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXTtcbiAgICBjb25zdCBmcm9tWSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG4gICAgcG9pbnRzLmxlbmd0aCAtPSAyO1xuICAgIGNvbnN0IG4gPSBjdXJ2ZXMuX3NlZ21lbnRzQ291bnQoQmV6aWVyVXRpbHMuY3VydmVMZW5ndGgoZnJvbVgsIGZyb21ZLCBjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1kpKTtcbiAgICBsZXQgZHQgPSAwO1xuICAgIGxldCBkdDIgPSAwO1xuICAgIGxldCBkdDMgPSAwO1xuICAgIGxldCB0MiA9IDA7XG4gICAgbGV0IHQzID0gMDtcbiAgICBwb2ludHMucHVzaChmcm9tWCwgZnJvbVkpO1xuICAgIGZvciAobGV0IGkgPSAxLCBqID0gMDsgaSA8PSBuOyArK2kpIHtcbiAgICAgIGogPSBpIC8gbjtcbiAgICAgIGR0ID0gMSAtIGo7XG4gICAgICBkdDIgPSBkdCAqIGR0O1xuICAgICAgZHQzID0gZHQyICogZHQ7XG4gICAgICB0MiA9IGogKiBqO1xuICAgICAgdDMgPSB0MiAqIGo7XG4gICAgICBwb2ludHMucHVzaChkdDMgKiBmcm9tWCArIDMgKiBkdDIgKiBqICogY3BYICsgMyAqIGR0ICogdDIgKiBjcFgyICsgdDMgKiB0b1gsIGR0MyAqIGZyb21ZICsgMyAqIGR0MiAqIGogKiBjcFkgKyAzICogZHQgKiB0MiAqIGNwWTIgKyB0MyAqIHRvWSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IEJlemllclV0aWxzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CZXppZXJVdGlscy5tanMubWFwXG4iLCJpbXBvcnQgeyBQb2ludCwgU0hBUEVTIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBMSU5FX0NBUCwgTElORV9KT0lOLCBjdXJ2ZXMgfSBmcm9tICcuLi9jb25zdC5tanMnO1xuXG5mdW5jdGlvbiBzcXVhcmUoeCwgeSwgbngsIG55LCBpbm5lcldlaWdodCwgb3V0ZXJXZWlnaHQsIGNsb2Nrd2lzZSwgdmVydHMpIHtcbiAgY29uc3QgaXggPSB4IC0gbnggKiBpbm5lcldlaWdodDtcbiAgY29uc3QgaXkgPSB5IC0gbnkgKiBpbm5lcldlaWdodDtcbiAgY29uc3Qgb3ggPSB4ICsgbnggKiBvdXRlcldlaWdodDtcbiAgY29uc3Qgb3kgPSB5ICsgbnkgKiBvdXRlcldlaWdodDtcbiAgbGV0IGV4eDtcbiAgbGV0IGV5eTtcbiAgaWYgKGNsb2Nrd2lzZSkge1xuICAgIGV4eCA9IG55O1xuICAgIGV5eSA9IC1ueDtcbiAgfSBlbHNlIHtcbiAgICBleHggPSAtbnk7XG4gICAgZXl5ID0gbng7XG4gIH1cbiAgY29uc3QgZWl4ID0gaXggKyBleHg7XG4gIGNvbnN0IGVpeSA9IGl5ICsgZXl5O1xuICBjb25zdCBlb3ggPSBveCArIGV4eDtcbiAgY29uc3QgZW95ID0gb3kgKyBleXk7XG4gIHZlcnRzLnB1c2goZWl4LCBlaXksIGVveCwgZW95KTtcbiAgcmV0dXJuIDI7XG59XG5mdW5jdGlvbiByb3VuZChjeCwgY3ksIHN4LCBzeSwgZXgsIGV5LCB2ZXJ0cywgY2xvY2t3aXNlKSB7XG4gIGNvbnN0IGN4MnAweCA9IHN4IC0gY3g7XG4gIGNvbnN0IGN5MnAweSA9IHN5IC0gY3k7XG4gIGxldCBhbmdsZTAgPSBNYXRoLmF0YW4yKGN4MnAweCwgY3kycDB5KTtcbiAgbGV0IGFuZ2xlMSA9IE1hdGguYXRhbjIoZXggLSBjeCwgZXkgLSBjeSk7XG4gIGlmIChjbG9ja3dpc2UgJiYgYW5nbGUwIDwgYW5nbGUxKSB7XG4gICAgYW5nbGUwICs9IE1hdGguUEkgKiAyO1xuICB9IGVsc2UgaWYgKCFjbG9ja3dpc2UgJiYgYW5nbGUwID4gYW5nbGUxKSB7XG4gICAgYW5nbGUxICs9IE1hdGguUEkgKiAyO1xuICB9XG4gIGxldCBzdGFydEFuZ2xlID0gYW5nbGUwO1xuICBjb25zdCBhbmdsZURpZmYgPSBhbmdsZTEgLSBhbmdsZTA7XG4gIGNvbnN0IGFic0FuZ2xlRGlmZiA9IE1hdGguYWJzKGFuZ2xlRGlmZik7XG4gIGNvbnN0IHJhZGl1cyA9IE1hdGguc3FydChjeDJwMHggKiBjeDJwMHggKyBjeTJwMHkgKiBjeTJwMHkpO1xuICBjb25zdCBzZWdDb3VudCA9ICgxNSAqIGFic0FuZ2xlRGlmZiAqIE1hdGguc3FydChyYWRpdXMpIC8gTWF0aC5QSSA+PiAwKSArIDE7XG4gIGNvbnN0IGFuZ2xlSW5jID0gYW5nbGVEaWZmIC8gc2VnQ291bnQ7XG4gIHN0YXJ0QW5nbGUgKz0gYW5nbGVJbmM7XG4gIGlmIChjbG9ja3dpc2UpIHtcbiAgICB2ZXJ0cy5wdXNoKGN4LCBjeSwgc3gsIHN5KTtcbiAgICBmb3IgKGxldCBpID0gMSwgYW5nbGUgPSBzdGFydEFuZ2xlOyBpIDwgc2VnQ291bnQ7IGkrKywgYW5nbGUgKz0gYW5nbGVJbmMpIHtcbiAgICAgIHZlcnRzLnB1c2goY3gsIGN5LCBjeCArIE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cywgY3kgKyBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMpO1xuICAgIH1cbiAgICB2ZXJ0cy5wdXNoKGN4LCBjeSwgZXgsIGV5KTtcbiAgfSBlbHNlIHtcbiAgICB2ZXJ0cy5wdXNoKHN4LCBzeSwgY3gsIGN5KTtcbiAgICBmb3IgKGxldCBpID0gMSwgYW5nbGUgPSBzdGFydEFuZ2xlOyBpIDwgc2VnQ291bnQ7IGkrKywgYW5nbGUgKz0gYW5nbGVJbmMpIHtcbiAgICAgIHZlcnRzLnB1c2goY3ggKyBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMsIGN5ICsgTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzLCBjeCwgY3kpO1xuICAgIH1cbiAgICB2ZXJ0cy5wdXNoKGV4LCBleSwgY3gsIGN5KTtcbiAgfVxuICByZXR1cm4gc2VnQ291bnQgKiAyO1xufVxuZnVuY3Rpb24gYnVpbGROb25OYXRpdmVMaW5lKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSkge1xuICBjb25zdCBzaGFwZSA9IGdyYXBoaWNzRGF0YS5zaGFwZTtcbiAgbGV0IHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHMgfHwgc2hhcGUucG9pbnRzLnNsaWNlKCk7XG4gIGNvbnN0IGVwcyA9IGdyYXBoaWNzR2VvbWV0cnkuY2xvc2VQb2ludEVwcztcbiAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc3R5bGUgPSBncmFwaGljc0RhdGEubGluZVN0eWxlO1xuICBjb25zdCBmaXJzdFBvaW50ID0gbmV3IFBvaW50KHBvaW50c1swXSwgcG9pbnRzWzFdKTtcbiAgY29uc3QgbGFzdFBvaW50ID0gbmV3IFBvaW50KHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0sIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pO1xuICBjb25zdCBjbG9zZWRTaGFwZSA9IHNoYXBlLnR5cGUgIT09IFNIQVBFUy5QT0xZIHx8IHNoYXBlLmNsb3NlU3Ryb2tlO1xuICBjb25zdCBjbG9zZWRQYXRoID0gTWF0aC5hYnMoZmlyc3RQb2ludC54IC0gbGFzdFBvaW50LngpIDwgZXBzICYmIE1hdGguYWJzKGZpcnN0UG9pbnQueSAtIGxhc3RQb2ludC55KSA8IGVwcztcbiAgaWYgKGNsb3NlZFNoYXBlKSB7XG4gICAgcG9pbnRzID0gcG9pbnRzLnNsaWNlKCk7XG4gICAgaWYgKGNsb3NlZFBhdGgpIHtcbiAgICAgIHBvaW50cy5wb3AoKTtcbiAgICAgIHBvaW50cy5wb3AoKTtcbiAgICAgIGxhc3RQb2ludC5zZXQocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSk7XG4gICAgfVxuICAgIGNvbnN0IG1pZFBvaW50WCA9IChmaXJzdFBvaW50LnggKyBsYXN0UG9pbnQueCkgKiAwLjU7XG4gICAgY29uc3QgbWlkUG9pbnRZID0gKGxhc3RQb2ludC55ICsgZmlyc3RQb2ludC55KSAqIDAuNTtcbiAgICBwb2ludHMudW5zaGlmdChtaWRQb2ludFgsIG1pZFBvaW50WSk7XG4gICAgcG9pbnRzLnB1c2gobWlkUG9pbnRYLCBtaWRQb2ludFkpO1xuICB9XG4gIGNvbnN0IHZlcnRzID0gZ3JhcGhpY3NHZW9tZXRyeS5wb2ludHM7XG4gIGNvbnN0IGxlbmd0aCA9IHBvaW50cy5sZW5ndGggLyAyO1xuICBsZXQgaW5kZXhDb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IGluZGV4U3RhcnQgPSB2ZXJ0cy5sZW5ndGggLyAyO1xuICBjb25zdCB3aWR0aCA9IHN0eWxlLndpZHRoIC8gMjtcbiAgY29uc3Qgd2lkdGhTcXVhcmVkID0gd2lkdGggKiB3aWR0aDtcbiAgY29uc3QgbWl0ZXJMaW1pdFNxdWFyZWQgPSBzdHlsZS5taXRlckxpbWl0ICogc3R5bGUubWl0ZXJMaW1pdDtcbiAgbGV0IHgwID0gcG9pbnRzWzBdO1xuICBsZXQgeTAgPSBwb2ludHNbMV07XG4gIGxldCB4MSA9IHBvaW50c1syXTtcbiAgbGV0IHkxID0gcG9pbnRzWzNdO1xuICBsZXQgeDIgPSAwO1xuICBsZXQgeTIgPSAwO1xuICBsZXQgcGVycHggPSAtKHkwIC0geTEpO1xuICBsZXQgcGVycHkgPSB4MCAtIHgxO1xuICBsZXQgcGVycDF4ID0gMDtcbiAgbGV0IHBlcnAxeSA9IDA7XG4gIGxldCBkaXN0ID0gTWF0aC5zcXJ0KHBlcnB4ICogcGVycHggKyBwZXJweSAqIHBlcnB5KTtcbiAgcGVycHggLz0gZGlzdDtcbiAgcGVycHkgLz0gZGlzdDtcbiAgcGVycHggKj0gd2lkdGg7XG4gIHBlcnB5ICo9IHdpZHRoO1xuICBjb25zdCByYXRpbyA9IHN0eWxlLmFsaWdubWVudDtcbiAgY29uc3QgaW5uZXJXZWlnaHQgPSAoMSAtIHJhdGlvKSAqIDI7XG4gIGNvbnN0IG91dGVyV2VpZ2h0ID0gcmF0aW8gKiAyO1xuICBpZiAoIWNsb3NlZFNoYXBlKSB7XG4gICAgaWYgKHN0eWxlLmNhcCA9PT0gTElORV9DQVAuUk9VTkQpIHtcbiAgICAgIGluZGV4Q291bnQgKz0gcm91bmQoeDAgLSBwZXJweCAqIChpbm5lcldlaWdodCAtIG91dGVyV2VpZ2h0KSAqIDAuNSwgeTAgLSBwZXJweSAqIChpbm5lcldlaWdodCAtIG91dGVyV2VpZ2h0KSAqIDAuNSwgeDAgLSBwZXJweCAqIGlubmVyV2VpZ2h0LCB5MCAtIHBlcnB5ICogaW5uZXJXZWlnaHQsIHgwICsgcGVycHggKiBvdXRlcldlaWdodCwgeTAgKyBwZXJweSAqIG91dGVyV2VpZ2h0LCB2ZXJ0cywgdHJ1ZSkgKyAyO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUuY2FwID09PSBMSU5FX0NBUC5TUVVBUkUpIHtcbiAgICAgIGluZGV4Q291bnQgKz0gc3F1YXJlKHgwLCB5MCwgcGVycHgsIHBlcnB5LCBpbm5lcldlaWdodCwgb3V0ZXJXZWlnaHQsIHRydWUsIHZlcnRzKTtcbiAgICB9XG4gIH1cbiAgdmVydHMucHVzaCh4MCAtIHBlcnB4ICogaW5uZXJXZWlnaHQsIHkwIC0gcGVycHkgKiBpbm5lcldlaWdodCwgeDAgKyBwZXJweCAqIG91dGVyV2VpZ2h0LCB5MCArIHBlcnB5ICogb3V0ZXJXZWlnaHQpO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aCAtIDE7ICsraSkge1xuICAgIHgwID0gcG9pbnRzWyhpIC0gMSkgKiAyXTtcbiAgICB5MCA9IHBvaW50c1soaSAtIDEpICogMiArIDFdO1xuICAgIHgxID0gcG9pbnRzW2kgKiAyXTtcbiAgICB5MSA9IHBvaW50c1tpICogMiArIDFdO1xuICAgIHgyID0gcG9pbnRzWyhpICsgMSkgKiAyXTtcbiAgICB5MiA9IHBvaW50c1soaSArIDEpICogMiArIDFdO1xuICAgIHBlcnB4ID0gLSh5MCAtIHkxKTtcbiAgICBwZXJweSA9IHgwIC0geDE7XG4gICAgZGlzdCA9IE1hdGguc3FydChwZXJweCAqIHBlcnB4ICsgcGVycHkgKiBwZXJweSk7XG4gICAgcGVycHggLz0gZGlzdDtcbiAgICBwZXJweSAvPSBkaXN0O1xuICAgIHBlcnB4ICo9IHdpZHRoO1xuICAgIHBlcnB5ICo9IHdpZHRoO1xuICAgIHBlcnAxeCA9IC0oeTEgLSB5Mik7XG4gICAgcGVycDF5ID0geDEgLSB4MjtcbiAgICBkaXN0ID0gTWF0aC5zcXJ0KHBlcnAxeCAqIHBlcnAxeCArIHBlcnAxeSAqIHBlcnAxeSk7XG4gICAgcGVycDF4IC89IGRpc3Q7XG4gICAgcGVycDF5IC89IGRpc3Q7XG4gICAgcGVycDF4ICo9IHdpZHRoO1xuICAgIHBlcnAxeSAqPSB3aWR0aDtcbiAgICBjb25zdCBkeDAgPSB4MSAtIHgwO1xuICAgIGNvbnN0IGR5MCA9IHkwIC0geTE7XG4gICAgY29uc3QgZHgxID0geDEgLSB4MjtcbiAgICBjb25zdCBkeTEgPSB5MiAtIHkxO1xuICAgIGNvbnN0IGRvdCA9IGR4MCAqIGR4MSArIGR5MCAqIGR5MTtcbiAgICBjb25zdCBjcm9zcyA9IGR5MCAqIGR4MSAtIGR5MSAqIGR4MDtcbiAgICBjb25zdCBjbG9ja3dpc2UgPSBjcm9zcyA8IDA7XG4gICAgaWYgKE1hdGguYWJzKGNyb3NzKSA8IDFlLTMgKiBNYXRoLmFicyhkb3QpKSB7XG4gICAgICB2ZXJ0cy5wdXNoKHgxIC0gcGVycHggKiBpbm5lcldlaWdodCwgeTEgLSBwZXJweSAqIGlubmVyV2VpZ2h0LCB4MSArIHBlcnB4ICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycHkgKiBvdXRlcldlaWdodCk7XG4gICAgICBpZiAoZG90ID49IDApIHtcbiAgICAgICAgaWYgKHN0eWxlLmpvaW4gPT09IExJTkVfSk9JTi5ST1VORCkge1xuICAgICAgICAgIGluZGV4Q291bnQgKz0gcm91bmQoeDEsIHkxLCB4MSAtIHBlcnB4ICogaW5uZXJXZWlnaHQsIHkxIC0gcGVycHkgKiBpbm5lcldlaWdodCwgeDEgLSBwZXJwMXggKiBpbm5lcldlaWdodCwgeTEgLSBwZXJwMXkgKiBpbm5lcldlaWdodCwgdmVydHMsIGZhbHNlKSArIDQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZXhDb3VudCArPSAyO1xuICAgICAgICB9XG4gICAgICAgIHZlcnRzLnB1c2goeDEgLSBwZXJwMXggKiBvdXRlcldlaWdodCwgeTEgLSBwZXJwMXkgKiBvdXRlcldlaWdodCwgeDEgKyBwZXJwMXggKiBpbm5lcldlaWdodCwgeTEgKyBwZXJwMXkgKiBpbm5lcldlaWdodCk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgYzEgPSAoLXBlcnB4ICsgeDApICogKC1wZXJweSArIHkxKSAtICgtcGVycHggKyB4MSkgKiAoLXBlcnB5ICsgeTApO1xuICAgIGNvbnN0IGMyID0gKC1wZXJwMXggKyB4MikgKiAoLXBlcnAxeSArIHkxKSAtICgtcGVycDF4ICsgeDEpICogKC1wZXJwMXkgKyB5Mik7XG4gICAgY29uc3QgcHggPSAoZHgwICogYzIgLSBkeDEgKiBjMSkgLyBjcm9zcztcbiAgICBjb25zdCBweSA9IChkeTEgKiBjMSAtIGR5MCAqIGMyKSAvIGNyb3NzO1xuICAgIGNvbnN0IHBkaXN0ID0gKHB4IC0geDEpICogKHB4IC0geDEpICsgKHB5IC0geTEpICogKHB5IC0geTEpO1xuICAgIGNvbnN0IGlteCA9IHgxICsgKHB4IC0geDEpICogaW5uZXJXZWlnaHQ7XG4gICAgY29uc3QgaW15ID0geTEgKyAocHkgLSB5MSkgKiBpbm5lcldlaWdodDtcbiAgICBjb25zdCBvbXggPSB4MSAtIChweCAtIHgxKSAqIG91dGVyV2VpZ2h0O1xuICAgIGNvbnN0IG9teSA9IHkxIC0gKHB5IC0geTEpICogb3V0ZXJXZWlnaHQ7XG4gICAgY29uc3Qgc21hbGxlckluc2lkZVNlZ21lbnRTcSA9IE1hdGgubWluKGR4MCAqIGR4MCArIGR5MCAqIGR5MCwgZHgxICogZHgxICsgZHkxICogZHkxKTtcbiAgICBjb25zdCBpbnNpZGVXZWlnaHQgPSBjbG9ja3dpc2UgPyBpbm5lcldlaWdodCA6IG91dGVyV2VpZ2h0O1xuICAgIGNvbnN0IHNtYWxsZXJJbnNpZGVEaWFnb25hbFNxID0gc21hbGxlckluc2lkZVNlZ21lbnRTcSArIGluc2lkZVdlaWdodCAqIGluc2lkZVdlaWdodCAqIHdpZHRoU3F1YXJlZDtcbiAgICBjb25zdCBpbnNpZGVNaXRlck9rID0gcGRpc3QgPD0gc21hbGxlckluc2lkZURpYWdvbmFsU3E7XG4gICAgbGV0IGpvaW4gPSBzdHlsZS5qb2luO1xuICAgIGlmIChqb2luID09PSBMSU5FX0pPSU4uTUlURVIgJiYgcGRpc3QgLyB3aWR0aFNxdWFyZWQgPiBtaXRlckxpbWl0U3F1YXJlZCkge1xuICAgICAgam9pbiA9IExJTkVfSk9JTi5CRVZFTDtcbiAgICB9XG4gICAgaWYgKGluc2lkZU1pdGVyT2spIHtcbiAgICAgIHN3aXRjaCAoam9pbikge1xuICAgICAgICBjYXNlIExJTkVfSk9JTi5NSVRFUjoge1xuICAgICAgICAgIHZlcnRzLnB1c2goaW14LCBpbXksIG9teCwgb215KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIExJTkVfSk9JTi5CRVZFTDoge1xuICAgICAgICAgIGlmIChjbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIHZlcnRzLnB1c2goaW14LCBpbXksIHgxICsgcGVycHggKiBvdXRlcldlaWdodCwgeTEgKyBwZXJweSAqIG91dGVyV2VpZ2h0LCBpbXgsIGlteSwgeDEgKyBwZXJwMXggKiBvdXRlcldlaWdodCwgeTEgKyBwZXJwMXkgKiBvdXRlcldlaWdodCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZlcnRzLnB1c2goeDEgLSBwZXJweCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnB5ICogaW5uZXJXZWlnaHQsIG9teCwgb215LCB4MSAtIHBlcnAxeCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnAxeSAqIGlubmVyV2VpZ2h0LCBvbXgsIG9teSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluZGV4Q291bnQgKz0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIExJTkVfSk9JTi5ST1VORDoge1xuICAgICAgICAgIGlmIChjbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIHZlcnRzLnB1c2goaW14LCBpbXksIHgxICsgcGVycHggKiBvdXRlcldlaWdodCwgeTEgKyBwZXJweSAqIG91dGVyV2VpZ2h0KTtcbiAgICAgICAgICAgIGluZGV4Q291bnQgKz0gcm91bmQoeDEsIHkxLCB4MSArIHBlcnB4ICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycHkgKiBvdXRlcldlaWdodCwgeDEgKyBwZXJwMXggKiBvdXRlcldlaWdodCwgeTEgKyBwZXJwMXkgKiBvdXRlcldlaWdodCwgdmVydHMsIHRydWUpICsgNDtcbiAgICAgICAgICAgIHZlcnRzLnB1c2goaW14LCBpbXksIHgxICsgcGVycDF4ICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycDF5ICogb3V0ZXJXZWlnaHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHgxIC0gcGVycHggKiBpbm5lcldlaWdodCwgeTEgLSBwZXJweSAqIGlubmVyV2VpZ2h0LCBvbXgsIG9teSk7XG4gICAgICAgICAgICBpbmRleENvdW50ICs9IHJvdW5kKHgxLCB5MSwgeDEgLSBwZXJweCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnB5ICogaW5uZXJXZWlnaHQsIHgxIC0gcGVycDF4ICogaW5uZXJXZWlnaHQsIHkxIC0gcGVycDF5ICogaW5uZXJXZWlnaHQsIHZlcnRzLCBmYWxzZSkgKyA0O1xuICAgICAgICAgICAgdmVydHMucHVzaCh4MSAtIHBlcnAxeCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnAxeSAqIGlubmVyV2VpZ2h0LCBvbXgsIG9teSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZlcnRzLnB1c2goeDEgLSBwZXJweCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnB5ICogaW5uZXJXZWlnaHQsIHgxICsgcGVycHggKiBvdXRlcldlaWdodCwgeTEgKyBwZXJweSAqIG91dGVyV2VpZ2h0KTtcbiAgICAgIHN3aXRjaCAoam9pbikge1xuICAgICAgICBjYXNlIExJTkVfSk9JTi5NSVRFUjoge1xuICAgICAgICAgIGlmIChjbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gob214LCBvbXksIG9teCwgb215KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmVydHMucHVzaChpbXgsIGlteSwgaW14LCBpbXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbmRleENvdW50ICs9IDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBMSU5FX0pPSU4uUk9VTkQ6IHtcbiAgICAgICAgICBpZiAoY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICBpbmRleENvdW50ICs9IHJvdW5kKHgxLCB5MSwgeDEgKyBwZXJweCAqIG91dGVyV2VpZ2h0LCB5MSArIHBlcnB5ICogb3V0ZXJXZWlnaHQsIHgxICsgcGVycDF4ICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycDF5ICogb3V0ZXJXZWlnaHQsIHZlcnRzLCB0cnVlKSArIDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4Q291bnQgKz0gcm91bmQoeDEsIHkxLCB4MSAtIHBlcnB4ICogaW5uZXJXZWlnaHQsIHkxIC0gcGVycHkgKiBpbm5lcldlaWdodCwgeDEgLSBwZXJwMXggKiBpbm5lcldlaWdodCwgeTEgLSBwZXJwMXkgKiBpbm5lcldlaWdodCwgdmVydHMsIGZhbHNlKSArIDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2ZXJ0cy5wdXNoKHgxIC0gcGVycDF4ICogaW5uZXJXZWlnaHQsIHkxIC0gcGVycDF5ICogaW5uZXJXZWlnaHQsIHgxICsgcGVycDF4ICogb3V0ZXJXZWlnaHQsIHkxICsgcGVycDF5ICogb3V0ZXJXZWlnaHQpO1xuICAgICAgaW5kZXhDb3VudCArPSAyO1xuICAgIH1cbiAgfVxuICB4MCA9IHBvaW50c1sobGVuZ3RoIC0gMikgKiAyXTtcbiAgeTAgPSBwb2ludHNbKGxlbmd0aCAtIDIpICogMiArIDFdO1xuICB4MSA9IHBvaW50c1sobGVuZ3RoIC0gMSkgKiAyXTtcbiAgeTEgPSBwb2ludHNbKGxlbmd0aCAtIDEpICogMiArIDFdO1xuICBwZXJweCA9IC0oeTAgLSB5MSk7XG4gIHBlcnB5ID0geDAgLSB4MTtcbiAgZGlzdCA9IE1hdGguc3FydChwZXJweCAqIHBlcnB4ICsgcGVycHkgKiBwZXJweSk7XG4gIHBlcnB4IC89IGRpc3Q7XG4gIHBlcnB5IC89IGRpc3Q7XG4gIHBlcnB4ICo9IHdpZHRoO1xuICBwZXJweSAqPSB3aWR0aDtcbiAgdmVydHMucHVzaCh4MSAtIHBlcnB4ICogaW5uZXJXZWlnaHQsIHkxIC0gcGVycHkgKiBpbm5lcldlaWdodCwgeDEgKyBwZXJweCAqIG91dGVyV2VpZ2h0LCB5MSArIHBlcnB5ICogb3V0ZXJXZWlnaHQpO1xuICBpZiAoIWNsb3NlZFNoYXBlKSB7XG4gICAgaWYgKHN0eWxlLmNhcCA9PT0gTElORV9DQVAuUk9VTkQpIHtcbiAgICAgIGluZGV4Q291bnQgKz0gcm91bmQoeDEgLSBwZXJweCAqIChpbm5lcldlaWdodCAtIG91dGVyV2VpZ2h0KSAqIDAuNSwgeTEgLSBwZXJweSAqIChpbm5lcldlaWdodCAtIG91dGVyV2VpZ2h0KSAqIDAuNSwgeDEgLSBwZXJweCAqIGlubmVyV2VpZ2h0LCB5MSAtIHBlcnB5ICogaW5uZXJXZWlnaHQsIHgxICsgcGVycHggKiBvdXRlcldlaWdodCwgeTEgKyBwZXJweSAqIG91dGVyV2VpZ2h0LCB2ZXJ0cywgZmFsc2UpICsgMjtcbiAgICB9IGVsc2UgaWYgKHN0eWxlLmNhcCA9PT0gTElORV9DQVAuU1FVQVJFKSB7XG4gICAgICBpbmRleENvdW50ICs9IHNxdWFyZSh4MSwgeTEsIHBlcnB4LCBwZXJweSwgaW5uZXJXZWlnaHQsIG91dGVyV2VpZ2h0LCBmYWxzZSwgdmVydHMpO1xuICAgIH1cbiAgfVxuICBjb25zdCBpbmRpY2VzID0gZ3JhcGhpY3NHZW9tZXRyeS5pbmRpY2VzO1xuICBjb25zdCBlcHMyID0gY3VydmVzLmVwc2lsb24gKiBjdXJ2ZXMuZXBzaWxvbjtcbiAgZm9yIChsZXQgaSA9IGluZGV4U3RhcnQ7IGkgPCBpbmRleENvdW50ICsgaW5kZXhTdGFydCAtIDI7ICsraSkge1xuICAgIHgwID0gdmVydHNbaSAqIDJdO1xuICAgIHkwID0gdmVydHNbaSAqIDIgKyAxXTtcbiAgICB4MSA9IHZlcnRzWyhpICsgMSkgKiAyXTtcbiAgICB5MSA9IHZlcnRzWyhpICsgMSkgKiAyICsgMV07XG4gICAgeDIgPSB2ZXJ0c1soaSArIDIpICogMl07XG4gICAgeTIgPSB2ZXJ0c1soaSArIDIpICogMiArIDFdO1xuICAgIGlmIChNYXRoLmFicyh4MCAqICh5MSAtIHkyKSArIHgxICogKHkyIC0geTApICsgeDIgKiAoeTAgLSB5MSkpIDwgZXBzMikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGluZGljZXMucHVzaChpLCBpICsgMSwgaSArIDIpO1xuICB9XG59XG5mdW5jdGlvbiBidWlsZE5hdGl2ZUxpbmUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KSB7XG4gIGxldCBpID0gMDtcbiAgY29uc3Qgc2hhcGUgPSBncmFwaGljc0RhdGEuc2hhcGU7XG4gIGNvbnN0IHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHMgfHwgc2hhcGUucG9pbnRzO1xuICBjb25zdCBjbG9zZWRTaGFwZSA9IHNoYXBlLnR5cGUgIT09IFNIQVBFUy5QT0xZIHx8IHNoYXBlLmNsb3NlU3Ryb2tlO1xuICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm47XG4gIGNvbnN0IHZlcnRzID0gZ3JhcGhpY3NHZW9tZXRyeS5wb2ludHM7XG4gIGNvbnN0IGluZGljZXMgPSBncmFwaGljc0dlb21ldHJ5LmluZGljZXM7XG4gIGNvbnN0IGxlbmd0aCA9IHBvaW50cy5sZW5ndGggLyAyO1xuICBjb25zdCBzdGFydEluZGV4ID0gdmVydHMubGVuZ3RoIC8gMjtcbiAgbGV0IGN1cnJlbnRJbmRleCA9IHN0YXJ0SW5kZXg7XG4gIHZlcnRzLnB1c2gocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2ZXJ0cy5wdXNoKHBvaW50c1tpICogMl0sIHBvaW50c1tpICogMiArIDFdKTtcbiAgICBpbmRpY2VzLnB1c2goY3VycmVudEluZGV4LCBjdXJyZW50SW5kZXggKyAxKTtcbiAgICBjdXJyZW50SW5kZXgrKztcbiAgfVxuICBpZiAoY2xvc2VkU2hhcGUpIHtcbiAgICBpbmRpY2VzLnB1c2goY3VycmVudEluZGV4LCBzdGFydEluZGV4KTtcbiAgfVxufVxuZnVuY3Rpb24gYnVpbGRMaW5lKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSkge1xuICBpZiAoZ3JhcGhpY3NEYXRhLmxpbmVTdHlsZS5uYXRpdmUpIHtcbiAgICBidWlsZE5hdGl2ZUxpbmUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KTtcbiAgfSBlbHNlIHtcbiAgICBidWlsZE5vbk5hdGl2ZUxpbmUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KTtcbiAgfVxufVxuXG5leHBvcnQgeyBidWlsZExpbmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkTGluZS5tanMubWFwXG4iLCJpbXBvcnQgeyBjdXJ2ZXMgfSBmcm9tICcuLi9jb25zdC5tanMnO1xuXG5jbGFzcyBRdWFkcmF0aWNVdGlscyB7XG4gIHN0YXRpYyBjdXJ2ZUxlbmd0aChmcm9tWCwgZnJvbVksIGNwWCwgY3BZLCB0b1gsIHRvWSkge1xuICAgIGNvbnN0IGF4ID0gZnJvbVggLSAyICogY3BYICsgdG9YO1xuICAgIGNvbnN0IGF5ID0gZnJvbVkgLSAyICogY3BZICsgdG9ZO1xuICAgIGNvbnN0IGJ4ID0gMiAqIGNwWCAtIDIgKiBmcm9tWDtcbiAgICBjb25zdCBieSA9IDIgKiBjcFkgLSAyICogZnJvbVk7XG4gICAgY29uc3QgYSA9IDQgKiAoYXggKiBheCArIGF5ICogYXkpO1xuICAgIGNvbnN0IGIgPSA0ICogKGF4ICogYnggKyBheSAqIGJ5KTtcbiAgICBjb25zdCBjID0gYnggKiBieCArIGJ5ICogYnk7XG4gICAgY29uc3QgcyA9IDIgKiBNYXRoLnNxcnQoYSArIGIgKyBjKTtcbiAgICBjb25zdCBhMiA9IE1hdGguc3FydChhKTtcbiAgICBjb25zdCBhMzIgPSAyICogYSAqIGEyO1xuICAgIGNvbnN0IGMyID0gMiAqIE1hdGguc3FydChjKTtcbiAgICBjb25zdCBiYSA9IGIgLyBhMjtcbiAgICByZXR1cm4gKGEzMiAqIHMgKyBhMiAqIGIgKiAocyAtIGMyKSArICg0ICogYyAqIGEgLSBiICogYikgKiBNYXRoLmxvZygoMiAqIGEyICsgYmEgKyBzKSAvIChiYSArIGMyKSkpIC8gKDQgKiBhMzIpO1xuICB9XG4gIHN0YXRpYyBjdXJ2ZVRvKGNwWCwgY3BZLCB0b1gsIHRvWSwgcG9pbnRzKSB7XG4gICAgY29uc3QgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdO1xuICAgIGNvbnN0IGZyb21ZID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBuID0gY3VydmVzLl9zZWdtZW50c0NvdW50KFF1YWRyYXRpY1V0aWxzLmN1cnZlTGVuZ3RoKGZyb21YLCBmcm9tWSwgY3BYLCBjcFksIHRvWCwgdG9ZKSk7XG4gICAgbGV0IHhhID0gMDtcbiAgICBsZXQgeWEgPSAwO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IG47ICsraSkge1xuICAgICAgY29uc3QgaiA9IGkgLyBuO1xuICAgICAgeGEgPSBmcm9tWCArIChjcFggLSBmcm9tWCkgKiBqO1xuICAgICAgeWEgPSBmcm9tWSArIChjcFkgLSBmcm9tWSkgKiBqO1xuICAgICAgcG9pbnRzLnB1c2goeGEgKyAoY3BYICsgKHRvWCAtIGNwWCkgKiBqIC0geGEpICogaiwgeWEgKyAoY3BZICsgKHRvWSAtIGNwWSkgKiBqIC0geWEpICogaik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IFF1YWRyYXRpY1V0aWxzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1RdWFkcmF0aWNVdGlscy5tanMubWFwXG4iLCJpbXBvcnQgeyBTSEFQRVMgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IGJ1aWxkQ2lyY2xlIH0gZnJvbSAnLi9idWlsZENpcmNsZS5tanMnO1xuZXhwb3J0IHsgYnVpbGRDaXJjbGUgfSBmcm9tICcuL2J1aWxkQ2lyY2xlLm1qcyc7XG5pbXBvcnQgeyBidWlsZFBvbHkgfSBmcm9tICcuL2J1aWxkUG9seS5tanMnO1xuZXhwb3J0IHsgYnVpbGRQb2x5IH0gZnJvbSAnLi9idWlsZFBvbHkubWpzJztcbmltcG9ydCB7IGJ1aWxkUmVjdGFuZ2xlIH0gZnJvbSAnLi9idWlsZFJlY3RhbmdsZS5tanMnO1xuZXhwb3J0IHsgYnVpbGRSZWN0YW5nbGUgfSBmcm9tICcuL2J1aWxkUmVjdGFuZ2xlLm1qcyc7XG5pbXBvcnQgeyBidWlsZFJvdW5kZWRSZWN0YW5nbGUgfSBmcm9tICcuL2J1aWxkUm91bmRlZFJlY3RhbmdsZS5tanMnO1xuZXhwb3J0IHsgYnVpbGRSb3VuZGVkUmVjdGFuZ2xlIH0gZnJvbSAnLi9idWlsZFJvdW5kZWRSZWN0YW5nbGUubWpzJztcbmV4cG9ydCB7IEFyY1V0aWxzIH0gZnJvbSAnLi9BcmNVdGlscy5tanMnO1xuZXhwb3J0IHsgQmF0Y2hQYXJ0IH0gZnJvbSAnLi9CYXRjaFBhcnQubWpzJztcbmV4cG9ydCB7IEJlemllclV0aWxzIH0gZnJvbSAnLi9CZXppZXJVdGlscy5tanMnO1xuZXhwb3J0IHsgYnVpbGRMaW5lIH0gZnJvbSAnLi9idWlsZExpbmUubWpzJztcbmV4cG9ydCB7IFF1YWRyYXRpY1V0aWxzIH0gZnJvbSAnLi9RdWFkcmF0aWNVdGlscy5tanMnO1xuXG5jb25zdCBGSUxMX0NPTU1BTkRTID0ge1xuICBbU0hBUEVTLlBPTFldOiBidWlsZFBvbHksXG4gIFtTSEFQRVMuQ0lSQ106IGJ1aWxkQ2lyY2xlLFxuICBbU0hBUEVTLkVMSVBdOiBidWlsZENpcmNsZSxcbiAgW1NIQVBFUy5SRUNUXTogYnVpbGRSZWN0YW5nbGUsXG4gIFtTSEFQRVMuUlJFQ106IGJ1aWxkUm91bmRlZFJlY3RhbmdsZVxufTtcbmNvbnN0IEJBVENIX1BPT0wgPSBbXTtcbmNvbnN0IERSQVdfQ0FMTF9QT09MID0gW107XG5cbmV4cG9ydCB7IEJBVENIX1BPT0wsIERSQVdfQ0FMTF9QT09MLCBGSUxMX0NPTU1BTkRTIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJjbGFzcyBHcmFwaGljc0RhdGEge1xuICBjb25zdHJ1Y3RvcihzaGFwZSwgZmlsbFN0eWxlID0gbnVsbCwgbGluZVN0eWxlID0gbnVsbCwgbWF0cml4ID0gbnVsbCkge1xuICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgdGhpcy5ob2xlcyA9IFtdO1xuICAgIHRoaXMuc2hhcGUgPSBzaGFwZTtcbiAgICB0aGlzLmxpbmVTdHlsZSA9IGxpbmVTdHlsZTtcbiAgICB0aGlzLmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICB0aGlzLm1hdHJpeCA9IG1hdHJpeDtcbiAgICB0aGlzLnR5cGUgPSBzaGFwZS50eXBlO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgR3JhcGhpY3NEYXRhKHRoaXMuc2hhcGUsIHRoaXMuZmlsbFN0eWxlLCB0aGlzLmxpbmVTdHlsZSwgdGhpcy5tYXRyaXgpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zaGFwZSA9IG51bGw7XG4gICAgdGhpcy5ob2xlcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuaG9sZXMgPSBudWxsO1xuICAgIHRoaXMucG9pbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5wb2ludHMgPSBudWxsO1xuICAgIHRoaXMubGluZVN0eWxlID0gbnVsbDtcbiAgICB0aGlzLmZpbGxTdHlsZSA9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHsgR3JhcGhpY3NEYXRhIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaGljc0RhdGEubWpzLm1hcFxuIiwiY2xhc3MgQmF0Y2hQYXJ0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG4gIGJlZ2luKHN0eWxlLCBzdGFydEluZGV4LCBhdHRyaWJTdGFydCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0SW5kZXg7XG4gICAgdGhpcy5hdHRyaWJTdGFydCA9IGF0dHJpYlN0YXJ0O1xuICB9XG4gIGVuZChlbmRJbmRleCwgZW5kQXR0cmliKSB7XG4gICAgdGhpcy5hdHRyaWJTaXplID0gZW5kQXR0cmliIC0gdGhpcy5hdHRyaWJTdGFydDtcbiAgICB0aGlzLnNpemUgPSBlbmRJbmRleCAtIHRoaXMuc3RhcnQ7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zdHlsZSA9IG51bGw7XG4gICAgdGhpcy5zaXplID0gMDtcbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLmF0dHJpYlN0YXJ0ID0gMDtcbiAgICB0aGlzLmF0dHJpYlNpemUgPSAwO1xuICB9XG59XG5cbmV4cG9ydCB7IEJhdGNoUGFydCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmF0Y2hQYXJ0Lm1qcy5tYXBcbiIsImltcG9ydCB7IFBvaW50LCBCYXRjaEdlb21ldHJ5LCBXUkFQX01PREVTLCBCYXNlVGV4dHVyZSwgQmF0Y2hEcmF3Q2FsbCwgQmF0Y2hUZXh0dXJlQXJyYXksIERSQVdfTU9ERVMsIENvbG9yIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBCb3VuZHMgfSBmcm9tICdAcGl4aS9kaXNwbGF5JztcbmltcG9ydCB7IEdyYXBoaWNzRGF0YSB9IGZyb20gJy4vR3JhcGhpY3NEYXRhLm1qcyc7XG5pbXBvcnQgeyBEUkFXX0NBTExfUE9PTCwgQkFUQ0hfUE9PTCwgRklMTF9DT01NQU5EUyB9IGZyb20gJy4vdXRpbHMvaW5kZXgubWpzJztcbmltcG9ydCB7IEJhdGNoUGFydCB9IGZyb20gJy4vdXRpbHMvQmF0Y2hQYXJ0Lm1qcyc7XG5pbXBvcnQgeyBidWlsZFBvbHkgfSBmcm9tICcuL3V0aWxzL2J1aWxkUG9seS5tanMnO1xuaW1wb3J0IHsgYnVpbGRMaW5lIH0gZnJvbSAnLi91dGlscy9idWlsZExpbmUubWpzJztcblxuY29uc3QgdG1wUG9pbnQgPSBuZXcgUG9pbnQoKTtcbmNvbnN0IF9HcmFwaGljc0dlb21ldHJ5ID0gY2xhc3MgZXh0ZW5kcyBCYXRjaEdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNsb3NlUG9pbnRFcHMgPSAxZS00O1xuICAgIHRoaXMuYm91bmRzUGFkZGluZyA9IDA7XG4gICAgdGhpcy51dnNGbG9hdDMyID0gbnVsbDtcbiAgICB0aGlzLmluZGljZXNVaW50MTYgPSBudWxsO1xuICAgIHRoaXMuYmF0Y2hhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgICB0aGlzLmNvbG9ycyA9IFtdO1xuICAgIHRoaXMudXZzID0gW107XG4gICAgdGhpcy5pbmRpY2VzID0gW107XG4gICAgdGhpcy50ZXh0dXJlSWRzID0gW107XG4gICAgdGhpcy5ncmFwaGljc0RhdGEgPSBbXTtcbiAgICB0aGlzLmRyYXdDYWxscyA9IFtdO1xuICAgIHRoaXMuYmF0Y2hEaXJ0eSA9IC0xO1xuICAgIHRoaXMuYmF0Y2hlcyA9IFtdO1xuICAgIHRoaXMuZGlydHkgPSAwO1xuICAgIHRoaXMuY2FjaGVEaXJ0eSA9IC0xO1xuICAgIHRoaXMuY2xlYXJEaXJ0eSA9IDA7XG4gICAgdGhpcy5zaGFwZUluZGV4ID0gMDtcbiAgICB0aGlzLl9ib3VuZHMgPSBuZXcgQm91bmRzKCk7XG4gICAgdGhpcy5ib3VuZHNEaXJ0eSA9IC0xO1xuICB9XG4gIGdldCBib3VuZHMoKSB7XG4gICAgdGhpcy51cGRhdGVCYXRjaGVzKCk7XG4gICAgaWYgKHRoaXMuYm91bmRzRGlydHkgIT09IHRoaXMuZGlydHkpIHtcbiAgICAgIHRoaXMuYm91bmRzRGlydHkgPSB0aGlzLmRpcnR5O1xuICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZHMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2JvdW5kcztcbiAgfVxuICBpbnZhbGlkYXRlKCkge1xuICAgIHRoaXMuYm91bmRzRGlydHkgPSAtMTtcbiAgICB0aGlzLmRpcnR5Kys7XG4gICAgdGhpcy5iYXRjaERpcnR5Kys7XG4gICAgdGhpcy5zaGFwZUluZGV4ID0gMDtcbiAgICB0aGlzLnBvaW50cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuY29sb3JzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy51dnMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmluZGljZXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnRleHR1cmVJZHMubGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZHJhd0NhbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmRyYXdDYWxsc1tpXS50ZXhBcnJheS5jbGVhcigpO1xuICAgICAgRFJBV19DQUxMX1BPT0wucHVzaCh0aGlzLmRyYXdDYWxsc1tpXSk7XG4gICAgfVxuICAgIHRoaXMuZHJhd0NhbGxzLmxlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGJhdGNoUGFydCA9IHRoaXMuYmF0Y2hlc1tpXTtcbiAgICAgIGJhdGNoUGFydC5yZXNldCgpO1xuICAgICAgQkFUQ0hfUE9PTC5wdXNoKGJhdGNoUGFydCk7XG4gICAgfVxuICAgIHRoaXMuYmF0Y2hlcy5sZW5ndGggPSAwO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGlmICh0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIHRoaXMuY2xlYXJEaXJ0eSsrO1xuICAgICAgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZHJhd1NoYXBlKHNoYXBlLCBmaWxsU3R5bGUgPSBudWxsLCBsaW5lU3R5bGUgPSBudWxsLCBtYXRyaXggPSBudWxsKSB7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBHcmFwaGljc0RhdGEoc2hhcGUsIGZpbGxTdHlsZSwgbGluZVN0eWxlLCBtYXRyaXgpO1xuICAgIHRoaXMuZ3JhcGhpY3NEYXRhLnB1c2goZGF0YSk7XG4gICAgdGhpcy5kaXJ0eSsrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRyYXdIb2xlKHNoYXBlLCBtYXRyaXggPSBudWxsKSB7XG4gICAgaWYgKCF0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gbmV3IEdyYXBoaWNzRGF0YShzaGFwZSwgbnVsbCwgbnVsbCwgbWF0cml4KTtcbiAgICBjb25zdCBsYXN0U2hhcGUgPSB0aGlzLmdyYXBoaWNzRGF0YVt0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGggLSAxXTtcbiAgICBkYXRhLmxpbmVTdHlsZSA9IGxhc3RTaGFwZS5saW5lU3R5bGU7XG4gICAgbGFzdFNoYXBlLmhvbGVzLnB1c2goZGF0YSk7XG4gICAgdGhpcy5kaXJ0eSsrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhW2ldLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5wb2ludHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnBvaW50cyA9IG51bGw7XG4gICAgdGhpcy5jb2xvcnMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmNvbG9ycyA9IG51bGw7XG4gICAgdGhpcy51dnMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnV2cyA9IG51bGw7XG4gICAgdGhpcy5pbmRpY2VzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5pbmRpY2VzID0gbnVsbDtcbiAgICB0aGlzLmluZGV4QnVmZmVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGggPSAwO1xuICAgIHRoaXMuZ3JhcGhpY3NEYXRhID0gbnVsbDtcbiAgICB0aGlzLmRyYXdDYWxscy5sZW5ndGggPSAwO1xuICAgIHRoaXMuZHJhd0NhbGxzID0gbnVsbDtcbiAgICB0aGlzLmJhdGNoZXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmJhdGNoZXMgPSBudWxsO1xuICAgIHRoaXMuX2JvdW5kcyA9IG51bGw7XG4gIH1cbiAgY29udGFpbnNQb2ludChwb2ludCkge1xuICAgIGNvbnN0IGdyYXBoaWNzRGF0YSA9IHRoaXMuZ3JhcGhpY3NEYXRhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JhcGhpY3NEYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBkYXRhID0gZ3JhcGhpY3NEYXRhW2ldO1xuICAgICAgaWYgKCFkYXRhLmZpbGxTdHlsZS52aXNpYmxlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuc2hhcGUpIHtcbiAgICAgICAgaWYgKGRhdGEubWF0cml4KSB7XG4gICAgICAgICAgZGF0YS5tYXRyaXguYXBwbHlJbnZlcnNlKHBvaW50LCB0bXBQb2ludCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG1wUG9pbnQuY29weUZyb20ocG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnNoYXBlLmNvbnRhaW5zKHRtcFBvaW50LngsIHRtcFBvaW50LnkpKSB7XG4gICAgICAgICAgbGV0IGhpdEhvbGUgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoZGF0YS5ob2xlcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGRhdGEuaG9sZXMubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGhvbGUgPSBkYXRhLmhvbGVzW2kyXTtcbiAgICAgICAgICAgICAgaWYgKGhvbGUuc2hhcGUuY29udGFpbnModG1wUG9pbnQueCwgdG1wUG9pbnQueSkpIHtcbiAgICAgICAgICAgICAgICBoaXRIb2xlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWhpdEhvbGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdXBkYXRlQmF0Y2hlcygpIHtcbiAgICBpZiAoIXRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCkge1xuICAgICAgdGhpcy5iYXRjaGFibGUgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMudmFsaWRhdGVCYXRjaGluZygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY2FjaGVEaXJ0eSA9IHRoaXMuZGlydHk7XG4gICAgY29uc3QgdXZzID0gdGhpcy51dnM7XG4gICAgY29uc3QgZ3JhcGhpY3NEYXRhID0gdGhpcy5ncmFwaGljc0RhdGE7XG4gICAgbGV0IGJhdGNoUGFydCA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnRTdHlsZSA9IG51bGw7XG4gICAgaWYgKHRoaXMuYmF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICBiYXRjaFBhcnQgPSB0aGlzLmJhdGNoZXNbdGhpcy5iYXRjaGVzLmxlbmd0aCAtIDFdO1xuICAgICAgY3VycmVudFN0eWxlID0gYmF0Y2hQYXJ0LnN0eWxlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gdGhpcy5zaGFwZUluZGV4OyBpIDwgZ3JhcGhpY3NEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnNoYXBlSW5kZXgrKztcbiAgICAgIGNvbnN0IGRhdGEgPSBncmFwaGljc0RhdGFbaV07XG4gICAgICBjb25zdCBmaWxsU3R5bGUgPSBkYXRhLmZpbGxTdHlsZTtcbiAgICAgIGNvbnN0IGxpbmVTdHlsZSA9IGRhdGEubGluZVN0eWxlO1xuICAgICAgY29uc3QgY29tbWFuZCA9IEZJTExfQ09NTUFORFNbZGF0YS50eXBlXTtcbiAgICAgIGNvbW1hbmQuYnVpbGQoZGF0YSk7XG4gICAgICBpZiAoZGF0YS5tYXRyaXgpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1Qb2ludHMoZGF0YS5wb2ludHMsIGRhdGEubWF0cml4KTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxsU3R5bGUudmlzaWJsZSB8fCBsaW5lU3R5bGUudmlzaWJsZSkge1xuICAgICAgICB0aGlzLnByb2Nlc3NIb2xlcyhkYXRhLmhvbGVzKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMjsgaisrKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gaiA9PT0gMCA/IGZpbGxTdHlsZSA6IGxpbmVTdHlsZTtcbiAgICAgICAgaWYgKCFzdHlsZS52aXNpYmxlKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBuZXh0VGV4dHVyZSA9IHN0eWxlLnRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgICAgIGNvbnN0IGluZGV4MiA9IHRoaXMuaW5kaWNlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGF0dHJpYkluZGV4ID0gdGhpcy5wb2ludHMubGVuZ3RoIC8gMjtcbiAgICAgICAgbmV4dFRleHR1cmUud3JhcE1vZGUgPSBXUkFQX01PREVTLlJFUEVBVDtcbiAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICB0aGlzLnByb2Nlc3NGaWxsKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucHJvY2Vzc0xpbmUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMucG9pbnRzLmxlbmd0aCAvIDIgLSBhdHRyaWJJbmRleDtcbiAgICAgICAgaWYgKHNpemUgPT09IDApXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChiYXRjaFBhcnQgJiYgIXRoaXMuX2NvbXBhcmVTdHlsZXMoY3VycmVudFN0eWxlLCBzdHlsZSkpIHtcbiAgICAgICAgICBiYXRjaFBhcnQuZW5kKGluZGV4MiwgYXR0cmliSW5kZXgpO1xuICAgICAgICAgIGJhdGNoUGFydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFiYXRjaFBhcnQpIHtcbiAgICAgICAgICBiYXRjaFBhcnQgPSBCQVRDSF9QT09MLnBvcCgpIHx8IG5ldyBCYXRjaFBhcnQoKTtcbiAgICAgICAgICBiYXRjaFBhcnQuYmVnaW4oc3R5bGUsIGluZGV4MiwgYXR0cmliSW5kZXgpO1xuICAgICAgICAgIHRoaXMuYmF0Y2hlcy5wdXNoKGJhdGNoUGFydCk7XG4gICAgICAgICAgY3VycmVudFN0eWxlID0gc3R5bGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRVdnModGhpcy5wb2ludHMsIHV2cywgc3R5bGUudGV4dHVyZSwgYXR0cmliSW5kZXgsIHNpemUsIHN0eWxlLm1hdHJpeCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRpY2VzLmxlbmd0aDtcbiAgICBjb25zdCBhdHRyaWIgPSB0aGlzLnBvaW50cy5sZW5ndGggLyAyO1xuICAgIGlmIChiYXRjaFBhcnQpIHtcbiAgICAgIGJhdGNoUGFydC5lbmQoaW5kZXgsIGF0dHJpYik7XG4gICAgfVxuICAgIGlmICh0aGlzLmJhdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmJhdGNoYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5lZWQzMiA9IGF0dHJpYiA+IDY1NTM1O1xuICAgIGlmICh0aGlzLmluZGljZXNVaW50MTYgJiYgdGhpcy5pbmRpY2VzLmxlbmd0aCA9PT0gdGhpcy5pbmRpY2VzVWludDE2Lmxlbmd0aCAmJiBuZWVkMzIgPT09IHRoaXMuaW5kaWNlc1VpbnQxNi5CWVRFU19QRVJfRUxFTUVOVCA+IDIpIHtcbiAgICAgIHRoaXMuaW5kaWNlc1VpbnQxNi5zZXQodGhpcy5pbmRpY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbmRpY2VzVWludDE2ID0gbmVlZDMyID8gbmV3IFVpbnQzMkFycmF5KHRoaXMuaW5kaWNlcykgOiBuZXcgVWludDE2QXJyYXkodGhpcy5pbmRpY2VzKTtcbiAgICB9XG4gICAgdGhpcy5iYXRjaGFibGUgPSB0aGlzLmlzQmF0Y2hhYmxlKCk7XG4gICAgaWYgKHRoaXMuYmF0Y2hhYmxlKSB7XG4gICAgICB0aGlzLnBhY2tCYXRjaGVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYnVpbGREcmF3Q2FsbHMoKTtcbiAgICB9XG4gIH1cbiAgX2NvbXBhcmVTdHlsZXMoc3R5bGVBLCBzdHlsZUIpIHtcbiAgICBpZiAoIXN0eWxlQSB8fCAhc3R5bGVCKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzdHlsZUEudGV4dHVyZS5iYXNlVGV4dHVyZSAhPT0gc3R5bGVCLnRleHR1cmUuYmFzZVRleHR1cmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN0eWxlQS5jb2xvciArIHN0eWxlQS5hbHBoYSAhPT0gc3R5bGVCLmNvbG9yICsgc3R5bGVCLmFscGhhKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghIXN0eWxlQS5uYXRpdmUgIT09ICEhc3R5bGVCLm5hdGl2ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YWxpZGF0ZUJhdGNoaW5nKCkge1xuICAgIGlmICh0aGlzLmRpcnR5ID09PSB0aGlzLmNhY2hlRGlydHkgfHwgIXRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ3JhcGhpY3NEYXRhW2ldO1xuICAgICAgY29uc3QgZmlsbCA9IGRhdGEuZmlsbFN0eWxlO1xuICAgICAgY29uc3QgbGluZSA9IGRhdGEubGluZVN0eWxlO1xuICAgICAgaWYgKGZpbGwgJiYgIWZpbGwudGV4dHVyZS5iYXNlVGV4dHVyZS52YWxpZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKGxpbmUgJiYgIWxpbmUudGV4dHVyZS5iYXNlVGV4dHVyZS52YWxpZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBwYWNrQmF0Y2hlcygpIHtcbiAgICB0aGlzLmJhdGNoRGlydHkrKztcbiAgICB0aGlzLnV2c0Zsb2F0MzIgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudXZzKTtcbiAgICBjb25zdCBiYXRjaGVzID0gdGhpcy5iYXRjaGVzO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gYmF0Y2hlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGJhdGNoID0gYmF0Y2hlc1tpXTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmF0Y2guc2l6ZTsgaisrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gYmF0Y2guc3RhcnQgKyBqO1xuICAgICAgICB0aGlzLmluZGljZXNVaW50MTZbaW5kZXhdID0gdGhpcy5pbmRpY2VzVWludDE2W2luZGV4XSAtIGJhdGNoLmF0dHJpYlN0YXJ0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpc0JhdGNoYWJsZSgpIHtcbiAgICBpZiAodGhpcy5wb2ludHMubGVuZ3RoID4gNjU1MzUgKiAyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGJhdGNoZXMgPSB0aGlzLmJhdGNoZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYmF0Y2hlc1tpXS5zdHlsZS5uYXRpdmUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wb2ludHMubGVuZ3RoIDwgX0dyYXBoaWNzR2VvbWV0cnkuQkFUQ0hBQkxFX1NJWkUgKiAyO1xuICB9XG4gIGJ1aWxkRHJhd0NhbGxzKCkge1xuICAgIGxldCBUSUNLID0gKytCYXNlVGV4dHVyZS5fZ2xvYmFsQmF0Y2g7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRyYXdDYWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5kcmF3Q2FsbHNbaV0udGV4QXJyYXkuY2xlYXIoKTtcbiAgICAgIERSQVdfQ0FMTF9QT09MLnB1c2godGhpcy5kcmF3Q2FsbHNbaV0pO1xuICAgIH1cbiAgICB0aGlzLmRyYXdDYWxscy5sZW5ndGggPSAwO1xuICAgIGNvbnN0IGNvbG9ycyA9IHRoaXMuY29sb3JzO1xuICAgIGNvbnN0IHRleHR1cmVJZHMgPSB0aGlzLnRleHR1cmVJZHM7XG4gICAgbGV0IGN1cnJlbnRHcm91cCA9IERSQVdfQ0FMTF9QT09MLnBvcCgpO1xuICAgIGlmICghY3VycmVudEdyb3VwKSB7XG4gICAgICBjdXJyZW50R3JvdXAgPSBuZXcgQmF0Y2hEcmF3Q2FsbCgpO1xuICAgICAgY3VycmVudEdyb3VwLnRleEFycmF5ID0gbmV3IEJhdGNoVGV4dHVyZUFycmF5KCk7XG4gICAgfVxuICAgIGN1cnJlbnRHcm91cC50ZXhBcnJheS5jb3VudCA9IDA7XG4gICAgY3VycmVudEdyb3VwLnN0YXJ0ID0gMDtcbiAgICBjdXJyZW50R3JvdXAuc2l6ZSA9IDA7XG4gICAgY3VycmVudEdyb3VwLnR5cGUgPSBEUkFXX01PREVTLlRSSUFOR0xFUztcbiAgICBsZXQgdGV4dHVyZUNvdW50ID0gMDtcbiAgICBsZXQgY3VycmVudFRleHR1cmUgPSBudWxsO1xuICAgIGxldCB0ZXh0dXJlSWQgPSAwO1xuICAgIGxldCBuYXRpdmUgPSBmYWxzZTtcbiAgICBsZXQgZHJhd01vZGUgPSBEUkFXX01PREVTLlRSSUFOR0xFUztcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIHRoaXMuZHJhd0NhbGxzLnB1c2goY3VycmVudEdyb3VwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYmF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuYmF0Y2hlc1tpXTtcbiAgICAgIGNvbnN0IG1heFRleHR1cmVzID0gODtcbiAgICAgIGNvbnN0IHN0eWxlID0gZGF0YS5zdHlsZTtcbiAgICAgIGNvbnN0IG5leHRUZXh0dXJlID0gc3R5bGUudGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICAgIGlmIChuYXRpdmUgIT09ICEhc3R5bGUubmF0aXZlKSB7XG4gICAgICAgIG5hdGl2ZSA9ICEhc3R5bGUubmF0aXZlO1xuICAgICAgICBkcmF3TW9kZSA9IG5hdGl2ZSA/IERSQVdfTU9ERVMuTElORVMgOiBEUkFXX01PREVTLlRSSUFOR0xFUztcbiAgICAgICAgY3VycmVudFRleHR1cmUgPSBudWxsO1xuICAgICAgICB0ZXh0dXJlQ291bnQgPSBtYXhUZXh0dXJlcztcbiAgICAgICAgVElDSysrO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRUZXh0dXJlICE9PSBuZXh0VGV4dHVyZSkge1xuICAgICAgICBjdXJyZW50VGV4dHVyZSA9IG5leHRUZXh0dXJlO1xuICAgICAgICBpZiAobmV4dFRleHR1cmUuX2JhdGNoRW5hYmxlZCAhPT0gVElDSykge1xuICAgICAgICAgIGlmICh0ZXh0dXJlQ291bnQgPT09IG1heFRleHR1cmVzKSB7XG4gICAgICAgICAgICBUSUNLKys7XG4gICAgICAgICAgICB0ZXh0dXJlQ291bnQgPSAwO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRHcm91cC5zaXplID4gMCkge1xuICAgICAgICAgICAgICBjdXJyZW50R3JvdXAgPSBEUkFXX0NBTExfUE9PTC5wb3AoKTtcbiAgICAgICAgICAgICAgaWYgKCFjdXJyZW50R3JvdXApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAgPSBuZXcgQmF0Y2hEcmF3Q2FsbCgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRHcm91cC50ZXhBcnJheSA9IG5ldyBCYXRjaFRleHR1cmVBcnJheSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuZHJhd0NhbGxzLnB1c2goY3VycmVudEdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRHcm91cC5zdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgY3VycmVudEdyb3VwLnNpemUgPSAwO1xuICAgICAgICAgICAgY3VycmVudEdyb3VwLnRleEFycmF5LmNvdW50ID0gMDtcbiAgICAgICAgICAgIGN1cnJlbnRHcm91cC50eXBlID0gZHJhd01vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHRUZXh0dXJlLnRvdWNoZWQgPSAxO1xuICAgICAgICAgIG5leHRUZXh0dXJlLl9iYXRjaEVuYWJsZWQgPSBUSUNLO1xuICAgICAgICAgIG5leHRUZXh0dXJlLl9iYXRjaExvY2F0aW9uID0gdGV4dHVyZUNvdW50O1xuICAgICAgICAgIG5leHRUZXh0dXJlLndyYXBNb2RlID0gV1JBUF9NT0RFUy5SRVBFQVQ7XG4gICAgICAgICAgY3VycmVudEdyb3VwLnRleEFycmF5LmVsZW1lbnRzW2N1cnJlbnRHcm91cC50ZXhBcnJheS5jb3VudCsrXSA9IG5leHRUZXh0dXJlO1xuICAgICAgICAgIHRleHR1cmVDb3VudCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdXJyZW50R3JvdXAuc2l6ZSArPSBkYXRhLnNpemU7XG4gICAgICBpbmRleCArPSBkYXRhLnNpemU7XG4gICAgICB0ZXh0dXJlSWQgPSBuZXh0VGV4dHVyZS5fYmF0Y2hMb2NhdGlvbjtcbiAgICAgIHRoaXMuYWRkQ29sb3JzKGNvbG9ycywgc3R5bGUuY29sb3IsIHN0eWxlLmFscGhhLCBkYXRhLmF0dHJpYlNpemUsIGRhdGEuYXR0cmliU3RhcnQpO1xuICAgICAgdGhpcy5hZGRUZXh0dXJlSWRzKHRleHR1cmVJZHMsIHRleHR1cmVJZCwgZGF0YS5hdHRyaWJTaXplLCBkYXRhLmF0dHJpYlN0YXJ0KTtcbiAgICB9XG4gICAgQmFzZVRleHR1cmUuX2dsb2JhbEJhdGNoID0gVElDSztcbiAgICB0aGlzLnBhY2tBdHRyaWJ1dGVzKCk7XG4gIH1cbiAgcGFja0F0dHJpYnV0ZXMoKSB7XG4gICAgY29uc3QgdmVydHMgPSB0aGlzLnBvaW50cztcbiAgICBjb25zdCB1dnMgPSB0aGlzLnV2cztcbiAgICBjb25zdCBjb2xvcnMgPSB0aGlzLmNvbG9ycztcbiAgICBjb25zdCB0ZXh0dXJlSWRzID0gdGhpcy50ZXh0dXJlSWRzO1xuICAgIGNvbnN0IGdsUG9pbnRzID0gbmV3IEFycmF5QnVmZmVyKHZlcnRzLmxlbmd0aCAqIDMgKiA0KTtcbiAgICBjb25zdCBmMzIgPSBuZXcgRmxvYXQzMkFycmF5KGdsUG9pbnRzKTtcbiAgICBjb25zdCB1MzIgPSBuZXcgVWludDMyQXJyYXkoZ2xQb2ludHMpO1xuICAgIGxldCBwID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgZjMyW3ArK10gPSB2ZXJ0c1tpICogMl07XG4gICAgICBmMzJbcCsrXSA9IHZlcnRzW2kgKiAyICsgMV07XG4gICAgICBmMzJbcCsrXSA9IHV2c1tpICogMl07XG4gICAgICBmMzJbcCsrXSA9IHV2c1tpICogMiArIDFdO1xuICAgICAgdTMyW3ArK10gPSBjb2xvcnNbaV07XG4gICAgICBmMzJbcCsrXSA9IHRleHR1cmVJZHNbaV07XG4gICAgfVxuICAgIHRoaXMuX2J1ZmZlci51cGRhdGUoZ2xQb2ludHMpO1xuICAgIHRoaXMuX2luZGV4QnVmZmVyLnVwZGF0ZSh0aGlzLmluZGljZXNVaW50MTYpO1xuICB9XG4gIHByb2Nlc3NGaWxsKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5ob2xlcy5sZW5ndGgpIHtcbiAgICAgIGJ1aWxkUG9seS50cmlhbmd1bGF0ZShkYXRhLCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29tbWFuZCA9IEZJTExfQ09NTUFORFNbZGF0YS50eXBlXTtcbiAgICAgIGNvbW1hbmQudHJpYW5ndWxhdGUoZGF0YSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIHByb2Nlc3NMaW5lKGRhdGEpIHtcbiAgICBidWlsZExpbmUoZGF0YSwgdGhpcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmhvbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBidWlsZExpbmUoZGF0YS5ob2xlc1tpXSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIHByb2Nlc3NIb2xlcyhob2xlcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGhvbGUgPSBob2xlc1tpXTtcbiAgICAgIGNvbnN0IGNvbW1hbmQgPSBGSUxMX0NPTU1BTkRTW2hvbGUudHlwZV07XG4gICAgICBjb21tYW5kLmJ1aWxkKGhvbGUpO1xuICAgICAgaWYgKGhvbGUubWF0cml4KSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtUG9pbnRzKGhvbGUucG9pbnRzLCBob2xlLm1hdHJpeCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGN1bGF0ZUJvdW5kcygpIHtcbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLl9ib3VuZHM7XG4gICAgYm91bmRzLmNsZWFyKCk7XG4gICAgYm91bmRzLmFkZFZlcnRleERhdGEodGhpcy5wb2ludHMsIDAsIHRoaXMucG9pbnRzLmxlbmd0aCk7XG4gICAgYm91bmRzLnBhZCh0aGlzLmJvdW5kc1BhZGRpbmcsIHRoaXMuYm91bmRzUGFkZGluZyk7XG4gIH1cbiAgdHJhbnNmb3JtUG9pbnRzKHBvaW50cywgbWF0cml4KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICBjb25zdCB4ID0gcG9pbnRzW2kgKiAyXTtcbiAgICAgIGNvbnN0IHkgPSBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgIHBvaW50c1tpICogMl0gPSBtYXRyaXguYSAqIHggKyBtYXRyaXguYyAqIHkgKyBtYXRyaXgudHg7XG4gICAgICBwb2ludHNbaSAqIDIgKyAxXSA9IG1hdHJpeC5iICogeCArIG1hdHJpeC5kICogeSArIG1hdHJpeC50eTtcbiAgICB9XG4gIH1cbiAgYWRkQ29sb3JzKGNvbG9ycywgY29sb3IsIGFscGhhLCBzaXplLCBvZmZzZXQgPSAwKSB7XG4gICAgY29uc3QgYmdyID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGNvbG9yKS50b0xpdHRsZUVuZGlhbk51bWJlcigpO1xuICAgIGNvbnN0IHJlc3VsdCA9IENvbG9yLnNoYXJlZC5zZXRWYWx1ZShiZ3IpLnRvUHJlbXVsdGlwbGllZChhbHBoYSk7XG4gICAgY29sb3JzLmxlbmd0aCA9IE1hdGgubWF4KGNvbG9ycy5sZW5ndGgsIG9mZnNldCArIHNpemUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBjb2xvcnNbb2Zmc2V0ICsgaV0gPSByZXN1bHQ7XG4gICAgfVxuICB9XG4gIGFkZFRleHR1cmVJZHModGV4dHVyZUlkcywgaWQsIHNpemUsIG9mZnNldCA9IDApIHtcbiAgICB0ZXh0dXJlSWRzLmxlbmd0aCA9IE1hdGgubWF4KHRleHR1cmVJZHMubGVuZ3RoLCBvZmZzZXQgKyBzaXplKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgdGV4dHVyZUlkc1tvZmZzZXQgKyBpXSA9IGlkO1xuICAgIH1cbiAgfVxuICBhZGRVdnModmVydHMsIHV2cywgdGV4dHVyZSwgc3RhcnQsIHNpemUsIG1hdHJpeCA9IG51bGwpIHtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGNvbnN0IHV2c1N0YXJ0ID0gdXZzLmxlbmd0aDtcbiAgICBjb25zdCBmcmFtZSA9IHRleHR1cmUuZnJhbWU7XG4gICAgd2hpbGUgKGluZGV4IDwgc2l6ZSkge1xuICAgICAgbGV0IHggPSB2ZXJ0c1soc3RhcnQgKyBpbmRleCkgKiAyXTtcbiAgICAgIGxldCB5ID0gdmVydHNbKHN0YXJ0ICsgaW5kZXgpICogMiArIDFdO1xuICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICBjb25zdCBueCA9IG1hdHJpeC5hICogeCArIG1hdHJpeC5jICogeSArIG1hdHJpeC50eDtcbiAgICAgICAgeSA9IG1hdHJpeC5iICogeCArIG1hdHJpeC5kICogeSArIG1hdHJpeC50eTtcbiAgICAgICAgeCA9IG54O1xuICAgICAgfVxuICAgICAgaW5kZXgrKztcbiAgICAgIHV2cy5wdXNoKHggLyBmcmFtZS53aWR0aCwgeSAvIGZyYW1lLmhlaWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGJhc2VUZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICBpZiAoZnJhbWUud2lkdGggPCBiYXNlVGV4dHVyZS53aWR0aCB8fCBmcmFtZS5oZWlnaHQgPCBiYXNlVGV4dHVyZS5oZWlnaHQpIHtcbiAgICAgIHRoaXMuYWRqdXN0VXZzKHV2cywgdGV4dHVyZSwgdXZzU3RhcnQsIHNpemUpO1xuICAgIH1cbiAgfVxuICBhZGp1c3RVdnModXZzLCB0ZXh0dXJlLCBzdGFydCwgc2l6ZSkge1xuICAgIGNvbnN0IGJhc2VUZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICBjb25zdCBlcHMgPSAxZS02O1xuICAgIGNvbnN0IGZpbmlzaCA9IHN0YXJ0ICsgc2l6ZSAqIDI7XG4gICAgY29uc3QgZnJhbWUgPSB0ZXh0dXJlLmZyYW1lO1xuICAgIGNvbnN0IHNjYWxlWCA9IGZyYW1lLndpZHRoIC8gYmFzZVRleHR1cmUud2lkdGg7XG4gICAgY29uc3Qgc2NhbGVZID0gZnJhbWUuaGVpZ2h0IC8gYmFzZVRleHR1cmUuaGVpZ2h0O1xuICAgIGxldCBvZmZzZXRYID0gZnJhbWUueCAvIGZyYW1lLndpZHRoO1xuICAgIGxldCBvZmZzZXRZID0gZnJhbWUueSAvIGZyYW1lLmhlaWdodDtcbiAgICBsZXQgbWluWCA9IE1hdGguZmxvb3IodXZzW3N0YXJ0XSArIGVwcyk7XG4gICAgbGV0IG1pblkgPSBNYXRoLmZsb29yKHV2c1tzdGFydCArIDFdICsgZXBzKTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQgKyAyOyBpIDwgZmluaXNoOyBpICs9IDIpIHtcbiAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBNYXRoLmZsb29yKHV2c1tpXSArIGVwcykpO1xuICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIE1hdGguZmxvb3IodXZzW2kgKyAxXSArIGVwcykpO1xuICAgIH1cbiAgICBvZmZzZXRYIC09IG1pblg7XG4gICAgb2Zmc2V0WSAtPSBtaW5ZO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGZpbmlzaDsgaSArPSAyKSB7XG4gICAgICB1dnNbaV0gPSAodXZzW2ldICsgb2Zmc2V0WCkgKiBzY2FsZVg7XG4gICAgICB1dnNbaSArIDFdID0gKHV2c1tpICsgMV0gKyBvZmZzZXRZKSAqIHNjYWxlWTtcbiAgICB9XG4gIH1cbn07XG5sZXQgR3JhcGhpY3NHZW9tZXRyeSA9IF9HcmFwaGljc0dlb21ldHJ5O1xuR3JhcGhpY3NHZW9tZXRyeS5CQVRDSEFCTEVfU0laRSA9IDEwMDtcblxuZXhwb3J0IHsgR3JhcGhpY3NHZW9tZXRyeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JhcGhpY3NHZW9tZXRyeS5tanMubWFwXG4iLCJpbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmNsYXNzIEZpbGxTdHlsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29sb3IgPSAxNjc3NzIxNTtcbiAgICB0aGlzLmFscGhhID0gMTtcbiAgICB0aGlzLnRleHR1cmUgPSBUZXh0dXJlLldISVRFO1xuICAgIHRoaXMubWF0cml4ID0gbnVsbDtcbiAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3Qgb2JqID0gbmV3IEZpbGxTdHlsZSgpO1xuICAgIG9iai5jb2xvciA9IHRoaXMuY29sb3I7XG4gICAgb2JqLmFscGhhID0gdGhpcy5hbHBoYTtcbiAgICBvYmoudGV4dHVyZSA9IHRoaXMudGV4dHVyZTtcbiAgICBvYmoubWF0cml4ID0gdGhpcy5tYXRyaXg7XG4gICAgb2JqLnZpc2libGUgPSB0aGlzLnZpc2libGU7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmNvbG9yID0gMTY3NzcyMTU7XG4gICAgdGhpcy5hbHBoYSA9IDE7XG4gICAgdGhpcy50ZXh0dXJlID0gVGV4dHVyZS5XSElURTtcbiAgICB0aGlzLm1hdHJpeCA9IG51bGw7XG4gICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuICAgIHRoaXMubWF0cml4ID0gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgeyBGaWxsU3R5bGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbGxTdHlsZS5tanMubWFwXG4iLCJpbXBvcnQgeyBMSU5FX0NBUCwgTElORV9KT0lOIH0gZnJvbSAnLi4vY29uc3QubWpzJztcbmltcG9ydCB7IEZpbGxTdHlsZSB9IGZyb20gJy4vRmlsbFN0eWxlLm1qcyc7XG5cbmNsYXNzIExpbmVTdHlsZSBleHRlbmRzIEZpbGxTdHlsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgdGhpcy5hbGlnbm1lbnQgPSAwLjU7XG4gICAgdGhpcy5uYXRpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmNhcCA9IExJTkVfQ0FQLkJVVFQ7XG4gICAgdGhpcy5qb2luID0gTElORV9KT0lOLk1JVEVSO1xuICAgIHRoaXMubWl0ZXJMaW1pdCA9IDEwO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IG9iaiA9IG5ldyBMaW5lU3R5bGUoKTtcbiAgICBvYmouY29sb3IgPSB0aGlzLmNvbG9yO1xuICAgIG9iai5hbHBoYSA9IHRoaXMuYWxwaGE7XG4gICAgb2JqLnRleHR1cmUgPSB0aGlzLnRleHR1cmU7XG4gICAgb2JqLm1hdHJpeCA9IHRoaXMubWF0cml4O1xuICAgIG9iai52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xuICAgIG9iai53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgb2JqLmFsaWdubWVudCA9IHRoaXMuYWxpZ25tZW50O1xuICAgIG9iai5uYXRpdmUgPSB0aGlzLm5hdGl2ZTtcbiAgICBvYmouY2FwID0gdGhpcy5jYXA7XG4gICAgb2JqLmpvaW4gPSB0aGlzLmpvaW47XG4gICAgb2JqLm1pdGVyTGltaXQgPSB0aGlzLm1pdGVyTGltaXQ7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICByZXNldCgpIHtcbiAgICBzdXBlci5yZXNldCgpO1xuICAgIHRoaXMuY29sb3IgPSAwO1xuICAgIHRoaXMuYWxpZ25tZW50ID0gMC41O1xuICAgIHRoaXMud2lkdGggPSAwO1xuICAgIHRoaXMubmF0aXZlID0gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IHsgTGluZVN0eWxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaW5lU3R5bGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgU3RhdGUsIENvbG9yLCBCTEVORF9NT0RFUywgVGV4dHVyZSwgUG9seWdvbiwgUElfMiwgUmVjdGFuZ2xlLCBSb3VuZGVkUmVjdGFuZ2xlLCBDaXJjbGUsIEVsbGlwc2UsIFNIQVBFUywgTWF0cml4LCBVbmlmb3JtR3JvdXAsIFNoYWRlciwgUG9pbnQgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJ0BwaXhpL2Rpc3BsYXknO1xuaW1wb3J0IHsgTElORV9DQVAsIExJTkVfSk9JTiwgY3VydmVzIH0gZnJvbSAnLi9jb25zdC5tanMnO1xuaW1wb3J0IHsgR3JhcGhpY3NHZW9tZXRyeSB9IGZyb20gJy4vR3JhcGhpY3NHZW9tZXRyeS5tanMnO1xuaW1wb3J0IHsgRmlsbFN0eWxlIH0gZnJvbSAnLi9zdHlsZXMvRmlsbFN0eWxlLm1qcyc7XG5pbXBvcnQgeyBMaW5lU3R5bGUgfSBmcm9tICcuL3N0eWxlcy9MaW5lU3R5bGUubWpzJztcbmltcG9ydCAnLi91dGlscy9pbmRleC5tanMnO1xuaW1wb3J0IHsgUXVhZHJhdGljVXRpbHMgfSBmcm9tICcuL3V0aWxzL1F1YWRyYXRpY1V0aWxzLm1qcyc7XG5pbXBvcnQgeyBCZXppZXJVdGlscyB9IGZyb20gJy4vdXRpbHMvQmV6aWVyVXRpbHMubWpzJztcbmltcG9ydCB7IEFyY1V0aWxzIH0gZnJvbSAnLi91dGlscy9BcmNVdGlscy5tanMnO1xuXG5jb25zdCBERUZBVUxUX1NIQURFUlMgPSB7fTtcbmNvbnN0IF9HcmFwaGljcyA9IGNsYXNzIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3IoZ2VvbWV0cnkgPSBudWxsKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNoYWRlciA9IG51bGw7XG4gICAgdGhpcy5wbHVnaW5OYW1lID0gXCJiYXRjaFwiO1xuICAgIHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xuICAgIHRoaXMuYmF0Y2hlcyA9IFtdO1xuICAgIHRoaXMuYmF0Y2hUaW50ID0gLTE7XG4gICAgdGhpcy5iYXRjaERpcnR5ID0gLTE7XG4gICAgdGhpcy52ZXJ0ZXhEYXRhID0gbnVsbDtcbiAgICB0aGlzLl9maWxsU3R5bGUgPSBuZXcgRmlsbFN0eWxlKCk7XG4gICAgdGhpcy5fbGluZVN0eWxlID0gbmV3IExpbmVTdHlsZSgpO1xuICAgIHRoaXMuX21hdHJpeCA9IG51bGw7XG4gICAgdGhpcy5faG9sZU1vZGUgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuZm9yMmQoKTtcbiAgICB0aGlzLl9nZW9tZXRyeSA9IGdlb21ldHJ5IHx8IG5ldyBHcmFwaGljc0dlb21ldHJ5KCk7XG4gICAgdGhpcy5fZ2VvbWV0cnkucmVmQ291bnQrKztcbiAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IC0xO1xuICAgIHRoaXMuX3RpbnRDb2xvciA9IG5ldyBDb2xvcigxNjc3NzIxNSk7XG4gICAgdGhpcy5ibGVuZE1vZGUgPSBCTEVORF9NT0RFUy5OT1JNQUw7XG4gIH1cbiAgZ2V0IGdlb21ldHJ5KCkge1xuICAgIHJldHVybiB0aGlzLl9nZW9tZXRyeTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICB0aGlzLmZpbmlzaFBvbHkoKTtcbiAgICByZXR1cm4gbmV3IF9HcmFwaGljcyh0aGlzLl9nZW9tZXRyeSk7XG4gIH1cbiAgc2V0IGJsZW5kTW9kZSh2YWx1ZSkge1xuICAgIHRoaXMuc3RhdGUuYmxlbmRNb2RlID0gdmFsdWU7XG4gIH1cbiAgZ2V0IGJsZW5kTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5ibGVuZE1vZGU7XG4gIH1cbiAgZ2V0IHRpbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbnRDb2xvci52YWx1ZTtcbiAgfVxuICBzZXQgdGludCh2YWx1ZSkge1xuICAgIHRoaXMuX3RpbnRDb2xvci5zZXRWYWx1ZSh2YWx1ZSk7XG4gIH1cbiAgZ2V0IGZpbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGxTdHlsZTtcbiAgfVxuICBnZXQgbGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGluZVN0eWxlO1xuICB9XG4gIGxpbmVTdHlsZShvcHRpb25zID0gbnVsbCwgY29sb3IgPSAwLCBhbHBoYSwgYWxpZ25tZW50ID0gMC41LCBuYXRpdmUgPSBmYWxzZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgb3B0aW9ucyA9IHsgd2lkdGg6IG9wdGlvbnMsIGNvbG9yLCBhbHBoYSwgYWxpZ25tZW50LCBuYXRpdmUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGluZVRleHR1cmVTdHlsZShvcHRpb25zKTtcbiAgfVxuICBsaW5lVGV4dHVyZVN0eWxlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZhdWx0TGluZVN0eWxlT3B0aW9ucyA9IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgdGV4dHVyZTogVGV4dHVyZS5XSElURSxcbiAgICAgIGNvbG9yOiBvcHRpb25zPy50ZXh0dXJlID8gMTY3NzcyMTUgOiAwLFxuICAgICAgbWF0cml4OiBudWxsLFxuICAgICAgYWxpZ25tZW50OiAwLjUsXG4gICAgICBuYXRpdmU6IGZhbHNlLFxuICAgICAgY2FwOiBMSU5FX0NBUC5CVVRULFxuICAgICAgam9pbjogTElORV9KT0lOLk1JVEVSLFxuICAgICAgbWl0ZXJMaW1pdDogMTBcbiAgICB9O1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRMaW5lU3R5bGVPcHRpb25zLCBvcHRpb25zKTtcbiAgICB0aGlzLm5vcm1hbGl6ZUNvbG9yKG9wdGlvbnMpO1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKSB7XG4gICAgICB0aGlzLnN0YXJ0UG9seSgpO1xuICAgIH1cbiAgICBjb25zdCB2aXNpYmxlID0gb3B0aW9ucy53aWR0aCA+IDAgJiYgb3B0aW9ucy5hbHBoYSA+IDA7XG4gICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICB0aGlzLl9saW5lU3R5bGUucmVzZXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbnMubWF0cml4KSB7XG4gICAgICAgIG9wdGlvbnMubWF0cml4ID0gb3B0aW9ucy5tYXRyaXguY2xvbmUoKTtcbiAgICAgICAgb3B0aW9ucy5tYXRyaXguaW52ZXJ0KCk7XG4gICAgICB9XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMuX2xpbmVTdHlsZSwgeyB2aXNpYmxlIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdGFydFBvbHkoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhdGgpIHtcbiAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzO1xuICAgICAgY29uc3QgbGVuID0gdGhpcy5jdXJyZW50UGF0aC5wb2ludHMubGVuZ3RoO1xuICAgICAgaWYgKGxlbiA+IDIpIHtcbiAgICAgICAgdGhpcy5kcmF3U2hhcGUodGhpcy5jdXJyZW50UGF0aCk7XG4gICAgICAgIHRoaXMuY3VycmVudFBhdGggPSBuZXcgUG9seWdvbigpO1xuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLmNsb3NlU3Ryb2tlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3VycmVudFBhdGgucG9pbnRzLnB1c2gocG9pbnRzW2xlbiAtIDJdLCBwb2ludHNbbGVuIC0gMV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN1cnJlbnRQYXRoID0gbmV3IFBvbHlnb24oKTtcbiAgICAgIHRoaXMuY3VycmVudFBhdGguY2xvc2VTdHJva2UgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZmluaXNoUG9seSgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50UGF0aCkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGgucG9pbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgdGhpcy5kcmF3U2hhcGUodGhpcy5jdXJyZW50UGF0aCk7XG4gICAgICAgIHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5wb2ludHMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbW92ZVRvKHgsIHkpIHtcbiAgICB0aGlzLnN0YXJ0UG9seSgpO1xuICAgIHRoaXMuY3VycmVudFBhdGgucG9pbnRzWzBdID0geDtcbiAgICB0aGlzLmN1cnJlbnRQYXRoLnBvaW50c1sxXSA9IHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbGluZVRvKHgsIHkpIHtcbiAgICBpZiAoIXRoaXMuY3VycmVudFBhdGgpIHtcbiAgICAgIHRoaXMubW92ZVRvKDAsIDApO1xuICAgIH1cbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cztcbiAgICBjb25zdCBmcm9tWCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl07XG4gICAgY29uc3QgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChmcm9tWCAhPT0geCB8fCBmcm9tWSAhPT0geSkge1xuICAgICAgcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9pbml0Q3VydmUoeCA9IDAsIHkgPSAwKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhdGgpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLnBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5wb2ludHMgPSBbeCwgeV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubW92ZVRvKHgsIHkpO1xuICAgIH1cbiAgfVxuICBxdWFkcmF0aWNDdXJ2ZVRvKGNwWCwgY3BZLCB0b1gsIHRvWSkge1xuICAgIHRoaXMuX2luaXRDdXJ2ZSgpO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzO1xuICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLm1vdmVUbygwLCAwKTtcbiAgICB9XG4gICAgUXVhZHJhdGljVXRpbHMuY3VydmVUbyhjcFgsIGNwWSwgdG9YLCB0b1ksIHBvaW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYmV6aWVyQ3VydmVUbyhjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1kpIHtcbiAgICB0aGlzLl9pbml0Q3VydmUoKTtcbiAgICBCZXppZXJVdGlscy5jdXJ2ZVRvKGNwWCwgY3BZLCBjcFgyLCBjcFkyLCB0b1gsIHRvWSwgdGhpcy5jdXJyZW50UGF0aC5wb2ludHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFyY1RvKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcbiAgICB0aGlzLl9pbml0Q3VydmUoeDEsIHkxKTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cztcbiAgICBjb25zdCByZXN1bHQgPSBBcmNVdGlscy5jdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMsIHBvaW50cyk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgY29uc3QgeyBjeCwgY3ksIHJhZGl1czogcmFkaXVzMiwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UgfSA9IHJlc3VsdDtcbiAgICAgIHRoaXMuYXJjKGN4LCBjeSwgcmFkaXVzMiwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhcmMoY3gsIGN5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlID0gZmFsc2UpIHtcbiAgICBpZiAoc3RhcnRBbmdsZSA9PT0gZW5kQW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoIWFudGljbG9ja3dpc2UgJiYgZW5kQW5nbGUgPD0gc3RhcnRBbmdsZSkge1xuICAgICAgZW5kQW5nbGUgKz0gUElfMjtcbiAgICB9IGVsc2UgaWYgKGFudGljbG9ja3dpc2UgJiYgc3RhcnRBbmdsZSA8PSBlbmRBbmdsZSkge1xuICAgICAgc3RhcnRBbmdsZSArPSBQSV8yO1xuICAgIH1cbiAgICBjb25zdCBzd2VlcCA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZTtcbiAgICBpZiAoc3dlZXAgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFggPSBjeCArIE1hdGguY29zKHN0YXJ0QW5nbGUpICogcmFkaXVzO1xuICAgIGNvbnN0IHN0YXJ0WSA9IGN5ICsgTWF0aC5zaW4oc3RhcnRBbmdsZSkgKiByYWRpdXM7XG4gICAgY29uc3QgZXBzID0gdGhpcy5fZ2VvbWV0cnkuY2xvc2VQb2ludEVwcztcbiAgICBsZXQgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aCA/IHRoaXMuY3VycmVudFBhdGgucG9pbnRzIDogbnVsbDtcbiAgICBpZiAocG9pbnRzKSB7XG4gICAgICBjb25zdCB4RGlmZiA9IE1hdGguYWJzKHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0gLSBzdGFydFgpO1xuICAgICAgY29uc3QgeURpZmYgPSBNYXRoLmFicyhwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdIC0gc3RhcnRZKTtcbiAgICAgIGlmICh4RGlmZiA8IGVwcyAmJiB5RGlmZiA8IGVwcykge1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9pbnRzLnB1c2goc3RhcnRYLCBzdGFydFkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1vdmVUbyhzdGFydFgsIHN0YXJ0WSk7XG4gICAgICBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cztcbiAgICB9XG4gICAgQXJjVXRpbHMuYXJjKHN0YXJ0WCwgc3RhcnRZLCBjeCwgY3ksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIHBvaW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYmVnaW5GaWxsKGNvbG9yID0gMCwgYWxwaGEpIHtcbiAgICByZXR1cm4gdGhpcy5iZWdpblRleHR1cmVGaWxsKHsgdGV4dHVyZTogVGV4dHVyZS5XSElURSwgY29sb3IsIGFscGhhIH0pO1xuICB9XG4gIG5vcm1hbGl6ZUNvbG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCB0ZW1wID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKG9wdGlvbnMuY29sb3IgPz8gMCk7XG4gICAgb3B0aW9ucy5jb2xvciA9IHRlbXAudG9OdW1iZXIoKTtcbiAgICBvcHRpb25zLmFscGhhID8/IChvcHRpb25zLmFscGhhID0gdGVtcC5hbHBoYSk7XG4gIH1cbiAgYmVnaW5UZXh0dXJlRmlsbChvcHRpb25zKSB7XG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICB0ZXh0dXJlOiBUZXh0dXJlLldISVRFLFxuICAgICAgY29sb3I6IDE2Nzc3MjE1LFxuICAgICAgbWF0cml4OiBudWxsXG4gICAgfTtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgdGhpcy5ub3JtYWxpemVDb2xvcihvcHRpb25zKTtcbiAgICBpZiAodGhpcy5jdXJyZW50UGF0aCkge1xuICAgICAgdGhpcy5zdGFydFBvbHkoKTtcbiAgICB9XG4gICAgY29uc3QgdmlzaWJsZSA9IG9wdGlvbnMuYWxwaGEgPiAwO1xuICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgdGhpcy5fZmlsbFN0eWxlLnJlc2V0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25zLm1hdHJpeCkge1xuICAgICAgICBvcHRpb25zLm1hdHJpeCA9IG9wdGlvbnMubWF0cml4LmNsb25lKCk7XG4gICAgICAgIG9wdGlvbnMubWF0cml4LmludmVydCgpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9maWxsU3R5bGUsIHsgdmlzaWJsZSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZW5kRmlsbCgpIHtcbiAgICB0aGlzLmZpbmlzaFBvbHkoKTtcbiAgICB0aGlzLl9maWxsU3R5bGUucmVzZXQoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkcmF3UmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhd1NoYXBlKG5ldyBSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xuICB9XG4gIGRyYXdSb3VuZGVkUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcbiAgICByZXR1cm4gdGhpcy5kcmF3U2hhcGUobmV3IFJvdW5kZWRSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSk7XG4gIH1cbiAgZHJhd0NpcmNsZSh4LCB5LCByYWRpdXMpIHtcbiAgICByZXR1cm4gdGhpcy5kcmF3U2hhcGUobmV3IENpcmNsZSh4LCB5LCByYWRpdXMpKTtcbiAgfVxuICBkcmF3RWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhd1NoYXBlKG5ldyBFbGxpcHNlKHgsIHksIHdpZHRoLCBoZWlnaHQpKTtcbiAgfVxuICBkcmF3UG9seWdvbiguLi5wYXRoKSB7XG4gICAgbGV0IHBvaW50cztcbiAgICBsZXQgY2xvc2VTdHJva2UgPSB0cnVlO1xuICAgIGNvbnN0IHBvbHkgPSBwYXRoWzBdO1xuICAgIGlmIChwb2x5LnBvaW50cykge1xuICAgICAgY2xvc2VTdHJva2UgPSBwb2x5LmNsb3NlU3Ryb2tlO1xuICAgICAgcG9pbnRzID0gcG9seS5wb2ludHM7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhdGhbMF0pKSB7XG4gICAgICBwb2ludHMgPSBwYXRoWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludHMgPSBwYXRoO1xuICAgIH1cbiAgICBjb25zdCBzaGFwZSA9IG5ldyBQb2x5Z29uKHBvaW50cyk7XG4gICAgc2hhcGUuY2xvc2VTdHJva2UgPSBjbG9zZVN0cm9rZTtcbiAgICB0aGlzLmRyYXdTaGFwZShzaGFwZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZHJhd1NoYXBlKHNoYXBlKSB7XG4gICAgaWYgKCF0aGlzLl9ob2xlTW9kZSkge1xuICAgICAgdGhpcy5fZ2VvbWV0cnkuZHJhd1NoYXBlKHNoYXBlLCB0aGlzLl9maWxsU3R5bGUuY2xvbmUoKSwgdGhpcy5fbGluZVN0eWxlLmNsb25lKCksIHRoaXMuX21hdHJpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2dlb21ldHJ5LmRyYXdIb2xlKHNoYXBlLCB0aGlzLl9tYXRyaXgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9nZW9tZXRyeS5jbGVhcigpO1xuICAgIHRoaXMuX2xpbmVTdHlsZS5yZXNldCgpO1xuICAgIHRoaXMuX2ZpbGxTdHlsZS5yZXNldCgpO1xuICAgIHRoaXMuX2JvdW5kc0lEKys7XG4gICAgdGhpcy5fbWF0cml4ID0gbnVsbDtcbiAgICB0aGlzLl9ob2xlTW9kZSA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlzRmFzdFJlY3QoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2dlb21ldHJ5LmdyYXBoaWNzRGF0YTtcbiAgICByZXR1cm4gZGF0YS5sZW5ndGggPT09IDEgJiYgZGF0YVswXS5zaGFwZS50eXBlID09PSBTSEFQRVMuUkVDVCAmJiAhZGF0YVswXS5tYXRyaXggJiYgIWRhdGFbMF0uaG9sZXMubGVuZ3RoICYmICEoZGF0YVswXS5saW5lU3R5bGUudmlzaWJsZSAmJiBkYXRhWzBdLmxpbmVTdHlsZS53aWR0aCk7XG4gIH1cbiAgX3JlbmRlcihyZW5kZXJlcikge1xuICAgIHRoaXMuZmluaXNoUG9seSgpO1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5fZ2VvbWV0cnk7XG4gICAgZ2VvbWV0cnkudXBkYXRlQmF0Y2hlcygpO1xuICAgIGlmIChnZW9tZXRyeS5iYXRjaGFibGUpIHtcbiAgICAgIGlmICh0aGlzLmJhdGNoRGlydHkgIT09IGdlb21ldHJ5LmJhdGNoRGlydHkpIHtcbiAgICAgICAgdGhpcy5fcG9wdWxhdGVCYXRjaGVzKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZW5kZXJCYXRjaGVkKHJlbmRlcmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVuZGVyZXIuYmF0Y2guZmx1c2goKTtcbiAgICAgIHRoaXMuX3JlbmRlckRpcmVjdChyZW5kZXJlcik7XG4gICAgfVxuICB9XG4gIF9wb3B1bGF0ZUJhdGNoZXMoKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLl9nZW9tZXRyeTtcbiAgICBjb25zdCBibGVuZE1vZGUgPSB0aGlzLmJsZW5kTW9kZTtcbiAgICBjb25zdCBsZW4gPSBnZW9tZXRyeS5iYXRjaGVzLmxlbmd0aDtcbiAgICB0aGlzLmJhdGNoVGludCA9IC0xO1xuICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gLTE7XG4gICAgdGhpcy5iYXRjaERpcnR5ID0gZ2VvbWV0cnkuYmF0Y2hEaXJ0eTtcbiAgICB0aGlzLmJhdGNoZXMubGVuZ3RoID0gbGVuO1xuICAgIHRoaXMudmVydGV4RGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZ2VvbWV0cnkucG9pbnRzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBnSSA9IGdlb21ldHJ5LmJhdGNoZXNbaV07XG4gICAgICBjb25zdCBjb2xvciA9IGdJLnN0eWxlLmNvbG9yO1xuICAgICAgY29uc3QgdmVydGV4RGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy52ZXJ0ZXhEYXRhLmJ1ZmZlciwgZ0kuYXR0cmliU3RhcnQgKiA0ICogMiwgZ0kuYXR0cmliU2l6ZSAqIDIpO1xuICAgICAgY29uc3QgdXZzID0gbmV3IEZsb2F0MzJBcnJheShnZW9tZXRyeS51dnNGbG9hdDMyLmJ1ZmZlciwgZ0kuYXR0cmliU3RhcnQgKiA0ICogMiwgZ0kuYXR0cmliU2l6ZSAqIDIpO1xuICAgICAgY29uc3QgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShnZW9tZXRyeS5pbmRpY2VzVWludDE2LmJ1ZmZlciwgZ0kuc3RhcnQgKiAyLCBnSS5zaXplKTtcbiAgICAgIGNvbnN0IGJhdGNoID0ge1xuICAgICAgICB2ZXJ0ZXhEYXRhLFxuICAgICAgICBibGVuZE1vZGUsXG4gICAgICAgIGluZGljZXMsXG4gICAgICAgIHV2cyxcbiAgICAgICAgX2JhdGNoUkdCOiBDb2xvci5zaGFyZWQuc2V0VmFsdWUoY29sb3IpLnRvUmdiQXJyYXkoKSxcbiAgICAgICAgX3RpbnRSR0I6IGNvbG9yLFxuICAgICAgICBfdGV4dHVyZTogZ0kuc3R5bGUudGV4dHVyZSxcbiAgICAgICAgYWxwaGE6IGdJLnN0eWxlLmFscGhhLFxuICAgICAgICB3b3JsZEFscGhhOiAxXG4gICAgICB9O1xuICAgICAgdGhpcy5iYXRjaGVzW2ldID0gYmF0Y2g7XG4gICAgfVxuICB9XG4gIF9yZW5kZXJCYXRjaGVkKHJlbmRlcmVyKSB7XG4gICAgaWYgKCF0aGlzLmJhdGNoZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlbmRlcmVyLmJhdGNoLnNldE9iamVjdFJlbmRlcmVyKHJlbmRlcmVyLnBsdWdpbnNbdGhpcy5wbHVnaW5OYW1lXSk7XG4gICAgdGhpcy5jYWxjdWxhdGVWZXJ0aWNlcygpO1xuICAgIHRoaXMuY2FsY3VsYXRlVGludHMoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuYmF0Y2hlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGJhdGNoID0gdGhpcy5iYXRjaGVzW2ldO1xuICAgICAgYmF0Y2gud29ybGRBbHBoYSA9IHRoaXMud29ybGRBbHBoYSAqIGJhdGNoLmFscGhhO1xuICAgICAgcmVuZGVyZXIucGx1Z2luc1t0aGlzLnBsdWdpbk5hbWVdLnJlbmRlcihiYXRjaCk7XG4gICAgfVxuICB9XG4gIF9yZW5kZXJEaXJlY3QocmVuZGVyZXIpIHtcbiAgICBjb25zdCBzaGFkZXIgPSB0aGlzLl9yZXNvbHZlRGlyZWN0U2hhZGVyKHJlbmRlcmVyKTtcbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuX2dlb21ldHJ5O1xuICAgIGNvbnN0IHdvcmxkQWxwaGEgPSB0aGlzLndvcmxkQWxwaGE7XG4gICAgY29uc3QgdW5pZm9ybXMgPSBzaGFkZXIudW5pZm9ybXM7XG4gICAgY29uc3QgZHJhd0NhbGxzID0gZ2VvbWV0cnkuZHJhd0NhbGxzO1xuICAgIHVuaWZvcm1zLnRyYW5zbGF0aW9uTWF0cml4ID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gICAgQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHRoaXMuX3RpbnRDb2xvcikucHJlbXVsdGlwbHkod29ybGRBbHBoYSkudG9BcnJheSh1bmlmb3Jtcy50aW50KTtcbiAgICByZW5kZXJlci5zaGFkZXIuYmluZChzaGFkZXIpO1xuICAgIHJlbmRlcmVyLmdlb21ldHJ5LmJpbmQoZ2VvbWV0cnksIHNoYWRlcik7XG4gICAgcmVuZGVyZXIuc3RhdGUuc2V0KHRoaXMuc3RhdGUpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gZHJhd0NhbGxzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5fcmVuZGVyRHJhd0NhbGxEaXJlY3QocmVuZGVyZXIsIGdlb21ldHJ5LmRyYXdDYWxsc1tpXSk7XG4gICAgfVxuICB9XG4gIF9yZW5kZXJEcmF3Q2FsbERpcmVjdChyZW5kZXJlciwgZHJhd0NhbGwpIHtcbiAgICBjb25zdCB7IHRleEFycmF5LCB0eXBlLCBzaXplLCBzdGFydCB9ID0gZHJhd0NhbGw7XG4gICAgY29uc3QgZ3JvdXBUZXh0dXJlQ291bnQgPSB0ZXhBcnJheS5jb3VudDtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdyb3VwVGV4dHVyZUNvdW50OyBqKyspIHtcbiAgICAgIHJlbmRlcmVyLnRleHR1cmUuYmluZCh0ZXhBcnJheS5lbGVtZW50c1tqXSwgaik7XG4gICAgfVxuICAgIHJlbmRlcmVyLmdlb21ldHJ5LmRyYXcodHlwZSwgc2l6ZSwgc3RhcnQpO1xuICB9XG4gIF9yZXNvbHZlRGlyZWN0U2hhZGVyKHJlbmRlcmVyKSB7XG4gICAgbGV0IHNoYWRlciA9IHRoaXMuc2hhZGVyO1xuICAgIGNvbnN0IHBsdWdpbk5hbWUgPSB0aGlzLnBsdWdpbk5hbWU7XG4gICAgaWYgKCFzaGFkZXIpIHtcbiAgICAgIGlmICghREVGQVVMVF9TSEFERVJTW3BsdWdpbk5hbWVdKSB7XG4gICAgICAgIGNvbnN0IHsgbWF4VGV4dHVyZXMgfSA9IHJlbmRlcmVyLnBsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgICAgIGNvbnN0IHNhbXBsZVZhbHVlcyA9IG5ldyBJbnQzMkFycmF5KG1heFRleHR1cmVzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhUZXh0dXJlczsgaSsrKSB7XG4gICAgICAgICAgc2FtcGxlVmFsdWVzW2ldID0gaTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAgICAgICAgICB0aW50OiBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxLCAxXSksXG4gICAgICAgICAgdHJhbnNsYXRpb25NYXRyaXg6IG5ldyBNYXRyaXgoKSxcbiAgICAgICAgICBkZWZhdWx0OiBVbmlmb3JtR3JvdXAuZnJvbSh7IHVTYW1wbGVyczogc2FtcGxlVmFsdWVzIH0sIHRydWUpXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSByZW5kZXJlci5wbHVnaW5zW3BsdWdpbk5hbWVdLl9zaGFkZXIucHJvZ3JhbTtcbiAgICAgICAgREVGQVVMVF9TSEFERVJTW3BsdWdpbk5hbWVdID0gbmV3IFNoYWRlcihwcm9ncmFtLCB1bmlmb3Jtcyk7XG4gICAgICB9XG4gICAgICBzaGFkZXIgPSBERUZBVUxUX1NIQURFUlNbcGx1Z2luTmFtZV07XG4gICAgfVxuICAgIHJldHVybiBzaGFkZXI7XG4gIH1cbiAgX2NhbGN1bGF0ZUJvdW5kcygpIHtcbiAgICB0aGlzLmZpbmlzaFBvbHkoKTtcbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuX2dlb21ldHJ5O1xuICAgIGlmICghZ2VvbWV0cnkuZ3JhcGhpY3NEYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IG1pblgsIG1pblksIG1heFgsIG1heFkgfSA9IGdlb21ldHJ5LmJvdW5kcztcbiAgICB0aGlzLl9ib3VuZHMuYWRkRnJhbWUodGhpcy50cmFuc2Zvcm0sIG1pblgsIG1pblksIG1heFgsIG1heFkpO1xuICB9XG4gIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcbiAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgX0dyYXBoaWNzLl9URU1QX1BPSU5UKTtcbiAgICByZXR1cm4gdGhpcy5fZ2VvbWV0cnkuY29udGFpbnNQb2ludChfR3JhcGhpY3MuX1RFTVBfUE9JTlQpO1xuICB9XG4gIGNhbGN1bGF0ZVRpbnRzKCkge1xuICAgIGlmICh0aGlzLmJhdGNoVGludCAhPT0gdGhpcy50aW50KSB7XG4gICAgICB0aGlzLmJhdGNoVGludCA9IHRoaXMuX3RpbnRDb2xvci50b051bWJlcigpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLmJhdGNoZXNbaV07XG4gICAgICAgIGJhdGNoLl90aW50UkdCID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHRoaXMuX3RpbnRDb2xvcikubXVsdGlwbHkoYmF0Y2guX2JhdGNoUkdCKS50b0xpdHRsZUVuZGlhbk51bWJlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxjdWxhdGVWZXJ0aWNlcygpIHtcbiAgICBjb25zdCB3dElEID0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQ7XG4gICAgaWYgKHRoaXMuX3RyYW5zZm9ybUlEID09PSB3dElEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gd3RJRDtcbiAgICBjb25zdCB3dCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgIGNvbnN0IGEgPSB3dC5hO1xuICAgIGNvbnN0IGIgPSB3dC5iO1xuICAgIGNvbnN0IGMgPSB3dC5jO1xuICAgIGNvbnN0IGQgPSB3dC5kO1xuICAgIGNvbnN0IHR4ID0gd3QudHg7XG4gICAgY29uc3QgdHkgPSB3dC50eTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZ2VvbWV0cnkucG9pbnRzO1xuICAgIGNvbnN0IHZlcnRleERhdGEgPSB0aGlzLnZlcnRleERhdGE7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHggPSBkYXRhW2ldO1xuICAgICAgY29uc3QgeSA9IGRhdGFbaSArIDFdO1xuICAgICAgdmVydGV4RGF0YVtjb3VudCsrXSA9IGEgKiB4ICsgYyAqIHkgKyB0eDtcbiAgICAgIHZlcnRleERhdGFbY291bnQrK10gPSBkICogeSArIGIgKiB4ICsgdHk7XG4gICAgfVxuICB9XG4gIGNsb3NlUGF0aCgpIHtcbiAgICBjb25zdCBjdXJyZW50UGF0aCA9IHRoaXMuY3VycmVudFBhdGg7XG4gICAgaWYgKGN1cnJlbnRQYXRoKSB7XG4gICAgICBjdXJyZW50UGF0aC5jbG9zZVN0cm9rZSA9IHRydWU7XG4gICAgICB0aGlzLmZpbmlzaFBvbHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0TWF0cml4KG1hdHJpeCkge1xuICAgIHRoaXMuX21hdHJpeCA9IG1hdHJpeDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBiZWdpbkhvbGUoKSB7XG4gICAgdGhpcy5maW5pc2hQb2x5KCk7XG4gICAgdGhpcy5faG9sZU1vZGUgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGVuZEhvbGUoKSB7XG4gICAgdGhpcy5maW5pc2hQb2x5KCk7XG4gICAgdGhpcy5faG9sZU1vZGUgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICB0aGlzLl9nZW9tZXRyeS5yZWZDb3VudC0tO1xuICAgIGlmICh0aGlzLl9nZW9tZXRyeS5yZWZDb3VudCA9PT0gMCkge1xuICAgICAgdGhpcy5fZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLl9tYXRyaXggPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xuICAgIHRoaXMuX2xpbmVTdHlsZS5kZXN0cm95KCk7XG4gICAgdGhpcy5fbGluZVN0eWxlID0gbnVsbDtcbiAgICB0aGlzLl9maWxsU3R5bGUuZGVzdHJveSgpO1xuICAgIHRoaXMuX2ZpbGxTdHlsZSA9IG51bGw7XG4gICAgdGhpcy5fZ2VvbWV0cnkgPSBudWxsO1xuICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcbiAgICB0aGlzLnZlcnRleERhdGEgPSBudWxsO1xuICAgIHRoaXMuYmF0Y2hlcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuYmF0Y2hlcyA9IG51bGw7XG4gICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgfVxufTtcbmxldCBHcmFwaGljcyA9IF9HcmFwaGljcztcbkdyYXBoaWNzLmN1cnZlcyA9IGN1cnZlcztcbkdyYXBoaWNzLl9URU1QX1BPSU5UID0gbmV3IFBvaW50KCk7XG5cbmV4cG9ydCB7IEdyYXBoaWNzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaGljcy5tanMubWFwXG4iLCJpbXBvcnQgeyBGSUxMX0NPTU1BTkRTLCBCQVRDSF9QT09MLCBEUkFXX0NBTExfUE9PTCB9IGZyb20gJy4vdXRpbHMvaW5kZXgubWpzJztcbmV4cG9ydCB7IEdSQVBISUNTX0NVUlZFUywgTElORV9DQVAsIExJTkVfSk9JTiwgY3VydmVzIH0gZnJvbSAnLi9jb25zdC5tanMnO1xuZXhwb3J0IHsgR3JhcGhpY3MgfSBmcm9tICcuL0dyYXBoaWNzLm1qcyc7XG5leHBvcnQgeyBHcmFwaGljc0RhdGEgfSBmcm9tICcuL0dyYXBoaWNzRGF0YS5tanMnO1xuZXhwb3J0IHsgR3JhcGhpY3NHZW9tZXRyeSB9IGZyb20gJy4vR3JhcGhpY3NHZW9tZXRyeS5tanMnO1xuZXhwb3J0IHsgRmlsbFN0eWxlIH0gZnJvbSAnLi9zdHlsZXMvRmlsbFN0eWxlLm1qcyc7XG5leHBvcnQgeyBMaW5lU3R5bGUgfSBmcm9tICcuL3N0eWxlcy9MaW5lU3R5bGUubWpzJztcbmltcG9ydCB7IGJ1aWxkUG9seSB9IGZyb20gJy4vdXRpbHMvYnVpbGRQb2x5Lm1qcyc7XG5pbXBvcnQgeyBidWlsZENpcmNsZSB9IGZyb20gJy4vdXRpbHMvYnVpbGRDaXJjbGUubWpzJztcbmltcG9ydCB7IGJ1aWxkUmVjdGFuZ2xlIH0gZnJvbSAnLi91dGlscy9idWlsZFJlY3RhbmdsZS5tanMnO1xuaW1wb3J0IHsgYnVpbGRSb3VuZGVkUmVjdGFuZ2xlIH0gZnJvbSAnLi91dGlscy9idWlsZFJvdW5kZWRSZWN0YW5nbGUubWpzJztcbmltcG9ydCB7IGJ1aWxkTGluZSB9IGZyb20gJy4vdXRpbHMvYnVpbGRMaW5lLm1qcyc7XG5pbXBvcnQgeyBBcmNVdGlscyB9IGZyb20gJy4vdXRpbHMvQXJjVXRpbHMubWpzJztcbmltcG9ydCB7IEJlemllclV0aWxzIH0gZnJvbSAnLi91dGlscy9CZXppZXJVdGlscy5tanMnO1xuaW1wb3J0IHsgUXVhZHJhdGljVXRpbHMgfSBmcm9tICcuL3V0aWxzL1F1YWRyYXRpY1V0aWxzLm1qcyc7XG5pbXBvcnQgeyBCYXRjaFBhcnQgfSBmcm9tICcuL3V0aWxzL0JhdGNoUGFydC5tanMnO1xuXG5jb25zdCBncmFwaGljc1V0aWxzID0ge1xuICBidWlsZFBvbHksXG4gIGJ1aWxkQ2lyY2xlLFxuICBidWlsZFJlY3RhbmdsZSxcbiAgYnVpbGRSb3VuZGVkUmVjdGFuZ2xlLFxuICBidWlsZExpbmUsXG4gIEFyY1V0aWxzLFxuICBCZXppZXJVdGlscyxcbiAgUXVhZHJhdGljVXRpbHMsXG4gIEJhdGNoUGFydCxcbiAgRklMTF9DT01NQU5EUyxcbiAgQkFUQ0hfUE9PTCxcbiAgRFJBV19DQUxMX1BPT0xcbn07XG5cbmV4cG9ydCB7IGdyYXBoaWNzVXRpbHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImNsYXNzIE1lc2hCYXRjaFV2cyB7XG4gIGNvbnN0cnVjdG9yKHV2QnVmZmVyLCB1dk1hdHJpeCkge1xuICAgIHRoaXMudXZCdWZmZXIgPSB1dkJ1ZmZlcjtcbiAgICB0aGlzLnV2TWF0cml4ID0gdXZNYXRyaXg7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICB0aGlzLl9idWZmZXJVcGRhdGVJZCA9IC0xO1xuICAgIHRoaXMuX3RleHR1cmVVcGRhdGVJZCA9IC0xO1xuICAgIHRoaXMuX3VwZGF0ZUlEID0gMDtcbiAgfVxuICB1cGRhdGUoZm9yY2VVcGRhdGUpIHtcbiAgICBpZiAoIWZvcmNlVXBkYXRlICYmIHRoaXMuX2J1ZmZlclVwZGF0ZUlkID09PSB0aGlzLnV2QnVmZmVyLl91cGRhdGVJRCAmJiB0aGlzLl90ZXh0dXJlVXBkYXRlSWQgPT09IHRoaXMudXZNYXRyaXguX3VwZGF0ZUlEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2J1ZmZlclVwZGF0ZUlkID0gdGhpcy51dkJ1ZmZlci5fdXBkYXRlSUQ7XG4gICAgdGhpcy5fdGV4dHVyZVVwZGF0ZUlkID0gdGhpcy51dk1hdHJpeC5fdXBkYXRlSUQ7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMudXZCdWZmZXIuZGF0YTtcbiAgICBpZiAoIXRoaXMuZGF0YSB8fCB0aGlzLmRhdGEubGVuZ3RoICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgfVxuICAgIHRoaXMudXZNYXRyaXgubXVsdGlwbHlVdnMoZGF0YSwgdGhpcy5kYXRhKTtcbiAgICB0aGlzLl91cGRhdGVJRCsrO1xuICB9XG59XG5cbmV4cG9ydCB7IE1lc2hCYXRjaFV2cyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzaEJhdGNoVXZzLm1qcy5tYXBcbiIsImltcG9ydCB7IFBvaW50LCBQb2x5Z29uLCBTdGF0ZSwgc2V0dGluZ3MsIERSQVdfTU9ERVMgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJ0BwaXhpL2Rpc3BsYXknO1xuaW1wb3J0IHsgTWVzaEJhdGNoVXZzIH0gZnJvbSAnLi9NZXNoQmF0Y2hVdnMubWpzJztcblxuY29uc3QgdGVtcFBvaW50ID0gbmV3IFBvaW50KCk7XG5jb25zdCB0ZW1wUG9seWdvbiA9IG5ldyBQb2x5Z29uKCk7XG5jb25zdCBfTWVzaCA9IGNsYXNzIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3IoZ2VvbWV0cnksIHNoYWRlciwgc3RhdGUsIGRyYXdNb2RlID0gRFJBV19NT0RFUy5UUklBTkdMRVMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICB0aGlzLnNoYWRlciA9IHNoYWRlcjtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGUgfHwgU3RhdGUuZm9yMmQoKTtcbiAgICB0aGlzLmRyYXdNb2RlID0gZHJhd01vZGU7XG4gICAgdGhpcy5zdGFydCA9IDA7XG4gICAgdGhpcy5zaXplID0gMDtcbiAgICB0aGlzLnV2cyA9IG51bGw7XG4gICAgdGhpcy5pbmRpY2VzID0gbnVsbDtcbiAgICB0aGlzLnZlcnRleERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDEpO1xuICAgIHRoaXMudmVydGV4RGlydHkgPSAtMTtcbiAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IC0xO1xuICAgIHRoaXMuX3JvdW5kUGl4ZWxzID0gc2V0dGluZ3MuUk9VTkRfUElYRUxTO1xuICAgIHRoaXMuYmF0Y2hVdnMgPSBudWxsO1xuICB9XG4gIGdldCBnZW9tZXRyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2VvbWV0cnk7XG4gIH1cbiAgc2V0IGdlb21ldHJ5KHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2dlb21ldHJ5ID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZ2VvbWV0cnkpIHtcbiAgICAgIHRoaXMuX2dlb21ldHJ5LnJlZkNvdW50LS07XG4gICAgICBpZiAodGhpcy5fZ2VvbWV0cnkucmVmQ291bnQgPT09IDApIHtcbiAgICAgICAgdGhpcy5fZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9nZW9tZXRyeSA9IHZhbHVlO1xuICAgIGlmICh0aGlzLl9nZW9tZXRyeSkge1xuICAgICAgdGhpcy5fZ2VvbWV0cnkucmVmQ291bnQrKztcbiAgICB9XG4gICAgdGhpcy52ZXJ0ZXhEaXJ0eSA9IC0xO1xuICB9XG4gIGdldCB1dkJ1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeS5idWZmZXJzWzFdO1xuICB9XG4gIGdldCB2ZXJ0aWNlc0J1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeS5idWZmZXJzWzBdO1xuICB9XG4gIHNldCBtYXRlcmlhbCh2YWx1ZSkge1xuICAgIHRoaXMuc2hhZGVyID0gdmFsdWU7XG4gIH1cbiAgZ2V0IG1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLnNoYWRlcjtcbiAgfVxuICBzZXQgYmxlbmRNb2RlKHZhbHVlKSB7XG4gICAgdGhpcy5zdGF0ZS5ibGVuZE1vZGUgPSB2YWx1ZTtcbiAgfVxuICBnZXQgYmxlbmRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmJsZW5kTW9kZTtcbiAgfVxuICBzZXQgcm91bmRQaXhlbHModmFsdWUpIHtcbiAgICBpZiAodGhpcy5fcm91bmRQaXhlbHMgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IC0xO1xuICAgIH1cbiAgICB0aGlzLl9yb3VuZFBpeGVscyA9IHZhbHVlO1xuICB9XG4gIGdldCByb3VuZFBpeGVscygpIHtcbiAgICByZXR1cm4gdGhpcy5fcm91bmRQaXhlbHM7XG4gIH1cbiAgZ2V0IHRpbnQoKSB7XG4gICAgcmV0dXJuIFwidGludFwiIGluIHRoaXMuc2hhZGVyID8gdGhpcy5zaGFkZXIudGludCA6IG51bGw7XG4gIH1cbiAgc2V0IHRpbnQodmFsdWUpIHtcbiAgICB0aGlzLnNoYWRlci50aW50ID0gdmFsdWU7XG4gIH1cbiAgZ2V0IHRpbnRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zaGFkZXIudGludFZhbHVlO1xuICB9XG4gIGdldCB0ZXh0dXJlKCkge1xuICAgIHJldHVybiBcInRleHR1cmVcIiBpbiB0aGlzLnNoYWRlciA/IHRoaXMuc2hhZGVyLnRleHR1cmUgOiBudWxsO1xuICB9XG4gIHNldCB0ZXh0dXJlKHZhbHVlKSB7XG4gICAgdGhpcy5zaGFkZXIudGV4dHVyZSA9IHZhbHVlO1xuICB9XG4gIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMuZ2VvbWV0cnkuYnVmZmVyc1swXS5kYXRhO1xuICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuc2hhZGVyO1xuICAgIGlmIChzaGFkZXIuYmF0Y2hhYmxlICYmIHRoaXMuZHJhd01vZGUgPT09IERSQVdfTU9ERVMuVFJJQU5HTEVTICYmIHZlcnRpY2VzLmxlbmd0aCA8IF9NZXNoLkJBVENIQUJMRV9TSVpFICogMikge1xuICAgICAgdGhpcy5fcmVuZGVyVG9CYXRjaChyZW5kZXJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlbmRlckRlZmF1bHQocmVuZGVyZXIpO1xuICAgIH1cbiAgfVxuICBfcmVuZGVyRGVmYXVsdChyZW5kZXJlcikge1xuICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuc2hhZGVyO1xuICAgIHNoYWRlci5hbHBoYSA9IHRoaXMud29ybGRBbHBoYTtcbiAgICBpZiAoc2hhZGVyLnVwZGF0ZSkge1xuICAgICAgc2hhZGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgICByZW5kZXJlci5iYXRjaC5mbHVzaCgpO1xuICAgIHNoYWRlci51bmlmb3Jtcy50cmFuc2xhdGlvbk1hdHJpeCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLnRvQXJyYXkodHJ1ZSk7XG4gICAgcmVuZGVyZXIuc2hhZGVyLmJpbmQoc2hhZGVyKTtcbiAgICByZW5kZXJlci5zdGF0ZS5zZXQodGhpcy5zdGF0ZSk7XG4gICAgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZCh0aGlzLmdlb21ldHJ5LCBzaGFkZXIpO1xuICAgIHJlbmRlcmVyLmdlb21ldHJ5LmRyYXcodGhpcy5kcmF3TW9kZSwgdGhpcy5zaXplLCB0aGlzLnN0YXJ0LCB0aGlzLmdlb21ldHJ5Lmluc3RhbmNlQ291bnQpO1xuICB9XG4gIF9yZW5kZXJUb0JhdGNoKHJlbmRlcmVyKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuc2hhZGVyO1xuICAgIGlmIChzaGFkZXIudXZNYXRyaXgpIHtcbiAgICAgIHNoYWRlci51dk1hdHJpeC51cGRhdGUoKTtcbiAgICAgIHRoaXMuY2FsY3VsYXRlVXZzKCk7XG4gICAgfVxuICAgIHRoaXMuY2FsY3VsYXRlVmVydGljZXMoKTtcbiAgICB0aGlzLmluZGljZXMgPSBnZW9tZXRyeS5pbmRleEJ1ZmZlci5kYXRhO1xuICAgIHRoaXMuX3RpbnRSR0IgPSBzaGFkZXIuX3RpbnRSR0I7XG4gICAgdGhpcy5fdGV4dHVyZSA9IHNoYWRlci50ZXh0dXJlO1xuICAgIGNvbnN0IHBsdWdpbk5hbWUgPSB0aGlzLm1hdGVyaWFsLnBsdWdpbk5hbWU7XG4gICAgcmVuZGVyZXIuYmF0Y2guc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2luc1twbHVnaW5OYW1lXSk7XG4gICAgcmVuZGVyZXIucGx1Z2luc1twbHVnaW5OYW1lXS5yZW5kZXIodGhpcyk7XG4gIH1cbiAgY2FsY3VsYXRlVmVydGljZXMoKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgIGNvbnN0IHZlcnRpY2VzQnVmZmVyID0gZ2VvbWV0cnkuYnVmZmVyc1swXTtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IHZlcnRpY2VzQnVmZmVyLmRhdGE7XG4gICAgY29uc3QgdmVydGV4RGlydHlJZCA9IHZlcnRpY2VzQnVmZmVyLl91cGRhdGVJRDtcbiAgICBpZiAodmVydGV4RGlydHlJZCA9PT0gdGhpcy52ZXJ0ZXhEaXJ0eSAmJiB0aGlzLl90cmFuc2Zvcm1JRCA9PT0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdHJhbnNmb3JtSUQgPSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRDtcbiAgICBpZiAodGhpcy52ZXJ0ZXhEYXRhLmxlbmd0aCAhPT0gdmVydGljZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnZlcnRleERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRpY2VzLmxlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IHd0ID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gICAgY29uc3QgYSA9IHd0LmE7XG4gICAgY29uc3QgYiA9IHd0LmI7XG4gICAgY29uc3QgYyA9IHd0LmM7XG4gICAgY29uc3QgZCA9IHd0LmQ7XG4gICAgY29uc3QgdHggPSB3dC50eDtcbiAgICBjb25zdCB0eSA9IHd0LnR5O1xuICAgIGNvbnN0IHZlcnRleERhdGEgPSB0aGlzLnZlcnRleERhdGE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0ZXhEYXRhLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgY29uc3QgeCA9IHZlcnRpY2VzW2kgKiAyXTtcbiAgICAgIGNvbnN0IHkgPSB2ZXJ0aWNlc1tpICogMiArIDFdO1xuICAgICAgdmVydGV4RGF0YVtpICogMl0gPSBhICogeCArIGMgKiB5ICsgdHg7XG4gICAgICB2ZXJ0ZXhEYXRhW2kgKiAyICsgMV0gPSBiICogeCArIGQgKiB5ICsgdHk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9yb3VuZFBpeGVscykge1xuICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IHNldHRpbmdzLlJFU09MVVRJT047XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRleERhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmVydGV4RGF0YVtpXSA9IE1hdGgucm91bmQodmVydGV4RGF0YVtpXSAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy52ZXJ0ZXhEaXJ0eSA9IHZlcnRleERpcnR5SWQ7XG4gIH1cbiAgY2FsY3VsYXRlVXZzKCkge1xuICAgIGNvbnN0IGdlb21VdnMgPSB0aGlzLmdlb21ldHJ5LmJ1ZmZlcnNbMV07XG4gICAgY29uc3Qgc2hhZGVyID0gdGhpcy5zaGFkZXI7XG4gICAgaWYgKCFzaGFkZXIudXZNYXRyaXguaXNTaW1wbGUpIHtcbiAgICAgIGlmICghdGhpcy5iYXRjaFV2cykge1xuICAgICAgICB0aGlzLmJhdGNoVXZzID0gbmV3IE1lc2hCYXRjaFV2cyhnZW9tVXZzLCBzaGFkZXIudXZNYXRyaXgpO1xuICAgICAgfVxuICAgICAgdGhpcy5iYXRjaFV2cy51cGRhdGUoKTtcbiAgICAgIHRoaXMudXZzID0gdGhpcy5iYXRjaFV2cy5kYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnV2cyA9IGdlb21VdnMuZGF0YTtcbiAgICB9XG4gIH1cbiAgX2NhbGN1bGF0ZUJvdW5kcygpIHtcbiAgICB0aGlzLmNhbGN1bGF0ZVZlcnRpY2VzKCk7XG4gICAgdGhpcy5fYm91bmRzLmFkZFZlcnRleERhdGEodGhpcy52ZXJ0ZXhEYXRhLCAwLCB0aGlzLnZlcnRleERhdGEubGVuZ3RoKTtcbiAgfVxuICBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgaWYgKCF0aGlzLmdldEJvdW5kcygpLmNvbnRhaW5zKHBvaW50LngsIHBvaW50LnkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKHBvaW50LCB0ZW1wUG9pbnQpO1xuICAgIGNvbnN0IHZlcnRpY2VzID0gdGhpcy5nZW9tZXRyeS5nZXRCdWZmZXIoXCJhVmVydGV4UG9zaXRpb25cIikuZGF0YTtcbiAgICBjb25zdCBwb2ludHMgPSB0ZW1wUG9seWdvbi5wb2ludHM7XG4gICAgY29uc3QgaW5kaWNlcyA9IHRoaXMuZ2VvbWV0cnkuZ2V0SW5kZXgoKS5kYXRhO1xuICAgIGNvbnN0IGxlbiA9IGluZGljZXMubGVuZ3RoO1xuICAgIGNvbnN0IHN0ZXAgPSB0aGlzLmRyYXdNb2RlID09PSA0ID8gMyA6IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgKyAyIDwgbGVuOyBpICs9IHN0ZXApIHtcbiAgICAgIGNvbnN0IGluZDAgPSBpbmRpY2VzW2ldICogMjtcbiAgICAgIGNvbnN0IGluZDEgPSBpbmRpY2VzW2kgKyAxXSAqIDI7XG4gICAgICBjb25zdCBpbmQyID0gaW5kaWNlc1tpICsgMl0gKiAyO1xuICAgICAgcG9pbnRzWzBdID0gdmVydGljZXNbaW5kMF07XG4gICAgICBwb2ludHNbMV0gPSB2ZXJ0aWNlc1tpbmQwICsgMV07XG4gICAgICBwb2ludHNbMl0gPSB2ZXJ0aWNlc1tpbmQxXTtcbiAgICAgIHBvaW50c1szXSA9IHZlcnRpY2VzW2luZDEgKyAxXTtcbiAgICAgIHBvaW50c1s0XSA9IHZlcnRpY2VzW2luZDJdO1xuICAgICAgcG9pbnRzWzVdID0gdmVydGljZXNbaW5kMiArIDFdO1xuICAgICAgaWYgKHRlbXBQb2x5Z29uLmNvbnRhaW5zKHRlbXBQb2ludC54LCB0ZW1wUG9pbnQueSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xuICAgIGlmICh0aGlzLl9jYWNoZWRUZXh0dXJlKSB7XG4gICAgICB0aGlzLl9jYWNoZWRUZXh0dXJlLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX2NhY2hlZFRleHR1cmUgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmdlb21ldHJ5ID0gbnVsbDtcbiAgICB0aGlzLnNoYWRlciA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgdGhpcy51dnMgPSBudWxsO1xuICAgIHRoaXMuaW5kaWNlcyA9IG51bGw7XG4gICAgdGhpcy52ZXJ0ZXhEYXRhID0gbnVsbDtcbiAgfVxufTtcbmxldCBNZXNoID0gX01lc2g7XG5NZXNoLkJBVENIQUJMRV9TSVpFID0gMTAwO1xuXG5leHBvcnQgeyBNZXNoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXNoLm1qcy5tYXBcbiIsImltcG9ydCB7IEdlb21ldHJ5LCBCdWZmZXIsIFRZUEVTIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmNsYXNzIE1lc2hHZW9tZXRyeSBleHRlbmRzIEdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3IodmVydGljZXMsIHV2cywgaW5kZXgpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHZlcnRpY2VzQnVmZmVyID0gbmV3IEJ1ZmZlcih2ZXJ0aWNlcyk7XG4gICAgY29uc3QgdXZzQnVmZmVyID0gbmV3IEJ1ZmZlcih1dnMsIHRydWUpO1xuICAgIGNvbnN0IGluZGV4QnVmZmVyID0gbmV3IEJ1ZmZlcihpbmRleCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgdGhpcy5hZGRBdHRyaWJ1dGUoXCJhVmVydGV4UG9zaXRpb25cIiwgdmVydGljZXNCdWZmZXIsIDIsIGZhbHNlLCBUWVBFUy5GTE9BVCkuYWRkQXR0cmlidXRlKFwiYVRleHR1cmVDb29yZFwiLCB1dnNCdWZmZXIsIDIsIGZhbHNlLCBUWVBFUy5GTE9BVCkuYWRkSW5kZXgoaW5kZXhCdWZmZXIpO1xuICAgIHRoaXMuX3VwZGF0ZUlkID0gLTE7XG4gIH1cbiAgZ2V0IHZlcnRleERpcnR5SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyc1swXS5fdXBkYXRlSUQ7XG4gIH1cbn1cblxuZXhwb3J0IHsgTWVzaEdlb21ldHJ5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXNoR2VvbWV0cnkubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHZlYzQgdUNvbG9yO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSAqIHVDb2xvcjtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGZyYWdtZW50IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc2gubWpzLm1hcFxuIiwidmFyIHZlcnRleCA9IFwiYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxudW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0MyB1VGV4dHVyZU1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxuXFxuICAgIHZUZXh0dXJlQ29vcmQgPSAodVRleHR1cmVNYXRyaXggKiB2ZWMzKGFUZXh0dXJlQ29vcmQsIDEuMCkpLnh5O1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgdmVydGV4IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc2gyLm1qcy5tYXBcbiIsImltcG9ydCB7IFNoYWRlciwgTWF0cml4LCBQcm9ncmFtLCBUZXh0dXJlTWF0cml4LCBDb2xvciB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gJy4vc2hhZGVyL21lc2gubWpzJztcbmltcG9ydCB2ZXJ0ZXggZnJvbSAnLi9zaGFkZXIvbWVzaDIubWpzJztcblxuY2xhc3MgTWVzaE1hdGVyaWFsIGV4dGVuZHMgU2hhZGVyIHtcbiAgY29uc3RydWN0b3IodVNhbXBsZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAgICAgIHVTYW1wbGVyLFxuICAgICAgYWxwaGE6IDEsXG4gICAgICB1VGV4dHVyZU1hdHJpeDogTWF0cml4LklERU5USVRZLFxuICAgICAgdUNvbG9yOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxLCAxXSlcbiAgICB9O1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHRpbnQ6IDE2Nzc3MjE1LFxuICAgICAgYWxwaGE6IDEsXG4gICAgICBwbHVnaW5OYW1lOiBcImJhdGNoXCJcbiAgICB9LCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy51bmlmb3Jtcykge1xuICAgICAgT2JqZWN0LmFzc2lnbih1bmlmb3Jtcywgb3B0aW9ucy51bmlmb3Jtcyk7XG4gICAgfVxuICAgIHN1cGVyKG9wdGlvbnMucHJvZ3JhbSB8fCBQcm9ncmFtLmZyb20odmVydGV4LCBmcmFnbWVudCksIHVuaWZvcm1zKTtcbiAgICB0aGlzLl9jb2xvckRpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy51dk1hdHJpeCA9IG5ldyBUZXh0dXJlTWF0cml4KHVTYW1wbGVyKTtcbiAgICB0aGlzLmJhdGNoYWJsZSA9IG9wdGlvbnMucHJvZ3JhbSA9PT0gdm9pZCAwO1xuICAgIHRoaXMucGx1Z2luTmFtZSA9IG9wdGlvbnMucGx1Z2luTmFtZTtcbiAgICB0aGlzLl90aW50Q29sb3IgPSBuZXcgQ29sb3Iob3B0aW9ucy50aW50KTtcbiAgICB0aGlzLl90aW50UkdCID0gdGhpcy5fdGludENvbG9yLnRvTGl0dGxlRW5kaWFuTnVtYmVyKCk7XG4gICAgdGhpcy5fY29sb3JEaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5hbHBoYSA9IG9wdGlvbnMuYWxwaGE7XG4gIH1cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudVNhbXBsZXI7XG4gIH1cbiAgc2V0IHRleHR1cmUodmFsdWUpIHtcbiAgICBpZiAodGhpcy51bmlmb3Jtcy51U2FtcGxlciAhPT0gdmFsdWUpIHtcbiAgICAgIGlmICghdGhpcy51bmlmb3Jtcy51U2FtcGxlci5iYXNlVGV4dHVyZS5hbHBoYU1vZGUgIT09ICF2YWx1ZS5iYXNlVGV4dHVyZS5hbHBoYU1vZGUpIHtcbiAgICAgICAgdGhpcy5fY29sb3JEaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLnVuaWZvcm1zLnVTYW1wbGVyID0gdmFsdWU7XG4gICAgICB0aGlzLnV2TWF0cml4LnRleHR1cmUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgc2V0IGFscGhhKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB0aGlzLl9hbHBoYSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9hbHBoYSA9IHZhbHVlO1xuICAgIHRoaXMuX2NvbG9yRGlydHkgPSB0cnVlO1xuICB9XG4gIGdldCBhbHBoYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWxwaGE7XG4gIH1cbiAgc2V0IHRpbnQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHRoaXMudGludClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl90aW50Q29sb3Iuc2V0VmFsdWUodmFsdWUpO1xuICAgIHRoaXMuX3RpbnRSR0IgPSB0aGlzLl90aW50Q29sb3IudG9MaXR0bGVFbmRpYW5OdW1iZXIoKTtcbiAgICB0aGlzLl9jb2xvckRpcnR5ID0gdHJ1ZTtcbiAgfVxuICBnZXQgdGludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGludENvbG9yLnZhbHVlO1xuICB9XG4gIGdldCB0aW50VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbnRDb2xvci50b051bWJlcigpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fY29sb3JEaXJ0eSkge1xuICAgICAgdGhpcy5fY29sb3JEaXJ0eSA9IGZhbHNlO1xuICAgICAgY29uc3QgYmFzZVRleHR1cmUgPSB0aGlzLnRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgICBjb25zdCBhcHBseVRvQ2hhbm5lbHMgPSBiYXNlVGV4dHVyZS5hbHBoYU1vZGU7XG4gICAgICBDb2xvci5zaGFyZWQuc2V0VmFsdWUodGhpcy5fdGludENvbG9yKS5wcmVtdWx0aXBseSh0aGlzLl9hbHBoYSwgYXBwbHlUb0NoYW5uZWxzKS50b0FycmF5KHRoaXMudW5pZm9ybXMudUNvbG9yKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudXZNYXRyaXgudXBkYXRlKCkpIHtcbiAgICAgIHRoaXMudW5pZm9ybXMudVRleHR1cmVNYXRyaXggPSB0aGlzLnV2TWF0cml4Lm1hcENvb3JkO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBNZXNoTWF0ZXJpYWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1lc2hNYXRlcmlhbC5tanMubWFwXG4iLCJleHBvcnQgeyBNZXNoIH0gZnJvbSAnLi9NZXNoLm1qcyc7XG5leHBvcnQgeyBNZXNoQmF0Y2hVdnMgfSBmcm9tICcuL01lc2hCYXRjaFV2cy5tanMnO1xuZXhwb3J0IHsgTWVzaEdlb21ldHJ5IH0gZnJvbSAnLi9NZXNoR2VvbWV0cnkubWpzJztcbmV4cG9ydCB7IE1lc2hNYXRlcmlhbCB9IGZyb20gJy4vTWVzaE1hdGVyaWFsLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBNZXNoR2VvbWV0cnkgfSBmcm9tICdAcGl4aS9tZXNoJztcblxuY2xhc3MgUGxhbmVHZW9tZXRyeSBleHRlbmRzIE1lc2hHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKHdpZHRoID0gMTAwLCBoZWlnaHQgPSAxMDAsIHNlZ1dpZHRoID0gMTAsIHNlZ0hlaWdodCA9IDEwKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNlZ1dpZHRoID0gc2VnV2lkdGg7XG4gICAgdGhpcy5zZWdIZWlnaHQgPSBzZWdIZWlnaHQ7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuYnVpbGQoKTtcbiAgfVxuICBidWlsZCgpIHtcbiAgICBjb25zdCB0b3RhbCA9IHRoaXMuc2VnV2lkdGggKiB0aGlzLnNlZ0hlaWdodDtcbiAgICBjb25zdCB2ZXJ0cyA9IFtdO1xuICAgIGNvbnN0IHV2cyA9IFtdO1xuICAgIGNvbnN0IGluZGljZXMgPSBbXTtcbiAgICBjb25zdCBzZWdtZW50c1ggPSB0aGlzLnNlZ1dpZHRoIC0gMTtcbiAgICBjb25zdCBzZWdtZW50c1kgPSB0aGlzLnNlZ0hlaWdodCAtIDE7XG4gICAgY29uc3Qgc2l6ZVggPSB0aGlzLndpZHRoIC8gc2VnbWVudHNYO1xuICAgIGNvbnN0IHNpemVZID0gdGhpcy5oZWlnaHQgLyBzZWdtZW50c1k7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKSB7XG4gICAgICBjb25zdCB4ID0gaSAlIHRoaXMuc2VnV2lkdGg7XG4gICAgICBjb25zdCB5ID0gaSAvIHRoaXMuc2VnV2lkdGggfCAwO1xuICAgICAgdmVydHMucHVzaCh4ICogc2l6ZVgsIHkgKiBzaXplWSk7XG4gICAgICB1dnMucHVzaCh4IC8gc2VnbWVudHNYLCB5IC8gc2VnbWVudHNZKTtcbiAgICB9XG4gICAgY29uc3QgdG90YWxTdWIgPSBzZWdtZW50c1ggKiBzZWdtZW50c1k7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbFN1YjsgaSsrKSB7XG4gICAgICBjb25zdCB4cG9zID0gaSAlIHNlZ21lbnRzWDtcbiAgICAgIGNvbnN0IHlwb3MgPSBpIC8gc2VnbWVudHNYIHwgMDtcbiAgICAgIGNvbnN0IHZhbHVlID0geXBvcyAqIHRoaXMuc2VnV2lkdGggKyB4cG9zO1xuICAgICAgY29uc3QgdmFsdWUyID0geXBvcyAqIHRoaXMuc2VnV2lkdGggKyB4cG9zICsgMTtcbiAgICAgIGNvbnN0IHZhbHVlMyA9ICh5cG9zICsgMSkgKiB0aGlzLnNlZ1dpZHRoICsgeHBvcztcbiAgICAgIGNvbnN0IHZhbHVlNCA9ICh5cG9zICsgMSkgKiB0aGlzLnNlZ1dpZHRoICsgeHBvcyArIDE7XG4gICAgICBpbmRpY2VzLnB1c2godmFsdWUsIHZhbHVlMiwgdmFsdWUzLCB2YWx1ZTIsIHZhbHVlNCwgdmFsdWUzKTtcbiAgICB9XG4gICAgdGhpcy5idWZmZXJzWzBdLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRzKTtcbiAgICB0aGlzLmJ1ZmZlcnNbMV0uZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkodXZzKTtcbiAgICB0aGlzLmluZGV4QnVmZmVyLmRhdGEgPSBuZXcgVWludDE2QXJyYXkoaW5kaWNlcyk7XG4gICAgdGhpcy5idWZmZXJzWzBdLnVwZGF0ZSgpO1xuICAgIHRoaXMuYnVmZmVyc1sxXS51cGRhdGUoKTtcbiAgICB0aGlzLmluZGV4QnVmZmVyLnVwZGF0ZSgpO1xuICB9XG59XG5cbmV4cG9ydCB7IFBsYW5lR2VvbWV0cnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBsYW5lR2VvbWV0cnkubWpzLm1hcFxuIiwiaW1wb3J0IHsgTWVzaEdlb21ldHJ5IH0gZnJvbSAnQHBpeGkvbWVzaCc7XG5cbmNsYXNzIFJvcGVHZW9tZXRyeSBleHRlbmRzIE1lc2hHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKHdpZHRoID0gMjAwLCBwb2ludHMsIHRleHR1cmVTY2FsZSA9IDApIHtcbiAgICBzdXBlcihuZXcgRmxvYXQzMkFycmF5KHBvaW50cy5sZW5ndGggKiA0KSwgbmV3IEZsb2F0MzJBcnJheShwb2ludHMubGVuZ3RoICogNCksIG5ldyBVaW50MTZBcnJheSgocG9pbnRzLmxlbmd0aCAtIDEpICogNikpO1xuICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgdGhpcy50ZXh0dXJlU2NhbGUgPSB0ZXh0dXJlU2NhbGU7XG4gICAgdGhpcy5idWlsZCgpO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gIH1cbiAgYnVpbGQoKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgaWYgKCFwb2ludHMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdmVydGV4QnVmZmVyID0gdGhpcy5nZXRCdWZmZXIoXCJhVmVydGV4UG9zaXRpb25cIik7XG4gICAgY29uc3QgdXZCdWZmZXIgPSB0aGlzLmdldEJ1ZmZlcihcImFUZXh0dXJlQ29vcmRcIik7XG4gICAgY29uc3QgaW5kZXhCdWZmZXIgPSB0aGlzLmdldEluZGV4KCk7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2ZXJ0ZXhCdWZmZXIuZGF0YS5sZW5ndGggLyA0ICE9PSBwb2ludHMubGVuZ3RoKSB7XG4gICAgICB2ZXJ0ZXhCdWZmZXIuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDQpO1xuICAgICAgdXZCdWZmZXIuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDQpO1xuICAgICAgaW5kZXhCdWZmZXIuZGF0YSA9IG5ldyBVaW50MTZBcnJheSgocG9pbnRzLmxlbmd0aCAtIDEpICogNik7XG4gICAgfVxuICAgIGNvbnN0IHV2cyA9IHV2QnVmZmVyLmRhdGE7XG4gICAgY29uc3QgaW5kaWNlcyA9IGluZGV4QnVmZmVyLmRhdGE7XG4gICAgdXZzWzBdID0gMDtcbiAgICB1dnNbMV0gPSAwO1xuICAgIHV2c1syXSA9IDA7XG4gICAgdXZzWzNdID0gMTtcbiAgICBsZXQgYW1vdW50ID0gMDtcbiAgICBsZXQgcHJldiA9IHBvaW50c1swXTtcbiAgICBjb25zdCB0ZXh0dXJlV2lkdGggPSB0aGlzLl93aWR0aCAqIHRoaXMudGV4dHVyZVNjYWxlO1xuICAgIGNvbnN0IHRvdGFsID0gcG9pbnRzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gaSAqIDQ7XG4gICAgICBpZiAodGhpcy50ZXh0dXJlU2NhbGUgPiAwKSB7XG4gICAgICAgIGNvbnN0IGR4ID0gcHJldi54IC0gcG9pbnRzW2ldLng7XG4gICAgICAgIGNvbnN0IGR5ID0gcHJldi55IC0gcG9pbnRzW2ldLnk7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgcHJldiA9IHBvaW50c1tpXTtcbiAgICAgICAgYW1vdW50ICs9IGRpc3RhbmNlIC8gdGV4dHVyZVdpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW1vdW50ID0gaSAvICh0b3RhbCAtIDEpO1xuICAgICAgfVxuICAgICAgdXZzW2luZGV4XSA9IGFtb3VudDtcbiAgICAgIHV2c1tpbmRleCArIDFdID0gMDtcbiAgICAgIHV2c1tpbmRleCArIDJdID0gYW1vdW50O1xuICAgICAgdXZzW2luZGV4ICsgM10gPSAxO1xuICAgIH1cbiAgICBsZXQgaW5kZXhDb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbCAtIDE7IGkrKykge1xuICAgICAgY29uc3QgaW5kZXggPSBpICogMjtcbiAgICAgIGluZGljZXNbaW5kZXhDb3VudCsrXSA9IGluZGV4O1xuICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXggKyAxO1xuICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXggKyAyO1xuICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXggKyAyO1xuICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXggKyAxO1xuICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXggKyAzO1xuICAgIH1cbiAgICB1dkJ1ZmZlci51cGRhdGUoKTtcbiAgICBpbmRleEJ1ZmZlci51cGRhdGUoKTtcbiAgICB0aGlzLnVwZGF0ZVZlcnRpY2VzKCk7XG4gIH1cbiAgdXBkYXRlVmVydGljZXMoKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBsYXN0UG9pbnQgPSBwb2ludHNbMF07XG4gICAgbGV0IG5leHRQb2ludDtcbiAgICBsZXQgcGVycFggPSAwO1xuICAgIGxldCBwZXJwWSA9IDA7XG4gICAgY29uc3QgdmVydGljZXMgPSB0aGlzLmJ1ZmZlcnNbMF0uZGF0YTtcbiAgICBjb25zdCB0b3RhbCA9IHBvaW50cy5sZW5ndGg7XG4gICAgY29uc3QgaGFsZldpZHRoID0gdGhpcy50ZXh0dXJlU2NhbGUgPiAwID8gdGhpcy50ZXh0dXJlU2NhbGUgKiB0aGlzLl93aWR0aCAvIDIgOiB0aGlzLl93aWR0aCAvIDI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IGluZGV4ID0gaSAqIDQ7XG4gICAgICBpZiAoaSA8IHBvaW50cy5sZW5ndGggLSAxKSB7XG4gICAgICAgIG5leHRQb2ludCA9IHBvaW50c1tpICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0UG9pbnQgPSBwb2ludDtcbiAgICAgIH1cbiAgICAgIHBlcnBZID0gLShuZXh0UG9pbnQueCAtIGxhc3RQb2ludC54KTtcbiAgICAgIHBlcnBYID0gbmV4dFBvaW50LnkgLSBsYXN0UG9pbnQueTtcbiAgICAgIGxldCByYXRpbyA9ICgxIC0gaSAvICh0b3RhbCAtIDEpKSAqIDEwO1xuICAgICAgaWYgKHJhdGlvID4gMSkge1xuICAgICAgICByYXRpbyA9IDE7XG4gICAgICB9XG4gICAgICBjb25zdCBwZXJwTGVuZ3RoID0gTWF0aC5zcXJ0KHBlcnBYICogcGVycFggKyBwZXJwWSAqIHBlcnBZKTtcbiAgICAgIGlmIChwZXJwTGVuZ3RoIDwgMWUtNikge1xuICAgICAgICBwZXJwWCA9IDA7XG4gICAgICAgIHBlcnBZID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlcnBYIC89IHBlcnBMZW5ndGg7XG4gICAgICAgIHBlcnBZIC89IHBlcnBMZW5ndGg7XG4gICAgICAgIHBlcnBYICo9IGhhbGZXaWR0aDtcbiAgICAgICAgcGVycFkgKj0gaGFsZldpZHRoO1xuICAgICAgfVxuICAgICAgdmVydGljZXNbaW5kZXhdID0gcG9pbnQueCArIHBlcnBYO1xuICAgICAgdmVydGljZXNbaW5kZXggKyAxXSA9IHBvaW50LnkgKyBwZXJwWTtcbiAgICAgIHZlcnRpY2VzW2luZGV4ICsgMl0gPSBwb2ludC54IC0gcGVycFg7XG4gICAgICB2ZXJ0aWNlc1tpbmRleCArIDNdID0gcG9pbnQueSAtIHBlcnBZO1xuICAgICAgbGFzdFBvaW50ID0gcG9pbnQ7XG4gICAgfVxuICAgIHRoaXMuYnVmZmVyc1swXS51cGRhdGUoKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgaWYgKHRoaXMudGV4dHVyZVNjYWxlID4gMCkge1xuICAgICAgdGhpcy5idWlsZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwZGF0ZVZlcnRpY2VzKCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IFJvcGVHZW9tZXRyeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Um9wZUdlb21ldHJ5Lm1qcy5tYXBcbiIsImltcG9ydCB7IFRleHR1cmUgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IE1lc2gsIE1lc2hNYXRlcmlhbCB9IGZyb20gJ0BwaXhpL21lc2gnO1xuaW1wb3J0IHsgUGxhbmVHZW9tZXRyeSB9IGZyb20gJy4vZ2VvbWV0cnkvUGxhbmVHZW9tZXRyeS5tanMnO1xuXG5jbGFzcyBTaW1wbGVQbGFuZSBleHRlbmRzIE1lc2gge1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlLCB2ZXJ0aWNlc1gsIHZlcnRpY2VzWSkge1xuICAgIGNvbnN0IHBsYW5lR2VvbWV0cnkgPSBuZXcgUGxhbmVHZW9tZXRyeSh0ZXh0dXJlLndpZHRoLCB0ZXh0dXJlLmhlaWdodCwgdmVydGljZXNYLCB2ZXJ0aWNlc1kpO1xuICAgIGNvbnN0IG1lc2hNYXRlcmlhbCA9IG5ldyBNZXNoTWF0ZXJpYWwoVGV4dHVyZS5XSElURSk7XG4gICAgc3VwZXIocGxhbmVHZW9tZXRyeSwgbWVzaE1hdGVyaWFsKTtcbiAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgIHRoaXMuYXV0b1Jlc2l6ZSA9IHRydWU7XG4gIH1cbiAgdGV4dHVyZVVwZGF0ZWQoKSB7XG4gICAgdGhpcy5fdGV4dHVyZUlEID0gdGhpcy5zaGFkZXIudGV4dHVyZS5fdXBkYXRlSUQ7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5zaGFkZXIudGV4dHVyZTtcbiAgICBpZiAodGhpcy5hdXRvUmVzaXplICYmIChnZW9tZXRyeS53aWR0aCAhPT0gd2lkdGggfHwgZ2VvbWV0cnkuaGVpZ2h0ICE9PSBoZWlnaHQpKSB7XG4gICAgICBnZW9tZXRyeS53aWR0aCA9IHRoaXMuc2hhZGVyLnRleHR1cmUud2lkdGg7XG4gICAgICBnZW9tZXRyeS5oZWlnaHQgPSB0aGlzLnNoYWRlci50ZXh0dXJlLmhlaWdodDtcbiAgICAgIGdlb21ldHJ5LmJ1aWxkKCk7XG4gICAgfVxuICB9XG4gIHNldCB0ZXh0dXJlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuc2hhZGVyLnRleHR1cmUgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2hhZGVyLnRleHR1cmUgPSB2YWx1ZTtcbiAgICB0aGlzLl90ZXh0dXJlSUQgPSAtMTtcbiAgICBpZiAodmFsdWUuYmFzZVRleHR1cmUudmFsaWQpIHtcbiAgICAgIHRoaXMudGV4dHVyZVVwZGF0ZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUub25jZShcInVwZGF0ZVwiLCB0aGlzLnRleHR1cmVVcGRhdGVkLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hhZGVyLnRleHR1cmU7XG4gIH1cbiAgX3JlbmRlcihyZW5kZXJlcikge1xuICAgIGlmICh0aGlzLl90ZXh0dXJlSUQgIT09IHRoaXMuc2hhZGVyLnRleHR1cmUuX3VwZGF0ZUlEKSB7XG4gICAgICB0aGlzLnRleHR1cmVVcGRhdGVkKCk7XG4gICAgfVxuICAgIHN1cGVyLl9yZW5kZXIocmVuZGVyZXIpO1xuICB9XG4gIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIHRoaXMuc2hhZGVyLnRleHR1cmUub2ZmKFwidXBkYXRlXCIsIHRoaXMudGV4dHVyZVVwZGF0ZWQsIHRoaXMpO1xuICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XG4gIH1cbn1cblxuZXhwb3J0IHsgU2ltcGxlUGxhbmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNpbXBsZVBsYW5lLm1qcy5tYXBcbiIsImltcG9ydCB7IFRleHR1cmUgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IFNpbXBsZVBsYW5lIH0gZnJvbSAnLi9TaW1wbGVQbGFuZS5tanMnO1xuXG5jb25zdCBERUZBVUxUX0JPUkRFUl9TSVpFID0gMTA7XG5jbGFzcyBOaW5lU2xpY2VQbGFuZSBleHRlbmRzIFNpbXBsZVBsYW5lIHtcbiAgY29uc3RydWN0b3IodGV4dHVyZSwgbGVmdFdpZHRoLCB0b3BIZWlnaHQsIHJpZ2h0V2lkdGgsIGJvdHRvbUhlaWdodCkge1xuICAgIHN1cGVyKFRleHR1cmUuV0hJVEUsIDQsIDQpO1xuICAgIHRoaXMuX29yaWdXaWR0aCA9IHRleHR1cmUub3JpZy53aWR0aDtcbiAgICB0aGlzLl9vcmlnSGVpZ2h0ID0gdGV4dHVyZS5vcmlnLmhlaWdodDtcbiAgICB0aGlzLl93aWR0aCA9IHRoaXMuX29yaWdXaWR0aDtcbiAgICB0aGlzLl9oZWlnaHQgPSB0aGlzLl9vcmlnSGVpZ2h0O1xuICAgIHRoaXMuX2xlZnRXaWR0aCA9IGxlZnRXaWR0aCA/PyB0ZXh0dXJlLmRlZmF1bHRCb3JkZXJzPy5sZWZ0ID8/IERFRkFVTFRfQk9SREVSX1NJWkU7XG4gICAgdGhpcy5fcmlnaHRXaWR0aCA9IHJpZ2h0V2lkdGggPz8gdGV4dHVyZS5kZWZhdWx0Qm9yZGVycz8ucmlnaHQgPz8gREVGQVVMVF9CT1JERVJfU0laRTtcbiAgICB0aGlzLl90b3BIZWlnaHQgPSB0b3BIZWlnaHQgPz8gdGV4dHVyZS5kZWZhdWx0Qm9yZGVycz8udG9wID8/IERFRkFVTFRfQk9SREVSX1NJWkU7XG4gICAgdGhpcy5fYm90dG9tSGVpZ2h0ID0gYm90dG9tSGVpZ2h0ID8/IHRleHR1cmUuZGVmYXVsdEJvcmRlcnM/LmJvdHRvbSA/PyBERUZBVUxUX0JPUkRFUl9TSVpFO1xuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gIH1cbiAgdGV4dHVyZVVwZGF0ZWQoKSB7XG4gICAgdGhpcy5fdGV4dHVyZUlEID0gdGhpcy5zaGFkZXIudGV4dHVyZS5fdXBkYXRlSUQ7XG4gICAgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG4gIGdldCB2ZXJ0aWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeS5nZXRCdWZmZXIoXCJhVmVydGV4UG9zaXRpb25cIikuZGF0YTtcbiAgfVxuICBzZXQgdmVydGljZXModmFsdWUpIHtcbiAgICB0aGlzLmdlb21ldHJ5LmdldEJ1ZmZlcihcImFWZXJ0ZXhQb3NpdGlvblwiKS5kYXRhID0gdmFsdWU7XG4gIH1cbiAgdXBkYXRlSG9yaXpvbnRhbFZlcnRpY2VzKCkge1xuICAgIGNvbnN0IHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2dldE1pblNjYWxlKCk7XG4gICAgdmVydGljZXNbOV0gPSB2ZXJ0aWNlc1sxMV0gPSB2ZXJ0aWNlc1sxM10gPSB2ZXJ0aWNlc1sxNV0gPSB0aGlzLl90b3BIZWlnaHQgKiBzY2FsZTtcbiAgICB2ZXJ0aWNlc1sxN10gPSB2ZXJ0aWNlc1sxOV0gPSB2ZXJ0aWNlc1syMV0gPSB2ZXJ0aWNlc1syM10gPSB0aGlzLl9oZWlnaHQgLSB0aGlzLl9ib3R0b21IZWlnaHQgKiBzY2FsZTtcbiAgICB2ZXJ0aWNlc1syNV0gPSB2ZXJ0aWNlc1syN10gPSB2ZXJ0aWNlc1syOV0gPSB2ZXJ0aWNlc1szMV0gPSB0aGlzLl9oZWlnaHQ7XG4gIH1cbiAgdXBkYXRlVmVydGljYWxWZXJ0aWNlcygpIHtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9nZXRNaW5TY2FsZSgpO1xuICAgIHZlcnRpY2VzWzJdID0gdmVydGljZXNbMTBdID0gdmVydGljZXNbMThdID0gdmVydGljZXNbMjZdID0gdGhpcy5fbGVmdFdpZHRoICogc2NhbGU7XG4gICAgdmVydGljZXNbNF0gPSB2ZXJ0aWNlc1sxMl0gPSB2ZXJ0aWNlc1syMF0gPSB2ZXJ0aWNlc1syOF0gPSB0aGlzLl93aWR0aCAtIHRoaXMuX3JpZ2h0V2lkdGggKiBzY2FsZTtcbiAgICB2ZXJ0aWNlc1s2XSA9IHZlcnRpY2VzWzE0XSA9IHZlcnRpY2VzWzIyXSA9IHZlcnRpY2VzWzMwXSA9IHRoaXMuX3dpZHRoO1xuICB9XG4gIF9nZXRNaW5TY2FsZSgpIHtcbiAgICBjb25zdCB3ID0gdGhpcy5fbGVmdFdpZHRoICsgdGhpcy5fcmlnaHRXaWR0aDtcbiAgICBjb25zdCBzY2FsZVcgPSB0aGlzLl93aWR0aCA+IHcgPyAxIDogdGhpcy5fd2lkdGggLyB3O1xuICAgIGNvbnN0IGggPSB0aGlzLl90b3BIZWlnaHQgKyB0aGlzLl9ib3R0b21IZWlnaHQ7XG4gICAgY29uc3Qgc2NhbGVIID0gdGhpcy5faGVpZ2h0ID4gaCA/IDEgOiB0aGlzLl9oZWlnaHQgLyBoO1xuICAgIGNvbnN0IHNjYWxlID0gTWF0aC5taW4oc2NhbGVXLCBzY2FsZUgpO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICB9XG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgfVxuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gICAgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG4gIGdldCBsZWZ0V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlZnRXaWR0aDtcbiAgfVxuICBzZXQgbGVmdFdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5fbGVmdFdpZHRoID0gdmFsdWU7XG4gICAgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG4gIGdldCByaWdodFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9yaWdodFdpZHRoO1xuICB9XG4gIHNldCByaWdodFdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5fcmlnaHRXaWR0aCA9IHZhbHVlO1xuICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuICBnZXQgdG9wSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl90b3BIZWlnaHQ7XG4gIH1cbiAgc2V0IHRvcEhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMuX3RvcEhlaWdodCA9IHZhbHVlO1xuICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuICBnZXQgYm90dG9tSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9ib3R0b21IZWlnaHQ7XG4gIH1cbiAgc2V0IGJvdHRvbUhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMuX2JvdHRvbUhlaWdodCA9IHZhbHVlO1xuICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuICBfcmVmcmVzaCgpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xuICAgIGNvbnN0IHV2cyA9IHRoaXMuZ2VvbWV0cnkuYnVmZmVyc1sxXS5kYXRhO1xuICAgIHRoaXMuX29yaWdXaWR0aCA9IHRleHR1cmUub3JpZy53aWR0aDtcbiAgICB0aGlzLl9vcmlnSGVpZ2h0ID0gdGV4dHVyZS5vcmlnLmhlaWdodDtcbiAgICBjb25zdCBfdXZ3ID0gMSAvIHRoaXMuX29yaWdXaWR0aDtcbiAgICBjb25zdCBfdXZoID0gMSAvIHRoaXMuX29yaWdIZWlnaHQ7XG4gICAgdXZzWzBdID0gdXZzWzhdID0gdXZzWzE2XSA9IHV2c1syNF0gPSAwO1xuICAgIHV2c1sxXSA9IHV2c1szXSA9IHV2c1s1XSA9IHV2c1s3XSA9IDA7XG4gICAgdXZzWzZdID0gdXZzWzE0XSA9IHV2c1syMl0gPSB1dnNbMzBdID0gMTtcbiAgICB1dnNbMjVdID0gdXZzWzI3XSA9IHV2c1syOV0gPSB1dnNbMzFdID0gMTtcbiAgICB1dnNbMl0gPSB1dnNbMTBdID0gdXZzWzE4XSA9IHV2c1syNl0gPSBfdXZ3ICogdGhpcy5fbGVmdFdpZHRoO1xuICAgIHV2c1s0XSA9IHV2c1sxMl0gPSB1dnNbMjBdID0gdXZzWzI4XSA9IDEgLSBfdXZ3ICogdGhpcy5fcmlnaHRXaWR0aDtcbiAgICB1dnNbOV0gPSB1dnNbMTFdID0gdXZzWzEzXSA9IHV2c1sxNV0gPSBfdXZoICogdGhpcy5fdG9wSGVpZ2h0O1xuICAgIHV2c1sxN10gPSB1dnNbMTldID0gdXZzWzIxXSA9IHV2c1syM10gPSAxIC0gX3V2aCAqIHRoaXMuX2JvdHRvbUhlaWdodDtcbiAgICB0aGlzLnVwZGF0ZUhvcml6b250YWxWZXJ0aWNlcygpO1xuICAgIHRoaXMudXBkYXRlVmVydGljYWxWZXJ0aWNlcygpO1xuICAgIHRoaXMuZ2VvbWV0cnkuYnVmZmVyc1swXS51cGRhdGUoKTtcbiAgICB0aGlzLmdlb21ldHJ5LmJ1ZmZlcnNbMV0udXBkYXRlKCk7XG4gIH1cbn1cblxuZXhwb3J0IHsgTmluZVNsaWNlUGxhbmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5pbmVTbGljZVBsYW5lLm1qcy5tYXBcbiIsImltcG9ydCB7IFRleHR1cmUgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IE1lc2gsIE1lc2hHZW9tZXRyeSwgTWVzaE1hdGVyaWFsIH0gZnJvbSAnQHBpeGkvbWVzaCc7XG5cbmNsYXNzIFNpbXBsZU1lc2ggZXh0ZW5kcyBNZXNoIHtcbiAgY29uc3RydWN0b3IodGV4dHVyZSA9IFRleHR1cmUuRU1QVFksIHZlcnRpY2VzLCB1dnMsIGluZGljZXMsIGRyYXdNb2RlKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgTWVzaEdlb21ldHJ5KHZlcnRpY2VzLCB1dnMsIGluZGljZXMpO1xuICAgIGdlb21ldHJ5LmdldEJ1ZmZlcihcImFWZXJ0ZXhQb3NpdGlvblwiKS5zdGF0aWMgPSBmYWxzZTtcbiAgICBjb25zdCBtZXNoTWF0ZXJpYWwgPSBuZXcgTWVzaE1hdGVyaWFsKHRleHR1cmUpO1xuICAgIHN1cGVyKGdlb21ldHJ5LCBtZXNoTWF0ZXJpYWwsIG51bGwsIGRyYXdNb2RlKTtcbiAgICB0aGlzLmF1dG9VcGRhdGUgPSB0cnVlO1xuICB9XG4gIGdldCB2ZXJ0aWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeS5nZXRCdWZmZXIoXCJhVmVydGV4UG9zaXRpb25cIikuZGF0YTtcbiAgfVxuICBzZXQgdmVydGljZXModmFsdWUpIHtcbiAgICB0aGlzLmdlb21ldHJ5LmdldEJ1ZmZlcihcImFWZXJ0ZXhQb3NpdGlvblwiKS5kYXRhID0gdmFsdWU7XG4gIH1cbiAgX3JlbmRlcihyZW5kZXJlcikge1xuICAgIGlmICh0aGlzLmF1dG9VcGRhdGUpIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuZ2V0QnVmZmVyKFwiYVZlcnRleFBvc2l0aW9uXCIpLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBzdXBlci5fcmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxufVxuXG5leHBvcnQgeyBTaW1wbGVNZXNoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaW1wbGVNZXNoLm1qcy5tYXBcbiIsImltcG9ydCB7IFdSQVBfTU9ERVMgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IE1lc2gsIE1lc2hNYXRlcmlhbCB9IGZyb20gJ0BwaXhpL21lc2gnO1xuaW1wb3J0IHsgUm9wZUdlb21ldHJ5IH0gZnJvbSAnLi9nZW9tZXRyeS9Sb3BlR2VvbWV0cnkubWpzJztcblxuY2xhc3MgU2ltcGxlUm9wZSBleHRlbmRzIE1lc2gge1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlLCBwb2ludHMsIHRleHR1cmVTY2FsZSA9IDApIHtcbiAgICBjb25zdCByb3BlR2VvbWV0cnkgPSBuZXcgUm9wZUdlb21ldHJ5KHRleHR1cmUuaGVpZ2h0LCBwb2ludHMsIHRleHR1cmVTY2FsZSk7XG4gICAgY29uc3QgbWVzaE1hdGVyaWFsID0gbmV3IE1lc2hNYXRlcmlhbCh0ZXh0dXJlKTtcbiAgICBpZiAodGV4dHVyZVNjYWxlID4gMCkge1xuICAgICAgdGV4dHVyZS5iYXNlVGV4dHVyZS53cmFwTW9kZSA9IFdSQVBfTU9ERVMuUkVQRUFUO1xuICAgIH1cbiAgICBzdXBlcihyb3BlR2VvbWV0cnksIG1lc2hNYXRlcmlhbCk7XG4gICAgdGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICBfcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgIGlmICh0aGlzLmF1dG9VcGRhdGUgfHwgZ2VvbWV0cnkuX3dpZHRoICE9PSB0aGlzLnNoYWRlci50ZXh0dXJlLmhlaWdodCkge1xuICAgICAgZ2VvbWV0cnkuX3dpZHRoID0gdGhpcy5zaGFkZXIudGV4dHVyZS5oZWlnaHQ7XG4gICAgICBnZW9tZXRyeS51cGRhdGUoKTtcbiAgICB9XG4gICAgc3VwZXIuX3JlbmRlcihyZW5kZXJlcik7XG4gIH1cbn1cblxuZXhwb3J0IHsgU2ltcGxlUm9wZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2ltcGxlUm9wZS5tanMubWFwXG4iLCJleHBvcnQgeyBQbGFuZUdlb21ldHJ5IH0gZnJvbSAnLi9nZW9tZXRyeS9QbGFuZUdlb21ldHJ5Lm1qcyc7XG5leHBvcnQgeyBSb3BlR2VvbWV0cnkgfSBmcm9tICcuL2dlb21ldHJ5L1JvcGVHZW9tZXRyeS5tanMnO1xuZXhwb3J0IHsgTmluZVNsaWNlUGxhbmUgfSBmcm9tICcuL05pbmVTbGljZVBsYW5lLm1qcyc7XG5leHBvcnQgeyBTaW1wbGVNZXNoIH0gZnJvbSAnLi9TaW1wbGVNZXNoLm1qcyc7XG5leHBvcnQgeyBTaW1wbGVQbGFuZSB9IGZyb20gJy4vU2ltcGxlUGxhbmUubWpzJztcbmV4cG9ydCB7IFNpbXBsZVJvcGUgfSBmcm9tICcuL1NpbXBsZVJvcGUubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IEJMRU5EX01PREVTLCBDb2xvciB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnQHBpeGkvZGlzcGxheSc7XG5cbmNsYXNzIFBhcnRpY2xlQ29udGFpbmVyIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3IobWF4U2l6ZSA9IDE1MDAsIHByb3BlcnRpZXMsIGJhdGNoU2l6ZSA9IDE2Mzg0LCBhdXRvUmVzaXplID0gZmFsc2UpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IG1heEJhdGNoU2l6ZSA9IDE2Mzg0O1xuICAgIGlmIChiYXRjaFNpemUgPiBtYXhCYXRjaFNpemUpIHtcbiAgICAgIGJhdGNoU2l6ZSA9IG1heEJhdGNoU2l6ZTtcbiAgICB9XG4gICAgdGhpcy5fcHJvcGVydGllcyA9IFtmYWxzZSwgdHJ1ZSwgZmFsc2UsIGZhbHNlLCBmYWxzZV07XG4gICAgdGhpcy5fbWF4U2l6ZSA9IG1heFNpemU7XG4gICAgdGhpcy5fYmF0Y2hTaXplID0gYmF0Y2hTaXplO1xuICAgIHRoaXMuX2J1ZmZlcnMgPSBudWxsO1xuICAgIHRoaXMuX2J1ZmZlclVwZGF0ZUlEcyA9IFtdO1xuICAgIHRoaXMuX3VwZGF0ZUlEID0gMDtcbiAgICB0aGlzLmludGVyYWN0aXZlQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICB0aGlzLmJsZW5kTW9kZSA9IEJMRU5EX01PREVTLk5PUk1BTDtcbiAgICB0aGlzLmF1dG9SZXNpemUgPSBhdXRvUmVzaXplO1xuICAgIHRoaXMucm91bmRQaXhlbHMgPSB0cnVlO1xuICAgIHRoaXMuYmFzZVRleHR1cmUgPSBudWxsO1xuICAgIHRoaXMuc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzKTtcbiAgICB0aGlzLl90aW50Q29sb3IgPSBuZXcgQ29sb3IoMCk7XG4gICAgdGhpcy50aW50UmdiID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICB0aGlzLnRpbnQgPSAxNjc3NzIxNTtcbiAgfVxuICBzZXRQcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcbiAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgdGhpcy5fcHJvcGVydGllc1swXSA9IFwidmVydGljZXNcIiBpbiBwcm9wZXJ0aWVzIHx8IFwic2NhbGVcIiBpbiBwcm9wZXJ0aWVzID8gISFwcm9wZXJ0aWVzLnZlcnRpY2VzIHx8ICEhcHJvcGVydGllcy5zY2FsZSA6IHRoaXMuX3Byb3BlcnRpZXNbMF07XG4gICAgICB0aGlzLl9wcm9wZXJ0aWVzWzFdID0gXCJwb3NpdGlvblwiIGluIHByb3BlcnRpZXMgPyAhIXByb3BlcnRpZXMucG9zaXRpb24gOiB0aGlzLl9wcm9wZXJ0aWVzWzFdO1xuICAgICAgdGhpcy5fcHJvcGVydGllc1syXSA9IFwicm90YXRpb25cIiBpbiBwcm9wZXJ0aWVzID8gISFwcm9wZXJ0aWVzLnJvdGF0aW9uIDogdGhpcy5fcHJvcGVydGllc1syXTtcbiAgICAgIHRoaXMuX3Byb3BlcnRpZXNbM10gPSBcInV2c1wiIGluIHByb3BlcnRpZXMgPyAhIXByb3BlcnRpZXMudXZzIDogdGhpcy5fcHJvcGVydGllc1szXTtcbiAgICAgIHRoaXMuX3Byb3BlcnRpZXNbNF0gPSBcInRpbnRcIiBpbiBwcm9wZXJ0aWVzIHx8IFwiYWxwaGFcIiBpbiBwcm9wZXJ0aWVzID8gISFwcm9wZXJ0aWVzLnRpbnQgfHwgISFwcm9wZXJ0aWVzLmFscGhhIDogdGhpcy5fcHJvcGVydGllc1s0XTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlVHJhbnNmb3JtKCkge1xuICAgIHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSgpO1xuICB9XG4gIGdldCB0aW50KCkge1xuICAgIHJldHVybiB0aGlzLl90aW50Q29sb3IudmFsdWU7XG4gIH1cbiAgc2V0IHRpbnQodmFsdWUpIHtcbiAgICB0aGlzLl90aW50Q29sb3Iuc2V0VmFsdWUodmFsdWUpO1xuICAgIHRoaXMuX3RpbnRDb2xvci50b1JnYkFycmF5KHRoaXMudGludFJnYik7XG4gIH1cbiAgcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgaWYgKCF0aGlzLnZpc2libGUgfHwgdGhpcy53b3JsZEFscGhhIDw9IDAgfHwgIXRoaXMuY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLnJlbmRlcmFibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmJhc2VUZXh0dXJlKSB7XG4gICAgICB0aGlzLmJhc2VUZXh0dXJlID0gdGhpcy5jaGlsZHJlblswXS5fdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICAgIGlmICghdGhpcy5iYXNlVGV4dHVyZS52YWxpZCkge1xuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLm9uY2UoXCJ1cGRhdGVcIiwgKCkgPT4gdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKDApKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyZXIuYmF0Y2guc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2lucy5wYXJ0aWNsZSk7XG4gICAgcmVuZGVyZXIucGx1Z2lucy5wYXJ0aWNsZS5yZW5kZXIodGhpcyk7XG4gIH1cbiAgb25DaGlsZHJlbkNoYW5nZShzbWFsbGVzdENoaWxkSW5kZXgpIHtcbiAgICBjb25zdCBidWZmZXJJbmRleCA9IE1hdGguZmxvb3Ioc21hbGxlc3RDaGlsZEluZGV4IC8gdGhpcy5fYmF0Y2hTaXplKTtcbiAgICB3aGlsZSAodGhpcy5fYnVmZmVyVXBkYXRlSURzLmxlbmd0aCA8IGJ1ZmZlckluZGV4KSB7XG4gICAgICB0aGlzLl9idWZmZXJVcGRhdGVJRHMucHVzaCgwKTtcbiAgICB9XG4gICAgdGhpcy5fYnVmZmVyVXBkYXRlSURzW2J1ZmZlckluZGV4XSA9ICsrdGhpcy5fdXBkYXRlSUQ7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVycykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9idWZmZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlcnNbaV0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYnVmZmVycyA9IG51bGw7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgdGhpcy5fcHJvcGVydGllcyA9IG51bGw7XG4gICAgdGhpcy5fYnVmZmVycyA9IG51bGw7XG4gICAgdGhpcy5fYnVmZmVyVXBkYXRlSURzID0gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgeyBQYXJ0aWNsZUNvbnRhaW5lciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFydGljbGVDb250YWluZXIubWpzLm1hcFxuIiwiaW1wb3J0IHsgR2VvbWV0cnksIFRZUEVTLCBCdWZmZXIsIHV0aWxzIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmNsYXNzIFBhcnRpY2xlQnVmZmVyIHtcbiAgY29uc3RydWN0b3IocHJvcGVydGllcywgZHluYW1pY1Byb3BlcnR5RmxhZ3MsIHNpemUpIHtcbiAgICB0aGlzLmdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5KCk7XG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzID0gW107XG4gICAgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBsZXQgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgcHJvcGVydHkgPSB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IHByb3BlcnR5LmF0dHJpYnV0ZU5hbWUsXG4gICAgICAgIHNpemU6IHByb3BlcnR5LnNpemUsXG4gICAgICAgIHVwbG9hZEZ1bmN0aW9uOiBwcm9wZXJ0eS51cGxvYWRGdW5jdGlvbixcbiAgICAgICAgdHlwZTogcHJvcGVydHkudHlwZSB8fCBUWVBFUy5GTE9BVCxcbiAgICAgICAgb2Zmc2V0OiBwcm9wZXJ0eS5vZmZzZXRcbiAgICAgIH07XG4gICAgICBpZiAoZHluYW1pY1Byb3BlcnR5RmxhZ3NbaV0pIHtcbiAgICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGljUHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zdGF0aWNTdHJpZGUgPSAwO1xuICAgIHRoaXMuc3RhdGljQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLnN0YXRpY0RhdGEgPSBudWxsO1xuICAgIHRoaXMuc3RhdGljRGF0YVVpbnQzMiA9IG51bGw7XG4gICAgdGhpcy5keW5hbWljU3RyaWRlID0gMDtcbiAgICB0aGlzLmR5bmFtaWNCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuZHluYW1pY0RhdGEgPSBudWxsO1xuICAgIHRoaXMuZHluYW1pY0RhdGFVaW50MzIgPSBudWxsO1xuICAgIHRoaXMuX3VwZGF0ZUlEID0gMDtcbiAgICB0aGlzLmluaXRCdWZmZXJzKCk7XG4gIH1cbiAgaW5pdEJ1ZmZlcnMoKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgIGxldCBkeW5hbWljT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gbmV3IEJ1ZmZlcih1dGlscy5jcmVhdGVJbmRpY2VzRm9yUXVhZHModGhpcy5zaXplKSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZ2VvbWV0cnkuYWRkSW5kZXgodGhpcy5pbmRleEJ1ZmZlcik7XG4gICAgdGhpcy5keW5hbWljU3RyaWRlID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gdGhpcy5keW5hbWljUHJvcGVydGllc1tpXTtcbiAgICAgIHByb3BlcnR5Lm9mZnNldCA9IGR5bmFtaWNPZmZzZXQ7XG4gICAgICBkeW5hbWljT2Zmc2V0ICs9IHByb3BlcnR5LnNpemU7XG4gICAgICB0aGlzLmR5bmFtaWNTdHJpZGUgKz0gcHJvcGVydHkuc2l6ZTtcbiAgICB9XG4gICAgY29uc3QgZHluQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuc2l6ZSAqIHRoaXMuZHluYW1pY1N0cmlkZSAqIDQgKiA0KTtcbiAgICB0aGlzLmR5bmFtaWNEYXRhID0gbmV3IEZsb2F0MzJBcnJheShkeW5CdWZmZXIpO1xuICAgIHRoaXMuZHluYW1pY0RhdGFVaW50MzIgPSBuZXcgVWludDMyQXJyYXkoZHluQnVmZmVyKTtcbiAgICB0aGlzLmR5bmFtaWNCdWZmZXIgPSBuZXcgQnVmZmVyKHRoaXMuZHluYW1pY0RhdGEsIGZhbHNlLCBmYWxzZSk7XG4gICAgbGV0IHN0YXRpY09mZnNldCA9IDA7XG4gICAgdGhpcy5zdGF0aWNTdHJpZGUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IHRoaXMuc3RhdGljUHJvcGVydGllc1tpXTtcbiAgICAgIHByb3BlcnR5Lm9mZnNldCA9IHN0YXRpY09mZnNldDtcbiAgICAgIHN0YXRpY09mZnNldCArPSBwcm9wZXJ0eS5zaXplO1xuICAgICAgdGhpcy5zdGF0aWNTdHJpZGUgKz0gcHJvcGVydHkuc2l6ZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdEJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLnNpemUgKiB0aGlzLnN0YXRpY1N0cmlkZSAqIDQgKiA0KTtcbiAgICB0aGlzLnN0YXRpY0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHN0YXRCdWZmZXIpO1xuICAgIHRoaXMuc3RhdGljRGF0YVVpbnQzMiA9IG5ldyBVaW50MzJBcnJheShzdGF0QnVmZmVyKTtcbiAgICB0aGlzLnN0YXRpY0J1ZmZlciA9IG5ldyBCdWZmZXIodGhpcy5zdGF0aWNEYXRhLCB0cnVlLCBmYWxzZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV07XG4gICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUocHJvcGVydHkuYXR0cmlidXRlTmFtZSwgdGhpcy5keW5hbWljQnVmZmVyLCAwLCBwcm9wZXJ0eS50eXBlID09PSBUWVBFUy5VTlNJR05FRF9CWVRFLCBwcm9wZXJ0eS50eXBlLCB0aGlzLmR5bmFtaWNTdHJpZGUgKiA0LCBwcm9wZXJ0eS5vZmZzZXQgKiA0KTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YXRpY1Byb3BlcnRpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gdGhpcy5zdGF0aWNQcm9wZXJ0aWVzW2ldO1xuICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKHByb3BlcnR5LmF0dHJpYnV0ZU5hbWUsIHRoaXMuc3RhdGljQnVmZmVyLCAwLCBwcm9wZXJ0eS50eXBlID09PSBUWVBFUy5VTlNJR05FRF9CWVRFLCBwcm9wZXJ0eS50eXBlLCB0aGlzLnN0YXRpY1N0cmlkZSAqIDQsIHByb3BlcnR5Lm9mZnNldCAqIDQpO1xuICAgIH1cbiAgfVxuICB1cGxvYWREeW5hbWljKGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gdGhpcy5keW5hbWljUHJvcGVydGllc1tpXTtcbiAgICAgIHByb3BlcnR5LnVwbG9hZEZ1bmN0aW9uKGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQsIHByb3BlcnR5LnR5cGUgPT09IFRZUEVTLlVOU0lHTkVEX0JZVEUgPyB0aGlzLmR5bmFtaWNEYXRhVWludDMyIDogdGhpcy5keW5hbWljRGF0YSwgdGhpcy5keW5hbWljU3RyaWRlLCBwcm9wZXJ0eS5vZmZzZXQpO1xuICAgIH1cbiAgICB0aGlzLmR5bmFtaWNCdWZmZXIuX3VwZGF0ZUlEKys7XG4gIH1cbiAgdXBsb2FkU3RhdGljKGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhdGljUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcHJvcGVydHkgPSB0aGlzLnN0YXRpY1Byb3BlcnRpZXNbaV07XG4gICAgICBwcm9wZXJ0eS51cGxvYWRGdW5jdGlvbihjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50LCBwcm9wZXJ0eS50eXBlID09PSBUWVBFUy5VTlNJR05FRF9CWVRFID8gdGhpcy5zdGF0aWNEYXRhVWludDMyIDogdGhpcy5zdGF0aWNEYXRhLCB0aGlzLnN0YXRpY1N0cmlkZSwgcHJvcGVydHkub2Zmc2V0KTtcbiAgICB9XG4gICAgdGhpcy5zdGF0aWNCdWZmZXIuX3VwZGF0ZUlEKys7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmluZGV4QnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzID0gbnVsbDtcbiAgICB0aGlzLmR5bmFtaWNCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuZHluYW1pY0RhdGEgPSBudWxsO1xuICAgIHRoaXMuZHluYW1pY0RhdGFVaW50MzIgPSBudWxsO1xuICAgIHRoaXMuc3RhdGljUHJvcGVydGllcyA9IG51bGw7XG4gICAgdGhpcy5zdGF0aWNCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuc3RhdGljRGF0YSA9IG51bGw7XG4gICAgdGhpcy5zdGF0aWNEYXRhVWludDMyID0gbnVsbDtcbiAgICB0aGlzLmdlb21ldHJ5LmRlc3Ryb3koKTtcbiAgfVxufVxuXG5leHBvcnQgeyBQYXJ0aWNsZUJ1ZmZlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFydGljbGVCdWZmZXIubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcblxcbnZvaWQgbWFpbih2b2lkKXtcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3I7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbn1cIjtcblxuZXhwb3J0IHsgZnJhZ21lbnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFydGljbGVzLm1qcy5tYXBcbiIsInZhciB2ZXJ0ZXggPSBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcbmF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcXG5cXG5hdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb25Db29yZDtcXG5hdHRyaWJ1dGUgZmxvYXQgYVJvdGF0aW9uO1xcblxcbnVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcXG51bmlmb3JtIHZlYzQgdUNvbG9yO1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxudm9pZCBtYWluKHZvaWQpe1xcbiAgICBmbG9hdCB4ID0gKGFWZXJ0ZXhQb3NpdGlvbi54KSAqIGNvcyhhUm90YXRpb24pIC0gKGFWZXJ0ZXhQb3NpdGlvbi55KSAqIHNpbihhUm90YXRpb24pO1xcbiAgICBmbG9hdCB5ID0gKGFWZXJ0ZXhQb3NpdGlvbi54KSAqIHNpbihhUm90YXRpb24pICsgKGFWZXJ0ZXhQb3NpdGlvbi55KSAqIGNvcyhhUm90YXRpb24pO1xcblxcbiAgICB2ZWMyIHYgPSB2ZWMyKHgsIHkpO1xcbiAgICB2ID0gdiArIGFQb3NpdGlvbkNvb3JkO1xcblxcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyh2LCAxLjApKS54eSwgMC4wLCAxLjApO1xcblxcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG4gICAgdkNvbG9yID0gYUNvbG9yICogdUNvbG9yO1xcbn1cXG5cIjtcblxuZXhwb3J0IHsgdmVydGV4IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnRpY2xlczIubWpzLm1hcFxuIiwiaW1wb3J0IHsgT2JqZWN0UmVuZGVyZXIsIE1hdHJpeCwgVFlQRVMsIFNoYWRlciwgU3RhdGUsIHV0aWxzLCBDb2xvciwgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgUGFydGljbGVCdWZmZXIgfSBmcm9tICcuL1BhcnRpY2xlQnVmZmVyLm1qcyc7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSAnLi9wYXJ0aWNsZXMubWpzJztcbmltcG9ydCB2ZXJ0ZXggZnJvbSAnLi9wYXJ0aWNsZXMyLm1qcyc7XG5cbmNsYXNzIFBhcnRpY2xlUmVuZGVyZXIgZXh0ZW5kcyBPYmplY3RSZW5kZXJlciB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgc3VwZXIocmVuZGVyZXIpO1xuICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBudWxsO1xuICAgIHRoaXMudGVtcE1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBbXG4gICAgICB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IFwiYVZlcnRleFBvc2l0aW9uXCIsXG4gICAgICAgIHNpemU6IDIsXG4gICAgICAgIHVwbG9hZEZ1bmN0aW9uOiB0aGlzLnVwbG9hZFZlcnRpY2VzLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IFwiYVBvc2l0aW9uQ29vcmRcIixcbiAgICAgICAgc2l6ZTogMixcbiAgICAgICAgdXBsb2FkRnVuY3Rpb246IHRoaXMudXBsb2FkUG9zaXRpb24sXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogXCJhUm90YXRpb25cIixcbiAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgdXBsb2FkRnVuY3Rpb246IHRoaXMudXBsb2FkUm90YXRpb24sXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogXCJhVGV4dHVyZUNvb3JkXCIsXG4gICAgICAgIHNpemU6IDIsXG4gICAgICAgIHVwbG9hZEZ1bmN0aW9uOiB0aGlzLnVwbG9hZFV2cyxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lOiBcImFDb2xvclwiLFxuICAgICAgICBzaXplOiAxLFxuICAgICAgICB0eXBlOiBUWVBFUy5VTlNJR05FRF9CWVRFLFxuICAgICAgICB1cGxvYWRGdW5jdGlvbjogdGhpcy51cGxvYWRUaW50LFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH1cbiAgICBdO1xuICAgIHRoaXMuc2hhZGVyID0gU2hhZGVyLmZyb20odmVydGV4LCBmcmFnbWVudCwge30pO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5mb3IyZCgpO1xuICB9XG4gIHJlbmRlcihjb250YWluZXIpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IGNvbnRhaW5lci5jaGlsZHJlbjtcbiAgICBjb25zdCBtYXhTaXplID0gY29udGFpbmVyLl9tYXhTaXplO1xuICAgIGNvbnN0IGJhdGNoU2l6ZSA9IGNvbnRhaW5lci5fYmF0Y2hTaXplO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBsZXQgdG90YWxDaGlsZHJlbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBpZiAodG90YWxDaGlsZHJlbiA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodG90YWxDaGlsZHJlbiA+IG1heFNpemUgJiYgIWNvbnRhaW5lci5hdXRvUmVzaXplKSB7XG4gICAgICB0b3RhbENoaWxkcmVuID0gbWF4U2l6ZTtcbiAgICB9XG4gICAgbGV0IGJ1ZmZlcnMgPSBjb250YWluZXIuX2J1ZmZlcnM7XG4gICAgaWYgKCFidWZmZXJzKSB7XG4gICAgICBidWZmZXJzID0gY29udGFpbmVyLl9idWZmZXJzID0gdGhpcy5nZW5lcmF0ZUJ1ZmZlcnMoY29udGFpbmVyKTtcbiAgICB9XG4gICAgY29uc3QgYmFzZVRleHR1cmUgPSBjaGlsZHJlblswXS5fdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICBjb25zdCBwcmVtdWx0aXBsaWVkID0gYmFzZVRleHR1cmUuYWxwaGFNb2RlID4gMDtcbiAgICB0aGlzLnN0YXRlLmJsZW5kTW9kZSA9IHV0aWxzLmNvcnJlY3RCbGVuZE1vZGUoY29udGFpbmVyLmJsZW5kTW9kZSwgcHJlbXVsdGlwbGllZCk7XG4gICAgcmVuZGVyZXIuc3RhdGUuc2V0KHRoaXMuc3RhdGUpO1xuICAgIGNvbnN0IGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgY29uc3QgbSA9IGNvbnRhaW5lci53b3JsZFRyYW5zZm9ybS5jb3B5VG8odGhpcy50ZW1wTWF0cml4KTtcbiAgICBtLnByZXBlbmQocmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMudW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCk7XG4gICAgdGhpcy5zaGFkZXIudW5pZm9ybXMudHJhbnNsYXRpb25NYXRyaXggPSBtLnRvQXJyYXkodHJ1ZSk7XG4gICAgdGhpcy5zaGFkZXIudW5pZm9ybXMudUNvbG9yID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKGNvbnRhaW5lci50aW50UmdiKS5wcmVtdWx0aXBseShjb250YWluZXIud29ybGRBbHBoYSwgcHJlbXVsdGlwbGllZCkudG9BcnJheSh0aGlzLnNoYWRlci51bmlmb3Jtcy51Q29sb3IpO1xuICAgIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnVTYW1wbGVyID0gYmFzZVRleHR1cmU7XG4gICAgdGhpcy5yZW5kZXJlci5zaGFkZXIuYmluZCh0aGlzLnNoYWRlcik7XG4gICAgbGV0IHVwZGF0ZVN0YXRpYyA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHRvdGFsQ2hpbGRyZW47IGkgKz0gYmF0Y2hTaXplLCBqICs9IDEpIHtcbiAgICAgIGxldCBhbW91bnQgPSB0b3RhbENoaWxkcmVuIC0gaTtcbiAgICAgIGlmIChhbW91bnQgPiBiYXRjaFNpemUpIHtcbiAgICAgICAgYW1vdW50ID0gYmF0Y2hTaXplO1xuICAgICAgfVxuICAgICAgaWYgKGogPj0gYnVmZmVycy5sZW5ndGgpIHtcbiAgICAgICAgYnVmZmVycy5wdXNoKHRoaXMuX2dlbmVyYXRlT25lTW9yZUJ1ZmZlcihjb250YWluZXIpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGJ1ZmZlcnNbal07XG4gICAgICBidWZmZXIudXBsb2FkRHluYW1pYyhjaGlsZHJlbiwgaSwgYW1vdW50KTtcbiAgICAgIGNvbnN0IGJpZCA9IGNvbnRhaW5lci5fYnVmZmVyVXBkYXRlSURzW2pdIHx8IDA7XG4gICAgICB1cGRhdGVTdGF0aWMgPSB1cGRhdGVTdGF0aWMgfHwgYnVmZmVyLl91cGRhdGVJRCA8IGJpZDtcbiAgICAgIGlmICh1cGRhdGVTdGF0aWMpIHtcbiAgICAgICAgYnVmZmVyLl91cGRhdGVJRCA9IGNvbnRhaW5lci5fdXBkYXRlSUQ7XG4gICAgICAgIGJ1ZmZlci51cGxvYWRTdGF0aWMoY2hpbGRyZW4sIGksIGFtb3VudCk7XG4gICAgICB9XG4gICAgICByZW5kZXJlci5nZW9tZXRyeS5iaW5kKGJ1ZmZlci5nZW9tZXRyeSk7XG4gICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBhbW91bnQgKiA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG4gICAgfVxuICB9XG4gIGdlbmVyYXRlQnVmZmVycyhjb250YWluZXIpIHtcbiAgICBjb25zdCBidWZmZXJzID0gW107XG4gICAgY29uc3Qgc2l6ZSA9IGNvbnRhaW5lci5fbWF4U2l6ZTtcbiAgICBjb25zdCBiYXRjaFNpemUgPSBjb250YWluZXIuX2JhdGNoU2l6ZTtcbiAgICBjb25zdCBkeW5hbWljUHJvcGVydHlGbGFncyA9IGNvbnRhaW5lci5fcHJvcGVydGllcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkgKz0gYmF0Y2hTaXplKSB7XG4gICAgICBidWZmZXJzLnB1c2gobmV3IFBhcnRpY2xlQnVmZmVyKHRoaXMucHJvcGVydGllcywgZHluYW1pY1Byb3BlcnR5RmxhZ3MsIGJhdGNoU2l6ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVycztcbiAgfVxuICBfZ2VuZXJhdGVPbmVNb3JlQnVmZmVyKGNvbnRhaW5lcikge1xuICAgIGNvbnN0IGJhdGNoU2l6ZSA9IGNvbnRhaW5lci5fYmF0Y2hTaXplO1xuICAgIGNvbnN0IGR5bmFtaWNQcm9wZXJ0eUZsYWdzID0gY29udGFpbmVyLl9wcm9wZXJ0aWVzO1xuICAgIHJldHVybiBuZXcgUGFydGljbGVCdWZmZXIodGhpcy5wcm9wZXJ0aWVzLCBkeW5hbWljUHJvcGVydHlGbGFncywgYmF0Y2hTaXplKTtcbiAgfVxuICB1cGxvYWRWZXJ0aWNlcyhjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50LCBhcnJheSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgICBsZXQgdzAgPSAwO1xuICAgIGxldCB3MSA9IDA7XG4gICAgbGV0IGgwID0gMDtcbiAgICBsZXQgaDEgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYW1vdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHNwcml0ZSA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXTtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBzcHJpdGUuX3RleHR1cmU7XG4gICAgICBjb25zdCBzeCA9IHNwcml0ZS5zY2FsZS54O1xuICAgICAgY29uc3Qgc3kgPSBzcHJpdGUuc2NhbGUueTtcbiAgICAgIGNvbnN0IHRyaW0gPSB0ZXh0dXJlLnRyaW07XG4gICAgICBjb25zdCBvcmlnID0gdGV4dHVyZS5vcmlnO1xuICAgICAgaWYgKHRyaW0pIHtcbiAgICAgICAgdzEgPSB0cmltLnggLSBzcHJpdGUuYW5jaG9yLnggKiBvcmlnLndpZHRoO1xuICAgICAgICB3MCA9IHcxICsgdHJpbS53aWR0aDtcbiAgICAgICAgaDEgPSB0cmltLnkgLSBzcHJpdGUuYW5jaG9yLnkgKiBvcmlnLmhlaWdodDtcbiAgICAgICAgaDAgPSBoMSArIHRyaW0uaGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdzAgPSBvcmlnLndpZHRoICogKDEgLSBzcHJpdGUuYW5jaG9yLngpO1xuICAgICAgICB3MSA9IG9yaWcud2lkdGggKiAtc3ByaXRlLmFuY2hvci54O1xuICAgICAgICBoMCA9IG9yaWcuaGVpZ2h0ICogKDEgLSBzcHJpdGUuYW5jaG9yLnkpO1xuICAgICAgICBoMSA9IG9yaWcuaGVpZ2h0ICogLXNwcml0ZS5hbmNob3IueTtcbiAgICAgIH1cbiAgICAgIGFycmF5W29mZnNldF0gPSB3MSAqIHN4O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSBoMSAqIHN5O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IHcwICogc3g7XG4gICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKyAxXSA9IGgxICogc3k7XG4gICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyXSA9IHcwICogc3g7XG4gICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyICsgMV0gPSBoMCAqIHN5O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogM10gPSB3MSAqIHN4O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMyArIDFdID0gaDAgKiBzeTtcbiAgICAgIG9mZnNldCArPSBzdHJpZGUgKiA0O1xuICAgIH1cbiAgfVxuICB1cGxvYWRQb3NpdGlvbihjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50LCBhcnJheSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBzcHJpdGVQb3NpdGlvbiA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXS5wb3NpdGlvbjtcbiAgICAgIGFycmF5W29mZnNldF0gPSBzcHJpdGVQb3NpdGlvbi54O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSBzcHJpdGVQb3NpdGlvbi55O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IHNwcml0ZVBvc2l0aW9uLng7XG4gICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKyAxXSA9IHNwcml0ZVBvc2l0aW9uLnk7XG4gICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyXSA9IHNwcml0ZVBvc2l0aW9uLng7XG4gICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyICsgMV0gPSBzcHJpdGVQb3NpdGlvbi55O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogM10gPSBzcHJpdGVQb3NpdGlvbi54O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMyArIDFdID0gc3ByaXRlUG9zaXRpb24ueTtcbiAgICAgIG9mZnNldCArPSBzdHJpZGUgKiA0O1xuICAgIH1cbiAgfVxuICB1cGxvYWRSb3RhdGlvbihjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50LCBhcnJheSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBzcHJpdGVSb3RhdGlvbiA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXS5yb3RhdGlvbjtcbiAgICAgIGFycmF5W29mZnNldF0gPSBzcHJpdGVSb3RhdGlvbjtcbiAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZV0gPSBzcHJpdGVSb3RhdGlvbjtcbiAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDJdID0gc3ByaXRlUm90YXRpb247XG4gICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAzXSA9IHNwcml0ZVJvdGF0aW9uO1xuICAgICAgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XG4gICAgfVxuICB9XG4gIHVwbG9hZFV2cyhjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50LCBhcnJheSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFtb3VudDsgKytpKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlVXZzID0gY2hpbGRyZW5bc3RhcnRJbmRleCArIGldLl90ZXh0dXJlLl91dnM7XG4gICAgICBpZiAodGV4dHVyZVV2cykge1xuICAgICAgICBhcnJheVtvZmZzZXRdID0gdGV4dHVyZVV2cy54MDtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSB0ZXh0dXJlVXZzLnkwO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gdGV4dHVyZVV2cy54MTtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICsgMV0gPSB0ZXh0dXJlVXZzLnkxO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyXSA9IHRleHR1cmVVdnMueDI7XG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDIgKyAxXSA9IHRleHR1cmVVdnMueTI7XG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDNdID0gdGV4dHVyZVV2cy54MztcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMyArIDFdID0gdGV4dHVyZVV2cy55MztcbiAgICAgICAgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheVtvZmZzZXRdID0gMDtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSAwO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gMDtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICsgMV0gPSAwO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKiAyXSA9IDA7XG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDIgKyAxXSA9IDA7XG4gICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDNdID0gMDtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogMyArIDFdID0gMDtcbiAgICAgICAgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHVwbG9hZFRpbnQoY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbW91bnQ7ICsraSkge1xuICAgICAgY29uc3Qgc3ByaXRlID0gY2hpbGRyZW5bc3RhcnRJbmRleCArIGldO1xuICAgICAgY29uc3QgcmVzdWx0ID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHNwcml0ZS5fdGludFJHQikudG9QcmVtdWx0aXBsaWVkKHNwcml0ZS5hbHBoYSwgc3ByaXRlLnRleHR1cmUuYmFzZVRleHR1cmUuYWxwaGFNb2RlID4gMCk7XG4gICAgICBhcnJheVtvZmZzZXRdID0gcmVzdWx0O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IHJlc3VsdDtcbiAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSAqIDJdID0gcmVzdWx0O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICogM10gPSByZXN1bHQ7XG4gICAgICBvZmZzZXQgKz0gc3RyaWRlICogNDtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgaWYgKHRoaXMuc2hhZGVyKSB7XG4gICAgICB0aGlzLnNoYWRlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLnNoYWRlciA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMudGVtcE1hdHJpeCA9IG51bGw7XG4gIH1cbn1cblBhcnRpY2xlUmVuZGVyZXIuZXh0ZW5zaW9uID0ge1xuICBuYW1lOiBcInBhcnRpY2xlXCIsXG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJQbHVnaW5cbn07XG5leHRlbnNpb25zLmFkZChQYXJ0aWNsZVJlbmRlcmVyKTtcblxuZXhwb3J0IHsgUGFydGljbGVSZW5kZXJlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFydGljbGVSZW5kZXJlci5tanMubWFwXG4iLCJleHBvcnQgeyBQYXJ0aWNsZUNvbnRhaW5lciB9IGZyb20gJy4vUGFydGljbGVDb250YWluZXIubWpzJztcbmV4cG9ydCB7IFBhcnRpY2xlUmVuZGVyZXIgfSBmcm9tICcuL1BhcnRpY2xlUmVuZGVyZXIubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsInZhciBURVhUX0dSQURJRU5UID0gLyogQF9fUFVSRV9fICovICgoVEVYVF9HUkFESUVOVDIpID0+IHtcbiAgVEVYVF9HUkFESUVOVDJbVEVYVF9HUkFESUVOVDJbXCJMSU5FQVJfVkVSVElDQUxcIl0gPSAwXSA9IFwiTElORUFSX1ZFUlRJQ0FMXCI7XG4gIFRFWFRfR1JBRElFTlQyW1RFWFRfR1JBRElFTlQyW1wiTElORUFSX0hPUklaT05UQUxcIl0gPSAxXSA9IFwiTElORUFSX0hPUklaT05UQUxcIjtcbiAgcmV0dXJuIFRFWFRfR1JBRElFTlQyO1xufSkoVEVYVF9HUkFESUVOVCB8fCB7fSk7XG5cbmV4cG9ydCB7IFRFWFRfR1JBRElFTlQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0Lm1qcy5tYXBcbiIsImltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmNvbnN0IGNvbnRleHRTZXR0aW5ncyA9IHtcbiAgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlXG59O1xuY29uc3QgX1RleHRNZXRyaWNzID0gY2xhc3Mge1xuICBzdGF0aWMgZ2V0IGV4cGVyaW1lbnRhbExldHRlclNwYWNpbmdTdXBwb3J0ZWQoKSB7XG4gICAgbGV0IHJlc3VsdCA9IF9UZXh0TWV0cmljcy5fZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZ1N1cHBvcnRlZDtcbiAgICBpZiAocmVzdWx0ICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IHByb3RvID0gc2V0dGluZ3MuQURBUFRFUi5nZXRDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQoKS5wcm90b3R5cGU7XG4gICAgICByZXN1bHQgPSBfVGV4dE1ldHJpY3MuX2V4cGVyaW1lbnRhbExldHRlclNwYWNpbmdTdXBwb3J0ZWQgPSBcImxldHRlclNwYWNpbmdcIiBpbiBwcm90byB8fCBcInRleHRMZXR0ZXJTcGFjaW5nXCIgaW4gcHJvdG87XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY29uc3RydWN0b3IodGV4dCwgc3R5bGUsIHdpZHRoLCBoZWlnaHQsIGxpbmVzLCBsaW5lV2lkdGhzLCBsaW5lSGVpZ2h0LCBtYXhMaW5lV2lkdGgsIGZvbnRQcm9wZXJ0aWVzKSB7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMubGluZXMgPSBsaW5lcztcbiAgICB0aGlzLmxpbmVXaWR0aHMgPSBsaW5lV2lkdGhzO1xuICAgIHRoaXMubGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgdGhpcy5tYXhMaW5lV2lkdGggPSBtYXhMaW5lV2lkdGg7XG4gICAgdGhpcy5mb250UHJvcGVydGllcyA9IGZvbnRQcm9wZXJ0aWVzO1xuICB9XG4gIHN0YXRpYyBtZWFzdXJlVGV4dCh0ZXh0LCBzdHlsZSwgd29yZFdyYXAsIGNhbnZhcyA9IF9UZXh0TWV0cmljcy5fY2FudmFzKSB7XG4gICAgd29yZFdyYXAgPSB3b3JkV3JhcCA9PT0gdm9pZCAwIHx8IHdvcmRXcmFwID09PSBudWxsID8gc3R5bGUud29yZFdyYXAgOiB3b3JkV3JhcDtcbiAgICBjb25zdCBmb250ID0gc3R5bGUudG9Gb250U3RyaW5nKCk7XG4gICAgY29uc3QgZm9udFByb3BlcnRpZXMgPSBfVGV4dE1ldHJpY3MubWVhc3VyZUZvbnQoZm9udCk7XG4gICAgaWYgKGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplID09PSAwKSB7XG4gICAgICBmb250UHJvcGVydGllcy5mb250U2l6ZSA9IHN0eWxlLmZvbnRTaXplO1xuICAgICAgZm9udFByb3BlcnRpZXMuYXNjZW50ID0gc3R5bGUuZm9udFNpemU7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIGNvbnRleHRTZXR0aW5ncyk7XG4gICAgY29udGV4dC5mb250ID0gZm9udDtcbiAgICBjb25zdCBvdXRwdXRUZXh0ID0gd29yZFdyYXAgPyBfVGV4dE1ldHJpY3Mud29yZFdyYXAodGV4dCwgc3R5bGUsIGNhbnZhcykgOiB0ZXh0O1xuICAgIGNvbnN0IGxpbmVzID0gb3V0cHV0VGV4dC5zcGxpdCgvKD86XFxyXFxufFxccnxcXG4pLyk7XG4gICAgY29uc3QgbGluZVdpZHRocyA9IG5ldyBBcnJheShsaW5lcy5sZW5ndGgpO1xuICAgIGxldCBtYXhMaW5lV2lkdGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IF9UZXh0TWV0cmljcy5fbWVhc3VyZVRleHQobGluZXNbaV0sIHN0eWxlLmxldHRlclNwYWNpbmcsIGNvbnRleHQpO1xuICAgICAgbGluZVdpZHRoc1tpXSA9IGxpbmVXaWR0aDtcbiAgICAgIG1heExpbmVXaWR0aCA9IE1hdGgubWF4KG1heExpbmVXaWR0aCwgbGluZVdpZHRoKTtcbiAgICB9XG4gICAgbGV0IHdpZHRoID0gbWF4TGluZVdpZHRoICsgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzO1xuICAgIGlmIChzdHlsZS5kcm9wU2hhZG93KSB7XG4gICAgICB3aWR0aCArPSBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgfVxuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBzdHlsZS5saW5lSGVpZ2h0IHx8IGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplICsgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzO1xuICAgIGxldCBoZWlnaHQgPSBNYXRoLm1heChsaW5lSGVpZ2h0LCBmb250UHJvcGVydGllcy5mb250U2l6ZSArIHN0eWxlLnN0cm9rZVRoaWNrbmVzcyAqIDIpICsgKGxpbmVzLmxlbmd0aCAtIDEpICogKGxpbmVIZWlnaHQgKyBzdHlsZS5sZWFkaW5nKTtcbiAgICBpZiAoc3R5bGUuZHJvcFNoYWRvdykge1xuICAgICAgaGVpZ2h0ICs9IHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfVGV4dE1ldHJpY3ModGV4dCwgc3R5bGUsIHdpZHRoLCBoZWlnaHQsIGxpbmVzLCBsaW5lV2lkdGhzLCBsaW5lSGVpZ2h0ICsgc3R5bGUubGVhZGluZywgbWF4TGluZVdpZHRoLCBmb250UHJvcGVydGllcyk7XG4gIH1cbiAgc3RhdGljIF9tZWFzdXJlVGV4dCh0ZXh0LCBsZXR0ZXJTcGFjaW5nLCBjb250ZXh0KSB7XG4gICAgbGV0IHVzZUV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcgPSBmYWxzZTtcbiAgICBpZiAoX1RleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmdTdXBwb3J0ZWQpIHtcbiAgICAgIGlmIChfVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZykge1xuICAgICAgICBjb250ZXh0LmxldHRlclNwYWNpbmcgPSBgJHtsZXR0ZXJTcGFjaW5nfXB4YDtcbiAgICAgICAgY29udGV4dC50ZXh0TGV0dGVyU3BhY2luZyA9IGAke2xldHRlclNwYWNpbmd9cHhgO1xuICAgICAgICB1c2VFeHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQubGV0dGVyU3BhY2luZyA9IFwiMHB4XCI7XG4gICAgICAgIGNvbnRleHQudGV4dExldHRlclNwYWNpbmcgPSBcIjBweFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgd2lkdGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgIGlmICh3aWR0aCA+IDApIHtcbiAgICAgIGlmICh1c2VFeHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nKSB7XG4gICAgICAgIHdpZHRoIC09IGxldHRlclNwYWNpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aCArPSAoX1RleHRNZXRyaWNzLmdyYXBoZW1lU2VnbWVudGVyKHRleHQpLmxlbmd0aCAtIDEpICogbGV0dGVyU3BhY2luZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoO1xuICB9XG4gIHN0YXRpYyB3b3JkV3JhcCh0ZXh0LCBzdHlsZSwgY2FudmFzID0gX1RleHRNZXRyaWNzLl9jYW52YXMpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCBjb250ZXh0U2V0dGluZ3MpO1xuICAgIGxldCB3aWR0aCA9IDA7XG4gICAgbGV0IGxpbmUgPSBcIlwiO1xuICAgIGxldCBsaW5lcyA9IFwiXCI7XG4gICAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCB7IGxldHRlclNwYWNpbmcsIHdoaXRlU3BhY2UgfSA9IHN0eWxlO1xuICAgIGNvbnN0IGNvbGxhcHNlU3BhY2VzID0gX1RleHRNZXRyaWNzLmNvbGxhcHNlU3BhY2VzKHdoaXRlU3BhY2UpO1xuICAgIGNvbnN0IGNvbGxhcHNlTmV3bGluZXMgPSBfVGV4dE1ldHJpY3MuY29sbGFwc2VOZXdsaW5lcyh3aGl0ZVNwYWNlKTtcbiAgICBsZXQgY2FuUHJlcGVuZFNwYWNlcyA9ICFjb2xsYXBzZVNwYWNlcztcbiAgICBjb25zdCB3b3JkV3JhcFdpZHRoID0gc3R5bGUud29yZFdyYXBXaWR0aCArIGxldHRlclNwYWNpbmc7XG4gICAgY29uc3QgdG9rZW5zID0gX1RleHRNZXRyaWNzLnRva2VuaXplKHRleHQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICBpZiAoX1RleHRNZXRyaWNzLmlzTmV3bGluZSh0b2tlbikpIHtcbiAgICAgICAgaWYgKCFjb2xsYXBzZU5ld2xpbmVzKSB7XG4gICAgICAgICAgbGluZXMgKz0gX1RleHRNZXRyaWNzLmFkZExpbmUobGluZSk7XG4gICAgICAgICAgY2FuUHJlcGVuZFNwYWNlcyA9ICFjb2xsYXBzZVNwYWNlcztcbiAgICAgICAgICBsaW5lID0gXCJcIjtcbiAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4gPSBcIiBcIjtcbiAgICAgIH1cbiAgICAgIGlmIChjb2xsYXBzZVNwYWNlcykge1xuICAgICAgICBjb25zdCBjdXJySXNCcmVha2luZ1NwYWNlID0gX1RleHRNZXRyaWNzLmlzQnJlYWtpbmdTcGFjZSh0b2tlbik7XG4gICAgICAgIGNvbnN0IGxhc3RJc0JyZWFraW5nU3BhY2UgPSBfVGV4dE1ldHJpY3MuaXNCcmVha2luZ1NwYWNlKGxpbmVbbGluZS5sZW5ndGggLSAxXSk7XG4gICAgICAgIGlmIChjdXJySXNCcmVha2luZ1NwYWNlICYmIGxhc3RJc0JyZWFraW5nU3BhY2UpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdG9rZW5XaWR0aCA9IF9UZXh0TWV0cmljcy5nZXRGcm9tQ2FjaGUodG9rZW4sIGxldHRlclNwYWNpbmcsIGNhY2hlLCBjb250ZXh0KTtcbiAgICAgIGlmICh0b2tlbldpZHRoID4gd29yZFdyYXBXaWR0aCkge1xuICAgICAgICBpZiAobGluZSAhPT0gXCJcIikge1xuICAgICAgICAgIGxpbmVzICs9IF9UZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUpO1xuICAgICAgICAgIGxpbmUgPSBcIlwiO1xuICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX1RleHRNZXRyaWNzLmNhbkJyZWFrV29yZHModG9rZW4sIHN0eWxlLmJyZWFrV29yZHMpKSB7XG4gICAgICAgICAgY29uc3QgY2hhcmFjdGVycyA9IF9UZXh0TWV0cmljcy53b3JkV3JhcFNwbGl0KHRva2VuKTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoYXJhY3RlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCBjaGFyID0gY2hhcmFjdGVyc1tqXTtcbiAgICAgICAgICAgIGxldCBsYXN0Q2hhciA9IGNoYXI7XG4gICAgICAgICAgICBsZXQgayA9IDE7XG4gICAgICAgICAgICB3aGlsZSAoY2hhcmFjdGVyc1tqICsga10pIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV4dENoYXIgPSBjaGFyYWN0ZXJzW2ogKyBrXTtcbiAgICAgICAgICAgICAgaWYgKCFfVGV4dE1ldHJpY3MuY2FuQnJlYWtDaGFycyhsYXN0Q2hhciwgbmV4dENoYXIsIHRva2VuLCBqLCBzdHlsZS5icmVha1dvcmRzKSkge1xuICAgICAgICAgICAgICAgIGNoYXIgKz0gbmV4dENoYXI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGFzdENoYXIgPSBuZXh0Q2hhcjtcbiAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaiArPSBrIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IGNoYXJhY3RlcldpZHRoID0gX1RleHRNZXRyaWNzLmdldEZyb21DYWNoZShjaGFyLCBsZXR0ZXJTcGFjaW5nLCBjYWNoZSwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoY2hhcmFjdGVyV2lkdGggKyB3aWR0aCA+IHdvcmRXcmFwV2lkdGgpIHtcbiAgICAgICAgICAgICAgbGluZXMgKz0gX1RleHRNZXRyaWNzLmFkZExpbmUobGluZSk7XG4gICAgICAgICAgICAgIGNhblByZXBlbmRTcGFjZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgbGluZSA9IFwiXCI7XG4gICAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmUgKz0gY2hhcjtcbiAgICAgICAgICAgIHdpZHRoICs9IGNoYXJhY3RlcldpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobGluZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsaW5lcyArPSBfVGV4dE1ldHJpY3MuYWRkTGluZShsaW5lKTtcbiAgICAgICAgICAgIGxpbmUgPSBcIlwiO1xuICAgICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpc0xhc3RUb2tlbiA9IGkgPT09IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgIGxpbmVzICs9IF9UZXh0TWV0cmljcy5hZGRMaW5lKHRva2VuLCAhaXNMYXN0VG9rZW4pO1xuICAgICAgICAgIGNhblByZXBlbmRTcGFjZXMgPSBmYWxzZTtcbiAgICAgICAgICBsaW5lID0gXCJcIjtcbiAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0b2tlbldpZHRoICsgd2lkdGggPiB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgY2FuUHJlcGVuZFNwYWNlcyA9IGZhbHNlO1xuICAgICAgICAgIGxpbmVzICs9IF9UZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUpO1xuICAgICAgICAgIGxpbmUgPSBcIlwiO1xuICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZS5sZW5ndGggPiAwIHx8ICFfVGV4dE1ldHJpY3MuaXNCcmVha2luZ1NwYWNlKHRva2VuKSB8fCBjYW5QcmVwZW5kU3BhY2VzKSB7XG4gICAgICAgICAgbGluZSArPSB0b2tlbjtcbiAgICAgICAgICB3aWR0aCArPSB0b2tlbldpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxpbmVzICs9IF9UZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUsIGZhbHNlKTtcbiAgICByZXR1cm4gbGluZXM7XG4gIH1cbiAgc3RhdGljIGFkZExpbmUobGluZSwgbmV3TGluZSA9IHRydWUpIHtcbiAgICBsaW5lID0gX1RleHRNZXRyaWNzLnRyaW1SaWdodChsaW5lKTtcbiAgICBsaW5lID0gbmV3TGluZSA/IGAke2xpbmV9XG5gIDogbGluZTtcbiAgICByZXR1cm4gbGluZTtcbiAgfVxuICBzdGF0aWMgZ2V0RnJvbUNhY2hlKGtleSwgbGV0dGVyU3BhY2luZywgY2FjaGUsIGNvbnRleHQpIHtcbiAgICBsZXQgd2lkdGggPSBjYWNoZVtrZXldO1xuICAgIGlmICh0eXBlb2Ygd2lkdGggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHdpZHRoID0gX1RleHRNZXRyaWNzLl9tZWFzdXJlVGV4dChrZXksIGxldHRlclNwYWNpbmcsIGNvbnRleHQpICsgbGV0dGVyU3BhY2luZztcbiAgICAgIGNhY2hlW2tleV0gPSB3aWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoO1xuICB9XG4gIHN0YXRpYyBjb2xsYXBzZVNwYWNlcyh3aGl0ZVNwYWNlKSB7XG4gICAgcmV0dXJuIHdoaXRlU3BhY2UgPT09IFwibm9ybWFsXCIgfHwgd2hpdGVTcGFjZSA9PT0gXCJwcmUtbGluZVwiO1xuICB9XG4gIHN0YXRpYyBjb2xsYXBzZU5ld2xpbmVzKHdoaXRlU3BhY2UpIHtcbiAgICByZXR1cm4gd2hpdGVTcGFjZSA9PT0gXCJub3JtYWxcIjtcbiAgfVxuICBzdGF0aWMgdHJpbVJpZ2h0KHRleHQpIHtcbiAgICBpZiAodHlwZW9mIHRleHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gdGV4dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgY2hhciA9IHRleHRbaV07XG4gICAgICBpZiAoIV9UZXh0TWV0cmljcy5pc0JyZWFraW5nU3BhY2UoY2hhcikpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9XG4gIHN0YXRpYyBpc05ld2xpbmUoY2hhcikge1xuICAgIGlmICh0eXBlb2YgY2hhciAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gX1RleHRNZXRyaWNzLl9uZXdsaW5lcy5pbmNsdWRlcyhjaGFyLmNoYXJDb2RlQXQoMCkpO1xuICB9XG4gIHN0YXRpYyBpc0JyZWFraW5nU3BhY2UoY2hhciwgX25leHRDaGFyKSB7XG4gICAgaWYgKHR5cGVvZiBjaGFyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBfVGV4dE1ldHJpY3MuX2JyZWFraW5nU3BhY2VzLmluY2x1ZGVzKGNoYXIuY2hhckNvZGVBdCgwKSk7XG4gIH1cbiAgc3RhdGljIHRva2VuaXplKHRleHQpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICBsZXQgdG9rZW4gPSBcIlwiO1xuICAgIGlmICh0eXBlb2YgdGV4dCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyID0gdGV4dFtpXTtcbiAgICAgIGNvbnN0IG5leHRDaGFyID0gdGV4dFtpICsgMV07XG4gICAgICBpZiAoX1RleHRNZXRyaWNzLmlzQnJlYWtpbmdTcGFjZShjaGFyLCBuZXh0Q2hhcikgfHwgX1RleHRNZXRyaWNzLmlzTmV3bGluZShjaGFyKSkge1xuICAgICAgICBpZiAodG9rZW4gIT09IFwiXCIpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgdG9rZW4gPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5wdXNoKGNoYXIpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRva2VuICs9IGNoYXI7XG4gICAgfVxuICAgIGlmICh0b2tlbiAhPT0gXCJcIikge1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdG9rZW5zO1xuICB9XG4gIHN0YXRpYyBjYW5CcmVha1dvcmRzKF90b2tlbiwgYnJlYWtXb3Jkcykge1xuICAgIHJldHVybiBicmVha1dvcmRzO1xuICB9XG4gIHN0YXRpYyBjYW5CcmVha0NoYXJzKF9jaGFyLCBfbmV4dENoYXIsIF90b2tlbiwgX2luZGV4LCBfYnJlYWtXb3Jkcykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN0YXRpYyB3b3JkV3JhcFNwbGl0KHRva2VuKSB7XG4gICAgcmV0dXJuIF9UZXh0TWV0cmljcy5ncmFwaGVtZVNlZ21lbnRlcih0b2tlbik7XG4gIH1cbiAgc3RhdGljIG1lYXN1cmVGb250KGZvbnQpIHtcbiAgICBpZiAoX1RleHRNZXRyaWNzLl9mb250c1tmb250XSkge1xuICAgICAgcmV0dXJuIF9UZXh0TWV0cmljcy5fZm9udHNbZm9udF07XG4gICAgfVxuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICBhc2NlbnQ6IDAsXG4gICAgICBkZXNjZW50OiAwLFxuICAgICAgZm9udFNpemU6IDBcbiAgICB9O1xuICAgIGNvbnN0IGNhbnZhcyA9IF9UZXh0TWV0cmljcy5fY2FudmFzO1xuICAgIGNvbnN0IGNvbnRleHQgPSBfVGV4dE1ldHJpY3MuX2NvbnRleHQ7XG4gICAgY29udGV4dC5mb250ID0gZm9udDtcbiAgICBjb25zdCBtZXRyaWNzU3RyaW5nID0gX1RleHRNZXRyaWNzLk1FVFJJQ1NfU1RSSU5HICsgX1RleHRNZXRyaWNzLkJBU0VMSU5FX1NZTUJPTDtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGguY2VpbChjb250ZXh0Lm1lYXN1cmVUZXh0KG1ldHJpY3NTdHJpbmcpLndpZHRoKTtcbiAgICBsZXQgYmFzZWxpbmUgPSBNYXRoLmNlaWwoY29udGV4dC5tZWFzdXJlVGV4dChfVGV4dE1ldHJpY3MuQkFTRUxJTkVfU1lNQk9MKS53aWR0aCk7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5jZWlsKF9UZXh0TWV0cmljcy5IRUlHSFRfTVVMVElQTElFUiAqIGJhc2VsaW5lKTtcbiAgICBiYXNlbGluZSA9IGJhc2VsaW5lICogX1RleHRNZXRyaWNzLkJBU0VMSU5FX01VTFRJUExJRVIgfCAwO1xuICAgIGlmICh3aWR0aCA9PT0gMCB8fCBoZWlnaHQgPT09IDApIHtcbiAgICAgIF9UZXh0TWV0cmljcy5fZm9udHNbZm9udF0gPSBwcm9wZXJ0aWVzO1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfVxuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBcIiNmMDBcIjtcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnRleHQuZm9udCA9IGZvbnQ7XG4gICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSBcImFscGhhYmV0aWNcIjtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwiIzAwMFwiO1xuICAgIGNvbnRleHQuZmlsbFRleHQobWV0cmljc1N0cmluZywgMCwgYmFzZWxpbmUpO1xuICAgIGNvbnN0IGltYWdlZGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gICAgY29uc3QgcGl4ZWxzID0gaW1hZ2VkYXRhLmxlbmd0aDtcbiAgICBjb25zdCBsaW5lID0gd2lkdGggKiA0O1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgaWR4ID0gMDtcbiAgICBsZXQgc3RvcCA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBiYXNlbGluZTsgKytpKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmU7IGogKz0gNCkge1xuICAgICAgICBpZiAoaW1hZ2VkYXRhW2lkeCArIGpdICE9PSAyNTUpIHtcbiAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFzdG9wKSB7XG4gICAgICAgIGlkeCArPSBsaW5lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BlcnRpZXMuYXNjZW50ID0gYmFzZWxpbmUgLSBpO1xuICAgIGlkeCA9IHBpeGVscyAtIGxpbmU7XG4gICAgc3RvcCA9IGZhbHNlO1xuICAgIGZvciAoaSA9IGhlaWdodDsgaSA+IGJhc2VsaW5lOyAtLWkpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGluZTsgaiArPSA0KSB7XG4gICAgICAgIGlmIChpbWFnZWRhdGFbaWR4ICsgal0gIT09IDI1NSkge1xuICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXN0b3ApIHtcbiAgICAgICAgaWR4IC09IGxpbmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcHJvcGVydGllcy5kZXNjZW50ID0gaSAtIGJhc2VsaW5lO1xuICAgIHByb3BlcnRpZXMuZm9udFNpemUgPSBwcm9wZXJ0aWVzLmFzY2VudCArIHByb3BlcnRpZXMuZGVzY2VudDtcbiAgICBfVGV4dE1ldHJpY3MuX2ZvbnRzW2ZvbnRdID0gcHJvcGVydGllcztcbiAgICByZXR1cm4gcHJvcGVydGllcztcbiAgfVxuICBzdGF0aWMgY2xlYXJNZXRyaWNzKGZvbnQgPSBcIlwiKSB7XG4gICAgaWYgKGZvbnQpIHtcbiAgICAgIGRlbGV0ZSBfVGV4dE1ldHJpY3MuX2ZvbnRzW2ZvbnRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBfVGV4dE1ldHJpY3MuX2ZvbnRzID0ge307XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgX2NhbnZhcygpIHtcbiAgICBpZiAoIV9UZXh0TWV0cmljcy5fX2NhbnZhcykge1xuICAgICAgbGV0IGNhbnZhcztcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDAsIDApO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gYy5nZXRDb250ZXh0KFwiMmRcIiwgY29udGV4dFNldHRpbmdzKTtcbiAgICAgICAgaWYgKGNvbnRleHQ/Lm1lYXN1cmVUZXh0KSB7XG4gICAgICAgICAgX1RleHRNZXRyaWNzLl9fY2FudmFzID0gYztcbiAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfVxuICAgICAgICBjYW52YXMgPSBzZXR0aW5ncy5BREFQVEVSLmNyZWF0ZUNhbnZhcygpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgY2FudmFzID0gc2V0dGluZ3MuQURBUFRFUi5jcmVhdGVDYW52YXMoKTtcbiAgICAgIH1cbiAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAxMDtcbiAgICAgIF9UZXh0TWV0cmljcy5fX2NhbnZhcyA9IGNhbnZhcztcbiAgICB9XG4gICAgcmV0dXJuIF9UZXh0TWV0cmljcy5fX2NhbnZhcztcbiAgfVxuICBzdGF0aWMgZ2V0IF9jb250ZXh0KCkge1xuICAgIGlmICghX1RleHRNZXRyaWNzLl9fY29udGV4dCkge1xuICAgICAgX1RleHRNZXRyaWNzLl9fY29udGV4dCA9IF9UZXh0TWV0cmljcy5fY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCBjb250ZXh0U2V0dGluZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gX1RleHRNZXRyaWNzLl9fY29udGV4dDtcbiAgfVxufTtcbmxldCBUZXh0TWV0cmljcyA9IF9UZXh0TWV0cmljcztcblRleHRNZXRyaWNzLk1FVFJJQ1NfU1RSSU5HID0gXCJ8XFx4QzlxXFx4QzVcIjtcblRleHRNZXRyaWNzLkJBU0VMSU5FX1NZTUJPTCA9IFwiTVwiO1xuVGV4dE1ldHJpY3MuQkFTRUxJTkVfTVVMVElQTElFUiA9IDEuNDtcblRleHRNZXRyaWNzLkhFSUdIVF9NVUxUSVBMSUVSID0gMjtcblRleHRNZXRyaWNzLmdyYXBoZW1lU2VnbWVudGVyID0gKCgpID0+IHtcbiAgaWYgKHR5cGVvZiBJbnRsPy5TZWdtZW50ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnN0IHNlZ21lbnRlciA9IG5ldyBJbnRsLlNlZ21lbnRlcigpO1xuICAgIHJldHVybiAocykgPT4gWy4uLnNlZ21lbnRlci5zZWdtZW50KHMpXS5tYXAoKHgpID0+IHguc2VnbWVudCk7XG4gIH1cbiAgcmV0dXJuIChzKSA9PiBbLi4uc107XG59KSgpO1xuVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZyA9IGZhbHNlO1xuVGV4dE1ldHJpY3MuX2ZvbnRzID0ge307XG5UZXh0TWV0cmljcy5fbmV3bGluZXMgPSBbXG4gIDEwLFxuICAxM1xuXTtcblRleHRNZXRyaWNzLl9icmVha2luZ1NwYWNlcyA9IFtcbiAgOSxcbiAgMzIsXG4gIDgxOTIsXG4gIDgxOTMsXG4gIDgxOTQsXG4gIDgxOTUsXG4gIDgxOTYsXG4gIDgxOTcsXG4gIDgxOTgsXG4gIDgyMDAsXG4gIDgyMDEsXG4gIDgyMDIsXG4gIDgyODcsXG4gIDEyMjg4XG5dO1xuXG5leHBvcnQgeyBUZXh0TWV0cmljcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dE1ldHJpY3MubWpzLm1hcFxuIiwiaW1wb3J0IHsgVEVYVF9HUkFESUVOVCB9IGZyb20gJy4vY29uc3QubWpzJztcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmNvbnN0IGdlbmVyaWNGb250RmFtaWxpZXMgPSBbXG4gIFwic2VyaWZcIixcbiAgXCJzYW5zLXNlcmlmXCIsXG4gIFwibW9ub3NwYWNlXCIsXG4gIFwiY3Vyc2l2ZVwiLFxuICBcImZhbnRhc3lcIixcbiAgXCJzeXN0ZW0tdWlcIlxuXTtcbmNvbnN0IF9UZXh0U3R5bGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHN0eWxlKSB7XG4gICAgdGhpcy5zdHlsZUlEID0gMDtcbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgZGVlcENvcHlQcm9wZXJ0aWVzKHRoaXMsIHN0eWxlLCBzdHlsZSk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmVkUHJvcGVydGllcyA9IHt9O1xuICAgIGRlZXBDb3B5UHJvcGVydGllcyhjbG9uZWRQcm9wZXJ0aWVzLCB0aGlzLCBfVGV4dFN0eWxlLmRlZmF1bHRTdHlsZSk7XG4gICAgcmV0dXJuIG5ldyBfVGV4dFN0eWxlKGNsb25lZFByb3BlcnRpZXMpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIGRlZXBDb3B5UHJvcGVydGllcyh0aGlzLCBfVGV4dFN0eWxlLmRlZmF1bHRTdHlsZSwgX1RleHRTdHlsZS5kZWZhdWx0U3R5bGUpO1xuICB9XG4gIGdldCBhbGlnbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYWxpZ247XG4gIH1cbiAgc2V0IGFsaWduKGFsaWduKSB7XG4gICAgaWYgKHRoaXMuX2FsaWduICE9PSBhbGlnbikge1xuICAgICAgdGhpcy5fYWxpZ24gPSBhbGlnbjtcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgYnJlYWtXb3JkcygpIHtcbiAgICByZXR1cm4gdGhpcy5fYnJlYWtXb3JkcztcbiAgfVxuICBzZXQgYnJlYWtXb3JkcyhicmVha1dvcmRzKSB7XG4gICAgaWYgKHRoaXMuX2JyZWFrV29yZHMgIT09IGJyZWFrV29yZHMpIHtcbiAgICAgIHRoaXMuX2JyZWFrV29yZHMgPSBicmVha1dvcmRzO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCBkcm9wU2hhZG93KCkge1xuICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93O1xuICB9XG4gIHNldCBkcm9wU2hhZG93KGRyb3BTaGFkb3cpIHtcbiAgICBpZiAodGhpcy5fZHJvcFNoYWRvdyAhPT0gZHJvcFNoYWRvdykge1xuICAgICAgdGhpcy5fZHJvcFNoYWRvdyA9IGRyb3BTaGFkb3c7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IGRyb3BTaGFkb3dBbHBoYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0FscGhhO1xuICB9XG4gIHNldCBkcm9wU2hhZG93QWxwaGEoZHJvcFNoYWRvd0FscGhhKSB7XG4gICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3dBbHBoYSAhPT0gZHJvcFNoYWRvd0FscGhhKSB7XG4gICAgICB0aGlzLl9kcm9wU2hhZG93QWxwaGEgPSBkcm9wU2hhZG93QWxwaGE7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IGRyb3BTaGFkb3dBbmdsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0FuZ2xlO1xuICB9XG4gIHNldCBkcm9wU2hhZG93QW5nbGUoZHJvcFNoYWRvd0FuZ2xlKSB7XG4gICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3dBbmdsZSAhPT0gZHJvcFNoYWRvd0FuZ2xlKSB7XG4gICAgICB0aGlzLl9kcm9wU2hhZG93QW5nbGUgPSBkcm9wU2hhZG93QW5nbGU7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IGRyb3BTaGFkb3dCbHVyKCkge1xuICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93Qmx1cjtcbiAgfVxuICBzZXQgZHJvcFNoYWRvd0JsdXIoZHJvcFNoYWRvd0JsdXIpIHtcbiAgICBpZiAodGhpcy5fZHJvcFNoYWRvd0JsdXIgIT09IGRyb3BTaGFkb3dCbHVyKSB7XG4gICAgICB0aGlzLl9kcm9wU2hhZG93Qmx1ciA9IGRyb3BTaGFkb3dCbHVyO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCBkcm9wU2hhZG93Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Ryb3BTaGFkb3dDb2xvcjtcbiAgfVxuICBzZXQgZHJvcFNoYWRvd0NvbG9yKGRyb3BTaGFkb3dDb2xvcikge1xuICAgIGNvbnN0IG91dHB1dENvbG9yID0gZ2V0Q29sb3IoZHJvcFNoYWRvd0NvbG9yKTtcbiAgICBpZiAodGhpcy5fZHJvcFNoYWRvd0NvbG9yICE9PSBvdXRwdXRDb2xvcikge1xuICAgICAgdGhpcy5fZHJvcFNoYWRvd0NvbG9yID0gb3V0cHV0Q29sb3I7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IGRyb3BTaGFkb3dEaXN0YW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0Rpc3RhbmNlO1xuICB9XG4gIHNldCBkcm9wU2hhZG93RGlzdGFuY2UoZHJvcFNoYWRvd0Rpc3RhbmNlKSB7XG4gICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3dEaXN0YW5jZSAhPT0gZHJvcFNoYWRvd0Rpc3RhbmNlKSB7XG4gICAgICB0aGlzLl9kcm9wU2hhZG93RGlzdGFuY2UgPSBkcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IGZpbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGw7XG4gIH1cbiAgc2V0IGZpbGwoZmlsbCkge1xuICAgIGNvbnN0IG91dHB1dENvbG9yID0gZ2V0Q29sb3IoZmlsbCk7XG4gICAgaWYgKHRoaXMuX2ZpbGwgIT09IG91dHB1dENvbG9yKSB7XG4gICAgICB0aGlzLl9maWxsID0gb3V0cHV0Q29sb3I7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IGZpbGxHcmFkaWVudFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGxHcmFkaWVudFR5cGU7XG4gIH1cbiAgc2V0IGZpbGxHcmFkaWVudFR5cGUoZmlsbEdyYWRpZW50VHlwZSkge1xuICAgIGlmICh0aGlzLl9maWxsR3JhZGllbnRUeXBlICE9PSBmaWxsR3JhZGllbnRUeXBlKSB7XG4gICAgICB0aGlzLl9maWxsR3JhZGllbnRUeXBlID0gZmlsbEdyYWRpZW50VHlwZTtcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgZmlsbEdyYWRpZW50U3RvcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGxHcmFkaWVudFN0b3BzO1xuICB9XG4gIHNldCBmaWxsR3JhZGllbnRTdG9wcyhmaWxsR3JhZGllbnRTdG9wcykge1xuICAgIGlmICghYXJlQXJyYXlzRXF1YWwodGhpcy5fZmlsbEdyYWRpZW50U3RvcHMsIGZpbGxHcmFkaWVudFN0b3BzKSkge1xuICAgICAgdGhpcy5fZmlsbEdyYWRpZW50U3RvcHMgPSBmaWxsR3JhZGllbnRTdG9wcztcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgZm9udEZhbWlseSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udEZhbWlseTtcbiAgfVxuICBzZXQgZm9udEZhbWlseShmb250RmFtaWx5KSB7XG4gICAgaWYgKHRoaXMuZm9udEZhbWlseSAhPT0gZm9udEZhbWlseSkge1xuICAgICAgdGhpcy5fZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IGZvbnRTaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9mb250U2l6ZTtcbiAgfVxuICBzZXQgZm9udFNpemUoZm9udFNpemUpIHtcbiAgICBpZiAodGhpcy5fZm9udFNpemUgIT09IGZvbnRTaXplKSB7XG4gICAgICB0aGlzLl9mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCBmb250U3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnRTdHlsZTtcbiAgfVxuICBzZXQgZm9udFN0eWxlKGZvbnRTdHlsZSkge1xuICAgIGlmICh0aGlzLl9mb250U3R5bGUgIT09IGZvbnRTdHlsZSkge1xuICAgICAgdGhpcy5fZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCBmb250VmFyaWFudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udFZhcmlhbnQ7XG4gIH1cbiAgc2V0IGZvbnRWYXJpYW50KGZvbnRWYXJpYW50KSB7XG4gICAgaWYgKHRoaXMuX2ZvbnRWYXJpYW50ICE9PSBmb250VmFyaWFudCkge1xuICAgICAgdGhpcy5fZm9udFZhcmlhbnQgPSBmb250VmFyaWFudDtcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgZm9udFdlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udFdlaWdodDtcbiAgfVxuICBzZXQgZm9udFdlaWdodChmb250V2VpZ2h0KSB7XG4gICAgaWYgKHRoaXMuX2ZvbnRXZWlnaHQgIT09IGZvbnRXZWlnaHQpIHtcbiAgICAgIHRoaXMuX2ZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCBsZXR0ZXJTcGFjaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9sZXR0ZXJTcGFjaW5nO1xuICB9XG4gIHNldCBsZXR0ZXJTcGFjaW5nKGxldHRlclNwYWNpbmcpIHtcbiAgICBpZiAodGhpcy5fbGV0dGVyU3BhY2luZyAhPT0gbGV0dGVyU3BhY2luZykge1xuICAgICAgdGhpcy5fbGV0dGVyU3BhY2luZyA9IGxldHRlclNwYWNpbmc7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IGxpbmVIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpbmVIZWlnaHQ7XG4gIH1cbiAgc2V0IGxpbmVIZWlnaHQobGluZUhlaWdodCkge1xuICAgIGlmICh0aGlzLl9saW5lSGVpZ2h0ICE9PSBsaW5lSGVpZ2h0KSB7XG4gICAgICB0aGlzLl9saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgbGVhZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVhZGluZztcbiAgfVxuICBzZXQgbGVhZGluZyhsZWFkaW5nKSB7XG4gICAgaWYgKHRoaXMuX2xlYWRpbmcgIT09IGxlYWRpbmcpIHtcbiAgICAgIHRoaXMuX2xlYWRpbmcgPSBsZWFkaW5nO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCBsaW5lSm9pbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbGluZUpvaW47XG4gIH1cbiAgc2V0IGxpbmVKb2luKGxpbmVKb2luKSB7XG4gICAgaWYgKHRoaXMuX2xpbmVKb2luICE9PSBsaW5lSm9pbikge1xuICAgICAgdGhpcy5fbGluZUpvaW4gPSBsaW5lSm9pbjtcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgbWl0ZXJMaW1pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWl0ZXJMaW1pdDtcbiAgfVxuICBzZXQgbWl0ZXJMaW1pdChtaXRlckxpbWl0KSB7XG4gICAgaWYgKHRoaXMuX21pdGVyTGltaXQgIT09IG1pdGVyTGltaXQpIHtcbiAgICAgIHRoaXMuX21pdGVyTGltaXQgPSBtaXRlckxpbWl0O1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCBwYWRkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWRkaW5nO1xuICB9XG4gIHNldCBwYWRkaW5nKHBhZGRpbmcpIHtcbiAgICBpZiAodGhpcy5fcGFkZGluZyAhPT0gcGFkZGluZykge1xuICAgICAgdGhpcy5fcGFkZGluZyA9IHBhZGRpbmc7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IHN0cm9rZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3Ryb2tlO1xuICB9XG4gIHNldCBzdHJva2Uoc3Ryb2tlKSB7XG4gICAgY29uc3Qgb3V0cHV0Q29sb3IgPSBnZXRDb2xvcihzdHJva2UpO1xuICAgIGlmICh0aGlzLl9zdHJva2UgIT09IG91dHB1dENvbG9yKSB7XG4gICAgICB0aGlzLl9zdHJva2UgPSBvdXRwdXRDb2xvcjtcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgc3Ryb2tlVGhpY2tuZXNzKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJva2VUaGlja25lc3M7XG4gIH1cbiAgc2V0IHN0cm9rZVRoaWNrbmVzcyhzdHJva2VUaGlja25lc3MpIHtcbiAgICBpZiAodGhpcy5fc3Ryb2tlVGhpY2tuZXNzICE9PSBzdHJva2VUaGlja25lc3MpIHtcbiAgICAgIHRoaXMuX3N0cm9rZVRoaWNrbmVzcyA9IHN0cm9rZVRoaWNrbmVzcztcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgdGV4dEJhc2VsaW5lKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0QmFzZWxpbmU7XG4gIH1cbiAgc2V0IHRleHRCYXNlbGluZSh0ZXh0QmFzZWxpbmUpIHtcbiAgICBpZiAodGhpcy5fdGV4dEJhc2VsaW5lICE9PSB0ZXh0QmFzZWxpbmUpIHtcbiAgICAgIHRoaXMuX3RleHRCYXNlbGluZSA9IHRleHRCYXNlbGluZTtcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICBnZXQgdHJpbSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJpbTtcbiAgfVxuICBzZXQgdHJpbSh0cmltKSB7XG4gICAgaWYgKHRoaXMuX3RyaW0gIT09IHRyaW0pIHtcbiAgICAgIHRoaXMuX3RyaW0gPSB0cmltO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCB3aGl0ZVNwYWNlKCkge1xuICAgIHJldHVybiB0aGlzLl93aGl0ZVNwYWNlO1xuICB9XG4gIHNldCB3aGl0ZVNwYWNlKHdoaXRlU3BhY2UpIHtcbiAgICBpZiAodGhpcy5fd2hpdGVTcGFjZSAhPT0gd2hpdGVTcGFjZSkge1xuICAgICAgdGhpcy5fd2hpdGVTcGFjZSA9IHdoaXRlU3BhY2U7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgZ2V0IHdvcmRXcmFwKCkge1xuICAgIHJldHVybiB0aGlzLl93b3JkV3JhcDtcbiAgfVxuICBzZXQgd29yZFdyYXAod29yZFdyYXApIHtcbiAgICBpZiAodGhpcy5fd29yZFdyYXAgIT09IHdvcmRXcmFwKSB7XG4gICAgICB0aGlzLl93b3JkV3JhcCA9IHdvcmRXcmFwO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIGdldCB3b3JkV3JhcFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl93b3JkV3JhcFdpZHRoO1xuICB9XG4gIHNldCB3b3JkV3JhcFdpZHRoKHdvcmRXcmFwV2lkdGgpIHtcbiAgICBpZiAodGhpcy5fd29yZFdyYXBXaWR0aCAhPT0gd29yZFdyYXBXaWR0aCkge1xuICAgICAgdGhpcy5fd29yZFdyYXBXaWR0aCA9IHdvcmRXcmFwV2lkdGg7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgdG9Gb250U3RyaW5nKCkge1xuICAgIGNvbnN0IGZvbnRTaXplU3RyaW5nID0gdHlwZW9mIHRoaXMuZm9udFNpemUgPT09IFwibnVtYmVyXCIgPyBgJHt0aGlzLmZvbnRTaXplfXB4YCA6IHRoaXMuZm9udFNpemU7XG4gICAgbGV0IGZvbnRGYW1pbGllcyA9IHRoaXMuZm9udEZhbWlseTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5mb250RmFtaWx5KSkge1xuICAgICAgZm9udEZhbWlsaWVzID0gdGhpcy5mb250RmFtaWx5LnNwbGl0KFwiLFwiKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IGZvbnRGYW1pbGllcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgbGV0IGZvbnRGYW1pbHkgPSBmb250RmFtaWxpZXNbaV0udHJpbSgpO1xuICAgICAgaWYgKCEvKFtcXFwiXFwnXSlbXlxcJ1xcXCJdK1xcMS8udGVzdChmb250RmFtaWx5KSAmJiAhZ2VuZXJpY0ZvbnRGYW1pbGllcy5pbmNsdWRlcyhmb250RmFtaWx5KSkge1xuICAgICAgICBmb250RmFtaWx5ID0gYFwiJHtmb250RmFtaWx5fVwiYDtcbiAgICAgIH1cbiAgICAgIGZvbnRGYW1pbGllc1tpXSA9IGZvbnRGYW1pbHk7XG4gICAgfVxuICAgIHJldHVybiBgJHt0aGlzLmZvbnRTdHlsZX0gJHt0aGlzLmZvbnRWYXJpYW50fSAke3RoaXMuZm9udFdlaWdodH0gJHtmb250U2l6ZVN0cmluZ30gJHtmb250RmFtaWxpZXMuam9pbihcIixcIil9YDtcbiAgfVxufTtcbmxldCBUZXh0U3R5bGUgPSBfVGV4dFN0eWxlO1xuVGV4dFN0eWxlLmRlZmF1bHRTdHlsZSA9IHtcbiAgYWxpZ246IFwibGVmdFwiLFxuICBicmVha1dvcmRzOiBmYWxzZSxcbiAgZHJvcFNoYWRvdzogZmFsc2UsXG4gIGRyb3BTaGFkb3dBbHBoYTogMSxcbiAgZHJvcFNoYWRvd0FuZ2xlOiBNYXRoLlBJIC8gNixcbiAgZHJvcFNoYWRvd0JsdXI6IDAsXG4gIGRyb3BTaGFkb3dDb2xvcjogXCJibGFja1wiLFxuICBkcm9wU2hhZG93RGlzdGFuY2U6IDUsXG4gIGZpbGw6IFwiYmxhY2tcIixcbiAgZmlsbEdyYWRpZW50VHlwZTogVEVYVF9HUkFESUVOVC5MSU5FQVJfVkVSVElDQUwsXG4gIGZpbGxHcmFkaWVudFN0b3BzOiBbXSxcbiAgZm9udEZhbWlseTogXCJBcmlhbFwiLFxuICBmb250U2l6ZTogMjYsXG4gIGZvbnRTdHlsZTogXCJub3JtYWxcIixcbiAgZm9udFZhcmlhbnQ6IFwibm9ybWFsXCIsXG4gIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIsXG4gIGxlYWRpbmc6IDAsXG4gIGxldHRlclNwYWNpbmc6IDAsXG4gIGxpbmVIZWlnaHQ6IDAsXG4gIGxpbmVKb2luOiBcIm1pdGVyXCIsXG4gIG1pdGVyTGltaXQ6IDEwLFxuICBwYWRkaW5nOiAwLFxuICBzdHJva2U6IFwiYmxhY2tcIixcbiAgc3Ryb2tlVGhpY2tuZXNzOiAwLFxuICB0ZXh0QmFzZWxpbmU6IFwiYWxwaGFiZXRpY1wiLFxuICB0cmltOiBmYWxzZSxcbiAgd2hpdGVTcGFjZTogXCJwcmVcIixcbiAgd29yZFdyYXA6IGZhbHNlLFxuICB3b3JkV3JhcFdpZHRoOiAxMDBcbn07XG5mdW5jdGlvbiBnZXRDb2xvcihjb2xvcikge1xuICBjb25zdCB0ZW1wID0gQ29sb3Iuc2hhcmVkO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY29sb3IpKSB7XG4gICAgcmV0dXJuIHRlbXAuc2V0VmFsdWUoY29sb3IpLnRvSGV4KCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbG9yLm1hcCgoYykgPT4gdGVtcC5zZXRWYWx1ZShjKS50b0hleCgpKTtcbiAgfVxufVxuZnVuY3Rpb24gYXJlQXJyYXlzRXF1YWwoYXJyYXkxLCBhcnJheTIpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5MSkgfHwgIUFycmF5LmlzQXJyYXkoYXJyYXkyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYXJyYXkxLmxlbmd0aCAhPT0gYXJyYXkyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5MS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhcnJheTFbaV0gIT09IGFycmF5MltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRlZXBDb3B5UHJvcGVydGllcyh0YXJnZXQsIHNvdXJjZSwgcHJvcGVydHlPYmopIHtcbiAgZm9yIChjb25zdCBwcm9wIGluIHByb3BlcnR5T2JqKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlW3Byb3BdKSkge1xuICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgVGV4dFN0eWxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0U3R5bGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgc2V0dGluZ3MsIFRleHR1cmUsIFJlY3RhbmdsZSwgdXRpbHMsIENvbG9yIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBTcHJpdGUgfSBmcm9tICdAcGl4aS9zcHJpdGUnO1xuaW1wb3J0IHsgVEVYVF9HUkFESUVOVCB9IGZyb20gJy4vY29uc3QubWpzJztcbmltcG9ydCB7IFRleHRNZXRyaWNzIH0gZnJvbSAnLi9UZXh0TWV0cmljcy5tanMnO1xuaW1wb3J0IHsgVGV4dFN0eWxlIH0gZnJvbSAnLi9UZXh0U3R5bGUubWpzJztcblxuY29uc3QgZGVmYXVsdERlc3Ryb3lPcHRpb25zID0ge1xuICB0ZXh0dXJlOiB0cnVlLFxuICBjaGlsZHJlbjogZmFsc2UsXG4gIGJhc2VUZXh0dXJlOiB0cnVlXG59O1xuY29uc3QgX1RleHQgPSBjbGFzcyBleHRlbmRzIFNwcml0ZSB7XG4gIGNvbnN0cnVjdG9yKHRleHQsIHN0eWxlLCBjYW52YXMpIHtcbiAgICBsZXQgb3duQ2FudmFzID0gZmFsc2U7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgIGNhbnZhcyA9IHNldHRpbmdzLkFEQVBURVIuY3JlYXRlQ2FudmFzKCk7XG4gICAgICBvd25DYW52YXMgPSB0cnVlO1xuICAgIH1cbiAgICBjYW52YXMud2lkdGggPSAzO1xuICAgIGNhbnZhcy5oZWlnaHQgPSAzO1xuICAgIGNvbnN0IHRleHR1cmUgPSBUZXh0dXJlLmZyb20oY2FudmFzKTtcbiAgICB0ZXh0dXJlLm9yaWcgPSBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgdGV4dHVyZS50cmltID0gbmV3IFJlY3RhbmdsZSgpO1xuICAgIHN1cGVyKHRleHR1cmUpO1xuICAgIHRoaXMuX293bkNhbnZhcyA9IG93bkNhbnZhcztcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLmNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuX3Jlc29sdXRpb24gPSBfVGV4dC5kZWZhdWx0UmVzb2x1dGlvbiA/PyBzZXR0aW5ncy5SRVNPTFVUSU9OO1xuICAgIHRoaXMuX2F1dG9SZXNvbHV0aW9uID0gX1RleHQuZGVmYXVsdEF1dG9SZXNvbHV0aW9uO1xuICAgIHRoaXMuX3RleHQgPSBudWxsO1xuICAgIHRoaXMuX3N0eWxlID0gbnVsbDtcbiAgICB0aGlzLl9zdHlsZUxpc3RlbmVyID0gbnVsbDtcbiAgICB0aGlzLl9mb250ID0gXCJcIjtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLmxvY2FsU3R5bGVJRCA9IC0xO1xuICB9XG4gIHN0YXRpYyBnZXQgZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZygpIHtcbiAgICByZXR1cm4gVGV4dE1ldHJpY3MuZXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZztcbiAgfVxuICBzdGF0aWMgc2V0IGV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcodmFsdWUpIHtcbiAgICB1dGlscy5kZXByZWNhdGlvbihcIjcuMS4wXCIsIFwiVGV4dC5leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nIGlzIGRlcHJlY2F0ZWQsIHVzZSBUZXh0TWV0cmljcy5leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nXCIpO1xuICAgIFRleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmcgPSB2YWx1ZTtcbiAgfVxuICB1cGRhdGVUZXh0KHJlc3BlY3REaXJ0eSkge1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5fc3R5bGU7XG4gICAgaWYgKHRoaXMubG9jYWxTdHlsZUlEICE9PSBzdHlsZS5zdHlsZUlEKSB7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMubG9jYWxTdHlsZUlEID0gc3R5bGUuc3R5bGVJRDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmRpcnR5ICYmIHJlc3BlY3REaXJ0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9mb250ID0gdGhpcy5fc3R5bGUudG9Gb250U3RyaW5nKCk7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICBjb25zdCBtZWFzdXJlZCA9IFRleHRNZXRyaWNzLm1lYXN1cmVUZXh0KHRoaXMuX3RleHQgfHwgXCIgXCIsIHRoaXMuX3N0eWxlLCB0aGlzLl9zdHlsZS53b3JkV3JhcCwgdGhpcy5jYW52YXMpO1xuICAgIGNvbnN0IHdpZHRoID0gbWVhc3VyZWQud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gbWVhc3VyZWQuaGVpZ2h0O1xuICAgIGNvbnN0IGxpbmVzID0gbWVhc3VyZWQubGluZXM7XG4gICAgY29uc3QgbGluZUhlaWdodCA9IG1lYXN1cmVkLmxpbmVIZWlnaHQ7XG4gICAgY29uc3QgbGluZVdpZHRocyA9IG1lYXN1cmVkLmxpbmVXaWR0aHM7XG4gICAgY29uc3QgbWF4TGluZVdpZHRoID0gbWVhc3VyZWQubWF4TGluZVdpZHRoO1xuICAgIGNvbnN0IGZvbnRQcm9wZXJ0aWVzID0gbWVhc3VyZWQuZm9udFByb3BlcnRpZXM7XG4gICAgdGhpcy5jYW52YXMud2lkdGggPSBNYXRoLmNlaWwoTWF0aC5jZWlsKE1hdGgubWF4KDEsIHdpZHRoKSArIHN0eWxlLnBhZGRpbmcgKiAyKSAqIHRoaXMuX3Jlc29sdXRpb24pO1xuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IE1hdGguY2VpbChNYXRoLmNlaWwoTWF0aC5tYXgoMSwgaGVpZ2h0KSArIHN0eWxlLnBhZGRpbmcgKiAyKSAqIHRoaXMuX3Jlc29sdXRpb24pO1xuICAgIGNvbnRleHQuc2NhbGUodGhpcy5fcmVzb2x1dGlvbiwgdGhpcy5fcmVzb2x1dGlvbik7XG4gICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gICAgY29udGV4dC5mb250ID0gdGhpcy5fZm9udDtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHN0eWxlLnN0cm9rZVRoaWNrbmVzcztcbiAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZTtcbiAgICBjb250ZXh0LmxpbmVKb2luID0gc3R5bGUubGluZUpvaW47XG4gICAgY29udGV4dC5taXRlckxpbWl0ID0gc3R5bGUubWl0ZXJMaW1pdDtcbiAgICBsZXQgbGluZVBvc2l0aW9uWDtcbiAgICBsZXQgbGluZVBvc2l0aW9uWTtcbiAgICBjb25zdCBwYXNzZXNDb3VudCA9IHN0eWxlLmRyb3BTaGFkb3cgPyAyIDogMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhc3Nlc0NvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGlzU2hhZG93UGFzcyA9IHN0eWxlLmRyb3BTaGFkb3cgJiYgaSA9PT0gMDtcbiAgICAgIGNvbnN0IGRzT2Zmc2V0VGV4dCA9IGlzU2hhZG93UGFzcyA/IE1hdGguY2VpbChNYXRoLm1heCgxLCBoZWlnaHQpICsgc3R5bGUucGFkZGluZyAqIDIpIDogMDtcbiAgICAgIGNvbnN0IGRzT2Zmc2V0U2hhZG93ID0gZHNPZmZzZXRUZXh0ICogdGhpcy5fcmVzb2x1dGlvbjtcbiAgICAgIGlmIChpc1NoYWRvd1Bhc3MpIHtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgIGNvbnN0IGRyb3BTaGFkb3dDb2xvciA9IHN0eWxlLmRyb3BTaGFkb3dDb2xvcjtcbiAgICAgICAgY29uc3QgZHJvcFNoYWRvd0JsdXIgPSBzdHlsZS5kcm9wU2hhZG93Qmx1ciAqIHRoaXMuX3Jlc29sdXRpb247XG4gICAgICAgIGNvbnN0IGRyb3BTaGFkb3dEaXN0YW5jZSA9IHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZSAqIHRoaXMuX3Jlc29sdXRpb247XG4gICAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBDb2xvci5zaGFyZWQuc2V0VmFsdWUoZHJvcFNoYWRvd0NvbG9yKS5zZXRBbHBoYShzdHlsZS5kcm9wU2hhZG93QWxwaGEpLnRvUmdiYVN0cmluZygpO1xuICAgICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSBkcm9wU2hhZG93Qmx1cjtcbiAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gTWF0aC5jb3Moc3R5bGUuZHJvcFNoYWRvd0FuZ2xlKSAqIGRyb3BTaGFkb3dEaXN0YW5jZTtcbiAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gTWF0aC5zaW4oc3R5bGUuZHJvcFNoYWRvd0FuZ2xlKSAqIGRyb3BTaGFkb3dEaXN0YW5jZSArIGRzT2Zmc2V0U2hhZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLl9nZW5lcmF0ZUZpbGxTdHlsZShzdHlsZSwgbGluZXMsIG1lYXN1cmVkKTtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHN0eWxlLnN0cm9rZTtcbiAgICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIjtcbiAgICAgICAgY29udGV4dC5zaGFkb3dCbHVyID0gMDtcbiAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICAgIH1cbiAgICAgIGxldCBsaW5lUG9zaXRpb25ZU2hpZnQgPSAobGluZUhlaWdodCAtIGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplKSAvIDI7XG4gICAgICBpZiAobGluZUhlaWdodCAtIGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplIDwgMCkge1xuICAgICAgICBsaW5lUG9zaXRpb25ZU2hpZnQgPSAwO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGxpbmVzLmxlbmd0aDsgaTIrKykge1xuICAgICAgICBsaW5lUG9zaXRpb25YID0gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMjtcbiAgICAgICAgbGluZVBvc2l0aW9uWSA9IHN0eWxlLnN0cm9rZVRoaWNrbmVzcyAvIDIgKyBpMiAqIGxpbmVIZWlnaHQgKyBmb250UHJvcGVydGllcy5hc2NlbnQgKyBsaW5lUG9zaXRpb25ZU2hpZnQ7XG4gICAgICAgIGlmIChzdHlsZS5hbGlnbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgbGluZVBvc2l0aW9uWCArPSBtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2kyXTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHlsZS5hbGlnbiA9PT0gXCJjZW50ZXJcIikge1xuICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaTJdKSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlLnN0cm9rZSAmJiBzdHlsZS5zdHJva2VUaGlja25lc3MpIHtcbiAgICAgICAgICB0aGlzLmRyYXdMZXR0ZXJTcGFjaW5nKGxpbmVzW2kyXSwgbGluZVBvc2l0aW9uWCArIHN0eWxlLnBhZGRpbmcsIGxpbmVQb3NpdGlvblkgKyBzdHlsZS5wYWRkaW5nIC0gZHNPZmZzZXRUZXh0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGUuZmlsbCkge1xuICAgICAgICAgIHRoaXMuZHJhd0xldHRlclNwYWNpbmcobGluZXNbaTJdLCBsaW5lUG9zaXRpb25YICsgc3R5bGUucGFkZGluZywgbGluZVBvc2l0aW9uWSArIHN0eWxlLnBhZGRpbmcgLSBkc09mZnNldFRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudXBkYXRlVGV4dHVyZSgpO1xuICB9XG4gIGRyYXdMZXR0ZXJTcGFjaW5nKHRleHQsIHgsIHksIGlzU3Ryb2tlID0gZmFsc2UpIHtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuX3N0eWxlO1xuICAgIGNvbnN0IGxldHRlclNwYWNpbmcgPSBzdHlsZS5sZXR0ZXJTcGFjaW5nO1xuICAgIGxldCB1c2VFeHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nID0gZmFsc2U7XG4gICAgaWYgKFRleHRNZXRyaWNzLmV4cGVyaW1lbnRhbExldHRlclNwYWNpbmdTdXBwb3J0ZWQpIHtcbiAgICAgIGlmIChUZXh0TWV0cmljcy5leHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5sZXR0ZXJTcGFjaW5nID0gYCR7bGV0dGVyU3BhY2luZ31weGA7XG4gICAgICAgIHRoaXMuY29udGV4dC50ZXh0TGV0dGVyU3BhY2luZyA9IGAke2xldHRlclNwYWNpbmd9cHhgO1xuICAgICAgICB1c2VFeHBlcmltZW50YWxMZXR0ZXJTcGFjaW5nID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5sZXR0ZXJTcGFjaW5nID0gXCIwcHhcIjtcbiAgICAgICAgdGhpcy5jb250ZXh0LnRleHRMZXR0ZXJTcGFjaW5nID0gXCIwcHhcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxldHRlclNwYWNpbmcgPT09IDAgfHwgdXNlRXhwZXJpbWVudGFsTGV0dGVyU3BhY2luZykge1xuICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5zdHJva2VUZXh0KHRleHQsIHgsIHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxUZXh0KHRleHQsIHgsIHkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY3VycmVudFBvc2l0aW9uID0geDtcbiAgICBjb25zdCBzdHJpbmdBcnJheSA9IFRleHRNZXRyaWNzLmdyYXBoZW1lU2VnbWVudGVyKHRleHQpO1xuICAgIGxldCBwcmV2aW91c1dpZHRoID0gdGhpcy5jb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgIGxldCBjdXJyZW50V2lkdGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRDaGFyID0gc3RyaW5nQXJyYXlbaV07XG4gICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnN0cm9rZVRleHQoY3VycmVudENoYXIsIGN1cnJlbnRQb3NpdGlvbiwgeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFRleHQoY3VycmVudENoYXIsIGN1cnJlbnRQb3NpdGlvbiwgeSk7XG4gICAgICB9XG4gICAgICBsZXQgdGV4dFN0ciA9IFwiXCI7XG4gICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBzdHJpbmdBcnJheS5sZW5ndGg7ICsraikge1xuICAgICAgICB0ZXh0U3RyICs9IHN0cmluZ0FycmF5W2pdO1xuICAgICAgfVxuICAgICAgY3VycmVudFdpZHRoID0gdGhpcy5jb250ZXh0Lm1lYXN1cmVUZXh0KHRleHRTdHIpLndpZHRoO1xuICAgICAgY3VycmVudFBvc2l0aW9uICs9IHByZXZpb3VzV2lkdGggLSBjdXJyZW50V2lkdGggKyBsZXR0ZXJTcGFjaW5nO1xuICAgICAgcHJldmlvdXNXaWR0aCA9IGN1cnJlbnRXaWR0aDtcbiAgICB9XG4gIH1cbiAgdXBkYXRlVGV4dHVyZSgpIHtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICBpZiAodGhpcy5fc3R5bGUudHJpbSkge1xuICAgICAgY29uc3QgdHJpbW1lZCA9IHV0aWxzLnRyaW1DYW52YXMoY2FudmFzKTtcbiAgICAgIGlmICh0cmltbWVkLmRhdGEpIHtcbiAgICAgICAgY2FudmFzLndpZHRoID0gdHJpbW1lZC53aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRyaW1tZWQuaGVpZ2h0O1xuICAgICAgICB0aGlzLmNvbnRleHQucHV0SW1hZ2VEYXRhKHRyaW1tZWQuZGF0YSwgMCwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlO1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5fc3R5bGU7XG4gICAgY29uc3QgcGFkZGluZyA9IHN0eWxlLnRyaW0gPyAwIDogc3R5bGUucGFkZGluZztcbiAgICBjb25zdCBiYXNlVGV4dHVyZSA9IHRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgdGV4dHVyZS50cmltLndpZHRoID0gdGV4dHVyZS5fZnJhbWUud2lkdGggPSBjYW52YXMud2lkdGggLyB0aGlzLl9yZXNvbHV0aW9uO1xuICAgIHRleHR1cmUudHJpbS5oZWlnaHQgPSB0ZXh0dXJlLl9mcmFtZS5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0IC8gdGhpcy5fcmVzb2x1dGlvbjtcbiAgICB0ZXh0dXJlLnRyaW0ueCA9IC1wYWRkaW5nO1xuICAgIHRleHR1cmUudHJpbS55ID0gLXBhZGRpbmc7XG4gICAgdGV4dHVyZS5vcmlnLndpZHRoID0gdGV4dHVyZS5fZnJhbWUud2lkdGggLSBwYWRkaW5nICogMjtcbiAgICB0ZXh0dXJlLm9yaWcuaGVpZ2h0ID0gdGV4dHVyZS5fZnJhbWUuaGVpZ2h0IC0gcGFkZGluZyAqIDI7XG4gICAgdGhpcy5fb25UZXh0dXJlVXBkYXRlKCk7XG4gICAgYmFzZVRleHR1cmUuc2V0UmVhbFNpemUoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0LCB0aGlzLl9yZXNvbHV0aW9uKTtcbiAgICB0ZXh0dXJlLnVwZGF0ZVV2cygpO1xuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgfVxuICBfcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgaWYgKHRoaXMuX2F1dG9SZXNvbHV0aW9uICYmIHRoaXMuX3Jlc29sdXRpb24gIT09IHJlbmRlcmVyLnJlc29sdXRpb24pIHtcbiAgICAgIHRoaXMuX3Jlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICBzdXBlci5fcmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxuICB1cGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgIHN1cGVyLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICB9XG4gIGdldEJvdW5kcyhza2lwVXBkYXRlLCByZWN0KSB7XG4gICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgIGlmICh0aGlzLl90ZXh0dXJlSUQgPT09IC0xKSB7XG4gICAgICBza2lwVXBkYXRlID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5nZXRCb3VuZHMoc2tpcFVwZGF0ZSwgcmVjdCk7XG4gIH1cbiAgZ2V0TG9jYWxCb3VuZHMocmVjdCkge1xuICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICByZXR1cm4gc3VwZXIuZ2V0TG9jYWxCb3VuZHMuY2FsbCh0aGlzLCByZWN0KTtcbiAgfVxuICBfY2FsY3VsYXRlQm91bmRzKCkge1xuICAgIHRoaXMuY2FsY3VsYXRlVmVydGljZXMoKTtcbiAgICB0aGlzLl9ib3VuZHMuYWRkUXVhZCh0aGlzLnZlcnRleERhdGEpO1xuICB9XG4gIF9nZW5lcmF0ZUZpbGxTdHlsZShzdHlsZSwgbGluZXMsIG1ldHJpY3MpIHtcbiAgICBjb25zdCBmaWxsU3R5bGUgPSBzdHlsZS5maWxsO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShmaWxsU3R5bGUpKSB7XG4gICAgICByZXR1cm4gZmlsbFN0eWxlO1xuICAgIH0gZWxzZSBpZiAoZmlsbFN0eWxlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGZpbGxTdHlsZVswXTtcbiAgICB9XG4gICAgbGV0IGdyYWRpZW50O1xuICAgIGNvbnN0IGRyb3BTaGFkb3dDb3JyZWN0aW9uID0gc3R5bGUuZHJvcFNoYWRvdyA/IHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZSA6IDA7XG4gICAgY29uc3QgcGFkZGluZyA9IHN0eWxlLnBhZGRpbmcgfHwgMDtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoIC8gdGhpcy5fcmVzb2x1dGlvbiAtIGRyb3BTaGFkb3dDb3JyZWN0aW9uIC0gcGFkZGluZyAqIDI7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0IC8gdGhpcy5fcmVzb2x1dGlvbiAtIGRyb3BTaGFkb3dDb3JyZWN0aW9uIC0gcGFkZGluZyAqIDI7XG4gICAgY29uc3QgZmlsbCA9IGZpbGxTdHlsZS5zbGljZSgpO1xuICAgIGNvbnN0IGZpbGxHcmFkaWVudFN0b3BzID0gc3R5bGUuZmlsbEdyYWRpZW50U3RvcHMuc2xpY2UoKTtcbiAgICBpZiAoIWZpbGxHcmFkaWVudFN0b3BzLmxlbmd0aCkge1xuICAgICAgY29uc3QgbGVuZ3RoUGx1czEgPSBmaWxsLmxlbmd0aCArIDE7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aFBsdXMxOyArK2kpIHtcbiAgICAgICAgZmlsbEdyYWRpZW50U3RvcHMucHVzaChpIC8gbGVuZ3RoUGx1czEpO1xuICAgICAgfVxuICAgIH1cbiAgICBmaWxsLnVuc2hpZnQoZmlsbFN0eWxlWzBdKTtcbiAgICBmaWxsR3JhZGllbnRTdG9wcy51bnNoaWZ0KDApO1xuICAgIGZpbGwucHVzaChmaWxsU3R5bGVbZmlsbFN0eWxlLmxlbmd0aCAtIDFdKTtcbiAgICBmaWxsR3JhZGllbnRTdG9wcy5wdXNoKDEpO1xuICAgIGlmIChzdHlsZS5maWxsR3JhZGllbnRUeXBlID09PSBURVhUX0dSQURJRU5ULkxJTkVBUl9WRVJUSUNBTCkge1xuICAgICAgZ3JhZGllbnQgPSB0aGlzLmNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQod2lkdGggLyAyLCBwYWRkaW5nLCB3aWR0aCAvIDIsIGhlaWdodCArIHBhZGRpbmcpO1xuICAgICAgY29uc3QgdGV4dEhlaWdodCA9IG1ldHJpY3MuZm9udFByb3BlcnRpZXMuZm9udFNpemUgKyBzdHlsZS5zdHJva2VUaGlja25lc3M7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxhc3RMaW5lQm90dG9tID0gbWV0cmljcy5saW5lSGVpZ2h0ICogKGkgLSAxKSArIHRleHRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IHRoaXNMaW5lVG9wID0gbWV0cmljcy5saW5lSGVpZ2h0ICogaTtcbiAgICAgICAgbGV0IHRoaXNMaW5lR3JhZGllbnRTdGFydCA9IHRoaXNMaW5lVG9wO1xuICAgICAgICBpZiAoaSA+IDAgJiYgbGFzdExpbmVCb3R0b20gPiB0aGlzTGluZVRvcCkge1xuICAgICAgICAgIHRoaXNMaW5lR3JhZGllbnRTdGFydCA9ICh0aGlzTGluZVRvcCArIGxhc3RMaW5lQm90dG9tKSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhpc0xpbmVCb3R0b20gPSB0aGlzTGluZVRvcCArIHRleHRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IG5leHRMaW5lVG9wID0gbWV0cmljcy5saW5lSGVpZ2h0ICogKGkgKyAxKTtcbiAgICAgICAgbGV0IHRoaXNMaW5lR3JhZGllbnRFbmQgPSB0aGlzTGluZUJvdHRvbTtcbiAgICAgICAgaWYgKGkgKyAxIDwgbGluZXMubGVuZ3RoICYmIG5leHRMaW5lVG9wIDwgdGhpc0xpbmVCb3R0b20pIHtcbiAgICAgICAgICB0aGlzTGluZUdyYWRpZW50RW5kID0gKHRoaXNMaW5lQm90dG9tICsgbmV4dExpbmVUb3ApIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBncmFkU3RvcExpbmVIZWlnaHQgPSAodGhpc0xpbmVHcmFkaWVudEVuZCAtIHRoaXNMaW5lR3JhZGllbnRTdGFydCkgLyBoZWlnaHQ7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZmlsbC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGxldCBsaW5lU3RvcCA9IDA7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmaWxsR3JhZGllbnRTdG9wc1tqXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbGluZVN0b3AgPSBmaWxsR3JhZGllbnRTdG9wc1tqXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGluZVN0b3AgPSBqIC8gZmlsbC5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBnbG9iYWxTdG9wID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgdGhpc0xpbmVHcmFkaWVudFN0YXJ0IC8gaGVpZ2h0ICsgbGluZVN0b3AgKiBncmFkU3RvcExpbmVIZWlnaHQpKTtcbiAgICAgICAgICBnbG9iYWxTdG9wID0gTnVtYmVyKGdsb2JhbFN0b3AudG9GaXhlZCg1KSk7XG4gICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKGdsb2JhbFN0b3AsIGZpbGxbal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyYWRpZW50ID0gdGhpcy5jb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KHBhZGRpbmcsIGhlaWdodCAvIDIsIHdpZHRoICsgcGFkZGluZywgaGVpZ2h0IC8gMik7XG4gICAgICBjb25zdCB0b3RhbEl0ZXJhdGlvbnMgPSBmaWxsLmxlbmd0aCArIDE7XG4gICAgICBsZXQgY3VycmVudEl0ZXJhdGlvbiA9IDE7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHN0b3A7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsbEdyYWRpZW50U3RvcHNbaV0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBzdG9wID0gZmlsbEdyYWRpZW50U3RvcHNbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RvcCA9IGN1cnJlbnRJdGVyYXRpb24gLyB0b3RhbEl0ZXJhdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3AsIGZpbGxbaV0pO1xuICAgICAgICBjdXJyZW50SXRlcmF0aW9uKys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBncmFkaWVudDtcbiAgfVxuICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBvcHRpb25zID0geyBjaGlsZHJlbjogb3B0aW9ucyB9O1xuICAgIH1cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdERlc3Ryb3lPcHRpb25zLCBvcHRpb25zKTtcbiAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xuICAgIGlmICh0aGlzLl9vd25DYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuY2FudmFzLndpZHRoID0gMDtcbiAgICB9XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgdGhpcy5fc3R5bGUgPSBudWxsO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICB0aGlzLnVwZGF0ZVRleHQodHJ1ZSk7XG4gICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuc2NhbGUueCkgKiB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGg7XG4gIH1cbiAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgIGNvbnN0IHMgPSB1dGlscy5zaWduKHRoaXMuc2NhbGUueCkgfHwgMTtcbiAgICB0aGlzLnNjYWxlLnggPSBzICogdmFsdWUgLyB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGg7XG4gICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zY2FsZS55KSAqIHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQ7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICBjb25zdCBzID0gdXRpbHMuc2lnbih0aGlzLnNjYWxlLnkpIHx8IDE7XG4gICAgdGhpcy5zY2FsZS55ID0gcyAqIHZhbHVlIC8gdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodDtcbiAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgfVxuICBnZXQgc3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlO1xuICB9XG4gIHNldCBzdHlsZShzdHlsZSkge1xuICAgIHN0eWxlID0gc3R5bGUgfHwge307XG4gICAgaWYgKHN0eWxlIGluc3RhbmNlb2YgVGV4dFN0eWxlKSB7XG4gICAgICB0aGlzLl9zdHlsZSA9IHN0eWxlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdHlsZSA9IG5ldyBUZXh0U3R5bGUoc3R5bGUpO1xuICAgIH1cbiAgICB0aGlzLmxvY2FsU3R5bGVJRCA9IC0xO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG4gIGdldCB0ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0O1xuICB9XG4gIHNldCB0ZXh0KHRleHQpIHtcbiAgICB0ZXh0ID0gU3RyaW5nKHRleHQgPT09IG51bGwgfHwgdGV4dCA9PT0gdm9pZCAwID8gXCJcIiA6IHRleHQpO1xuICAgIGlmICh0aGlzLl90ZXh0ID09PSB0ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3RleHQgPSB0ZXh0O1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHV0aW9uO1xuICB9XG4gIHNldCByZXNvbHV0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fYXV0b1Jlc29sdXRpb24gPSBmYWxzZTtcbiAgICBpZiAodGhpcy5fcmVzb2x1dGlvbiA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcmVzb2x1dGlvbiA9IHZhbHVlO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG59O1xubGV0IFRleHQgPSBfVGV4dDtcblRleHQuZGVmYXVsdEF1dG9SZXNvbHV0aW9uID0gdHJ1ZTtcblxuZXhwb3J0IHsgVGV4dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dC5tanMubWFwXG4iLCJleHBvcnQgeyBURVhUX0dSQURJRU5UIH0gZnJvbSAnLi9jb25zdC5tanMnO1xuZXhwb3J0IHsgVGV4dCB9IGZyb20gJy4vVGV4dC5tanMnO1xuZXhwb3J0IHsgVGV4dE1ldHJpY3MgfSBmcm9tICcuL1RleHRNZXRyaWNzLm1qcyc7XG5leHBvcnQgeyBUZXh0U3R5bGUgfSBmcm9tICcuL1RleHRTdHlsZS5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiY2xhc3MgQ291bnRMaW1pdGVyIHtcbiAgY29uc3RydWN0b3IobWF4SXRlbXNQZXJGcmFtZSkge1xuICAgIHRoaXMubWF4SXRlbXNQZXJGcmFtZSA9IG1heEl0ZW1zUGVyRnJhbWU7XG4gICAgdGhpcy5pdGVtc0xlZnQgPSAwO1xuICB9XG4gIGJlZ2luRnJhbWUoKSB7XG4gICAgdGhpcy5pdGVtc0xlZnQgPSB0aGlzLm1heEl0ZW1zUGVyRnJhbWU7XG4gIH1cbiAgYWxsb3dlZFRvVXBsb2FkKCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zTGVmdC0tID4gMDtcbiAgfVxufVxuXG5leHBvcnQgeyBDb3VudExpbWl0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvdW50TGltaXRlci5tanMubWFwXG4iLCJpbXBvcnQgeyBUZXh0dXJlLCBCYXNlVGV4dHVyZSwgVGlja2VyLCBVUERBVEVfUFJJT1JJVFkgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJ0BwaXhpL2Rpc3BsYXknO1xuaW1wb3J0IHsgVGV4dCwgVGV4dFN0eWxlLCBUZXh0TWV0cmljcyB9IGZyb20gJ0BwaXhpL3RleHQnO1xuaW1wb3J0IHsgQ291bnRMaW1pdGVyIH0gZnJvbSAnLi9Db3VudExpbWl0ZXIubWpzJztcblxuZnVuY3Rpb24gZmluZE11bHRpcGxlQmFzZVRleHR1cmVzKGl0ZW0sIHF1ZXVlKSB7XG4gIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKGl0ZW0/Ll90ZXh0dXJlcz8ubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtLl90ZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGl0ZW0uX3RleHR1cmVzW2ldIGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgICBjb25zdCBiYXNlVGV4dHVyZSA9IGl0ZW0uX3RleHR1cmVzW2ldLmJhc2VUZXh0dXJlO1xuICAgICAgICBpZiAoIXF1ZXVlLmluY2x1ZGVzKGJhc2VUZXh0dXJlKSkge1xuICAgICAgICAgIHF1ZXVlLnB1c2goYmFzZVRleHR1cmUpO1xuICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZpbmRCYXNlVGV4dHVyZShpdGVtLCBxdWV1ZSkge1xuICBpZiAoaXRlbS5iYXNlVGV4dHVyZSBpbnN0YW5jZW9mIEJhc2VUZXh0dXJlKSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IGl0ZW0uYmFzZVRleHR1cmU7XG4gICAgaWYgKCFxdWV1ZS5pbmNsdWRlcyh0ZXh0dXJlKSkge1xuICAgICAgcXVldWUucHVzaCh0ZXh0dXJlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZmluZFRleHR1cmUoaXRlbSwgcXVldWUpIHtcbiAgaWYgKGl0ZW0uX3RleHR1cmUgJiYgaXRlbS5fdGV4dHVyZSBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gaXRlbS5fdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICBpZiAoIXF1ZXVlLmluY2x1ZGVzKHRleHR1cmUpKSB7XG4gICAgICBxdWV1ZS5wdXNoKHRleHR1cmUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkcmF3VGV4dChfaGVscGVyLCBpdGVtKSB7XG4gIGlmIChpdGVtIGluc3RhbmNlb2YgVGV4dCkge1xuICAgIGl0ZW0udXBkYXRlVGV4dCh0cnVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVUZXh0U3R5bGUoX2hlbHBlciwgaXRlbSkge1xuICBpZiAoaXRlbSBpbnN0YW5jZW9mIFRleHRTdHlsZSkge1xuICAgIGNvbnN0IGZvbnQgPSBpdGVtLnRvRm9udFN0cmluZygpO1xuICAgIFRleHRNZXRyaWNzLm1lYXN1cmVGb250KGZvbnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGZpbmRUZXh0KGl0ZW0sIHF1ZXVlKSB7XG4gIGlmIChpdGVtIGluc3RhbmNlb2YgVGV4dCkge1xuICAgIGlmICghcXVldWUuaW5jbHVkZXMoaXRlbS5zdHlsZSkpIHtcbiAgICAgIHF1ZXVlLnB1c2goaXRlbS5zdHlsZSk7XG4gICAgfVxuICAgIGlmICghcXVldWUuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgIHF1ZXVlLnB1c2goaXRlbSk7XG4gICAgfVxuICAgIGNvbnN0IHRleHR1cmUgPSBpdGVtLl90ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgIGlmICghcXVldWUuaW5jbHVkZXModGV4dHVyZSkpIHtcbiAgICAgIHF1ZXVlLnB1c2godGV4dHVyZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGZpbmRUZXh0U3R5bGUoaXRlbSwgcXVldWUpIHtcbiAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBUZXh0U3R5bGUpIHtcbiAgICBpZiAoIXF1ZXVlLmluY2x1ZGVzKGl0ZW0pKSB7XG4gICAgICBxdWV1ZS5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBfQmFzZVByZXBhcmUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5saW1pdGVyID0gbmV3IENvdW50TGltaXRlcihfQmFzZVByZXBhcmUudXBsb2Fkc1BlckZyYW1lKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy51cGxvYWRIb29rSGVscGVyID0gbnVsbDtcbiAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgdGhpcy5hZGRIb29rcyA9IFtdO1xuICAgIHRoaXMudXBsb2FkSG9va3MgPSBbXTtcbiAgICB0aGlzLmNvbXBsZXRlcyA9IFtdO1xuICAgIHRoaXMudGlja2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZGVsYXllZFRpY2sgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMucXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmVwYXJlSXRlbXMoKTtcbiAgICB9O1xuICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhmaW5kVGV4dCk7XG4gICAgdGhpcy5yZWdpc3RlckZpbmRIb29rKGZpbmRUZXh0U3R5bGUpO1xuICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhmaW5kTXVsdGlwbGVCYXNlVGV4dHVyZXMpO1xuICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhmaW5kQmFzZVRleHR1cmUpO1xuICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhmaW5kVGV4dHVyZSk7XG4gICAgdGhpcy5yZWdpc3RlclVwbG9hZEhvb2soZHJhd1RleHQpO1xuICAgIHRoaXMucmVnaXN0ZXJVcGxvYWRIb29rKGNhbGN1bGF0ZVRleHRTdHlsZSk7XG4gIH1cbiAgdXBsb2FkKGl0ZW0pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIHRoaXMuYWRkKGl0ZW0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuY29tcGxldGVzLnB1c2gocmVzb2x2ZSk7XG4gICAgICAgIGlmICghdGhpcy50aWNraW5nKSB7XG4gICAgICAgICAgdGhpcy50aWNraW5nID0gdHJ1ZTtcbiAgICAgICAgICBUaWNrZXIuc3lzdGVtLmFkZE9uY2UodGhpcy50aWNrLCB0aGlzLCBVUERBVEVfUFJJT1JJVFkuVVRJTElUWSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB0aWNrKCkge1xuICAgIHNldFRpbWVvdXQodGhpcy5kZWxheWVkVGljaywgMCk7XG4gIH1cbiAgcHJlcGFyZUl0ZW1zKCkge1xuICAgIHRoaXMubGltaXRlci5iZWdpbkZyYW1lKCk7XG4gICAgd2hpbGUgKHRoaXMucXVldWUubGVuZ3RoICYmIHRoaXMubGltaXRlci5hbGxvd2VkVG9VcGxvYWQoKSkge1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXMucXVldWVbMF07XG4gICAgICBsZXQgdXBsb2FkZWQgPSBmYWxzZTtcbiAgICAgIGlmIChpdGVtICYmICFpdGVtLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMudXBsb2FkSG9va3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy51cGxvYWRIb29rc1tpXSh0aGlzLnVwbG9hZEhvb2tIZWxwZXIsIGl0ZW0pKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICB1cGxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdXBsb2FkZWQpIHtcbiAgICAgICAgdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMucXVldWUubGVuZ3RoKSB7XG4gICAgICB0aGlzLnRpY2tpbmcgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGNvbXBsZXRlcyA9IHRoaXMuY29tcGxldGVzLnNsaWNlKDApO1xuICAgICAgdGhpcy5jb21wbGV0ZXMubGVuZ3RoID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjb21wbGV0ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29tcGxldGVzW2ldKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIFRpY2tlci5zeXN0ZW0uYWRkT25jZSh0aGlzLnRpY2ssIHRoaXMsIFVQREFURV9QUklPUklUWS5VVElMSVRZKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJGaW5kSG9vayhhZGRIb29rKSB7XG4gICAgaWYgKGFkZEhvb2spIHtcbiAgICAgIHRoaXMuYWRkSG9va3MucHVzaChhZGRIb29rKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVnaXN0ZXJVcGxvYWRIb29rKHVwbG9hZEhvb2spIHtcbiAgICBpZiAodXBsb2FkSG9vaykge1xuICAgICAgdGhpcy51cGxvYWRIb29rcy5wdXNoKHVwbG9hZEhvb2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhZGQoaXRlbSkge1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLmFkZEhvb2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5hZGRIb29rc1tpXShpdGVtLCB0aGlzLnF1ZXVlKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBDb250YWluZXIpIHtcbiAgICAgIGZvciAobGV0IGkgPSBpdGVtLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMuYWRkKGl0ZW0uY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnRpY2tpbmcpIHtcbiAgICAgIFRpY2tlci5zeXN0ZW0ucmVtb3ZlKHRoaXMudGljaywgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMudGlja2luZyA9IGZhbHNlO1xuICAgIHRoaXMuYWRkSG9va3MgPSBudWxsO1xuICAgIHRoaXMudXBsb2FkSG9va3MgPSBudWxsO1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMuY29tcGxldGVzID0gbnVsbDtcbiAgICB0aGlzLnF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLmxpbWl0ZXIgPSBudWxsO1xuICAgIHRoaXMudXBsb2FkSG9va0hlbHBlciA9IG51bGw7XG4gIH1cbn07XG5sZXQgQmFzZVByZXBhcmUgPSBfQmFzZVByZXBhcmU7XG5CYXNlUHJlcGFyZS51cGxvYWRzUGVyRnJhbWUgPSA0O1xuXG5leHBvcnQgeyBCYXNlUHJlcGFyZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZVByZXBhcmUubWpzLm1hcFxuIiwiaW1wb3J0IHsgc2V0dGluZ3MsIHV0aWxzIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5leHBvcnQgeyBzZXR0aW5ncyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgQmFzZVByZXBhcmUgfSBmcm9tICcuL0Jhc2VQcmVwYXJlLm1qcyc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNldHRpbmdzLCB7XG4gIFVQTE9BRFNfUEVSX0ZSQU1FOiB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIEJhc2VQcmVwYXJlLnVwbG9hZHNQZXJGcmFtZTtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgdXRpbHMuZGVwcmVjYXRpb24oXCI3LjEuMFwiLCBcInNldHRpbmdzLlVQTE9BRFNfUEVSX0ZSQU1FIGlzIGRlcHJlY2F0ZWQsIHVzZSBwcmVwYXJlLkJhc2VQcmVwYXJlLnVwbG9hZHNQZXJGcmFtZVwiKTtcbiAgICAgIEJhc2VQcmVwYXJlLnVwbG9hZHNQZXJGcmFtZSA9IHZhbHVlO1xuICAgIH1cbiAgfVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXR0aW5ncy5tanMubWFwXG4iLCJpbXBvcnQgeyBCYXNlVGV4dHVyZSwgRXh0ZW5zaW9uVHlwZSwgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgR3JhcGhpY3MgfSBmcm9tICdAcGl4aS9ncmFwaGljcyc7XG5pbXBvcnQgeyBCYXNlUHJlcGFyZSB9IGZyb20gJy4vQmFzZVByZXBhcmUubWpzJztcblxuZnVuY3Rpb24gdXBsb2FkQmFzZVRleHR1cmVzKHJlbmRlcmVyLCBpdGVtKSB7XG4gIGlmIChpdGVtIGluc3RhbmNlb2YgQmFzZVRleHR1cmUpIHtcbiAgICBpZiAoIWl0ZW0uX2dsVGV4dHVyZXNbcmVuZGVyZXIuQ09OVEVYVF9VSURdKSB7XG4gICAgICByZW5kZXJlci50ZXh0dXJlLmJpbmQoaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHVwbG9hZEdyYXBoaWNzKHJlbmRlcmVyLCBpdGVtKSB7XG4gIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBHcmFwaGljcykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgeyBnZW9tZXRyeSB9ID0gaXRlbTtcbiAgaXRlbS5maW5pc2hQb2x5KCk7XG4gIGdlb21ldHJ5LnVwZGF0ZUJhdGNoZXMoKTtcbiAgY29uc3QgeyBiYXRjaGVzIH0gPSBnZW9tZXRyeTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgeyB0ZXh0dXJlIH0gPSBiYXRjaGVzW2ldLnN0eWxlO1xuICAgIGlmICh0ZXh0dXJlKSB7XG4gICAgICB1cGxvYWRCYXNlVGV4dHVyZXMocmVuZGVyZXIsIHRleHR1cmUuYmFzZVRleHR1cmUpO1xuICAgIH1cbiAgfVxuICBpZiAoIWdlb21ldHJ5LmJhdGNoYWJsZSkge1xuICAgIHJlbmRlcmVyLmdlb21ldHJ5LmJpbmQoZ2VvbWV0cnksIGl0ZW0uX3Jlc29sdmVEaXJlY3RTaGFkZXIocmVuZGVyZXIpKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGZpbmRHcmFwaGljcyhpdGVtLCBxdWV1ZSkge1xuICBpZiAoaXRlbSBpbnN0YW5jZW9mIEdyYXBoaWNzKSB7XG4gICAgcXVldWUucHVzaChpdGVtKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5jbGFzcyBQcmVwYXJlIGV4dGVuZHMgQmFzZVByZXBhcmUge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHN1cGVyKHJlbmRlcmVyKTtcbiAgICB0aGlzLnVwbG9hZEhvb2tIZWxwZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhmaW5kR3JhcGhpY3MpO1xuICAgIHRoaXMucmVnaXN0ZXJVcGxvYWRIb29rKHVwbG9hZEJhc2VUZXh0dXJlcyk7XG4gICAgdGhpcy5yZWdpc3RlclVwbG9hZEhvb2sodXBsb2FkR3JhcGhpY3MpO1xuICB9XG59XG5QcmVwYXJlLmV4dGVuc2lvbiA9IHtcbiAgbmFtZTogXCJwcmVwYXJlXCIsXG4gIHR5cGU6IEV4dGVuc2lvblR5cGUuUmVuZGVyZXJTeXN0ZW1cbn07XG5leHRlbnNpb25zLmFkZChQcmVwYXJlKTtcblxuZXhwb3J0IHsgUHJlcGFyZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJlcGFyZS5tanMubWFwXG4iLCJpbXBvcnQgJy4vc2V0dGluZ3MubWpzJztcbmV4cG9ydCB7IEJhc2VQcmVwYXJlIH0gZnJvbSAnLi9CYXNlUHJlcGFyZS5tanMnO1xuZXhwb3J0IHsgQ291bnRMaW1pdGVyIH0gZnJvbSAnLi9Db3VudExpbWl0ZXIubWpzJztcbmV4cG9ydCB7IFByZXBhcmUgfSBmcm9tICcuL1ByZXBhcmUubWpzJztcbmV4cG9ydCB7IFRpbWVMaW1pdGVyIH0gZnJvbSAnLi9UaW1lTGltaXRlci5tanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgVGV4dHVyZSwgVGlja2VyLCBVUERBVEVfUFJJT1JJVFkgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IFNwcml0ZSB9IGZyb20gJ0BwaXhpL3Nwcml0ZSc7XG5cbmNsYXNzIEFuaW1hdGVkU3ByaXRlIGV4dGVuZHMgU3ByaXRlIHtcbiAgY29uc3RydWN0b3IodGV4dHVyZXMsIGF1dG9VcGRhdGUgPSB0cnVlKSB7XG4gICAgc3VwZXIodGV4dHVyZXNbMF0gaW5zdGFuY2VvZiBUZXh0dXJlID8gdGV4dHVyZXNbMF0gOiB0ZXh0dXJlc1swXS50ZXh0dXJlKTtcbiAgICB0aGlzLl90ZXh0dXJlcyA9IG51bGw7XG4gICAgdGhpcy5fZHVyYXRpb25zID0gbnVsbDtcbiAgICB0aGlzLl9hdXRvVXBkYXRlID0gYXV0b1VwZGF0ZTtcbiAgICB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gZmFsc2U7XG4gICAgdGhpcy5hbmltYXRpb25TcGVlZCA9IDE7XG4gICAgdGhpcy5sb29wID0gdHJ1ZTtcbiAgICB0aGlzLnVwZGF0ZUFuY2hvciA9IGZhbHNlO1xuICAgIHRoaXMub25Db21wbGV0ZSA9IG51bGw7XG4gICAgdGhpcy5vbkZyYW1lQ2hhbmdlID0gbnVsbDtcbiAgICB0aGlzLm9uTG9vcCA9IG51bGw7XG4gICAgdGhpcy5fY3VycmVudFRpbWUgPSAwO1xuICAgIHRoaXMuX3BsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9wcmV2aW91c0ZyYW1lID0gbnVsbDtcbiAgICB0aGlzLnRleHR1cmVzID0gdGV4dHVyZXM7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICBpZiAoIXRoaXMuX3BsYXlpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcGxheWluZyA9IGZhbHNlO1xuICAgIGlmICh0aGlzLl9hdXRvVXBkYXRlICYmIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIpIHtcbiAgICAgIFRpY2tlci5zaGFyZWQucmVtb3ZlKHRoaXMudXBkYXRlLCB0aGlzKTtcbiAgICAgIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcGxheSgpIHtcbiAgICBpZiAodGhpcy5fcGxheWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9wbGF5aW5nID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5fYXV0b1VwZGF0ZSAmJiAhdGhpcy5faXNDb25uZWN0ZWRUb1RpY2tlcikge1xuICAgICAgVGlja2VyLnNoYXJlZC5hZGQodGhpcy51cGRhdGUsIHRoaXMsIFVQREFURV9QUklPUklUWS5ISUdIKTtcbiAgICAgIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBnb3RvQW5kU3RvcChmcmFtZU51bWJlcikge1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIHRoaXMuY3VycmVudEZyYW1lID0gZnJhbWVOdW1iZXI7XG4gIH1cbiAgZ290b0FuZFBsYXkoZnJhbWVOdW1iZXIpIHtcbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IGZyYW1lTnVtYmVyO1xuICAgIHRoaXMucGxheSgpO1xuICB9XG4gIHVwZGF0ZShkZWx0YVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuX3BsYXlpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWxhcHNlZCA9IHRoaXMuYW5pbWF0aW9uU3BlZWQgKiBkZWx0YVRpbWU7XG4gICAgY29uc3QgcHJldmlvdXNGcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgIGlmICh0aGlzLl9kdXJhdGlvbnMgIT09IG51bGwpIHtcbiAgICAgIGxldCBsYWcgPSB0aGlzLl9jdXJyZW50VGltZSAlIDEgKiB0aGlzLl9kdXJhdGlvbnNbdGhpcy5jdXJyZW50RnJhbWVdO1xuICAgICAgbGFnICs9IGVsYXBzZWQgLyA2MCAqIDFlMztcbiAgICAgIHdoaWxlIChsYWcgPCAwKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lLS07XG4gICAgICAgIGxhZyArPSB0aGlzLl9kdXJhdGlvbnNbdGhpcy5jdXJyZW50RnJhbWVdO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbiA9IE1hdGguc2lnbih0aGlzLmFuaW1hdGlvblNwZWVkICogZGVsdGFUaW1lKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gTWF0aC5mbG9vcih0aGlzLl9jdXJyZW50VGltZSk7XG4gICAgICB3aGlsZSAobGFnID49IHRoaXMuX2R1cmF0aW9uc1t0aGlzLmN1cnJlbnRGcmFtZV0pIHtcbiAgICAgICAgbGFnIC09IHRoaXMuX2R1cmF0aW9uc1t0aGlzLmN1cnJlbnRGcmFtZV0gKiBzaWduO1xuICAgICAgICB0aGlzLl9jdXJyZW50VGltZSArPSBzaWduO1xuICAgICAgfVxuICAgICAgdGhpcy5fY3VycmVudFRpbWUgKz0gbGFnIC8gdGhpcy5fZHVyYXRpb25zW3RoaXMuY3VycmVudEZyYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY3VycmVudFRpbWUgKz0gZWxhcHNlZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRUaW1lIDwgMCAmJiAhdGhpcy5sb29wKSB7XG4gICAgICB0aGlzLmdvdG9BbmRTdG9wKDApO1xuICAgICAgaWYgKHRoaXMub25Db21wbGV0ZSkge1xuICAgICAgICB0aGlzLm9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2N1cnJlbnRUaW1lID49IHRoaXMuX3RleHR1cmVzLmxlbmd0aCAmJiAhdGhpcy5sb29wKSB7XG4gICAgICB0aGlzLmdvdG9BbmRTdG9wKHRoaXMuX3RleHR1cmVzLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKHRoaXMub25Db21wbGV0ZSkge1xuICAgICAgICB0aGlzLm9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByZXZpb3VzRnJhbWUgIT09IHRoaXMuY3VycmVudEZyYW1lKSB7XG4gICAgICBpZiAodGhpcy5sb29wICYmIHRoaXMub25Mb29wKSB7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvblNwZWVkID4gMCAmJiB0aGlzLmN1cnJlbnRGcmFtZSA8IHByZXZpb3VzRnJhbWUgfHwgdGhpcy5hbmltYXRpb25TcGVlZCA8IDAgJiYgdGhpcy5jdXJyZW50RnJhbWUgPiBwcmV2aW91c0ZyYW1lKSB7XG4gICAgICAgICAgdGhpcy5vbkxvb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVUZXh0dXJlKCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVRleHR1cmUoKSB7XG4gICAgY29uc3QgY3VycmVudEZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XG4gICAgaWYgKHRoaXMuX3ByZXZpb3VzRnJhbWUgPT09IGN1cnJlbnRGcmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9wcmV2aW91c0ZyYW1lID0gY3VycmVudEZyYW1lO1xuICAgIHRoaXMuX3RleHR1cmUgPSB0aGlzLl90ZXh0dXJlc1tjdXJyZW50RnJhbWVdO1xuICAgIHRoaXMuX3RleHR1cmVJRCA9IC0xO1xuICAgIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPSAtMTtcbiAgICB0aGlzLl9jYWNoZWRUaW50ID0gMTY3NzcyMTU7XG4gICAgdGhpcy51dnMgPSB0aGlzLl90ZXh0dXJlLl91dnMudXZzRmxvYXQzMjtcbiAgICBpZiAodGhpcy51cGRhdGVBbmNob3IpIHtcbiAgICAgIHRoaXMuX2FuY2hvci5jb3B5RnJvbSh0aGlzLl90ZXh0dXJlLmRlZmF1bHRBbmNob3IpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vbkZyYW1lQ2hhbmdlKSB7XG4gICAgICB0aGlzLm9uRnJhbWVDaGFuZ2UodGhpcy5jdXJyZW50RnJhbWUpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xuICAgIHRoaXMub25Db21wbGV0ZSA9IG51bGw7XG4gICAgdGhpcy5vbkZyYW1lQ2hhbmdlID0gbnVsbDtcbiAgICB0aGlzLm9uTG9vcCA9IG51bGw7XG4gIH1cbiAgc3RhdGljIGZyb21GcmFtZXMoZnJhbWVzKSB7XG4gICAgY29uc3QgdGV4dHVyZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgdGV4dHVyZXMucHVzaChUZXh0dXJlLmZyb20oZnJhbWVzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQW5pbWF0ZWRTcHJpdGUodGV4dHVyZXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSW1hZ2VzKGltYWdlcykge1xuICAgIGNvbnN0IHRleHR1cmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbWFnZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHRleHR1cmVzLnB1c2goVGV4dHVyZS5mcm9tKGltYWdlc1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFuaW1hdGVkU3ByaXRlKHRleHR1cmVzKTtcbiAgfVxuICBnZXQgdG90YWxGcmFtZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVzLmxlbmd0aDtcbiAgfVxuICBnZXQgdGV4dHVyZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVzO1xuICB9XG4gIHNldCB0ZXh0dXJlcyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVswXSBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgIHRoaXMuX3RleHR1cmVzID0gdmFsdWU7XG4gICAgICB0aGlzLl9kdXJhdGlvbnMgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90ZXh0dXJlcyA9IFtdO1xuICAgICAgdGhpcy5fZHVyYXRpb25zID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3RleHR1cmVzLnB1c2godmFsdWVbaV0udGV4dHVyZSk7XG4gICAgICAgIHRoaXMuX2R1cmF0aW9ucy5wdXNoKHZhbHVlW2ldLnRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9wcmV2aW91c0ZyYW1lID0gbnVsbDtcbiAgICB0aGlzLmdvdG9BbmRTdG9wKDApO1xuICAgIHRoaXMudXBkYXRlVGV4dHVyZSgpO1xuICB9XG4gIGdldCBjdXJyZW50RnJhbWUoKSB7XG4gICAgbGV0IGN1cnJlbnRGcmFtZSA9IE1hdGguZmxvb3IodGhpcy5fY3VycmVudFRpbWUpICUgdGhpcy5fdGV4dHVyZXMubGVuZ3RoO1xuICAgIGlmIChjdXJyZW50RnJhbWUgPCAwKSB7XG4gICAgICBjdXJyZW50RnJhbWUgKz0gdGhpcy5fdGV4dHVyZXMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudEZyYW1lO1xuICB9XG4gIHNldCBjdXJyZW50RnJhbWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gdGhpcy50b3RhbEZyYW1lcyAtIDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgW0FuaW1hdGVkU3ByaXRlXTogSW52YWxpZCBmcmFtZSBpbmRleCB2YWx1ZSAke3ZhbHVlfSwgZXhwZWN0ZWQgdG8gYmUgYmV0d2VlbiAwIGFuZCB0b3RhbEZyYW1lcyAke3RoaXMudG90YWxGcmFtZXN9LmApO1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c0ZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XG4gICAgdGhpcy5fY3VycmVudFRpbWUgPSB2YWx1ZTtcbiAgICBpZiAocHJldmlvdXNGcmFtZSAhPT0gdGhpcy5jdXJyZW50RnJhbWUpIHtcbiAgICAgIHRoaXMudXBkYXRlVGV4dHVyZSgpO1xuICAgIH1cbiAgfVxuICBnZXQgcGxheWluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGxheWluZztcbiAgfVxuICBnZXQgYXV0b1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b1VwZGF0ZTtcbiAgfVxuICBzZXQgYXV0b1VwZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fYXV0b1VwZGF0ZSkge1xuICAgICAgdGhpcy5fYXV0b1VwZGF0ZSA9IHZhbHVlO1xuICAgICAgaWYgKCF0aGlzLl9hdXRvVXBkYXRlICYmIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIpIHtcbiAgICAgICAgVGlja2VyLnNoYXJlZC5yZW1vdmUodGhpcy51cGRhdGUsIHRoaXMpO1xuICAgICAgICB0aGlzLl9pc0Nvbm5lY3RlZFRvVGlja2VyID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2F1dG9VcGRhdGUgJiYgIXRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgJiYgdGhpcy5fcGxheWluZykge1xuICAgICAgICBUaWNrZXIuc2hhcmVkLmFkZCh0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX2lzQ29ubmVjdGVkVG9UaWNrZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBBbmltYXRlZFNwcml0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QW5pbWF0ZWRTcHJpdGUubWpzLm1hcFxuIiwiZXhwb3J0IHsgQW5pbWF0ZWRTcHJpdGUgfSBmcm9tICcuL0FuaW1hdGVkU3ByaXRlLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgeyBQb2ludCwgVHJhbnNmb3JtLCBUZXh0dXJlTWF0cml4LCBSZWN0YW5nbGUsIFRleHR1cmUgfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IFNwcml0ZSB9IGZyb20gJ0BwaXhpL3Nwcml0ZSc7XG5cbmNvbnN0IHRlbXBQb2ludCA9IG5ldyBQb2ludCgpO1xuY2xhc3MgVGlsaW5nU3ByaXRlIGV4dGVuZHMgU3ByaXRlIHtcbiAgY29uc3RydWN0b3IodGV4dHVyZSwgd2lkdGggPSAxMDAsIGhlaWdodCA9IDEwMCkge1xuICAgIHN1cGVyKHRleHR1cmUpO1xuICAgIHRoaXMudGlsZVRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oKTtcbiAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnV2TWF0cml4ID0gdGhpcy50ZXh0dXJlLnV2TWF0cml4IHx8IG5ldyBUZXh0dXJlTWF0cml4KHRleHR1cmUpO1xuICAgIHRoaXMucGx1Z2luTmFtZSA9IFwidGlsaW5nU3ByaXRlXCI7XG4gICAgdGhpcy51dlJlc3BlY3RBbmNob3IgPSBmYWxzZTtcbiAgfVxuICBnZXQgY2xhbXBNYXJnaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMudXZNYXRyaXguY2xhbXBNYXJnaW47XG4gIH1cbiAgc2V0IGNsYW1wTWFyZ2luKHZhbHVlKSB7XG4gICAgdGhpcy51dk1hdHJpeC5jbGFtcE1hcmdpbiA9IHZhbHVlO1xuICAgIHRoaXMudXZNYXRyaXgudXBkYXRlKHRydWUpO1xuICB9XG4gIGdldCB0aWxlU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZVRyYW5zZm9ybS5zY2FsZTtcbiAgfVxuICBzZXQgdGlsZVNjYWxlKHZhbHVlKSB7XG4gICAgdGhpcy50aWxlVHJhbnNmb3JtLnNjYWxlLmNvcHlGcm9tKHZhbHVlKTtcbiAgfVxuICBnZXQgdGlsZVBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRpbGVUcmFuc2Zvcm0ucG9zaXRpb247XG4gIH1cbiAgc2V0IHRpbGVQb3NpdGlvbih2YWx1ZSkge1xuICAgIHRoaXMudGlsZVRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5RnJvbSh2YWx1ZSk7XG4gIH1cbiAgX29uVGV4dHVyZVVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy51dk1hdHJpeCkge1xuICAgICAgdGhpcy51dk1hdHJpeC50ZXh0dXJlID0gdGhpcy5fdGV4dHVyZTtcbiAgICB9XG4gICAgdGhpcy5fY2FjaGVkVGludCA9IDE2Nzc3MjE1O1xuICB9XG4gIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZTtcbiAgICBpZiAoIXRleHR1cmUgfHwgIXRleHR1cmUudmFsaWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50aWxlVHJhbnNmb3JtLnVwZGF0ZUxvY2FsVHJhbnNmb3JtKCk7XG4gICAgdGhpcy51dk1hdHJpeC51cGRhdGUoKTtcbiAgICByZW5kZXJlci5iYXRjaC5zZXRPYmplY3RSZW5kZXJlcihyZW5kZXJlci5wbHVnaW5zW3RoaXMucGx1Z2luTmFtZV0pO1xuICAgIHJlbmRlcmVyLnBsdWdpbnNbdGhpcy5wbHVnaW5OYW1lXS5yZW5kZXIodGhpcyk7XG4gIH1cbiAgX2NhbGN1bGF0ZUJvdW5kcygpIHtcbiAgICBjb25zdCBtaW5YID0gdGhpcy5fd2lkdGggKiAtdGhpcy5fYW5jaG9yLl94O1xuICAgIGNvbnN0IG1pblkgPSB0aGlzLl9oZWlnaHQgKiAtdGhpcy5fYW5jaG9yLl95O1xuICAgIGNvbnN0IG1heFggPSB0aGlzLl93aWR0aCAqICgxIC0gdGhpcy5fYW5jaG9yLl94KTtcbiAgICBjb25zdCBtYXhZID0gdGhpcy5faGVpZ2h0ICogKDEgLSB0aGlzLl9hbmNob3IuX3kpO1xuICAgIHRoaXMuX2JvdW5kcy5hZGRGcmFtZSh0aGlzLnRyYW5zZm9ybSwgbWluWCwgbWluWSwgbWF4WCwgbWF4WSk7XG4gIH1cbiAgZ2V0TG9jYWxCb3VuZHMocmVjdCkge1xuICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fYm91bmRzLm1pblggPSB0aGlzLl93aWR0aCAqIC10aGlzLl9hbmNob3IuX3g7XG4gICAgICB0aGlzLl9ib3VuZHMubWluWSA9IHRoaXMuX2hlaWdodCAqIC10aGlzLl9hbmNob3IuX3k7XG4gICAgICB0aGlzLl9ib3VuZHMubWF4WCA9IHRoaXMuX3dpZHRoICogKDEgLSB0aGlzLl9hbmNob3IuX3gpO1xuICAgICAgdGhpcy5fYm91bmRzLm1heFkgPSB0aGlzLl9oZWlnaHQgKiAoMSAtIHRoaXMuX2FuY2hvci5feSk7XG4gICAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2NhbEJvdW5kc1JlY3QpIHtcbiAgICAgICAgICB0aGlzLl9sb2NhbEJvdW5kc1JlY3QgPSBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjdCA9IHRoaXMuX2xvY2FsQm91bmRzUmVjdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9ib3VuZHMuZ2V0UmVjdGFuZ2xlKHJlY3QpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZ2V0TG9jYWxCb3VuZHMuY2FsbCh0aGlzLCByZWN0KTtcbiAgfVxuICBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgdGhpcy53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UocG9pbnQsIHRlbXBQb2ludCk7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gICAgY29uc3QgeDEgPSAtd2lkdGggKiB0aGlzLmFuY2hvci5feDtcbiAgICBpZiAodGVtcFBvaW50LnggPj0geDEgJiYgdGVtcFBvaW50LnggPCB4MSArIHdpZHRoKSB7XG4gICAgICBjb25zdCB5MSA9IC1oZWlnaHQgKiB0aGlzLmFuY2hvci5feTtcbiAgICAgIGlmICh0ZW1wUG9pbnQueSA+PSB5MSAmJiB0ZW1wUG9pbnQueSA8IHkxICsgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgICB0aGlzLnRpbGVUcmFuc2Zvcm0gPSBudWxsO1xuICAgIHRoaXMudXZNYXRyaXggPSBudWxsO1xuICB9XG4gIHN0YXRpYyBmcm9tKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRleHR1cmUgPSBzb3VyY2UgaW5zdGFuY2VvZiBUZXh0dXJlID8gc291cmNlIDogVGV4dHVyZS5mcm9tKHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBUaWxpbmdTcHJpdGUodGV4dHVyZSwgb3B0aW9ucy53aWR0aCwgb3B0aW9ucy5oZWlnaHQpO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gIH1cbiAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCB7IFRpbGluZ1Nwcml0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlsaW5nU3ByaXRlLm1qcy5tYXBcbiIsInZhciBnbDJGcmFnbWVudFNyYyA9IFwiI3ZlcnNpb24gMzAwIGVzXFxuI2RlZmluZSBTSEFERVJfTkFNRSBUaWxpbmctU3ByaXRlLTEwMFxcblxcbnByZWNpc2lvbiBsb3dwIGZsb2F0O1xcblxcbmluIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG5vdXQgdmVjNCBmcmFnbWVudENvbG9yO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gdmVjNCB1Q29sb3I7XFxudW5pZm9ybSBtYXQzIHVNYXBDb29yZDtcXG51bmlmb3JtIHZlYzQgdUNsYW1wRnJhbWU7XFxudW5pZm9ybSB2ZWMyIHVDbGFtcE9mZnNldDtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIHZlYzIgY29vcmQgPSB2VGV4dHVyZUNvb3JkICsgY2VpbCh1Q2xhbXBPZmZzZXQgLSB2VGV4dHVyZUNvb3JkKTtcXG4gICAgY29vcmQgPSAodU1hcENvb3JkICogdmVjMyhjb29yZCwgMS4wKSkueHk7XFxuICAgIHZlYzIgdW5jbGFtcGVkID0gY29vcmQ7XFxuICAgIGNvb3JkID0gY2xhbXAoY29vcmQsIHVDbGFtcEZyYW1lLnh5LCB1Q2xhbXBGcmFtZS56dyk7XFxuXFxuICAgIHZlYzQgdGV4U2FtcGxlID0gdGV4dHVyZSh1U2FtcGxlciwgY29vcmQsIHVuY2xhbXBlZCA9PSBjb29yZCA/IDAuMGYgOiAtMzIuMGYpOy8vIGxvZC1iaWFzIHZlcnkgbmVnYXRpdmUgdG8gZm9yY2UgbG9kIDBcXG5cXG4gICAgZnJhZ21lbnRDb2xvciA9IHRleFNhbXBsZSAqIHVDb2xvcjtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGdsMkZyYWdtZW50U3JjIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwcml0ZS10aWxpbmcubWpzLm1hcFxuIiwidmFyIGdsMlZlcnRleFNyYyA9IFwiI3ZlcnNpb24gMzAwIGVzXFxuI2RlZmluZSBTSEFERVJfTkFNRSBUaWxpbmctU3ByaXRlLTMwMFxcblxcbnByZWNpc2lvbiBsb3dwIGZsb2F0O1xcblxcbmluIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcbmluIHZlYzIgYVRleHR1cmVDb29yZDtcXG5cXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG51bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7XFxudW5pZm9ybSBtYXQzIHVUcmFuc2Zvcm07XFxuXFxub3V0IHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxuXFxuICAgIHZUZXh0dXJlQ29vcmQgPSAodVRyYW5zZm9ybSAqIHZlYzMoYVRleHR1cmVDb29yZCwgMS4wKSkueHk7XFxufVxcblwiO1xuXG5leHBvcnQgeyBnbDJWZXJ0ZXhTcmMgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ByaXRlLXRpbGluZzIubWpzLm1hcFxuIiwidmFyIGdsMUZyYWdtZW50U3JjID0gXCIjdmVyc2lvbiAxMDBcXG4jaWZkZWYgR0xfRVhUX3NoYWRlcl90ZXh0dXJlX2xvZFxcbiAgICAjZXh0ZW5zaW9uIEdMX0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QgOiBlbmFibGVcXG4jZW5kaWZcXG4jZGVmaW5lIFNIQURFUl9OQU1FIFRpbGluZy1TcHJpdGUtMTAwXFxuXFxucHJlY2lzaW9uIGxvd3AgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxudW5pZm9ybSB2ZWM0IHVDb2xvcjtcXG51bmlmb3JtIG1hdDMgdU1hcENvb3JkO1xcbnVuaWZvcm0gdmVjNCB1Q2xhbXBGcmFtZTtcXG51bmlmb3JtIHZlYzIgdUNsYW1wT2Zmc2V0O1xcblxcbnZvaWQgbWFpbih2b2lkKVxcbntcXG4gICAgdmVjMiBjb29yZCA9IHZUZXh0dXJlQ29vcmQgKyBjZWlsKHVDbGFtcE9mZnNldCAtIHZUZXh0dXJlQ29vcmQpO1xcbiAgICBjb29yZCA9ICh1TWFwQ29vcmQgKiB2ZWMzKGNvb3JkLCAxLjApKS54eTtcXG4gICAgdmVjMiB1bmNsYW1wZWQgPSBjb29yZDtcXG4gICAgY29vcmQgPSBjbGFtcChjb29yZCwgdUNsYW1wRnJhbWUueHksIHVDbGFtcEZyYW1lLnp3KTtcXG5cXG4gICAgI2lmZGVmIEdMX0VYVF9zaGFkZXJfdGV4dHVyZV9sb2RcXG4gICAgICAgIHZlYzQgdGV4U2FtcGxlID0gdW5jbGFtcGVkID09IGNvb3JkXFxuICAgICAgICAgICAgPyB0ZXh0dXJlMkQodVNhbXBsZXIsIGNvb3JkKSBcXG4gICAgICAgICAgICA6IHRleHR1cmUyRExvZEVYVCh1U2FtcGxlciwgY29vcmQsIDApO1xcbiAgICAjZWxzZVxcbiAgICAgICAgdmVjNCB0ZXhTYW1wbGUgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIGNvb3JkKTtcXG4gICAgI2VuZGlmXFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleFNhbXBsZSAqIHVDb2xvcjtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGdsMUZyYWdtZW50U3JjIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwcml0ZS10aWxpbmctZmFsbGJhY2subWpzLm1hcFxuIiwidmFyIGdsMVZlcnRleFNyYyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBTSEFERVJfTkFNRSBUaWxpbmctU3ByaXRlLTEwMFxcblxcbnByZWNpc2lvbiBsb3dwIGZsb2F0O1xcblxcbmF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcXG51bmlmb3JtIG1hdDMgdVRyYW5zZm9ybTtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG52b2lkIG1haW4odm9pZClcXG57XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxuXFxuICAgIHZUZXh0dXJlQ29vcmQgPSAodVRyYW5zZm9ybSAqIHZlYzMoYVRleHR1cmVDb29yZCwgMS4wKSkueHk7XFxufVxcblwiO1xuXG5leHBvcnQgeyBnbDFWZXJ0ZXhTcmMgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ByaXRlLXRpbGluZy1mYWxsYmFjazIubWpzLm1hcFxuIiwidmFyIGZyYWdtZW50U2ltcGxlU3JjID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIFNIQURFUl9OQU1FIFRpbGluZy1TcHJpdGUtU2ltcGxlLTEwMFxcblxcbnByZWNpc2lvbiBsb3dwIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcbnVuaWZvcm0gdmVjNCB1Q29sb3I7XFxuXFxudm9pZCBtYWluKHZvaWQpXFxue1xcbiAgICB2ZWM0IHRleFNhbXBsZSA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleFNhbXBsZSAqIHVDb2xvcjtcXG59XFxuXCI7XG5cbmV4cG9ydCB7IGZyYWdtZW50U2ltcGxlU3JjIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwcml0ZS10aWxpbmctc2ltcGxlLm1qcy5tYXBcbiIsImltcG9ydCB7IE1hdHJpeCwgT2JqZWN0UmVuZGVyZXIsIFF1YWRVdiwgU3RhdGUsIFNoYWRlciwgV1JBUF9NT0RFUywgQ29sb3IsIHV0aWxzLCBFeHRlbnNpb25UeXBlLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgZ2wyRnJhZ21lbnRTcmMgZnJvbSAnLi9zcHJpdGUtdGlsaW5nLm1qcyc7XG5pbXBvcnQgZ2wyVmVydGV4U3JjIGZyb20gJy4vc3ByaXRlLXRpbGluZzIubWpzJztcbmltcG9ydCBnbDFGcmFnbWVudFNyYyBmcm9tICcuL3Nwcml0ZS10aWxpbmctZmFsbGJhY2subWpzJztcbmltcG9ydCBnbDFWZXJ0ZXhTcmMgZnJvbSAnLi9zcHJpdGUtdGlsaW5nLWZhbGxiYWNrMi5tanMnO1xuaW1wb3J0IGZyYWdtZW50U2ltcGxlU3JjIGZyb20gJy4vc3ByaXRlLXRpbGluZy1zaW1wbGUubWpzJztcblxuY29uc3QgdGVtcE1hdCA9IG5ldyBNYXRyaXgoKTtcbmNsYXNzIFRpbGluZ1Nwcml0ZVJlbmRlcmVyIGV4dGVuZHMgT2JqZWN0UmVuZGVyZXIge1xuICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgIHN1cGVyKHJlbmRlcmVyKTtcbiAgICByZW5kZXJlci5ydW5uZXJzLmNvbnRleHRDaGFuZ2UuYWRkKHRoaXMpO1xuICAgIHRoaXMucXVhZCA9IG5ldyBRdWFkVXYoKTtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuZm9yMmQoKTtcbiAgfVxuICBjb250ZXh0Q2hhbmdlKCkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHsgZ2xvYmFsczogcmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMgfTtcbiAgICB0aGlzLnNpbXBsZVNoYWRlciA9IFNoYWRlci5mcm9tKGdsMVZlcnRleFNyYywgZnJhZ21lbnRTaW1wbGVTcmMsIHVuaWZvcm1zKTtcbiAgICB0aGlzLnNoYWRlciA9IHJlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uID4gMSA/IFNoYWRlci5mcm9tKGdsMlZlcnRleFNyYywgZ2wyRnJhZ21lbnRTcmMsIHVuaWZvcm1zKSA6IFNoYWRlci5mcm9tKGdsMVZlcnRleFNyYywgZ2wxRnJhZ21lbnRTcmMsIHVuaWZvcm1zKTtcbiAgfVxuICByZW5kZXIodHMpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgY29uc3QgcXVhZCA9IHRoaXMucXVhZDtcbiAgICBsZXQgdmVydGljZXMgPSBxdWFkLnZlcnRpY2VzO1xuICAgIHZlcnRpY2VzWzBdID0gdmVydGljZXNbNl0gPSB0cy5fd2lkdGggKiAtdHMuYW5jaG9yLng7XG4gICAgdmVydGljZXNbMV0gPSB2ZXJ0aWNlc1szXSA9IHRzLl9oZWlnaHQgKiAtdHMuYW5jaG9yLnk7XG4gICAgdmVydGljZXNbMl0gPSB2ZXJ0aWNlc1s0XSA9IHRzLl93aWR0aCAqICgxIC0gdHMuYW5jaG9yLngpO1xuICAgIHZlcnRpY2VzWzVdID0gdmVydGljZXNbN10gPSB0cy5faGVpZ2h0ICogKDEgLSB0cy5hbmNob3IueSk7XG4gICAgY29uc3QgYW5jaG9yWCA9IHRzLnV2UmVzcGVjdEFuY2hvciA/IHRzLmFuY2hvci54IDogMDtcbiAgICBjb25zdCBhbmNob3JZID0gdHMudXZSZXNwZWN0QW5jaG9yID8gdHMuYW5jaG9yLnkgOiAwO1xuICAgIHZlcnRpY2VzID0gcXVhZC51dnM7XG4gICAgdmVydGljZXNbMF0gPSB2ZXJ0aWNlc1s2XSA9IC1hbmNob3JYO1xuICAgIHZlcnRpY2VzWzFdID0gdmVydGljZXNbM10gPSAtYW5jaG9yWTtcbiAgICB2ZXJ0aWNlc1syXSA9IHZlcnRpY2VzWzRdID0gMSAtIGFuY2hvclg7XG4gICAgdmVydGljZXNbNV0gPSB2ZXJ0aWNlc1s3XSA9IDEgLSBhbmNob3JZO1xuICAgIHF1YWQuaW52YWxpZGF0ZSgpO1xuICAgIGNvbnN0IHRleCA9IHRzLl90ZXh0dXJlO1xuICAgIGNvbnN0IGJhc2VUZXggPSB0ZXguYmFzZVRleHR1cmU7XG4gICAgY29uc3QgcHJlbXVsdGlwbGllZCA9IGJhc2VUZXguYWxwaGFNb2RlID4gMDtcbiAgICBjb25zdCBsdCA9IHRzLnRpbGVUcmFuc2Zvcm0ubG9jYWxUcmFuc2Zvcm07XG4gICAgY29uc3QgdXYgPSB0cy51dk1hdHJpeDtcbiAgICBsZXQgaXNTaW1wbGUgPSBiYXNlVGV4LmlzUG93ZXJPZlR3byAmJiB0ZXguZnJhbWUud2lkdGggPT09IGJhc2VUZXgud2lkdGggJiYgdGV4LmZyYW1lLmhlaWdodCA9PT0gYmFzZVRleC5oZWlnaHQ7XG4gICAgaWYgKGlzU2ltcGxlKSB7XG4gICAgICBpZiAoIWJhc2VUZXguX2dsVGV4dHVyZXNbcmVuZGVyZXIuQ09OVEVYVF9VSURdKSB7XG4gICAgICAgIGlmIChiYXNlVGV4LndyYXBNb2RlID09PSBXUkFQX01PREVTLkNMQU1QKSB7XG4gICAgICAgICAgYmFzZVRleC53cmFwTW9kZSA9IFdSQVBfTU9ERVMuUkVQRUFUO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc1NpbXBsZSA9IGJhc2VUZXgud3JhcE1vZGUgIT09IFdSQVBfTU9ERVMuQ0xBTVA7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNoYWRlciA9IGlzU2ltcGxlID8gdGhpcy5zaW1wbGVTaGFkZXIgOiB0aGlzLnNoYWRlcjtcbiAgICBjb25zdCB3ID0gdGV4LndpZHRoO1xuICAgIGNvbnN0IGggPSB0ZXguaGVpZ2h0O1xuICAgIGNvbnN0IFcgPSB0cy5fd2lkdGg7XG4gICAgY29uc3QgSCA9IHRzLl9oZWlnaHQ7XG4gICAgdGVtcE1hdC5zZXQobHQuYSAqIHcgLyBXLCBsdC5iICogdyAvIEgsIGx0LmMgKiBoIC8gVywgbHQuZCAqIGggLyBILCBsdC50eCAvIFcsIGx0LnR5IC8gSCk7XG4gICAgdGVtcE1hdC5pbnZlcnQoKTtcbiAgICBpZiAoaXNTaW1wbGUpIHtcbiAgICAgIHRlbXBNYXQucHJlcGVuZCh1di5tYXBDb29yZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNoYWRlci51bmlmb3Jtcy51TWFwQ29vcmQgPSB1di5tYXBDb29yZC50b0FycmF5KHRydWUpO1xuICAgICAgc2hhZGVyLnVuaWZvcm1zLnVDbGFtcEZyYW1lID0gdXYudUNsYW1wRnJhbWU7XG4gICAgICBzaGFkZXIudW5pZm9ybXMudUNsYW1wT2Zmc2V0ID0gdXYudUNsYW1wT2Zmc2V0O1xuICAgIH1cbiAgICBzaGFkZXIudW5pZm9ybXMudVRyYW5zZm9ybSA9IHRlbXBNYXQudG9BcnJheSh0cnVlKTtcbiAgICBzaGFkZXIudW5pZm9ybXMudUNvbG9yID0gQ29sb3Iuc2hhcmVkLnNldFZhbHVlKHRzLnRpbnQpLnByZW11bHRpcGx5KHRzLndvcmxkQWxwaGEsIHByZW11bHRpcGxpZWQpLnRvQXJyYXkoc2hhZGVyLnVuaWZvcm1zLnVDb2xvcik7XG4gICAgc2hhZGVyLnVuaWZvcm1zLnRyYW5zbGF0aW9uTWF0cml4ID0gdHMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLnRvQXJyYXkodHJ1ZSk7XG4gICAgc2hhZGVyLnVuaWZvcm1zLnVTYW1wbGVyID0gdGV4O1xuICAgIHJlbmRlcmVyLnNoYWRlci5iaW5kKHNoYWRlcik7XG4gICAgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZChxdWFkKTtcbiAgICB0aGlzLnN0YXRlLmJsZW5kTW9kZSA9IHV0aWxzLmNvcnJlY3RCbGVuZE1vZGUodHMuYmxlbmRNb2RlLCBwcmVtdWx0aXBsaWVkKTtcbiAgICByZW5kZXJlci5zdGF0ZS5zZXQodGhpcy5zdGF0ZSk7XG4gICAgcmVuZGVyZXIuZ2VvbWV0cnkuZHJhdyh0aGlzLnJlbmRlcmVyLmdsLlRSSUFOR0xFUywgNiwgMCk7XG4gIH1cbn1cblRpbGluZ1Nwcml0ZVJlbmRlcmVyLmV4dGVuc2lvbiA9IHtcbiAgbmFtZTogXCJ0aWxpbmdTcHJpdGVcIixcbiAgdHlwZTogRXh0ZW5zaW9uVHlwZS5SZW5kZXJlclBsdWdpblxufTtcbmV4dGVuc2lvbnMuYWRkKFRpbGluZ1Nwcml0ZVJlbmRlcmVyKTtcblxuZXhwb3J0IHsgVGlsaW5nU3ByaXRlUmVuZGVyZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbGluZ1Nwcml0ZVJlbmRlcmVyLm1qcy5tYXBcbiIsImV4cG9ydCB7IFRpbGluZ1Nwcml0ZSB9IGZyb20gJy4vVGlsaW5nU3ByaXRlLm1qcyc7XG5leHBvcnQgeyBUaWxpbmdTcHJpdGVSZW5kZXJlciB9IGZyb20gJy4vVGlsaW5nU3ByaXRlUmVuZGVyZXIubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IFRleHR1cmUsIEJhc2VUZXh0dXJlLCB1dGlscywgUmVjdGFuZ2xlIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5cbmNvbnN0IF9TcHJpdGVzaGVldCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodGV4dHVyZSwgZGF0YSwgcmVzb2x1dGlvbkZpbGVuYW1lID0gbnVsbCkge1xuICAgIHRoaXMubGlua2VkU2hlZXRzID0gW107XG4gICAgdGhpcy5fdGV4dHVyZSA9IHRleHR1cmUgaW5zdGFuY2VvZiBUZXh0dXJlID8gdGV4dHVyZSA6IG51bGw7XG4gICAgdGhpcy5iYXNlVGV4dHVyZSA9IHRleHR1cmUgaW5zdGFuY2VvZiBCYXNlVGV4dHVyZSA/IHRleHR1cmUgOiB0aGlzLl90ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgIHRoaXMudGV4dHVyZXMgPSB7fTtcbiAgICB0aGlzLmFuaW1hdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIGNvbnN0IHJlc291cmNlID0gdGhpcy5iYXNlVGV4dHVyZS5yZXNvdXJjZTtcbiAgICB0aGlzLnJlc29sdXRpb24gPSB0aGlzLl91cGRhdGVSZXNvbHV0aW9uKHJlc29sdXRpb25GaWxlbmFtZSB8fCAocmVzb3VyY2UgPyByZXNvdXJjZS51cmwgOiBudWxsKSk7XG4gICAgdGhpcy5fZnJhbWVzID0gdGhpcy5kYXRhLmZyYW1lcztcbiAgICB0aGlzLl9mcmFtZUtleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9mcmFtZXMpO1xuICAgIHRoaXMuX2JhdGNoSW5kZXggPSAwO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbDtcbiAgfVxuICBfdXBkYXRlUmVzb2x1dGlvbihyZXNvbHV0aW9uRmlsZW5hbWUgPSBudWxsKSB7XG4gICAgY29uc3QgeyBzY2FsZSB9ID0gdGhpcy5kYXRhLm1ldGE7XG4gICAgbGV0IHJlc29sdXRpb24gPSB1dGlscy5nZXRSZXNvbHV0aW9uT2ZVcmwocmVzb2x1dGlvbkZpbGVuYW1lLCBudWxsKTtcbiAgICBpZiAocmVzb2x1dGlvbiA9PT0gbnVsbCkge1xuICAgICAgcmVzb2x1dGlvbiA9IHBhcnNlRmxvYXQoc2NhbGUgPz8gXCIxXCIpO1xuICAgIH1cbiAgICBpZiAocmVzb2x1dGlvbiAhPT0gMSkge1xuICAgICAgdGhpcy5iYXNlVGV4dHVyZS5zZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x1dGlvbjtcbiAgfVxuICBwYXJzZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrID0gcmVzb2x2ZTtcbiAgICAgIHRoaXMuX2JhdGNoSW5kZXggPSAwO1xuICAgICAgaWYgKHRoaXMuX2ZyYW1lS2V5cy5sZW5ndGggPD0gX1Nwcml0ZXNoZWV0LkJBVENIX1NJWkUpIHtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc0ZyYW1lcygwKTtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc0FuaW1hdGlvbnMoKTtcbiAgICAgICAgdGhpcy5fcGFyc2VDb21wbGV0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbmV4dEJhdGNoKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX3Byb2Nlc3NGcmFtZXMoaW5pdGlhbEZyYW1lSW5kZXgpIHtcbiAgICBsZXQgZnJhbWVJbmRleCA9IGluaXRpYWxGcmFtZUluZGV4O1xuICAgIGNvbnN0IG1heEZyYW1lcyA9IF9TcHJpdGVzaGVldC5CQVRDSF9TSVpFO1xuICAgIHdoaWxlIChmcmFtZUluZGV4IC0gaW5pdGlhbEZyYW1lSW5kZXggPCBtYXhGcmFtZXMgJiYgZnJhbWVJbmRleCA8IHRoaXMuX2ZyYW1lS2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLl9mcmFtZUtleXNbZnJhbWVJbmRleF07XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5fZnJhbWVzW2ldO1xuICAgICAgY29uc3QgcmVjdCA9IGRhdGEuZnJhbWU7XG4gICAgICBpZiAocmVjdCkge1xuICAgICAgICBsZXQgZnJhbWUgPSBudWxsO1xuICAgICAgICBsZXQgdHJpbSA9IG51bGw7XG4gICAgICAgIGNvbnN0IHNvdXJjZVNpemUgPSBkYXRhLnRyaW1tZWQgIT09IGZhbHNlICYmIGRhdGEuc291cmNlU2l6ZSA/IGRhdGEuc291cmNlU2l6ZSA6IGRhdGEuZnJhbWU7XG4gICAgICAgIGNvbnN0IG9yaWcgPSBuZXcgUmVjdGFuZ2xlKDAsIDAsIE1hdGguZmxvb3Ioc291cmNlU2l6ZS53KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihzb3VyY2VTaXplLmgpIC8gdGhpcy5yZXNvbHV0aW9uKTtcbiAgICAgICAgaWYgKGRhdGEucm90YXRlZCkge1xuICAgICAgICAgIGZyYW1lID0gbmV3IFJlY3RhbmdsZShNYXRoLmZsb29yKHJlY3QueCkgLyB0aGlzLnJlc29sdXRpb24sIE1hdGguZmxvb3IocmVjdC55KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihyZWN0LmgpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKHJlY3QudykgLyB0aGlzLnJlc29sdXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyYW1lID0gbmV3IFJlY3RhbmdsZShNYXRoLmZsb29yKHJlY3QueCkgLyB0aGlzLnJlc29sdXRpb24sIE1hdGguZmxvb3IocmVjdC55KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihyZWN0LncpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKHJlY3QuaCkgLyB0aGlzLnJlc29sdXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnRyaW1tZWQgIT09IGZhbHNlICYmIGRhdGEuc3ByaXRlU291cmNlU2l6ZSkge1xuICAgICAgICAgIHRyaW0gPSBuZXcgUmVjdGFuZ2xlKE1hdGguZmxvb3IoZGF0YS5zcHJpdGVTb3VyY2VTaXplLngpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKGRhdGEuc3ByaXRlU291cmNlU2l6ZS55KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihyZWN0LncpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKHJlY3QuaCkgLyB0aGlzLnJlc29sdXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dHVyZXNbaV0gPSBuZXcgVGV4dHVyZSh0aGlzLmJhc2VUZXh0dXJlLCBmcmFtZSwgb3JpZywgdHJpbSwgZGF0YS5yb3RhdGVkID8gMiA6IDAsIGRhdGEuYW5jaG9yLCBkYXRhLmJvcmRlcnMpO1xuICAgICAgICBUZXh0dXJlLmFkZFRvQ2FjaGUodGhpcy50ZXh0dXJlc1tpXSwgaSk7XG4gICAgICB9XG4gICAgICBmcmFtZUluZGV4Kys7XG4gICAgfVxuICB9XG4gIF9wcm9jZXNzQW5pbWF0aW9ucygpIHtcbiAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5kYXRhLmFuaW1hdGlvbnMgfHwge307XG4gICAgZm9yIChjb25zdCBhbmltTmFtZSBpbiBhbmltYXRpb25zKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbnNbYW5pbU5hbWVdID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFuaW1hdGlvbnNbYW5pbU5hbWVdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lTmFtZSA9IGFuaW1hdGlvbnNbYW5pbU5hbWVdW2ldO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnNbYW5pbU5hbWVdLnB1c2godGhpcy50ZXh0dXJlc1tmcmFtZU5hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3BhcnNlQ29tcGxldGUoKSB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl9jYWxsYmFjaztcbiAgICB0aGlzLl9jYWxsYmFjayA9IG51bGw7XG4gICAgdGhpcy5fYmF0Y2hJbmRleCA9IDA7XG4gICAgY2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLnRleHR1cmVzKTtcbiAgfVxuICBfbmV4dEJhdGNoKCkge1xuICAgIHRoaXMuX3Byb2Nlc3NGcmFtZXModGhpcy5fYmF0Y2hJbmRleCAqIF9TcHJpdGVzaGVldC5CQVRDSF9TSVpFKTtcbiAgICB0aGlzLl9iYXRjaEluZGV4Kys7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fYmF0Y2hJbmRleCAqIF9TcHJpdGVzaGVldC5CQVRDSF9TSVpFIDwgdGhpcy5fZnJhbWVLZXlzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9uZXh0QmF0Y2goKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NBbmltYXRpb25zKCk7XG4gICAgICAgIHRoaXMuX3BhcnNlQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9LCAwKTtcbiAgfVxuICBkZXN0cm95KGRlc3Ryb3lCYXNlID0gZmFsc2UpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy50ZXh0dXJlcykge1xuICAgICAgdGhpcy50ZXh0dXJlc1tpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuX2ZyYW1lcyA9IG51bGw7XG4gICAgdGhpcy5fZnJhbWVLZXlzID0gbnVsbDtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIHRoaXMudGV4dHVyZXMgPSBudWxsO1xuICAgIGlmIChkZXN0cm95QmFzZSkge1xuICAgICAgdGhpcy5fdGV4dHVyZT8uZGVzdHJveSgpO1xuICAgICAgdGhpcy5iYXNlVGV4dHVyZS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuX3RleHR1cmUgPSBudWxsO1xuICAgIHRoaXMuYmFzZVRleHR1cmUgPSBudWxsO1xuICAgIHRoaXMubGlua2VkU2hlZXRzID0gW107XG4gIH1cbn07XG5sZXQgU3ByaXRlc2hlZXQgPSBfU3ByaXRlc2hlZXQ7XG5TcHJpdGVzaGVldC5CQVRDSF9TSVpFID0gMWUzO1xuXG5leHBvcnQgeyBTcHJpdGVzaGVldCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3ByaXRlc2hlZXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgTG9hZGVyUGFyc2VyUHJpb3JpdHksIGNvcHlTZWFyY2hQYXJhbXMgfSBmcm9tICdAcGl4aS9hc3NldHMnO1xuaW1wb3J0IHsgdXRpbHMsIEV4dGVuc2lvblR5cGUsIHNldHRpbmdzLCBleHRlbnNpb25zIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBTcHJpdGVzaGVldCB9IGZyb20gJy4vU3ByaXRlc2hlZXQubWpzJztcblxuY29uc3QgdmFsaWRJbWFnZXMgPSBbXCJqcGdcIiwgXCJwbmdcIiwgXCJqcGVnXCIsIFwiYXZpZlwiLCBcIndlYnBcIl07XG5mdW5jdGlvbiBnZXRDYWNoZWFibGVBc3NldHMoa2V5cywgYXNzZXQsIGlnbm9yZU11bHRpUGFjaykge1xuICBjb25zdCBvdXQgPSB7fTtcbiAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBvdXRba2V5XSA9IGFzc2V0O1xuICB9KTtcbiAgT2JqZWN0LmtleXMoYXNzZXQudGV4dHVyZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIG91dFtrZXldID0gYXNzZXQudGV4dHVyZXNba2V5XTtcbiAgfSk7XG4gIGlmICghaWdub3JlTXVsdGlQYWNrKSB7XG4gICAgY29uc3QgYmFzZVBhdGggPSB1dGlscy5wYXRoLmRpcm5hbWUoa2V5c1swXSk7XG4gICAgYXNzZXQubGlua2VkU2hlZXRzLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgIGNvbnN0IG91dDIgPSBnZXRDYWNoZWFibGVBc3NldHMoW2Ake2Jhc2VQYXRofS8ke2Fzc2V0LmRhdGEubWV0YS5yZWxhdGVkX211bHRpX3BhY2tzW2ldfWBdLCBpdGVtLCB0cnVlKTtcbiAgICAgIE9iamVjdC5hc3NpZ24ob3V0LCBvdXQyKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuY29uc3Qgc3ByaXRlc2hlZXRBc3NldCA9IHtcbiAgZXh0ZW5zaW9uOiBFeHRlbnNpb25UeXBlLkFzc2V0LFxuICBjYWNoZToge1xuICAgIHRlc3Q6IChhc3NldCkgPT4gYXNzZXQgaW5zdGFuY2VvZiBTcHJpdGVzaGVldCxcbiAgICBnZXRDYWNoZWFibGVBc3NldHM6IChrZXlzLCBhc3NldCkgPT4gZ2V0Q2FjaGVhYmxlQXNzZXRzKGtleXMsIGFzc2V0LCBmYWxzZSlcbiAgfSxcbiAgcmVzb2x2ZXI6IHtcbiAgICB0ZXN0OiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IHRlbXBVUkwgPSB2YWx1ZS5zcGxpdChcIj9cIilbMF07XG4gICAgICBjb25zdCBzcGxpdCA9IHRlbXBVUkwuc3BsaXQoXCIuXCIpO1xuICAgICAgY29uc3QgZXh0ZW5zaW9uID0gc3BsaXQucG9wKCk7XG4gICAgICBjb25zdCBmb3JtYXQgPSBzcGxpdC5wb3AoKTtcbiAgICAgIHJldHVybiBleHRlbnNpb24gPT09IFwianNvblwiICYmIHZhbGlkSW1hZ2VzLmluY2x1ZGVzKGZvcm1hdCk7XG4gICAgfSxcbiAgICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBzcGxpdCA9IHZhbHVlLnNwbGl0KFwiLlwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc29sdXRpb246IHBhcnNlRmxvYXQoc2V0dGluZ3MuUkVUSU5BX1BSRUZJWC5leGVjKHZhbHVlKT8uWzFdID8/IFwiMVwiKSxcbiAgICAgICAgZm9ybWF0OiBzcGxpdFtzcGxpdC5sZW5ndGggLSAyXSxcbiAgICAgICAgc3JjOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIGxvYWRlcjoge1xuICAgIG5hbWU6IFwic3ByaXRlc2hlZXRMb2FkZXJcIixcbiAgICBleHRlbnNpb246IHtcbiAgICAgIHR5cGU6IEV4dGVuc2lvblR5cGUuTG9hZFBhcnNlcixcbiAgICAgIHByaW9yaXR5OiBMb2FkZXJQYXJzZXJQcmlvcml0eS5Ob3JtYWxcbiAgICB9LFxuICAgIGFzeW5jIHRlc3RQYXJzZShhc3NldCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHV0aWxzLnBhdGguZXh0bmFtZShvcHRpb25zLnNyYykudG9Mb3dlckNhc2UoKSA9PT0gXCIuanNvblwiICYmICEhYXNzZXQuZnJhbWVzO1xuICAgIH0sXG4gICAgYXN5bmMgcGFyc2UoYXNzZXQsIG9wdGlvbnMsIGxvYWRlcikge1xuICAgICAgbGV0IGJhc2VQYXRoID0gdXRpbHMucGF0aC5kaXJuYW1lKG9wdGlvbnMuc3JjKTtcbiAgICAgIGlmIChiYXNlUGF0aCAmJiBiYXNlUGF0aC5sYXN0SW5kZXhPZihcIi9cIikgIT09IGJhc2VQYXRoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgYmFzZVBhdGggKz0gXCIvXCI7XG4gICAgICB9XG4gICAgICBsZXQgaW1hZ2VQYXRoID0gYmFzZVBhdGggKyBhc3NldC5tZXRhLmltYWdlO1xuICAgICAgaW1hZ2VQYXRoID0gY29weVNlYXJjaFBhcmFtcyhpbWFnZVBhdGgsIG9wdGlvbnMuc3JjKTtcbiAgICAgIGNvbnN0IGFzc2V0cyA9IGF3YWl0IGxvYWRlci5sb2FkKFtpbWFnZVBhdGhdKTtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBhc3NldHNbaW1hZ2VQYXRoXTtcbiAgICAgIGNvbnN0IHNwcml0ZXNoZWV0ID0gbmV3IFNwcml0ZXNoZWV0KHRleHR1cmUuYmFzZVRleHR1cmUsIGFzc2V0LCBvcHRpb25zLnNyYyk7XG4gICAgICBhd2FpdCBzcHJpdGVzaGVldC5wYXJzZSgpO1xuICAgICAgY29uc3QgbXVsdGlQYWNrcyA9IGFzc2V0Py5tZXRhPy5yZWxhdGVkX211bHRpX3BhY2tzO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobXVsdGlQYWNrcykpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG11bHRpUGFja3MpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgaXRlbVVybCA9IGJhc2VQYXRoICsgaXRlbTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5kYXRhPy5pZ25vcmVNdWx0aVBhY2spIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtVXJsID0gY29weVNlYXJjaFBhcmFtcyhpdGVtVXJsLCBvcHRpb25zLnNyYyk7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChsb2FkZXIubG9hZCh7XG4gICAgICAgICAgICBzcmM6IGl0ZW1VcmwsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGlnbm9yZU11bHRpUGFjazogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIHNwcml0ZXNoZWV0LmxpbmtlZFNoZWV0cyA9IHJlcztcbiAgICAgICAgcmVzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICBpdGVtLmxpbmtlZFNoZWV0cyA9IFtzcHJpdGVzaGVldF0uY29uY2F0KHNwcml0ZXNoZWV0LmxpbmtlZFNoZWV0cy5maWx0ZXIoKHNwKSA9PiBzcCAhPT0gaXRlbSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzcHJpdGVzaGVldDtcbiAgICB9LFxuICAgIHVubG9hZChzcHJpdGVzaGVldCkge1xuICAgICAgc3ByaXRlc2hlZXQuZGVzdHJveSh0cnVlKTtcbiAgICB9XG4gIH1cbn07XG5leHRlbnNpb25zLmFkZChzcHJpdGVzaGVldEFzc2V0KTtcblxuZXhwb3J0IHsgc3ByaXRlc2hlZXRBc3NldCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ByaXRlc2hlZXRBc3NldC5tanMubWFwXG4iLCJleHBvcnQgeyBTcHJpdGVzaGVldCB9IGZyb20gJy4vU3ByaXRlc2hlZXQubWpzJztcbmV4cG9ydCB7IHNwcml0ZXNoZWV0QXNzZXQgfSBmcm9tICcuL3Nwcml0ZXNoZWV0QXNzZXQubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImNsYXNzIEJpdG1hcEZvbnREYXRhIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pbmZvID0gW107XG4gICAgdGhpcy5jb21tb24gPSBbXTtcbiAgICB0aGlzLnBhZ2UgPSBbXTtcbiAgICB0aGlzLmNoYXIgPSBbXTtcbiAgICB0aGlzLmtlcm5pbmcgPSBbXTtcbiAgICB0aGlzLmRpc3RhbmNlRmllbGQgPSBbXTtcbiAgfVxufVxuXG5leHBvcnQgeyBCaXRtYXBGb250RGF0YSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qml0bWFwRm9udERhdGEubWpzLm1hcFxuIiwiaW1wb3J0IHsgQml0bWFwRm9udERhdGEgfSBmcm9tICcuLi9CaXRtYXBGb250RGF0YS5tanMnO1xuXG5jbGFzcyBUZXh0Rm9ybWF0IHtcbiAgc3RhdGljIHRlc3QoZGF0YSkge1xuICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiBkYXRhLnN0YXJ0c1dpdGgoXCJpbmZvIGZhY2U9XCIpO1xuICB9XG4gIHN0YXRpYyBwYXJzZSh0eHQpIHtcbiAgICBjb25zdCBpdGVtcyA9IHR4dC5tYXRjaCgvXlthLXpdK1xccysuKyQvZ20pO1xuICAgIGNvbnN0IHJhd0RhdGEgPSB7XG4gICAgICBpbmZvOiBbXSxcbiAgICAgIGNvbW1vbjogW10sXG4gICAgICBwYWdlOiBbXSxcbiAgICAgIGNoYXI6IFtdLFxuICAgICAgY2hhcnM6IFtdLFxuICAgICAga2VybmluZzogW10sXG4gICAgICBrZXJuaW5nczogW10sXG4gICAgICBkaXN0YW5jZUZpZWxkOiBbXVxuICAgIH07XG4gICAgZm9yIChjb25zdCBpIGluIGl0ZW1zKSB7XG4gICAgICBjb25zdCBuYW1lID0gaXRlbXNbaV0ubWF0Y2goL15bYS16XSsvZ20pWzBdO1xuICAgICAgY29uc3QgYXR0cmlidXRlTGlzdCA9IGl0ZW1zW2ldLm1hdGNoKC9bYS16QS1aXSs9KFteXFxzXCInXSt8XCIoW15cIl0qKVwiKS9nbSk7XG4gICAgICBjb25zdCBpdGVtRGF0YSA9IHt9O1xuICAgICAgZm9yIChjb25zdCBpMiBpbiBhdHRyaWJ1dGVMaXN0KSB7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gYXR0cmlidXRlTGlzdFtpMl0uc3BsaXQoXCI9XCIpO1xuICAgICAgICBjb25zdCBrZXkgPSBzcGxpdFswXTtcbiAgICAgICAgY29uc3Qgc3RyVmFsdWUgPSBzcGxpdFsxXS5yZXBsYWNlKC9cIi9nbSwgXCJcIik7XG4gICAgICAgIGNvbnN0IGZsb2F0VmFsdWUgPSBwYXJzZUZsb2F0KHN0clZhbHVlKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpc05hTihmbG9hdFZhbHVlKSA/IHN0clZhbHVlIDogZmxvYXRWYWx1ZTtcbiAgICAgICAgaXRlbURhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmF3RGF0YVtuYW1lXS5wdXNoKGl0ZW1EYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZm9udCA9IG5ldyBCaXRtYXBGb250RGF0YSgpO1xuICAgIHJhd0RhdGEuaW5mby5mb3JFYWNoKChpbmZvKSA9PiBmb250LmluZm8ucHVzaCh7XG4gICAgICBmYWNlOiBpbmZvLmZhY2UsXG4gICAgICBzaXplOiBwYXJzZUludChpbmZvLnNpemUsIDEwKVxuICAgIH0pKTtcbiAgICByYXdEYXRhLmNvbW1vbi5mb3JFYWNoKChjb21tb24pID0+IGZvbnQuY29tbW9uLnB1c2goe1xuICAgICAgbGluZUhlaWdodDogcGFyc2VJbnQoY29tbW9uLmxpbmVIZWlnaHQsIDEwKVxuICAgIH0pKTtcbiAgICByYXdEYXRhLnBhZ2UuZm9yRWFjaCgocGFnZSkgPT4gZm9udC5wYWdlLnB1c2goe1xuICAgICAgaWQ6IHBhcnNlSW50KHBhZ2UuaWQsIDEwKSxcbiAgICAgIGZpbGU6IHBhZ2UuZmlsZVxuICAgIH0pKTtcbiAgICByYXdEYXRhLmNoYXIuZm9yRWFjaCgoY2hhcikgPT4gZm9udC5jaGFyLnB1c2goe1xuICAgICAgaWQ6IHBhcnNlSW50KGNoYXIuaWQsIDEwKSxcbiAgICAgIHBhZ2U6IHBhcnNlSW50KGNoYXIucGFnZSwgMTApLFxuICAgICAgeDogcGFyc2VJbnQoY2hhci54LCAxMCksXG4gICAgICB5OiBwYXJzZUludChjaGFyLnksIDEwKSxcbiAgICAgIHdpZHRoOiBwYXJzZUludChjaGFyLndpZHRoLCAxMCksXG4gICAgICBoZWlnaHQ6IHBhcnNlSW50KGNoYXIuaGVpZ2h0LCAxMCksXG4gICAgICB4b2Zmc2V0OiBwYXJzZUludChjaGFyLnhvZmZzZXQsIDEwKSxcbiAgICAgIHlvZmZzZXQ6IHBhcnNlSW50KGNoYXIueW9mZnNldCwgMTApLFxuICAgICAgeGFkdmFuY2U6IHBhcnNlSW50KGNoYXIueGFkdmFuY2UsIDEwKVxuICAgIH0pKTtcbiAgICByYXdEYXRhLmtlcm5pbmcuZm9yRWFjaCgoa2VybmluZykgPT4gZm9udC5rZXJuaW5nLnB1c2goe1xuICAgICAgZmlyc3Q6IHBhcnNlSW50KGtlcm5pbmcuZmlyc3QsIDEwKSxcbiAgICAgIHNlY29uZDogcGFyc2VJbnQoa2VybmluZy5zZWNvbmQsIDEwKSxcbiAgICAgIGFtb3VudDogcGFyc2VJbnQoa2VybmluZy5hbW91bnQsIDEwKVxuICAgIH0pKTtcbiAgICByYXdEYXRhLmRpc3RhbmNlRmllbGQuZm9yRWFjaCgoZGYpID0+IGZvbnQuZGlzdGFuY2VGaWVsZC5wdXNoKHtcbiAgICAgIGRpc3RhbmNlUmFuZ2U6IHBhcnNlSW50KGRmLmRpc3RhbmNlUmFuZ2UsIDEwKSxcbiAgICAgIGZpZWxkVHlwZTogZGYuZmllbGRUeXBlXG4gICAgfSkpO1xuICAgIHJldHVybiBmb250O1xuICB9XG59XG5cbmV4cG9ydCB7IFRleHRGb3JtYXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHRGb3JtYXQubWpzLm1hcFxuIiwiaW1wb3J0IHsgQml0bWFwRm9udERhdGEgfSBmcm9tICcuLi9CaXRtYXBGb250RGF0YS5tanMnO1xuXG5jbGFzcyBYTUxGb3JtYXQge1xuICBzdGF0aWMgdGVzdChkYXRhKSB7XG4gICAgY29uc3QgeG1sID0gZGF0YTtcbiAgICByZXR1cm4gXCJnZXRFbGVtZW50c0J5VGFnTmFtZVwiIGluIHhtbCAmJiB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwYWdlXCIpLmxlbmd0aCAmJiB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbmZvXCIpWzBdLmdldEF0dHJpYnV0ZShcImZhY2VcIikgIT09IG51bGw7XG4gIH1cbiAgc3RhdGljIHBhcnNlKHhtbCkge1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgQml0bWFwRm9udERhdGEoKTtcbiAgICBjb25zdCBpbmZvID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5mb1wiKTtcbiAgICBjb25zdCBjb21tb24gPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjb21tb25cIik7XG4gICAgY29uc3QgcGFnZSA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInBhZ2VcIik7XG4gICAgY29uc3QgY2hhciA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImNoYXJcIik7XG4gICAgY29uc3Qga2VybmluZyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImtlcm5pbmdcIik7XG4gICAgY29uc3QgZGlzdGFuY2VGaWVsZCA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRpc3RhbmNlRmllbGRcIik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmZvLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhLmluZm8ucHVzaCh7XG4gICAgICAgIGZhY2U6IGluZm9baV0uZ2V0QXR0cmlidXRlKFwiZmFjZVwiKSxcbiAgICAgICAgc2l6ZTogcGFyc2VJbnQoaW5mb1tpXS5nZXRBdHRyaWJ1dGUoXCJzaXplXCIpLCAxMClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1vbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YS5jb21tb24ucHVzaCh7XG4gICAgICAgIGxpbmVIZWlnaHQ6IHBhcnNlSW50KGNvbW1vbltpXS5nZXRBdHRyaWJ1dGUoXCJsaW5lSGVpZ2h0XCIpLCAxMClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEucGFnZS5wdXNoKHtcbiAgICAgICAgaWQ6IHBhcnNlSW50KHBhZ2VbaV0uZ2V0QXR0cmlidXRlKFwiaWRcIiksIDEwKSB8fCAwLFxuICAgICAgICBmaWxlOiBwYWdlW2ldLmdldEF0dHJpYnV0ZShcImZpbGVcIilcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxldHRlciA9IGNoYXJbaV07XG4gICAgICBkYXRhLmNoYXIucHVzaCh7XG4gICAgICAgIGlkOiBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKFwiaWRcIiksIDEwKSxcbiAgICAgICAgcGFnZTogcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZShcInBhZ2VcIiksIDEwKSB8fCAwLFxuICAgICAgICB4OiBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKFwieFwiKSwgMTApLFxuICAgICAgICB5OiBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKFwieVwiKSwgMTApLFxuICAgICAgICB3aWR0aDogcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZShcIndpZHRoXCIpLCAxMCksXG4gICAgICAgIGhlaWdodDogcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZShcImhlaWdodFwiKSwgMTApLFxuICAgICAgICB4b2Zmc2V0OiBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKFwieG9mZnNldFwiKSwgMTApLFxuICAgICAgICB5b2Zmc2V0OiBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKFwieW9mZnNldFwiKSwgMTApLFxuICAgICAgICB4YWR2YW5jZTogcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZShcInhhZHZhbmNlXCIpLCAxMClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5pbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEua2VybmluZy5wdXNoKHtcbiAgICAgICAgZmlyc3Q6IHBhcnNlSW50KGtlcm5pbmdbaV0uZ2V0QXR0cmlidXRlKFwiZmlyc3RcIiksIDEwKSxcbiAgICAgICAgc2Vjb25kOiBwYXJzZUludChrZXJuaW5nW2ldLmdldEF0dHJpYnV0ZShcInNlY29uZFwiKSwgMTApLFxuICAgICAgICBhbW91bnQ6IHBhcnNlSW50KGtlcm5pbmdbaV0uZ2V0QXR0cmlidXRlKFwiYW1vdW50XCIpLCAxMClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpc3RhbmNlRmllbGQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEuZGlzdGFuY2VGaWVsZC5wdXNoKHtcbiAgICAgICAgZmllbGRUeXBlOiBkaXN0YW5jZUZpZWxkW2ldLmdldEF0dHJpYnV0ZShcImZpZWxkVHlwZVwiKSxcbiAgICAgICAgZGlzdGFuY2VSYW5nZTogcGFyc2VJbnQoZGlzdGFuY2VGaWVsZFtpXS5nZXRBdHRyaWJ1dGUoXCJkaXN0YW5jZVJhbmdlXCIpLCAxMClcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxufVxuXG5leHBvcnQgeyBYTUxGb3JtYXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVhNTEZvcm1hdC5tanMubWFwXG4iLCJpbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgWE1MRm9ybWF0IH0gZnJvbSAnLi9YTUxGb3JtYXQubWpzJztcblxuY2xhc3MgWE1MU3RyaW5nRm9ybWF0IHtcbiAgc3RhdGljIHRlc3QoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiBkYXRhLmluY2x1ZGVzKFwiPGZvbnQ+XCIpKSB7XG4gICAgICByZXR1cm4gWE1MRm9ybWF0LnRlc3Qoc2V0dGluZ3MuQURBUFRFUi5wYXJzZVhNTChkYXRhKSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgcGFyc2UoeG1sVHh0KSB7XG4gICAgcmV0dXJuIFhNTEZvcm1hdC5wYXJzZShzZXR0aW5ncy5BREFQVEVSLnBhcnNlWE1MKHhtbFR4dCkpO1xuICB9XG59XG5cbmV4cG9ydCB7IFhNTFN0cmluZ0Zvcm1hdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9WE1MU3RyaW5nRm9ybWF0Lm1qcy5tYXBcbiIsImltcG9ydCB7IFRleHRGb3JtYXQgfSBmcm9tICcuL1RleHRGb3JtYXQubWpzJztcbmV4cG9ydCB7IFRleHRGb3JtYXQgfSBmcm9tICcuL1RleHRGb3JtYXQubWpzJztcbmltcG9ydCB7IFhNTEZvcm1hdCB9IGZyb20gJy4vWE1MRm9ybWF0Lm1qcyc7XG5leHBvcnQgeyBYTUxGb3JtYXQgfSBmcm9tICcuL1hNTEZvcm1hdC5tanMnO1xuaW1wb3J0IHsgWE1MU3RyaW5nRm9ybWF0IH0gZnJvbSAnLi9YTUxTdHJpbmdGb3JtYXQubWpzJztcbmV4cG9ydCB7IFhNTFN0cmluZ0Zvcm1hdCB9IGZyb20gJy4vWE1MU3RyaW5nRm9ybWF0Lm1qcyc7XG5cbmNvbnN0IGZvcm1hdHMgPSBbXG4gIFRleHRGb3JtYXQsXG4gIFhNTEZvcm1hdCxcbiAgWE1MU3RyaW5nRm9ybWF0XG5dO1xuZnVuY3Rpb24gYXV0b0RldGVjdEZvcm1hdChkYXRhKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybWF0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChmb3JtYXRzW2ldLnRlc3QoZGF0YSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRzW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IHsgYXV0b0RldGVjdEZvcm1hdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHsgVEVYVF9HUkFESUVOVCB9IGZyb20gJ0BwaXhpL3RleHQnO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUZpbGxTdHlsZShjYW52YXMsIGNvbnRleHQsIHN0eWxlLCByZXNvbHV0aW9uLCBsaW5lcywgbWV0cmljcykge1xuICBjb25zdCBmaWxsU3R5bGUgPSBzdHlsZS5maWxsO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsbFN0eWxlKSkge1xuICAgIHJldHVybiBmaWxsU3R5bGU7XG4gIH0gZWxzZSBpZiAoZmlsbFN0eWxlLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmaWxsU3R5bGVbMF07XG4gIH1cbiAgbGV0IGdyYWRpZW50O1xuICBjb25zdCBkcm9wU2hhZG93Q29ycmVjdGlvbiA9IHN0eWxlLmRyb3BTaGFkb3cgPyBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2UgOiAwO1xuICBjb25zdCBwYWRkaW5nID0gc3R5bGUucGFkZGluZyB8fCAwO1xuICBjb25zdCB3aWR0aCA9IGNhbnZhcy53aWR0aCAvIHJlc29sdXRpb24gLSBkcm9wU2hhZG93Q29ycmVjdGlvbiAtIHBhZGRpbmcgKiAyO1xuICBjb25zdCBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0IC8gcmVzb2x1dGlvbiAtIGRyb3BTaGFkb3dDb3JyZWN0aW9uIC0gcGFkZGluZyAqIDI7XG4gIGNvbnN0IGZpbGwgPSBmaWxsU3R5bGUuc2xpY2UoKTtcbiAgY29uc3QgZmlsbEdyYWRpZW50U3RvcHMgPSBzdHlsZS5maWxsR3JhZGllbnRTdG9wcy5zbGljZSgpO1xuICBpZiAoIWZpbGxHcmFkaWVudFN0b3BzLmxlbmd0aCkge1xuICAgIGNvbnN0IGxlbmd0aFBsdXMxID0gZmlsbC5sZW5ndGggKyAxO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuZ3RoUGx1czE7ICsraSkge1xuICAgICAgZmlsbEdyYWRpZW50U3RvcHMucHVzaChpIC8gbGVuZ3RoUGx1czEpO1xuICAgIH1cbiAgfVxuICBmaWxsLnVuc2hpZnQoZmlsbFN0eWxlWzBdKTtcbiAgZmlsbEdyYWRpZW50U3RvcHMudW5zaGlmdCgwKTtcbiAgZmlsbC5wdXNoKGZpbGxTdHlsZVtmaWxsU3R5bGUubGVuZ3RoIC0gMV0pO1xuICBmaWxsR3JhZGllbnRTdG9wcy5wdXNoKDEpO1xuICBpZiAoc3R5bGUuZmlsbEdyYWRpZW50VHlwZSA9PT0gVEVYVF9HUkFESUVOVC5MSU5FQVJfVkVSVElDQUwpIHtcbiAgICBncmFkaWVudCA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQod2lkdGggLyAyLCBwYWRkaW5nLCB3aWR0aCAvIDIsIGhlaWdodCArIHBhZGRpbmcpO1xuICAgIGxldCBsYXN0SXRlcmF0aW9uU3RvcCA9IDA7XG4gICAgY29uc3QgdGV4dEhlaWdodCA9IG1ldHJpY3MuZm9udFByb3BlcnRpZXMuZm9udFNpemUgKyBzdHlsZS5zdHJva2VUaGlja25lc3M7XG4gICAgY29uc3QgZ3JhZFN0b3BMaW5lSGVpZ2h0ID0gdGV4dEhlaWdodCAvIGhlaWdodDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0aGlzTGluZVRvcCA9IG1ldHJpY3MubGluZUhlaWdodCAqIGk7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZpbGwubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbGV0IGxpbmVTdG9wID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWxsR3JhZGllbnRTdG9wc1tqXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGxpbmVTdG9wID0gZmlsbEdyYWRpZW50U3RvcHNbal07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGluZVN0b3AgPSBqIC8gZmlsbC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ2xvYmFsU3RvcCA9IHRoaXNMaW5lVG9wIC8gaGVpZ2h0ICsgbGluZVN0b3AgKiBncmFkU3RvcExpbmVIZWlnaHQ7XG4gICAgICAgIGxldCBjbGFtcGVkU3RvcCA9IE1hdGgubWF4KGxhc3RJdGVyYXRpb25TdG9wLCBnbG9iYWxTdG9wKTtcbiAgICAgICAgY2xhbXBlZFN0b3AgPSBNYXRoLm1pbihjbGFtcGVkU3RvcCwgMSk7XG4gICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChjbGFtcGVkU3RvcCwgZmlsbFtqXSk7XG4gICAgICAgIGxhc3RJdGVyYXRpb25TdG9wID0gY2xhbXBlZFN0b3A7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGdyYWRpZW50ID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChwYWRkaW5nLCBoZWlnaHQgLyAyLCB3aWR0aCArIHBhZGRpbmcsIGhlaWdodCAvIDIpO1xuICAgIGNvbnN0IHRvdGFsSXRlcmF0aW9ucyA9IGZpbGwubGVuZ3RoICsgMTtcbiAgICBsZXQgY3VycmVudEl0ZXJhdGlvbiA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgc3RvcDtcbiAgICAgIGlmICh0eXBlb2YgZmlsbEdyYWRpZW50U3RvcHNbaV0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgc3RvcCA9IGZpbGxHcmFkaWVudFN0b3BzW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcCA9IGN1cnJlbnRJdGVyYXRpb24gLyB0b3RhbEl0ZXJhdGlvbnM7XG4gICAgICB9XG4gICAgICBncmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcCwgZmlsbFtpXSk7XG4gICAgICBjdXJyZW50SXRlcmF0aW9uKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBncmFkaWVudDtcbn1cblxuZXhwb3J0IHsgZ2VuZXJhdGVGaWxsU3R5bGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbmVyYXRlRmlsbFN0eWxlLm1qcy5tYXBcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBnZW5lcmF0ZUZpbGxTdHlsZSB9IGZyb20gJy4vZ2VuZXJhdGVGaWxsU3R5bGUubWpzJztcblxuZnVuY3Rpb24gZHJhd0dseXBoKGNhbnZhcywgY29udGV4dCwgbWV0cmljcywgeCwgeSwgcmVzb2x1dGlvbiwgc3R5bGUpIHtcbiAgY29uc3QgY2hhciA9IG1ldHJpY3MudGV4dDtcbiAgY29uc3QgZm9udFByb3BlcnRpZXMgPSBtZXRyaWNzLmZvbnRQcm9wZXJ0aWVzO1xuICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgY29udGV4dC5zY2FsZShyZXNvbHV0aW9uLCByZXNvbHV0aW9uKTtcbiAgY29uc3QgdHggPSBzdHlsZS5zdHJva2VUaGlja25lc3MgLyAyO1xuICBjb25zdCB0eSA9IC0oc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMik7XG4gIGNvbnRleHQuZm9udCA9IHN0eWxlLnRvRm9udFN0cmluZygpO1xuICBjb250ZXh0LmxpbmVXaWR0aCA9IHN0eWxlLnN0cm9rZVRoaWNrbmVzcztcbiAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmU7XG4gIGNvbnRleHQubGluZUpvaW4gPSBzdHlsZS5saW5lSm9pbjtcbiAgY29udGV4dC5taXRlckxpbWl0ID0gc3R5bGUubWl0ZXJMaW1pdDtcbiAgY29udGV4dC5maWxsU3R5bGUgPSBnZW5lcmF0ZUZpbGxTdHlsZShjYW52YXMsIGNvbnRleHQsIHN0eWxlLCByZXNvbHV0aW9uLCBbY2hhcl0sIG1ldHJpY3MpO1xuICBjb250ZXh0LnN0cm9rZVN0eWxlID0gc3R5bGUuc3Ryb2tlO1xuICBpZiAoc3R5bGUuZHJvcFNoYWRvdykge1xuICAgIGNvbnN0IGRyb3BTaGFkb3dDb2xvciA9IHN0eWxlLmRyb3BTaGFkb3dDb2xvcjtcbiAgICBjb25zdCBkcm9wU2hhZG93Qmx1ciA9IHN0eWxlLmRyb3BTaGFkb3dCbHVyICogcmVzb2x1dGlvbjtcbiAgICBjb25zdCBkcm9wU2hhZG93RGlzdGFuY2UgPSBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2UgKiByZXNvbHV0aW9uO1xuICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBDb2xvci5zaGFyZWQuc2V0VmFsdWUoZHJvcFNoYWRvd0NvbG9yKS5zZXRBbHBoYShzdHlsZS5kcm9wU2hhZG93QWxwaGEpLnRvUmdiYVN0cmluZygpO1xuICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IGRyb3BTaGFkb3dCbHVyO1xuICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IE1hdGguY29zKHN0eWxlLmRyb3BTaGFkb3dBbmdsZSkgKiBkcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gTWF0aC5zaW4oc3R5bGUuZHJvcFNoYWRvd0FuZ2xlKSAqIGRyb3BTaGFkb3dEaXN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gXCJibGFja1wiO1xuICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IDA7XG4gICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSAwO1xuICB9XG4gIGlmIChzdHlsZS5zdHJva2UgJiYgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzKSB7XG4gICAgY29udGV4dC5zdHJva2VUZXh0KGNoYXIsIHR4LCB0eSArIG1ldHJpY3MubGluZUhlaWdodCAtIGZvbnRQcm9wZXJ0aWVzLmRlc2NlbnQpO1xuICB9XG4gIGlmIChzdHlsZS5maWxsKSB7XG4gICAgY29udGV4dC5maWxsVGV4dChjaGFyLCB0eCwgdHkgKyBtZXRyaWNzLmxpbmVIZWlnaHQgLSBmb250UHJvcGVydGllcy5kZXNjZW50KTtcbiAgfVxuICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgY29udGV4dC5maWxsU3R5bGUgPSBcInJnYmEoMCwgMCwgMCwgMClcIjtcbn1cblxuZXhwb3J0IHsgZHJhd0dseXBoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcmF3R2x5cGgubWpzLm1hcFxuIiwiZXhwb3J0IHsgZHJhd0dseXBoIH0gZnJvbSAnLi9kcmF3R2x5cGgubWpzJztcbmV4cG9ydCB7IGV4dHJhY3RDaGFyQ29kZSB9IGZyb20gJy4vZXh0cmFjdENoYXJDb2RlLm1qcyc7XG5leHBvcnQgeyBnZW5lcmF0ZUZpbGxTdHlsZSB9IGZyb20gJy4vZ2VuZXJhdGVGaWxsU3R5bGUubWpzJztcbmV4cG9ydCB7IHJlc29sdmVDaGFyYWN0ZXJzIH0gZnJvbSAnLi9yZXNvbHZlQ2hhcmFjdGVycy5tanMnO1xuZXhwb3J0IHsgc3BsaXRUZXh0VG9DaGFyYWN0ZXJzIH0gZnJvbSAnLi9zcGxpdFRleHRUb0NoYXJhY3RlcnMubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImZ1bmN0aW9uIHNwbGl0VGV4dFRvQ2hhcmFjdGVycyh0ZXh0KSB7XG4gIHJldHVybiBBcnJheS5mcm9tID8gQXJyYXkuZnJvbSh0ZXh0KSA6IHRleHQuc3BsaXQoXCJcIik7XG59XG5cbmV4cG9ydCB7IHNwbGl0VGV4dFRvQ2hhcmFjdGVycyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3BsaXRUZXh0VG9DaGFyYWN0ZXJzLm1qcy5tYXBcbiIsImltcG9ydCB7IHNwbGl0VGV4dFRvQ2hhcmFjdGVycyB9IGZyb20gJy4vc3BsaXRUZXh0VG9DaGFyYWN0ZXJzLm1qcyc7XG5cbmZ1bmN0aW9uIHJlc29sdmVDaGFyYWN0ZXJzKGNoYXJzKSB7XG4gIGlmICh0eXBlb2YgY2hhcnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjaGFycyA9IFtjaGFyc107XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBqID0gY2hhcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgY29uc3QgaXRlbSA9IGNoYXJzW2ldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICBpZiAoaXRlbS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbQml0bWFwRm9udF06IEludmFsaWQgY2hhcmFjdGVyIHJhbmdlIGxlbmd0aCwgZXhwZWN0aW5nIDIgZ290ICR7aXRlbS5sZW5ndGh9LmApO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnRDb2RlID0gaXRlbVswXS5jaGFyQ29kZUF0KDApO1xuICAgICAgY29uc3QgZW5kQ29kZSA9IGl0ZW1bMV0uY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmIChlbmRDb2RlIDwgc3RhcnRDb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIltCaXRtYXBGb250XTogSW52YWxpZCBjaGFyYWN0ZXIgcmFuZ2UuXCIpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaTIgPSBzdGFydENvZGUsIGoyID0gZW5kQ29kZTsgaTIgPD0gajI7IGkyKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShpMikpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaCguLi5zcGxpdFRleHRUb0NoYXJhY3RlcnMoaXRlbSkpO1xuICAgIH1cbiAgfVxuICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIltCaXRtYXBGb250XTogRW1wdHkgc2V0IHdoZW4gcmVzb2x2aW5nIGNoYXJhY3RlcnMuXCIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IHJlc29sdmVDaGFyYWN0ZXJzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlQ2hhcmFjdGVycy5tanMubWFwXG4iLCJmdW5jdGlvbiBleHRyYWN0Q2hhckNvZGUoc3RyKSB7XG4gIHJldHVybiBzdHIuY29kZVBvaW50QXQgPyBzdHIuY29kZVBvaW50QXQoMCkgOiBzdHIuY2hhckNvZGVBdCgwKTtcbn1cblxuZXhwb3J0IHsgZXh0cmFjdENoYXJDb2RlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRyYWN0Q2hhckNvZGUubWpzLm1hcFxuIiwiaW1wb3J0IHsgdXRpbHMsIEFMUEhBX01PREVTLCBNSVBNQVBfTU9ERVMsIFJlY3RhbmdsZSwgVGV4dHVyZSwgc2V0dGluZ3MsIEJhc2VUZXh0dXJlIH0gZnJvbSAnQHBpeGkvY29yZSc7XG5pbXBvcnQgeyBUZXh0U3R5bGUsIFRleHRNZXRyaWNzIH0gZnJvbSAnQHBpeGkvdGV4dCc7XG5pbXBvcnQgeyBCaXRtYXBGb250RGF0YSB9IGZyb20gJy4vQml0bWFwRm9udERhdGEubWpzJztcbmltcG9ydCB7IGF1dG9EZXRlY3RGb3JtYXQgfSBmcm9tICcuL2Zvcm1hdHMvaW5kZXgubWpzJztcbmltcG9ydCAnLi91dGlscy9pbmRleC5tanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUNoYXJhY3RlcnMgfSBmcm9tICcuL3V0aWxzL3Jlc29sdmVDaGFyYWN0ZXJzLm1qcyc7XG5pbXBvcnQgeyBkcmF3R2x5cGggfSBmcm9tICcuL3V0aWxzL2RyYXdHbHlwaC5tanMnO1xuaW1wb3J0IHsgZXh0cmFjdENoYXJDb2RlIH0gZnJvbSAnLi91dGlscy9leHRyYWN0Q2hhckNvZGUubWpzJztcblxuY29uc3QgX0JpdG1hcEZvbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIHRleHR1cmVzLCBvd25zVGV4dHVyZXMpIHtcbiAgICBjb25zdCBbaW5mb10gPSBkYXRhLmluZm87XG4gICAgY29uc3QgW2NvbW1vbl0gPSBkYXRhLmNvbW1vbjtcbiAgICBjb25zdCBbcGFnZV0gPSBkYXRhLnBhZ2U7XG4gICAgY29uc3QgW2Rpc3RhbmNlRmllbGRdID0gZGF0YS5kaXN0YW5jZUZpZWxkO1xuICAgIGNvbnN0IHJlcyA9IHV0aWxzLmdldFJlc29sdXRpb25PZlVybChwYWdlLmZpbGUpO1xuICAgIGNvbnN0IHBhZ2VUZXh0dXJlcyA9IHt9O1xuICAgIHRoaXMuX293bnNUZXh0dXJlcyA9IG93bnNUZXh0dXJlcztcbiAgICB0aGlzLmZvbnQgPSBpbmZvLmZhY2U7XG4gICAgdGhpcy5zaXplID0gaW5mby5zaXplO1xuICAgIHRoaXMubGluZUhlaWdodCA9IGNvbW1vbi5saW5lSGVpZ2h0IC8gcmVzO1xuICAgIHRoaXMuY2hhcnMgPSB7fTtcbiAgICB0aGlzLnBhZ2VUZXh0dXJlcyA9IHBhZ2VUZXh0dXJlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEucGFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgeyBpZCwgZmlsZSB9ID0gZGF0YS5wYWdlW2ldO1xuICAgICAgcGFnZVRleHR1cmVzW2lkXSA9IHRleHR1cmVzIGluc3RhbmNlb2YgQXJyYXkgPyB0ZXh0dXJlc1tpXSA6IHRleHR1cmVzW2ZpbGVdO1xuICAgICAgaWYgKGRpc3RhbmNlRmllbGQ/LmZpZWxkVHlwZSAmJiBkaXN0YW5jZUZpZWxkLmZpZWxkVHlwZSAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgcGFnZVRleHR1cmVzW2lkXS5iYXNlVGV4dHVyZS5hbHBoYU1vZGUgPSBBTFBIQV9NT0RFUy5OT19QUkVNVUxUSVBMSUVEX0FMUEhBO1xuICAgICAgICBwYWdlVGV4dHVyZXNbaWRdLmJhc2VUZXh0dXJlLm1pcG1hcCA9IE1JUE1BUF9NT0RFUy5PRkY7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5jaGFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB7IGlkLCBwYWdlOiBwYWdlMiB9ID0gZGF0YS5jaGFyW2ldO1xuICAgICAgbGV0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCwgeG9mZnNldCwgeW9mZnNldCwgeGFkdmFuY2UgfSA9IGRhdGEuY2hhcltpXTtcbiAgICAgIHggLz0gcmVzO1xuICAgICAgeSAvPSByZXM7XG4gICAgICB3aWR0aCAvPSByZXM7XG4gICAgICBoZWlnaHQgLz0gcmVzO1xuICAgICAgeG9mZnNldCAvPSByZXM7XG4gICAgICB5b2Zmc2V0IC89IHJlcztcbiAgICAgIHhhZHZhbmNlIC89IHJlcztcbiAgICAgIGNvbnN0IHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHggKyBwYWdlVGV4dHVyZXNbcGFnZTJdLmZyYW1lLnggLyByZXMsIHkgKyBwYWdlVGV4dHVyZXNbcGFnZTJdLmZyYW1lLnkgLyByZXMsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5jaGFyc1tpZF0gPSB7XG4gICAgICAgIHhPZmZzZXQ6IHhvZmZzZXQsXG4gICAgICAgIHlPZmZzZXQ6IHlvZmZzZXQsXG4gICAgICAgIHhBZHZhbmNlOiB4YWR2YW5jZSxcbiAgICAgICAga2VybmluZzoge30sXG4gICAgICAgIHRleHR1cmU6IG5ldyBUZXh0dXJlKHBhZ2VUZXh0dXJlc1twYWdlMl0uYmFzZVRleHR1cmUsIHJlY3QpLFxuICAgICAgICBwYWdlOiBwYWdlMlxuICAgICAgfTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmtlcm5pbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCB7IGZpcnN0LCBzZWNvbmQsIGFtb3VudCB9ID0gZGF0YS5rZXJuaW5nW2ldO1xuICAgICAgZmlyc3QgLz0gcmVzO1xuICAgICAgc2Vjb25kIC89IHJlcztcbiAgICAgIGFtb3VudCAvPSByZXM7XG4gICAgICBpZiAodGhpcy5jaGFyc1tzZWNvbmRdKSB7XG4gICAgICAgIHRoaXMuY2hhcnNbc2Vjb25kXS5rZXJuaW5nW2ZpcnN0XSA9IGFtb3VudDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kaXN0YW5jZUZpZWxkUmFuZ2UgPSBkaXN0YW5jZUZpZWxkPy5kaXN0YW5jZVJhbmdlO1xuICAgIHRoaXMuZGlzdGFuY2VGaWVsZFR5cGUgPSBkaXN0YW5jZUZpZWxkPy5maWVsZFR5cGU/LnRvTG93ZXJDYXNlKCkgPz8gXCJub25lXCI7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMuY2hhcnMpIHtcbiAgICAgIHRoaXMuY2hhcnNbaWRdLnRleHR1cmUuZGVzdHJveSgpO1xuICAgICAgdGhpcy5jaGFyc1tpZF0udGV4dHVyZSA9IG51bGw7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaWQgaW4gdGhpcy5wYWdlVGV4dHVyZXMpIHtcbiAgICAgIGlmICh0aGlzLl9vd25zVGV4dHVyZXMpIHtcbiAgICAgICAgdGhpcy5wYWdlVGV4dHVyZXNbaWRdLmRlc3Ryb3kodHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnBhZ2VUZXh0dXJlc1tpZF0gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmNoYXJzID0gbnVsbDtcbiAgICB0aGlzLnBhZ2VUZXh0dXJlcyA9IG51bGw7XG4gIH1cbiAgc3RhdGljIGluc3RhbGwoZGF0YSwgdGV4dHVyZXMsIG93bnNUZXh0dXJlcykge1xuICAgIGxldCBmb250RGF0YTtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEJpdG1hcEZvbnREYXRhKSB7XG4gICAgICBmb250RGF0YSA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IGF1dG9EZXRlY3RGb3JtYXQoZGF0YSk7XG4gICAgICBpZiAoIWZvcm1hdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgZGF0YSBmb3JtYXQgZm9yIGZvbnQuXCIpO1xuICAgICAgfVxuICAgICAgZm9udERhdGEgPSBmb3JtYXQucGFyc2UoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0ZXh0dXJlcyBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgIHRleHR1cmVzID0gW3RleHR1cmVzXTtcbiAgICB9XG4gICAgY29uc3QgZm9udCA9IG5ldyBfQml0bWFwRm9udChmb250RGF0YSwgdGV4dHVyZXMsIG93bnNUZXh0dXJlcyk7XG4gICAgX0JpdG1hcEZvbnQuYXZhaWxhYmxlW2ZvbnQuZm9udF0gPSBmb250O1xuICAgIHJldHVybiBmb250O1xuICB9XG4gIHN0YXRpYyB1bmluc3RhbGwobmFtZSkge1xuICAgIGNvbnN0IGZvbnQgPSBfQml0bWFwRm9udC5hdmFpbGFibGVbbmFtZV07XG4gICAgaWYgKCFmb250KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGZvbnQgZm91bmQgbmFtZWQgJyR7bmFtZX0nYCk7XG4gICAgfVxuICAgIGZvbnQuZGVzdHJveSgpO1xuICAgIGRlbGV0ZSBfQml0bWFwRm9udC5hdmFpbGFibGVbbmFtZV07XG4gIH1cbiAgc3RhdGljIGZyb20obmFtZSwgdGV4dFN0eWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbQml0bWFwRm9udF0gUHJvcGVydHkgYG5hbWVgIGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY2hhcnMsXG4gICAgICBwYWRkaW5nLFxuICAgICAgcmVzb2x1dGlvbixcbiAgICAgIHRleHR1cmVXaWR0aCxcbiAgICAgIHRleHR1cmVIZWlnaHQsXG4gICAgICAuLi5iYXNlT3B0aW9uc1xuICAgIH0gPSBPYmplY3QuYXNzaWduKHt9LCBfQml0bWFwRm9udC5kZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgY29uc3QgY2hhcnNMaXN0ID0gcmVzb2x2ZUNoYXJhY3RlcnMoY2hhcnMpO1xuICAgIGNvbnN0IHN0eWxlID0gdGV4dFN0eWxlIGluc3RhbmNlb2YgVGV4dFN0eWxlID8gdGV4dFN0eWxlIDogbmV3IFRleHRTdHlsZSh0ZXh0U3R5bGUpO1xuICAgIGNvbnN0IGxpbmVXaWR0aCA9IHRleHR1cmVXaWR0aDtcbiAgICBjb25zdCBmb250RGF0YSA9IG5ldyBCaXRtYXBGb250RGF0YSgpO1xuICAgIGZvbnREYXRhLmluZm9bMF0gPSB7XG4gICAgICBmYWNlOiBzdHlsZS5mb250RmFtaWx5LFxuICAgICAgc2l6ZTogc3R5bGUuZm9udFNpemVcbiAgICB9O1xuICAgIGZvbnREYXRhLmNvbW1vblswXSA9IHtcbiAgICAgIGxpbmVIZWlnaHQ6IHN0eWxlLmZvbnRTaXplXG4gICAgfTtcbiAgICBsZXQgcG9zaXRpb25YID0gMDtcbiAgICBsZXQgcG9zaXRpb25ZID0gMDtcbiAgICBsZXQgY2FudmFzO1xuICAgIGxldCBjb250ZXh0O1xuICAgIGxldCBiYXNlVGV4dHVyZTtcbiAgICBsZXQgbWF4Q2hhckhlaWdodCA9IDA7XG4gICAgY29uc3QgYmFzZVRleHR1cmVzID0gW107XG4gICAgY29uc3QgdGV4dHVyZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgY2FudmFzID0gc2V0dGluZ3MuQURBUFRFUi5jcmVhdGVDYW52YXMoKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gdGV4dHVyZVdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGV4dHVyZUhlaWdodDtcbiAgICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIGJhc2VUZXh0dXJlID0gbmV3IEJhc2VUZXh0dXJlKGNhbnZhcywgeyByZXNvbHV0aW9uLCAuLi5iYXNlT3B0aW9ucyB9KTtcbiAgICAgICAgYmFzZVRleHR1cmVzLnB1c2goYmFzZVRleHR1cmUpO1xuICAgICAgICB0ZXh0dXJlcy5wdXNoKG5ldyBUZXh0dXJlKGJhc2VUZXh0dXJlKSk7XG4gICAgICAgIGZvbnREYXRhLnBhZ2UucHVzaCh7XG4gICAgICAgICAgaWQ6IHRleHR1cmVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgZmlsZTogXCJcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYXJhY3RlciA9IGNoYXJzTGlzdFtpXTtcbiAgICAgIGNvbnN0IG1ldHJpY3MgPSBUZXh0TWV0cmljcy5tZWFzdXJlVGV4dChjaGFyYWN0ZXIsIHN0eWxlLCBmYWxzZSwgY2FudmFzKTtcbiAgICAgIGNvbnN0IHdpZHRoID0gbWV0cmljcy53aWR0aDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguY2VpbChtZXRyaWNzLmhlaWdodCk7XG4gICAgICBjb25zdCB0ZXh0dXJlR2x5cGhXaWR0aCA9IE1hdGguY2VpbCgoc3R5bGUuZm9udFN0eWxlID09PSBcIml0YWxpY1wiID8gMiA6IDEpICogd2lkdGgpO1xuICAgICAgaWYgKHBvc2l0aW9uWSA+PSB0ZXh0dXJlSGVpZ2h0IC0gaGVpZ2h0ICogcmVzb2x1dGlvbikge1xuICAgICAgICBpZiAocG9zaXRpb25ZID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbQml0bWFwRm9udF0gdGV4dHVyZUhlaWdodCAke3RleHR1cmVIZWlnaHR9cHggaXMgdG9vIHNtYWxsIChmb250RmFtaWx5OiAnJHtzdHlsZS5mb250RmFtaWx5fScsIGZvbnRTaXplOiAke3N0eWxlLmZvbnRTaXplfXB4LCBjaGFyOiAnJHtjaGFyYWN0ZXJ9JylgKTtcbiAgICAgICAgfVxuICAgICAgICAtLWk7XG4gICAgICAgIGNhbnZhcyA9IG51bGw7XG4gICAgICAgIGNvbnRleHQgPSBudWxsO1xuICAgICAgICBiYXNlVGV4dHVyZSA9IG51bGw7XG4gICAgICAgIHBvc2l0aW9uWSA9IDA7XG4gICAgICAgIHBvc2l0aW9uWCA9IDA7XG4gICAgICAgIG1heENoYXJIZWlnaHQgPSAwO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG1heENoYXJIZWlnaHQgPSBNYXRoLm1heChoZWlnaHQgKyBtZXRyaWNzLmZvbnRQcm9wZXJ0aWVzLmRlc2NlbnQsIG1heENoYXJIZWlnaHQpO1xuICAgICAgaWYgKHRleHR1cmVHbHlwaFdpZHRoICogcmVzb2x1dGlvbiArIHBvc2l0aW9uWCA+PSBsaW5lV2lkdGgpIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uWCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgW0JpdG1hcEZvbnRdIHRleHR1cmVXaWR0aCAke3RleHR1cmVXaWR0aH1weCBpcyB0b28gc21hbGwgKGZvbnRGYW1pbHk6ICcke3N0eWxlLmZvbnRGYW1pbHl9JywgZm9udFNpemU6ICR7c3R5bGUuZm9udFNpemV9cHgsIGNoYXI6ICcke2NoYXJhY3Rlcn0nKWApO1xuICAgICAgICB9XG4gICAgICAgIC0taTtcbiAgICAgICAgcG9zaXRpb25ZICs9IG1heENoYXJIZWlnaHQgKiByZXNvbHV0aW9uO1xuICAgICAgICBwb3NpdGlvblkgPSBNYXRoLmNlaWwocG9zaXRpb25ZKTtcbiAgICAgICAgcG9zaXRpb25YID0gMDtcbiAgICAgICAgbWF4Q2hhckhlaWdodCA9IDA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZHJhd0dseXBoKGNhbnZhcywgY29udGV4dCwgbWV0cmljcywgcG9zaXRpb25YLCBwb3NpdGlvblksIHJlc29sdXRpb24sIHN0eWxlKTtcbiAgICAgIGNvbnN0IGlkID0gZXh0cmFjdENoYXJDb2RlKG1ldHJpY3MudGV4dCk7XG4gICAgICBmb250RGF0YS5jaGFyLnB1c2goe1xuICAgICAgICBpZCxcbiAgICAgICAgcGFnZTogdGV4dHVyZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgeDogcG9zaXRpb25YIC8gcmVzb2x1dGlvbixcbiAgICAgICAgeTogcG9zaXRpb25ZIC8gcmVzb2x1dGlvbixcbiAgICAgICAgd2lkdGg6IHRleHR1cmVHbHlwaFdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHhvZmZzZXQ6IDAsXG4gICAgICAgIHlvZmZzZXQ6IDAsXG4gICAgICAgIHhhZHZhbmNlOiB3aWR0aCAtIChzdHlsZS5kcm9wU2hhZG93ID8gc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlIDogMCkgLSAoc3R5bGUuc3Ryb2tlID8gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIDogMClcbiAgICAgIH0pO1xuICAgICAgcG9zaXRpb25YICs9ICh0ZXh0dXJlR2x5cGhXaWR0aCArIDIgKiBwYWRkaW5nKSAqIHJlc29sdXRpb247XG4gICAgICBwb3NpdGlvblggPSBNYXRoLmNlaWwocG9zaXRpb25YKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNoYXJzTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgZmlyc3QgPSBjaGFyc0xpc3RbaV07XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIGNvbnN0IHNlY29uZCA9IGNoYXJzTGlzdFtqXTtcbiAgICAgICAgY29uc3QgYzEgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGZpcnN0KS53aWR0aDtcbiAgICAgICAgY29uc3QgYzIgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHNlY29uZCkud2lkdGg7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gY29udGV4dC5tZWFzdXJlVGV4dChmaXJzdCArIHNlY29uZCkud2lkdGg7XG4gICAgICAgIGNvbnN0IGFtb3VudCA9IHRvdGFsIC0gKGMxICsgYzIpO1xuICAgICAgICBpZiAoYW1vdW50KSB7XG4gICAgICAgICAgZm9udERhdGEua2VybmluZy5wdXNoKHtcbiAgICAgICAgICAgIGZpcnN0OiBleHRyYWN0Q2hhckNvZGUoZmlyc3QpLFxuICAgICAgICAgICAgc2Vjb25kOiBleHRyYWN0Q2hhckNvZGUoc2Vjb25kKSxcbiAgICAgICAgICAgIGFtb3VudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZvbnQgPSBuZXcgX0JpdG1hcEZvbnQoZm9udERhdGEsIHRleHR1cmVzLCB0cnVlKTtcbiAgICBpZiAoX0JpdG1hcEZvbnQuYXZhaWxhYmxlW25hbWVdICE9PSB2b2lkIDApIHtcbiAgICAgIF9CaXRtYXBGb250LnVuaW5zdGFsbChuYW1lKTtcbiAgICB9XG4gICAgX0JpdG1hcEZvbnQuYXZhaWxhYmxlW25hbWVdID0gZm9udDtcbiAgICByZXR1cm4gZm9udDtcbiAgfVxufTtcbmxldCBCaXRtYXBGb250ID0gX0JpdG1hcEZvbnQ7XG5CaXRtYXBGb250LkFMUEhBID0gW1tcImFcIiwgXCJ6XCJdLCBbXCJBXCIsIFwiWlwiXSwgXCIgXCJdO1xuQml0bWFwRm9udC5OVU1FUklDID0gW1tcIjBcIiwgXCI5XCJdXTtcbkJpdG1hcEZvbnQuQUxQSEFOVU1FUklDID0gW1tcImFcIiwgXCJ6XCJdLCBbXCJBXCIsIFwiWlwiXSwgW1wiMFwiLCBcIjlcIl0sIFwiIFwiXTtcbkJpdG1hcEZvbnQuQVNDSUkgPSBbW1wiIFwiLCBcIn5cIl1dO1xuQml0bWFwRm9udC5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgcmVzb2x1dGlvbjogMSxcbiAgdGV4dHVyZVdpZHRoOiA1MTIsXG4gIHRleHR1cmVIZWlnaHQ6IDUxMixcbiAgcGFkZGluZzogNCxcbiAgY2hhcnM6IF9CaXRtYXBGb250LkFMUEhBTlVNRVJJQ1xufTtcbkJpdG1hcEZvbnQuYXZhaWxhYmxlID0ge307XG5cbmV4cG9ydCB7IEJpdG1hcEZvbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJpdG1hcEZvbnQubWpzLm1hcFxuIiwidmFyIG1zZGZGcmFnID0gXCIvLyBQaXhpIHRleHR1cmUgaW5mb1xcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcblxcclxcbi8vIFRpbnRcXHJcXG51bmlmb3JtIHZlYzQgdUNvbG9yO1xcclxcblxcclxcbi8vIG9uIDJEIGFwcGxpY2F0aW9ucyBmd2lkdGggaXMgc2NyZWVuU2NhbGUgLyBnbHlwaEF0bGFzU2NhbGUgKiBkaXN0YW5jZUZpZWxkUmFuZ2VcXHJcXG51bmlmb3JtIGZsb2F0IHVGV2lkdGg7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpIHtcXHJcXG5cXHJcXG4gIC8vIFRvIHN0YWNrIE1TREYgYW5kIFNERiB3ZSBuZWVkIGEgbm9uLXByZS1tdWx0aXBsaWVkLWFscGhhIHRleHR1cmUuXFxyXFxuICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXHJcXG5cXHJcXG4gIC8vIE1TREZcXHJcXG4gIGZsb2F0IG1lZGlhbiA9IHRleENvbG9yLnIgKyB0ZXhDb2xvci5nICsgdGV4Q29sb3IuYiAtXFxyXFxuICAgICAgICAgICAgICAgICAgbWluKHRleENvbG9yLnIsIG1pbih0ZXhDb2xvci5nLCB0ZXhDb2xvci5iKSkgLVxcclxcbiAgICAgICAgICAgICAgICAgIG1heCh0ZXhDb2xvci5yLCBtYXgodGV4Q29sb3IuZywgdGV4Q29sb3IuYikpO1xcclxcbiAgLy8gU0RGXFxyXFxuICBtZWRpYW4gPSBtaW4obWVkaWFuLCB0ZXhDb2xvci5hKTtcXHJcXG5cXHJcXG4gIGZsb2F0IHNjcmVlblB4RGlzdGFuY2UgPSB1RldpZHRoICogKG1lZGlhbiAtIDAuNSk7XFxyXFxuICBmbG9hdCBhbHBoYSA9IGNsYW1wKHNjcmVlblB4RGlzdGFuY2UgKyAwLjUsIDAuMCwgMS4wKTtcXHJcXG4gIGlmIChtZWRpYW4gPCAwLjAxKSB7XFxyXFxuICAgIGFscGhhID0gMC4wO1xcclxcbiAgfSBlbHNlIGlmIChtZWRpYW4gPiAwLjk5KSB7XFxyXFxuICAgIGFscGhhID0gMS4wO1xcclxcbiAgfVxcclxcblxcclxcbiAgLy8gR2FtbWEgY29ycmVjdGlvbiBmb3IgY292ZXJhZ2UtbGlrZSBhbHBoYVxcclxcbiAgZmxvYXQgbHVtYSA9IGRvdCh1Q29sb3IucmdiLCB2ZWMzKDAuMjk5LCAwLjU4NywgMC4xMTQpKTtcXHJcXG4gIGZsb2F0IGdhbW1hID0gbWl4KDEuMCwgMS4wIC8gMi4yLCBsdW1hKTtcXHJcXG4gIGZsb2F0IGNvdmVyYWdlID0gcG93KHVDb2xvci5hICogYWxwaGEsIGdhbW1hKTsgIFxcclxcblxcclxcbiAgLy8gTlBNIFRleHR1cmVzLCBOUE0gb3V0cHV0c1xcclxcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh1Q29sb3IucmdiLCBjb3ZlcmFnZSk7XFxyXFxufVxcclxcblwiO1xuXG5leHBvcnQgeyBtc2RmRnJhZyBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tc2RmLm1qcy5tYXBcbiIsInZhciBtc2RmVmVydCA9IFwiLy8gTWVzaCBtYXRlcmlhbCBkZWZhdWx0IGZyYWdtZW50XFxyXFxuYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcclxcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxyXFxuXFxyXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxyXFxudW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xcclxcbnVuaWZvcm0gbWF0MyB1VGV4dHVyZU1hdHJpeDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxyXFxuXFxyXFxuICAgIHZUZXh0dXJlQ29vcmQgPSAodVRleHR1cmVNYXRyaXggKiB2ZWMzKGFUZXh0dXJlQ29vcmQsIDEuMCkpLnh5O1xcclxcbn1cXHJcXG5cIjtcblxuZXhwb3J0IHsgbXNkZlZlcnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXNkZjIubWpzLm1hcFxuIiwiaW1wb3J0IHsgQ29sb3IsIE9ic2VydmFibGVQb2ludCwgc2V0dGluZ3MsIFBvaW50LCBUZXh0dXJlLCB1dGlscywgQkxFTkRfTU9ERVMsIFByb2dyYW0gfSBmcm9tICdAcGl4aS9jb3JlJztcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gJ0BwaXhpL2Rpc3BsYXknO1xuaW1wb3J0IHsgTWVzaEdlb21ldHJ5LCBNZXNoTWF0ZXJpYWwsIE1lc2ggfSBmcm9tICdAcGl4aS9tZXNoJztcbmltcG9ydCB7IEJpdG1hcEZvbnQgfSBmcm9tICcuL0JpdG1hcEZvbnQubWpzJztcbmltcG9ydCBtc2RmRnJhZyBmcm9tICcuL3NoYWRlci9tc2RmLm1qcyc7XG5pbXBvcnQgbXNkZlZlcnQgZnJvbSAnLi9zaGFkZXIvbXNkZjIubWpzJztcbmltcG9ydCAnLi91dGlscy9pbmRleC5tanMnO1xuaW1wb3J0IHsgc3BsaXRUZXh0VG9DaGFyYWN0ZXJzIH0gZnJvbSAnLi91dGlscy9zcGxpdFRleHRUb0NoYXJhY3RlcnMubWpzJztcbmltcG9ydCB7IGV4dHJhY3RDaGFyQ29kZSB9IGZyb20gJy4vdXRpbHMvZXh0cmFjdENoYXJDb2RlLm1qcyc7XG5cbmNvbnN0IHBhZ2VNZXNoRGF0YURlZmF1bHRQYWdlTWVzaERhdGEgPSBbXTtcbmNvbnN0IHBhZ2VNZXNoRGF0YU1TREZQYWdlTWVzaERhdGEgPSBbXTtcbmNvbnN0IGNoYXJSZW5kZXJEYXRhUG9vbCA9IFtdO1xuY29uc3QgX0JpdG1hcFRleHQgPSBjbGFzcyBleHRlbmRzIENvbnRhaW5lciB7XG4gIGNvbnN0cnVjdG9yKHRleHQsIHN0eWxlID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHsgYWxpZ24sIHRpbnQsIG1heFdpZHRoLCBsZXR0ZXJTcGFjaW5nLCBmb250TmFtZSwgZm9udFNpemUgfSA9IE9iamVjdC5hc3NpZ24oe30sIF9CaXRtYXBUZXh0LnN0eWxlRGVmYXVsdHMsIHN0eWxlKTtcbiAgICBpZiAoIUJpdG1hcEZvbnQuYXZhaWxhYmxlW2ZvbnROYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIEJpdG1hcEZvbnQgXCIke2ZvbnROYW1lfVwiYCk7XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZVBhZ2VzTWVzaERhdGEgPSBbXTtcbiAgICB0aGlzLl90ZXh0V2lkdGggPSAwO1xuICAgIHRoaXMuX3RleHRIZWlnaHQgPSAwO1xuICAgIHRoaXMuX2FsaWduID0gYWxpZ247XG4gICAgdGhpcy5fdGludENvbG9yID0gbmV3IENvbG9yKHRpbnQpO1xuICAgIHRoaXMuX2ZvbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5fZm9udE5hbWUgPSBmb250TmFtZTtcbiAgICB0aGlzLl9mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5fbWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICB0aGlzLl9tYXhMaW5lSGVpZ2h0ID0gMDtcbiAgICB0aGlzLl9sZXR0ZXJTcGFjaW5nID0gbGV0dGVyU3BhY2luZztcbiAgICB0aGlzLl9hbmNob3IgPSBuZXcgT2JzZXJ2YWJsZVBvaW50KCgpID0+IHtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH0sIHRoaXMsIDAsIDApO1xuICAgIHRoaXMuX3JvdW5kUGl4ZWxzID0gc2V0dGluZ3MuUk9VTkRfUElYRUxTO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX3Jlc29sdXRpb24gPSBzZXR0aW5ncy5SRVNPTFVUSU9OO1xuICAgIHRoaXMuX2F1dG9SZXNvbHV0aW9uID0gdHJ1ZTtcbiAgICB0aGlzLl90ZXh0dXJlQ2FjaGUgPSB7fTtcbiAgfVxuICB1cGRhdGVUZXh0KCkge1xuICAgIGNvbnN0IGRhdGEgPSBCaXRtYXBGb250LmF2YWlsYWJsZVt0aGlzLl9mb250TmFtZV07XG4gICAgY29uc3QgZm9udFNpemUgPSB0aGlzLmZvbnRTaXplO1xuICAgIGNvbnN0IHNjYWxlID0gZm9udFNpemUgLyBkYXRhLnNpemU7XG4gICAgY29uc3QgcG9zID0gbmV3IFBvaW50KCk7XG4gICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICBjb25zdCBsaW5lV2lkdGhzID0gW107XG4gICAgY29uc3QgbGluZVNwYWNlcyA9IFtdO1xuICAgIGNvbnN0IHRleHQgPSB0aGlzLl90ZXh0LnJlcGxhY2UoLyg/OlxcclxcbnxcXHIpL2csIFwiXFxuXCIpIHx8IFwiIFwiO1xuICAgIGNvbnN0IGNoYXJzSW5wdXQgPSBzcGxpdFRleHRUb0NoYXJhY3RlcnModGV4dCk7XG4gICAgY29uc3QgbWF4V2lkdGggPSB0aGlzLl9tYXhXaWR0aCAqIGRhdGEuc2l6ZSAvIGZvbnRTaXplO1xuICAgIGNvbnN0IHBhZ2VNZXNoRGF0YVBvb2wgPSBkYXRhLmRpc3RhbmNlRmllbGRUeXBlID09PSBcIm5vbmVcIiA/IHBhZ2VNZXNoRGF0YURlZmF1bHRQYWdlTWVzaERhdGEgOiBwYWdlTWVzaERhdGFNU0RGUGFnZU1lc2hEYXRhO1xuICAgIGxldCBwcmV2Q2hhckNvZGUgPSBudWxsO1xuICAgIGxldCBsYXN0TGluZVdpZHRoID0gMDtcbiAgICBsZXQgbWF4TGluZVdpZHRoID0gMDtcbiAgICBsZXQgbGluZSA9IDA7XG4gICAgbGV0IGxhc3RCcmVha1BvcyA9IC0xO1xuICAgIGxldCBsYXN0QnJlYWtXaWR0aCA9IDA7XG4gICAgbGV0IHNwYWNlc1JlbW92ZWQgPSAwO1xuICAgIGxldCBtYXhMaW5lSGVpZ2h0ID0gMDtcbiAgICBsZXQgc3BhY2VDb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFyc0lucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyID0gY2hhcnNJbnB1dFtpXTtcbiAgICAgIGNvbnN0IGNoYXJDb2RlID0gZXh0cmFjdENoYXJDb2RlKGNoYXIpO1xuICAgICAgaWYgKC8oPzpcXHMpLy50ZXN0KGNoYXIpKSB7XG4gICAgICAgIGxhc3RCcmVha1BvcyA9IGk7XG4gICAgICAgIGxhc3RCcmVha1dpZHRoID0gbGFzdExpbmVXaWR0aDtcbiAgICAgICAgc3BhY2VDb3VudCsrO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXIgPT09IFwiXFxyXCIgfHwgY2hhciA9PT0gXCJcXG5cIikge1xuICAgICAgICBsaW5lV2lkdGhzLnB1c2gobGFzdExpbmVXaWR0aCk7XG4gICAgICAgIGxpbmVTcGFjZXMucHVzaCgtMSk7XG4gICAgICAgIG1heExpbmVXaWR0aCA9IE1hdGgubWF4KG1heExpbmVXaWR0aCwgbGFzdExpbmVXaWR0aCk7XG4gICAgICAgICsrbGluZTtcbiAgICAgICAgKytzcGFjZXNSZW1vdmVkO1xuICAgICAgICBwb3MueCA9IDA7XG4gICAgICAgIHBvcy55ICs9IGRhdGEubGluZUhlaWdodDtcbiAgICAgICAgcHJldkNoYXJDb2RlID0gbnVsbDtcbiAgICAgICAgc3BhY2VDb3VudCA9IDA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hhckRhdGEgPSBkYXRhLmNoYXJzW2NoYXJDb2RlXTtcbiAgICAgIGlmICghY2hhckRhdGEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJldkNoYXJDb2RlICYmIGNoYXJEYXRhLmtlcm5pbmdbcHJldkNoYXJDb2RlXSkge1xuICAgICAgICBwb3MueCArPSBjaGFyRGF0YS5rZXJuaW5nW3ByZXZDaGFyQ29kZV07XG4gICAgICB9XG4gICAgICBjb25zdCBjaGFyUmVuZGVyRGF0YSA9IGNoYXJSZW5kZXJEYXRhUG9vbC5wb3AoKSB8fCB7XG4gICAgICAgIHRleHR1cmU6IFRleHR1cmUuRU1QVFksXG4gICAgICAgIGxpbmU6IDAsXG4gICAgICAgIGNoYXJDb2RlOiAwLFxuICAgICAgICBwcmV2U3BhY2VzOiAwLFxuICAgICAgICBwb3NpdGlvbjogbmV3IFBvaW50KClcbiAgICAgIH07XG4gICAgICBjaGFyUmVuZGVyRGF0YS50ZXh0dXJlID0gY2hhckRhdGEudGV4dHVyZTtcbiAgICAgIGNoYXJSZW5kZXJEYXRhLmxpbmUgPSBsaW5lO1xuICAgICAgY2hhclJlbmRlckRhdGEuY2hhckNvZGUgPSBjaGFyQ29kZTtcbiAgICAgIGNoYXJSZW5kZXJEYXRhLnBvc2l0aW9uLnggPSBNYXRoLnJvdW5kKHBvcy54ICsgY2hhckRhdGEueE9mZnNldCArIHRoaXMuX2xldHRlclNwYWNpbmcgLyAyKTtcbiAgICAgIGNoYXJSZW5kZXJEYXRhLnBvc2l0aW9uLnkgPSBNYXRoLnJvdW5kKHBvcy55ICsgY2hhckRhdGEueU9mZnNldCk7XG4gICAgICBjaGFyUmVuZGVyRGF0YS5wcmV2U3BhY2VzID0gc3BhY2VDb3VudDtcbiAgICAgIGNoYXJzLnB1c2goY2hhclJlbmRlckRhdGEpO1xuICAgICAgbGFzdExpbmVXaWR0aCA9IGNoYXJSZW5kZXJEYXRhLnBvc2l0aW9uLnggKyBNYXRoLm1heChjaGFyRGF0YS54QWR2YW5jZSAtIGNoYXJEYXRhLnhPZmZzZXQsIGNoYXJEYXRhLnRleHR1cmUub3JpZy53aWR0aCk7XG4gICAgICBwb3MueCArPSBjaGFyRGF0YS54QWR2YW5jZSArIHRoaXMuX2xldHRlclNwYWNpbmc7XG4gICAgICBtYXhMaW5lSGVpZ2h0ID0gTWF0aC5tYXgobWF4TGluZUhlaWdodCwgY2hhckRhdGEueU9mZnNldCArIGNoYXJEYXRhLnRleHR1cmUuaGVpZ2h0KTtcbiAgICAgIHByZXZDaGFyQ29kZSA9IGNoYXJDb2RlO1xuICAgICAgaWYgKGxhc3RCcmVha1BvcyAhPT0gLTEgJiYgbWF4V2lkdGggPiAwICYmIHBvcy54ID4gbWF4V2lkdGgpIHtcbiAgICAgICAgKytzcGFjZXNSZW1vdmVkO1xuICAgICAgICB1dGlscy5yZW1vdmVJdGVtcyhjaGFycywgMSArIGxhc3RCcmVha1BvcyAtIHNwYWNlc1JlbW92ZWQsIDEgKyBpIC0gbGFzdEJyZWFrUG9zKTtcbiAgICAgICAgaSA9IGxhc3RCcmVha1BvcztcbiAgICAgICAgbGFzdEJyZWFrUG9zID0gLTE7XG4gICAgICAgIGxpbmVXaWR0aHMucHVzaChsYXN0QnJlYWtXaWR0aCk7XG4gICAgICAgIGxpbmVTcGFjZXMucHVzaChjaGFycy5sZW5ndGggPiAwID8gY2hhcnNbY2hhcnMubGVuZ3RoIC0gMV0ucHJldlNwYWNlcyA6IDApO1xuICAgICAgICBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIGxhc3RCcmVha1dpZHRoKTtcbiAgICAgICAgbGluZSsrO1xuICAgICAgICBwb3MueCA9IDA7XG4gICAgICAgIHBvcy55ICs9IGRhdGEubGluZUhlaWdodDtcbiAgICAgICAgcHJldkNoYXJDb2RlID0gbnVsbDtcbiAgICAgICAgc3BhY2VDb3VudCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxhc3RDaGFyID0gY2hhcnNJbnB1dFtjaGFyc0lucHV0Lmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0Q2hhciAhPT0gXCJcXHJcIiAmJiBsYXN0Q2hhciAhPT0gXCJcXG5cIikge1xuICAgICAgaWYgKC8oPzpcXHMpLy50ZXN0KGxhc3RDaGFyKSkge1xuICAgICAgICBsYXN0TGluZVdpZHRoID0gbGFzdEJyZWFrV2lkdGg7XG4gICAgICB9XG4gICAgICBsaW5lV2lkdGhzLnB1c2gobGFzdExpbmVXaWR0aCk7XG4gICAgICBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIGxhc3RMaW5lV2lkdGgpO1xuICAgICAgbGluZVNwYWNlcy5wdXNoKC0xKTtcbiAgICB9XG4gICAgY29uc3QgbGluZUFsaWduT2Zmc2V0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGxpbmU7IGkrKykge1xuICAgICAgbGV0IGFsaWduT2Zmc2V0ID0gMDtcbiAgICAgIGlmICh0aGlzLl9hbGlnbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgIGFsaWduT2Zmc2V0ID0gbWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpXTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYWxpZ24gPT09IFwiY2VudGVyXCIpIHtcbiAgICAgICAgYWxpZ25PZmZzZXQgPSAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpXSkgLyAyO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9hbGlnbiA9PT0gXCJqdXN0aWZ5XCIpIHtcbiAgICAgICAgYWxpZ25PZmZzZXQgPSBsaW5lU3BhY2VzW2ldIDwgMCA/IDAgOiAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpXSkgLyBsaW5lU3BhY2VzW2ldO1xuICAgICAgfVxuICAgICAgbGluZUFsaWduT2Zmc2V0cy5wdXNoKGFsaWduT2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgbGVuQ2hhcnMgPSBjaGFycy5sZW5ndGg7XG4gICAgY29uc3QgcGFnZXNNZXNoRGF0YSA9IHt9O1xuICAgIGNvbnN0IG5ld1BhZ2VzTWVzaERhdGEgPSBbXTtcbiAgICBjb25zdCBhY3RpdmVQYWdlc01lc2hEYXRhID0gdGhpcy5fYWN0aXZlUGFnZXNNZXNoRGF0YTtcbiAgICBwYWdlTWVzaERhdGFQb29sLnB1c2goLi4uYWN0aXZlUGFnZXNNZXNoRGF0YSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5DaGFyczsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gY2hhcnNbaV0udGV4dHVyZTtcbiAgICAgIGNvbnN0IGJhc2VUZXh0dXJlVWlkID0gdGV4dHVyZS5iYXNlVGV4dHVyZS51aWQ7XG4gICAgICBpZiAoIXBhZ2VzTWVzaERhdGFbYmFzZVRleHR1cmVVaWRdKSB7XG4gICAgICAgIGxldCBwYWdlTWVzaERhdGEgPSBwYWdlTWVzaERhdGFQb29sLnBvcCgpO1xuICAgICAgICBpZiAoIXBhZ2VNZXNoRGF0YSkge1xuICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IE1lc2hHZW9tZXRyeSgpO1xuICAgICAgICAgIGxldCBtYXRlcmlhbDtcbiAgICAgICAgICBsZXQgbWVzaEJsZW5kTW9kZTtcbiAgICAgICAgICBpZiAoZGF0YS5kaXN0YW5jZUZpZWxkVHlwZSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgIG1hdGVyaWFsID0gbmV3IE1lc2hNYXRlcmlhbChUZXh0dXJlLkVNUFRZKTtcbiAgICAgICAgICAgIG1lc2hCbGVuZE1vZGUgPSBCTEVORF9NT0RFUy5OT1JNQUw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGVyaWFsID0gbmV3IE1lc2hNYXRlcmlhbChUZXh0dXJlLkVNUFRZLCB7IHByb2dyYW06IFByb2dyYW0uZnJvbShtc2RmVmVydCwgbXNkZkZyYWcpLCB1bmlmb3JtczogeyB1RldpZHRoOiAwIH0gfSk7XG4gICAgICAgICAgICBtZXNoQmxlbmRNb2RlID0gQkxFTkRfTU9ERVMuTk9STUFMX05QTTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbWVzaCA9IG5ldyBNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgICAgbWVzaC5ibGVuZE1vZGUgPSBtZXNoQmxlbmRNb2RlO1xuICAgICAgICAgIHBhZ2VNZXNoRGF0YSA9IHtcbiAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgICAgaW5kZXhDb3VudDogMCxcbiAgICAgICAgICAgIHZlcnRleENvdW50OiAwLFxuICAgICAgICAgICAgdXZzQ291bnQ6IDAsXG4gICAgICAgICAgICB0b3RhbDogMCxcbiAgICAgICAgICAgIG1lc2gsXG4gICAgICAgICAgICB2ZXJ0aWNlczogbnVsbCxcbiAgICAgICAgICAgIHV2czogbnVsbCxcbiAgICAgICAgICAgIGluZGljZXM6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHBhZ2VNZXNoRGF0YS5pbmRleCA9IDA7XG4gICAgICAgIHBhZ2VNZXNoRGF0YS5pbmRleENvdW50ID0gMDtcbiAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRleENvdW50ID0gMDtcbiAgICAgICAgcGFnZU1lc2hEYXRhLnV2c0NvdW50ID0gMDtcbiAgICAgICAgcGFnZU1lc2hEYXRhLnRvdGFsID0gMDtcbiAgICAgICAgY29uc3QgeyBfdGV4dHVyZUNhY2hlIH0gPSB0aGlzO1xuICAgICAgICBfdGV4dHVyZUNhY2hlW2Jhc2VUZXh0dXJlVWlkXSA9IF90ZXh0dXJlQ2FjaGVbYmFzZVRleHR1cmVVaWRdIHx8IG5ldyBUZXh0dXJlKHRleHR1cmUuYmFzZVRleHR1cmUpO1xuICAgICAgICBwYWdlTWVzaERhdGEubWVzaC50ZXh0dXJlID0gX3RleHR1cmVDYWNoZVtiYXNlVGV4dHVyZVVpZF07XG4gICAgICAgIHBhZ2VNZXNoRGF0YS5tZXNoLnRpbnQgPSB0aGlzLl90aW50Q29sb3IudmFsdWU7XG4gICAgICAgIG5ld1BhZ2VzTWVzaERhdGEucHVzaChwYWdlTWVzaERhdGEpO1xuICAgICAgICBwYWdlc01lc2hEYXRhW2Jhc2VUZXh0dXJlVWlkXSA9IHBhZ2VNZXNoRGF0YTtcbiAgICAgIH1cbiAgICAgIHBhZ2VzTWVzaERhdGFbYmFzZVRleHR1cmVVaWRdLnRvdGFsKys7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aXZlUGFnZXNNZXNoRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFuZXdQYWdlc01lc2hEYXRhLmluY2x1ZGVzKGFjdGl2ZVBhZ2VzTWVzaERhdGFbaV0pKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoYWN0aXZlUGFnZXNNZXNoRGF0YVtpXS5tZXNoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdQYWdlc01lc2hEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobmV3UGFnZXNNZXNoRGF0YVtpXS5tZXNoLnBhcmVudCAhPT0gdGhpcykge1xuICAgICAgICB0aGlzLmFkZENoaWxkKG5ld1BhZ2VzTWVzaERhdGFbaV0ubWVzaCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZVBhZ2VzTWVzaERhdGEgPSBuZXdQYWdlc01lc2hEYXRhO1xuICAgIGZvciAoY29uc3QgaSBpbiBwYWdlc01lc2hEYXRhKSB7XG4gICAgICBjb25zdCBwYWdlTWVzaERhdGEgPSBwYWdlc01lc2hEYXRhW2ldO1xuICAgICAgY29uc3QgdG90YWwgPSBwYWdlTWVzaERhdGEudG90YWw7XG4gICAgICBpZiAoIShwYWdlTWVzaERhdGEuaW5kaWNlcz8ubGVuZ3RoID4gNiAqIHRvdGFsKSB8fCBwYWdlTWVzaERhdGEudmVydGljZXMubGVuZ3RoIDwgTWVzaC5CQVRDSEFCTEVfU0laRSAqIDIpIHtcbiAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSg0ICogMiAqIHRvdGFsKTtcbiAgICAgICAgcGFnZU1lc2hEYXRhLnV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoNCAqIDIgKiB0b3RhbCk7XG4gICAgICAgIHBhZ2VNZXNoRGF0YS5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KDYgKiB0b3RhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0b3RhbDIgPSBwYWdlTWVzaERhdGEudG90YWw7XG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gcGFnZU1lc2hEYXRhLnZlcnRpY2VzO1xuICAgICAgICBmb3IgKGxldCBpMiA9IHRvdGFsMiAqIDQgKiAyOyBpMiA8IHZlcnRpY2VzLmxlbmd0aDsgaTIrKykge1xuICAgICAgICAgIHZlcnRpY2VzW2kyXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhZ2VNZXNoRGF0YS5tZXNoLnNpemUgPSA2ICogdG90YWw7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuQ2hhcnM7IGkrKykge1xuICAgICAgY29uc3QgY2hhciA9IGNoYXJzW2ldO1xuICAgICAgbGV0IG9mZnNldCA9IGNoYXIucG9zaXRpb24ueCArIGxpbmVBbGlnbk9mZnNldHNbY2hhci5saW5lXSAqICh0aGlzLl9hbGlnbiA9PT0gXCJqdXN0aWZ5XCIgPyBjaGFyLnByZXZTcGFjZXMgOiAxKTtcbiAgICAgIGlmICh0aGlzLl9yb3VuZFBpeGVscykge1xuICAgICAgICBvZmZzZXQgPSBNYXRoLnJvdW5kKG9mZnNldCk7XG4gICAgICB9XG4gICAgICBjb25zdCB4UG9zID0gb2Zmc2V0ICogc2NhbGU7XG4gICAgICBjb25zdCB5UG9zID0gY2hhci5wb3NpdGlvbi55ICogc2NhbGU7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gY2hhci50ZXh0dXJlO1xuICAgICAgY29uc3QgcGFnZU1lc2ggPSBwYWdlc01lc2hEYXRhW3RleHR1cmUuYmFzZVRleHR1cmUudWlkXTtcbiAgICAgIGNvbnN0IHRleHR1cmVGcmFtZSA9IHRleHR1cmUuZnJhbWU7XG4gICAgICBjb25zdCB0ZXh0dXJlVXZzID0gdGV4dHVyZS5fdXZzO1xuICAgICAgY29uc3QgaW5kZXggPSBwYWdlTWVzaC5pbmRleCsrO1xuICAgICAgcGFnZU1lc2guaW5kaWNlc1tpbmRleCAqIDYgKyAwXSA9IDAgKyBpbmRleCAqIDQ7XG4gICAgICBwYWdlTWVzaC5pbmRpY2VzW2luZGV4ICogNiArIDFdID0gMSArIGluZGV4ICogNDtcbiAgICAgIHBhZ2VNZXNoLmluZGljZXNbaW5kZXggKiA2ICsgMl0gPSAyICsgaW5kZXggKiA0O1xuICAgICAgcGFnZU1lc2guaW5kaWNlc1tpbmRleCAqIDYgKyAzXSA9IDAgKyBpbmRleCAqIDQ7XG4gICAgICBwYWdlTWVzaC5pbmRpY2VzW2luZGV4ICogNiArIDRdID0gMiArIGluZGV4ICogNDtcbiAgICAgIHBhZ2VNZXNoLmluZGljZXNbaW5kZXggKiA2ICsgNV0gPSAzICsgaW5kZXggKiA0O1xuICAgICAgcGFnZU1lc2gudmVydGljZXNbaW5kZXggKiA4ICsgMF0gPSB4UG9zO1xuICAgICAgcGFnZU1lc2gudmVydGljZXNbaW5kZXggKiA4ICsgMV0gPSB5UG9zO1xuICAgICAgcGFnZU1lc2gudmVydGljZXNbaW5kZXggKiA4ICsgMl0gPSB4UG9zICsgdGV4dHVyZUZyYW1lLndpZHRoICogc2NhbGU7XG4gICAgICBwYWdlTWVzaC52ZXJ0aWNlc1tpbmRleCAqIDggKyAzXSA9IHlQb3M7XG4gICAgICBwYWdlTWVzaC52ZXJ0aWNlc1tpbmRleCAqIDggKyA0XSA9IHhQb3MgKyB0ZXh0dXJlRnJhbWUud2lkdGggKiBzY2FsZTtcbiAgICAgIHBhZ2VNZXNoLnZlcnRpY2VzW2luZGV4ICogOCArIDVdID0geVBvcyArIHRleHR1cmVGcmFtZS5oZWlnaHQgKiBzY2FsZTtcbiAgICAgIHBhZ2VNZXNoLnZlcnRpY2VzW2luZGV4ICogOCArIDZdID0geFBvcztcbiAgICAgIHBhZ2VNZXNoLnZlcnRpY2VzW2luZGV4ICogOCArIDddID0geVBvcyArIHRleHR1cmVGcmFtZS5oZWlnaHQgKiBzY2FsZTtcbiAgICAgIHBhZ2VNZXNoLnV2c1tpbmRleCAqIDggKyAwXSA9IHRleHR1cmVVdnMueDA7XG4gICAgICBwYWdlTWVzaC51dnNbaW5kZXggKiA4ICsgMV0gPSB0ZXh0dXJlVXZzLnkwO1xuICAgICAgcGFnZU1lc2gudXZzW2luZGV4ICogOCArIDJdID0gdGV4dHVyZVV2cy54MTtcbiAgICAgIHBhZ2VNZXNoLnV2c1tpbmRleCAqIDggKyAzXSA9IHRleHR1cmVVdnMueTE7XG4gICAgICBwYWdlTWVzaC51dnNbaW5kZXggKiA4ICsgNF0gPSB0ZXh0dXJlVXZzLngyO1xuICAgICAgcGFnZU1lc2gudXZzW2luZGV4ICogOCArIDVdID0gdGV4dHVyZVV2cy55MjtcbiAgICAgIHBhZ2VNZXNoLnV2c1tpbmRleCAqIDggKyA2XSA9IHRleHR1cmVVdnMueDM7XG4gICAgICBwYWdlTWVzaC51dnNbaW5kZXggKiA4ICsgN10gPSB0ZXh0dXJlVXZzLnkzO1xuICAgIH1cbiAgICB0aGlzLl90ZXh0V2lkdGggPSBtYXhMaW5lV2lkdGggKiBzY2FsZTtcbiAgICB0aGlzLl90ZXh0SGVpZ2h0ID0gKHBvcy55ICsgZGF0YS5saW5lSGVpZ2h0KSAqIHNjYWxlO1xuICAgIGZvciAoY29uc3QgaSBpbiBwYWdlc01lc2hEYXRhKSB7XG4gICAgICBjb25zdCBwYWdlTWVzaERhdGEgPSBwYWdlc01lc2hEYXRhW2ldO1xuICAgICAgaWYgKHRoaXMuYW5jaG9yLnggIT09IDAgfHwgdGhpcy5hbmNob3IueSAhPT0gMCkge1xuICAgICAgICBsZXQgdmVydGV4Q291bnQgPSAwO1xuICAgICAgICBjb25zdCBhbmNob3JPZmZzZXRYID0gdGhpcy5fdGV4dFdpZHRoICogdGhpcy5hbmNob3IueDtcbiAgICAgICAgY29uc3QgYW5jaG9yT2Zmc2V0WSA9IHRoaXMuX3RleHRIZWlnaHQgKiB0aGlzLmFuY2hvci55O1xuICAgICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgcGFnZU1lc2hEYXRhLnRvdGFsOyBpMisrKSB7XG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFg7XG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFk7XG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFg7XG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFk7XG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFg7XG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFk7XG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFg7XG4gICAgICAgICAgcGFnZU1lc2hEYXRhLnZlcnRpY2VzW3ZlcnRleENvdW50KytdIC09IGFuY2hvck9mZnNldFk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX21heExpbmVIZWlnaHQgPSBtYXhMaW5lSGVpZ2h0ICogc2NhbGU7XG4gICAgICBjb25zdCB2ZXJ0ZXhCdWZmZXIgPSBwYWdlTWVzaERhdGEubWVzaC5nZW9tZXRyeS5nZXRCdWZmZXIoXCJhVmVydGV4UG9zaXRpb25cIik7XG4gICAgICBjb25zdCB0ZXh0dXJlQnVmZmVyID0gcGFnZU1lc2hEYXRhLm1lc2guZ2VvbWV0cnkuZ2V0QnVmZmVyKFwiYVRleHR1cmVDb29yZFwiKTtcbiAgICAgIGNvbnN0IGluZGV4QnVmZmVyID0gcGFnZU1lc2hEYXRhLm1lc2guZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgICAgIHZlcnRleEJ1ZmZlci5kYXRhID0gcGFnZU1lc2hEYXRhLnZlcnRpY2VzO1xuICAgICAgdGV4dHVyZUJ1ZmZlci5kYXRhID0gcGFnZU1lc2hEYXRhLnV2cztcbiAgICAgIGluZGV4QnVmZmVyLmRhdGEgPSBwYWdlTWVzaERhdGEuaW5kaWNlcztcbiAgICAgIHZlcnRleEJ1ZmZlci51cGRhdGUoKTtcbiAgICAgIHRleHR1cmVCdWZmZXIudXBkYXRlKCk7XG4gICAgICBpbmRleEJ1ZmZlci51cGRhdGUoKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhclJlbmRlckRhdGFQb29sLnB1c2goY2hhcnNbaV0pO1xuICAgIH1cbiAgICB0aGlzLl9mb250ID0gZGF0YTtcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIH1cbiAgdXBkYXRlVHJhbnNmb3JtKCkge1xuICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICB0aGlzLmNvbnRhaW5lclVwZGF0ZVRyYW5zZm9ybSgpO1xuICB9XG4gIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICBpZiAodGhpcy5fYXV0b1Jlc29sdXRpb24gJiYgdGhpcy5fcmVzb2x1dGlvbiAhPT0gcmVuZGVyZXIucmVzb2x1dGlvbikge1xuICAgICAgdGhpcy5fcmVzb2x1dGlvbiA9IHJlbmRlcmVyLnJlc29sdXRpb247XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgeyBkaXN0YW5jZUZpZWxkUmFuZ2UsIGRpc3RhbmNlRmllbGRUeXBlLCBzaXplIH0gPSBCaXRtYXBGb250LmF2YWlsYWJsZVt0aGlzLl9mb250TmFtZV07XG4gICAgaWYgKGRpc3RhbmNlRmllbGRUeXBlICE9PSBcIm5vbmVcIikge1xuICAgICAgY29uc3QgeyBhLCBiLCBjLCBkIH0gPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xuICAgICAgY29uc3QgZHggPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG4gICAgICBjb25zdCBkeSA9IE1hdGguc3FydChjICogYyArIGQgKiBkKTtcbiAgICAgIGNvbnN0IHdvcmxkU2NhbGUgPSAoTWF0aC5hYnMoZHgpICsgTWF0aC5hYnMoZHkpKSAvIDI7XG4gICAgICBjb25zdCBmb250U2NhbGUgPSB0aGlzLmZvbnRTaXplIC8gc2l6ZTtcbiAgICAgIGNvbnN0IHJlc29sdXRpb24gPSByZW5kZXJlci5fdmlldy5yZXNvbHV0aW9uO1xuICAgICAgZm9yIChjb25zdCBtZXNoIG9mIHRoaXMuX2FjdGl2ZVBhZ2VzTWVzaERhdGEpIHtcbiAgICAgICAgbWVzaC5tZXNoLnNoYWRlci51bmlmb3Jtcy51RldpZHRoID0gd29ybGRTY2FsZSAqIGRpc3RhbmNlRmllbGRSYW5nZSAqIGZvbnRTY2FsZSAqIHJlc29sdXRpb247XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyLl9yZW5kZXIocmVuZGVyZXIpO1xuICB9XG4gIGdldExvY2FsQm91bmRzKCkge1xuICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICByZXR1cm4gc3VwZXIuZ2V0TG9jYWxCb3VuZHMoKTtcbiAgfVxuICB2YWxpZGF0ZSgpIHtcbiAgICBjb25zdCBmb250ID0gQml0bWFwRm9udC5hdmFpbGFibGVbdGhpcy5fZm9udE5hbWVdO1xuICAgIGlmICghZm9udCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIEJpdG1hcEZvbnQgXCIke3RoaXMuX2ZvbnROYW1lfVwiYCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9mb250ICE9PSBmb250KSB7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgIHRoaXMudXBkYXRlVGV4dCgpO1xuICAgIH1cbiAgfVxuICBnZXQgdGludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGludENvbG9yLnZhbHVlO1xuICB9XG4gIHNldCB0aW50KHZhbHVlKSB7XG4gICAgaWYgKHRoaXMudGludCA9PT0gdmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fdGludENvbG9yLnNldFZhbHVlKHZhbHVlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2FjdGl2ZVBhZ2VzTWVzaERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2FjdGl2ZVBhZ2VzTWVzaERhdGFbaV0ubWVzaC50aW50ID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIGdldCBhbGlnbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYWxpZ247XG4gIH1cbiAgc2V0IGFsaWduKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2FsaWduICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fYWxpZ24gPSB2YWx1ZTtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBnZXQgZm9udE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnROYW1lO1xuICB9XG4gIHNldCBmb250TmFtZSh2YWx1ZSkge1xuICAgIGlmICghQml0bWFwRm9udC5hdmFpbGFibGVbdmFsdWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgQml0bWFwRm9udCBcIiR7dmFsdWV9XCJgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2ZvbnROYW1lICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fZm9udE5hbWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBnZXQgZm9udFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnRTaXplID8/IEJpdG1hcEZvbnQuYXZhaWxhYmxlW3RoaXMuX2ZvbnROYW1lXS5zaXplO1xuICB9XG4gIHNldCBmb250U2l6ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9mb250U2l6ZSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2ZvbnRTaXplID0gdmFsdWU7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgZ2V0IGFuY2hvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fYW5jaG9yO1xuICB9XG4gIHNldCBhbmNob3IodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICB0aGlzLl9hbmNob3Iuc2V0KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYW5jaG9yLmNvcHlGcm9tKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHQ7XG4gIH1cbiAgc2V0IHRleHQodGV4dCkge1xuICAgIHRleHQgPSBTdHJpbmcodGV4dCA9PT0gbnVsbCB8fCB0ZXh0ID09PSB2b2lkIDAgPyBcIlwiIDogdGV4dCk7XG4gICAgaWYgKHRoaXMuX3RleHQgPT09IHRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdGV4dCA9IHRleHQ7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cbiAgZ2V0IG1heFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXhXaWR0aDtcbiAgfVxuICBzZXQgbWF4V2lkdGgodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fbWF4V2lkdGggPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX21heFdpZHRoID0gdmFsdWU7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cbiAgZ2V0IG1heExpbmVIZWlnaHQoKSB7XG4gICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgIHJldHVybiB0aGlzLl9tYXhMaW5lSGVpZ2h0O1xuICB9XG4gIGdldCB0ZXh0V2lkdGgoKSB7XG4gICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgIHJldHVybiB0aGlzLl90ZXh0V2lkdGg7XG4gIH1cbiAgZ2V0IGxldHRlclNwYWNpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xldHRlclNwYWNpbmc7XG4gIH1cbiAgc2V0IGxldHRlclNwYWNpbmcodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fbGV0dGVyU3BhY2luZyAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2xldHRlclNwYWNpbmcgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBnZXQgcm91bmRQaXhlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JvdW5kUGl4ZWxzO1xuICB9XG4gIHNldCByb3VuZFBpeGVscyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcm91bmRQaXhlbHMpIHtcbiAgICAgIHRoaXMuX3JvdW5kUGl4ZWxzID0gdmFsdWU7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgZ2V0IHRleHRIZWlnaHQoKSB7XG4gICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgIHJldHVybiB0aGlzLl90ZXh0SGVpZ2h0O1xuICB9XG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHV0aW9uO1xuICB9XG4gIHNldCByZXNvbHV0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fYXV0b1Jlc29sdXRpb24gPSBmYWxzZTtcbiAgICBpZiAodGhpcy5fcmVzb2x1dGlvbiA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcmVzb2x1dGlvbiA9IHZhbHVlO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG4gIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIGNvbnN0IHsgX3RleHR1cmVDYWNoZSB9ID0gdGhpcztcbiAgICBjb25zdCBkYXRhID0gQml0bWFwRm9udC5hdmFpbGFibGVbdGhpcy5fZm9udE5hbWVdO1xuICAgIGNvbnN0IHBhZ2VNZXNoRGF0YVBvb2wgPSBkYXRhLmRpc3RhbmNlRmllbGRUeXBlID09PSBcIm5vbmVcIiA/IHBhZ2VNZXNoRGF0YURlZmF1bHRQYWdlTWVzaERhdGEgOiBwYWdlTWVzaERhdGFNU0RGUGFnZU1lc2hEYXRhO1xuICAgIHBhZ2VNZXNoRGF0YVBvb2wucHVzaCguLi50aGlzLl9hY3RpdmVQYWdlc01lc2hEYXRhKTtcbiAgICBmb3IgKGNvbnN0IHBhZ2VNZXNoRGF0YSBvZiB0aGlzLl9hY3RpdmVQYWdlc01lc2hEYXRhKSB7XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKHBhZ2VNZXNoRGF0YS5tZXNoKTtcbiAgICB9XG4gICAgdGhpcy5fYWN0aXZlUGFnZXNNZXNoRGF0YSA9IFtdO1xuICAgIHBhZ2VNZXNoRGF0YVBvb2wuZmlsdGVyKChwYWdlKSA9PiBfdGV4dHVyZUNhY2hlW3BhZ2UubWVzaC50ZXh0dXJlLmJhc2VUZXh0dXJlLnVpZF0pLmZvckVhY2goKHBhZ2UpID0+IHtcbiAgICAgIHBhZ2UubWVzaC50ZXh0dXJlID0gVGV4dHVyZS5FTVBUWTtcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IGlkIGluIF90ZXh0dXJlQ2FjaGUpIHtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBfdGV4dHVyZUNhY2hlW2lkXTtcbiAgICAgIHRleHR1cmUuZGVzdHJveSgpO1xuICAgICAgZGVsZXRlIF90ZXh0dXJlQ2FjaGVbaWRdO1xuICAgIH1cbiAgICB0aGlzLl9mb250ID0gbnVsbDtcbiAgICB0aGlzLl90aW50Q29sb3IgPSBudWxsO1xuICAgIHRoaXMuX3RleHR1cmVDYWNoZSA9IG51bGw7XG4gICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgfVxufTtcbmxldCBCaXRtYXBUZXh0ID0gX0JpdG1hcFRleHQ7XG5CaXRtYXBUZXh0LnN0eWxlRGVmYXVsdHMgPSB7XG4gIGFsaWduOiBcImxlZnRcIixcbiAgdGludDogMTY3NzcyMTUsXG4gIG1heFdpZHRoOiAwLFxuICBsZXR0ZXJTcGFjaW5nOiAwXG59O1xuXG5leHBvcnQgeyBCaXRtYXBUZXh0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CaXRtYXBUZXh0Lm1qcy5tYXBcbiIsImltcG9ydCB7IExvYWRlclBhcnNlclByaW9yaXR5LCBjb3B5U2VhcmNoUGFyYW1zIH0gZnJvbSAnQHBpeGkvYXNzZXRzJztcbmltcG9ydCB7IEV4dGVuc2lvblR5cGUsIHV0aWxzLCBzZXR0aW5ncywgZXh0ZW5zaW9ucyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgQml0bWFwRm9udCB9IGZyb20gJy4vQml0bWFwRm9udC5tanMnO1xuaW1wb3J0ICcuL2Zvcm1hdHMvaW5kZXgubWpzJztcbmltcG9ydCB7IFRleHRGb3JtYXQgfSBmcm9tICcuL2Zvcm1hdHMvVGV4dEZvcm1hdC5tanMnO1xuaW1wb3J0IHsgWE1MU3RyaW5nRm9ybWF0IH0gZnJvbSAnLi9mb3JtYXRzL1hNTFN0cmluZ0Zvcm1hdC5tanMnO1xuXG5jb25zdCB2YWxpZEV4dGVuc2lvbnMgPSBbXCIueG1sXCIsIFwiLmZudFwiXTtcbmNvbnN0IGxvYWRCaXRtYXBGb250ID0ge1xuICBleHRlbnNpb246IHtcbiAgICB0eXBlOiBFeHRlbnNpb25UeXBlLkxvYWRQYXJzZXIsXG4gICAgcHJpb3JpdHk6IExvYWRlclBhcnNlclByaW9yaXR5Lk5vcm1hbFxuICB9LFxuICBuYW1lOiBcImxvYWRCaXRtYXBGb250XCIsXG4gIHRlc3QodXJsKSB7XG4gICAgcmV0dXJuIHZhbGlkRXh0ZW5zaW9ucy5pbmNsdWRlcyh1dGlscy5wYXRoLmV4dG5hbWUodXJsKS50b0xvd2VyQ2FzZSgpKTtcbiAgfSxcbiAgYXN5bmMgdGVzdFBhcnNlKGRhdGEpIHtcbiAgICByZXR1cm4gVGV4dEZvcm1hdC50ZXN0KGRhdGEpIHx8IFhNTFN0cmluZ0Zvcm1hdC50ZXN0KGRhdGEpO1xuICB9LFxuICBhc3luYyBwYXJzZShhc3NldCwgZGF0YSwgbG9hZGVyKSB7XG4gICAgY29uc3QgZm9udERhdGEgPSBUZXh0Rm9ybWF0LnRlc3QoYXNzZXQpID8gVGV4dEZvcm1hdC5wYXJzZShhc3NldCkgOiBYTUxTdHJpbmdGb3JtYXQucGFyc2UoYXNzZXQpO1xuICAgIGNvbnN0IHsgc3JjIH0gPSBkYXRhO1xuICAgIGNvbnN0IHsgcGFnZTogcGFnZXMgfSA9IGZvbnREYXRhO1xuICAgIGNvbnN0IHRleHR1cmVVcmxzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWdlcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgcGFnZUZpbGUgPSBwYWdlc1tpXS5maWxlO1xuICAgICAgbGV0IGltYWdlUGF0aCA9IHV0aWxzLnBhdGguam9pbih1dGlscy5wYXRoLmRpcm5hbWUoc3JjKSwgcGFnZUZpbGUpO1xuICAgICAgaW1hZ2VQYXRoID0gY29weVNlYXJjaFBhcmFtcyhpbWFnZVBhdGgsIHNyYyk7XG4gICAgICB0ZXh0dXJlVXJscy5wdXNoKGltYWdlUGF0aCk7XG4gICAgfVxuICAgIGNvbnN0IGxvYWRlZFRleHR1cmVzID0gYXdhaXQgbG9hZGVyLmxvYWQodGV4dHVyZVVybHMpO1xuICAgIGNvbnN0IHRleHR1cmVzID0gdGV4dHVyZVVybHMubWFwKCh1cmwpID0+IGxvYWRlZFRleHR1cmVzW3VybF0pO1xuICAgIHJldHVybiBCaXRtYXBGb250Lmluc3RhbGwoZm9udERhdGEsIHRleHR1cmVzLCB0cnVlKTtcbiAgfSxcbiAgYXN5bmMgbG9hZCh1cmwsIF9vcHRpb25zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZXR0aW5ncy5BREFQVEVSLmZldGNoKHVybCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgfSxcbiAgdW5sb2FkKGJpdG1hcEZvbnQpIHtcbiAgICBiaXRtYXBGb250LmRlc3Ryb3koKTtcbiAgfVxufTtcbmV4dGVuc2lvbnMuYWRkKGxvYWRCaXRtYXBGb250KTtcblxuZXhwb3J0IHsgbG9hZEJpdG1hcEZvbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRCaXRtYXBGb250Lm1qcy5tYXBcbiIsImV4cG9ydCB7IEJpdG1hcEZvbnQgfSBmcm9tICcuL0JpdG1hcEZvbnQubWpzJztcbmV4cG9ydCB7IEJpdG1hcEZvbnREYXRhIH0gZnJvbSAnLi9CaXRtYXBGb250RGF0YS5tanMnO1xuZXhwb3J0IHsgQml0bWFwVGV4dCB9IGZyb20gJy4vQml0bWFwVGV4dC5tanMnO1xuaW1wb3J0ICcuL0JpdG1hcFRleHRTdHlsZS5tanMnO1xuZXhwb3J0IHsgYXV0b0RldGVjdEZvcm1hdCB9IGZyb20gJy4vZm9ybWF0cy9pbmRleC5tanMnO1xuZXhwb3J0IHsgbG9hZEJpdG1hcEZvbnQgfSBmcm9tICcuL2xvYWRCaXRtYXBGb250Lm1qcyc7XG5leHBvcnQgeyBUZXh0Rm9ybWF0IH0gZnJvbSAnLi9mb3JtYXRzL1RleHRGb3JtYXQubWpzJztcbmV4cG9ydCB7IFhNTEZvcm1hdCB9IGZyb20gJy4vZm9ybWF0cy9YTUxGb3JtYXQubWpzJztcbmV4cG9ydCB7IFhNTFN0cmluZ0Zvcm1hdCB9IGZyb20gJy4vZm9ybWF0cy9YTUxTdHJpbmdGb3JtYXQubWpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydCB7IHNldHRpbmdzLCB1dGlscyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgVGV4dFN0eWxlIH0gZnJvbSAnQHBpeGkvdGV4dCc7XG5cbmNvbnN0IF9IVE1MVGV4dFN0eWxlID0gY2xhc3MgZXh0ZW5kcyBUZXh0U3R5bGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuX2ZvbnRzID0gW107XG4gICAgdGhpcy5fb3ZlcnJpZGVzID0gW107XG4gICAgdGhpcy5fc3R5bGVzaGVldCA9IFwiXCI7XG4gICAgdGhpcy5mb250c0RpcnR5ID0gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGZyb20ob3JpZ2luYWxTdHlsZSkge1xuICAgIHJldHVybiBuZXcgX0hUTUxUZXh0U3R5bGUoT2JqZWN0LmtleXMoX0hUTUxUZXh0U3R5bGUuZGVmYXVsdE9wdGlvbnMpLnJlZHVjZSgob2JqLCBwcm9wKSA9PiAoeyAuLi5vYmosIFtwcm9wXTogb3JpZ2luYWxTdHlsZVtwcm9wXSB9KSwge30pKTtcbiAgfVxuICBjbGVhbkZvbnRzKCkge1xuICAgIGlmICh0aGlzLl9mb250cy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLl9mb250cy5mb3JFYWNoKChmb250KSA9PiB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoZm9udC5zcmMpO1xuICAgICAgICBmb250LnJlZnMtLTtcbiAgICAgICAgaWYgKGZvbnQucmVmcyA9PT0gMCkge1xuICAgICAgICAgIGlmIChmb250LmZvbnRGYWNlKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5mb250cy5kZWxldGUoZm9udC5mb250RmFjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBfSFRNTFRleHRTdHlsZS5hdmFpbGFibGVGb250c1tmb250Lm9yaWdpbmFsVXJsXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmZvbnRGYW1pbHkgPSBcIkFyaWFsXCI7XG4gICAgICB0aGlzLl9mb250cy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICB0aGlzLmZvbnRzRGlydHkgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBsb2FkRm9udCh1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXZhaWxhYmxlRm9udHMgfSA9IF9IVE1MVGV4dFN0eWxlO1xuICAgIGlmIChhdmFpbGFibGVGb250c1t1cmxdKSB7XG4gICAgICBjb25zdCBmb250ID0gYXZhaWxhYmxlRm9udHNbdXJsXTtcbiAgICAgIHRoaXMuX2ZvbnRzLnB1c2goZm9udCk7XG4gICAgICBmb250LnJlZnMrKztcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgdGhpcy5mb250c0RpcnR5ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNldHRpbmdzLkFEQVBURVIuZmV0Y2godXJsKS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuYmxvYigpKS50aGVuKGFzeW5jIChibG9iKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBzcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKFtzcmMsIHJlYWRlci5yZXN1bHRdKTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gICAgfSkpLnRoZW4oYXN5bmMgKFtzcmMsIGRhdGFTcmNdKSA9PiB7XG4gICAgICBjb25zdCBmb250ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGZhbWlseTogdXRpbHMucGF0aC5iYXNlbmFtZSh1cmwsIHV0aWxzLnBhdGguZXh0bmFtZSh1cmwpKSxcbiAgICAgICAgd2VpZ2h0OiBcIm5vcm1hbFwiLFxuICAgICAgICBzdHlsZTogXCJub3JtYWxcIixcbiAgICAgICAgc3JjLFxuICAgICAgICBkYXRhU3JjLFxuICAgICAgICByZWZzOiAxLFxuICAgICAgICBvcmlnaW5hbFVybDogdXJsLFxuICAgICAgICBmb250RmFjZTogbnVsbFxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICBhdmFpbGFibGVGb250c1t1cmxdID0gZm9udDtcbiAgICAgIHRoaXMuX2ZvbnRzLnB1c2goZm9udCk7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgIGNvbnN0IGZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKGZvbnQuZmFtaWx5LCBgdXJsKCR7Zm9udC5zcmN9KWAsIHtcbiAgICAgICAgd2VpZ2h0OiBmb250LndlaWdodCxcbiAgICAgICAgc3R5bGU6IGZvbnQuc3R5bGVcbiAgICAgIH0pO1xuICAgICAgZm9udC5mb250RmFjZSA9IGZvbnRGYWNlO1xuICAgICAgYXdhaXQgZm9udEZhY2UubG9hZCgpO1xuICAgICAgZG9jdW1lbnQuZm9udHMuYWRkKGZvbnRGYWNlKTtcbiAgICAgIGF3YWl0IGRvY3VtZW50LmZvbnRzLnJlYWR5O1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICB0aGlzLmZvbnRzRGlydHkgPSB0cnVlO1xuICAgIH0pO1xuICB9XG4gIGFkZE92ZXJyaWRlKC4uLnZhbHVlKSB7XG4gICAgY29uc3QgdG9BZGQgPSB2YWx1ZS5maWx0ZXIoKHYpID0+ICF0aGlzLl9vdmVycmlkZXMuaW5jbHVkZXModikpO1xuICAgIGlmICh0b0FkZC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLl9vdmVycmlkZXMucHVzaCguLi50b0FkZCk7XG4gICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICB9XG4gIH1cbiAgcmVtb3ZlT3ZlcnJpZGUoLi4udmFsdWUpIHtcbiAgICBjb25zdCB0b1JlbW92ZSA9IHZhbHVlLmZpbHRlcigodikgPT4gdGhpcy5fb3ZlcnJpZGVzLmluY2x1ZGVzKHYpKTtcbiAgICBpZiAodG9SZW1vdmUubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fb3ZlcnJpZGVzID0gdGhpcy5fb3ZlcnJpZGVzLmZpbHRlcigodikgPT4gIXRvUmVtb3ZlLmluY2x1ZGVzKHYpKTtcbiAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgIH1cbiAgfVxuICB0b0NTUyhzY2FsZSkge1xuICAgIHJldHVybiBbXG4gICAgICBgdHJhbnNmb3JtOiBzY2FsZSgke3NjYWxlfSlgLFxuICAgICAgYHRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0YCxcbiAgICAgIFwiZGlzcGxheTogaW5saW5lLWJsb2NrXCIsXG4gICAgICBgY29sb3I6ICR7dGhpcy5ub3JtYWxpemVDb2xvcih0aGlzLmZpbGwpfWAsXG4gICAgICBgZm9udC1zaXplOiAke3RoaXMuZm9udFNpemV9cHhgLFxuICAgICAgYGZvbnQtZmFtaWx5OiAke3RoaXMuZm9udEZhbWlseX1gLFxuICAgICAgYGZvbnQtd2VpZ2h0OiAke3RoaXMuZm9udFdlaWdodH1gLFxuICAgICAgYGZvbnQtc3R5bGU6ICR7dGhpcy5mb250U3R5bGV9YCxcbiAgICAgIGBmb250LXZhcmlhbnQ6ICR7dGhpcy5mb250VmFyaWFudH1gLFxuICAgICAgYGxldHRlci1zcGFjaW5nOiAke3RoaXMubGV0dGVyU3BhY2luZ31weGAsXG4gICAgICBgdGV4dC1hbGlnbjogJHt0aGlzLmFsaWdufWAsXG4gICAgICBgcGFkZGluZzogJHt0aGlzLnBhZGRpbmd9cHhgLFxuICAgICAgYHdoaXRlLXNwYWNlOiAke3RoaXMud2hpdGVTcGFjZX1gLFxuICAgICAgLi4udGhpcy5saW5lSGVpZ2h0ID8gW2BsaW5lLWhlaWdodDogJHt0aGlzLmxpbmVIZWlnaHR9cHhgXSA6IFtdLFxuICAgICAgLi4udGhpcy53b3JkV3JhcCA/IFtcbiAgICAgICAgYHdvcmQtd3JhcDogJHt0aGlzLmJyZWFrV29yZHMgPyBcImJyZWFrLWFsbFwiIDogXCJicmVhay13b3JkXCJ9YCxcbiAgICAgICAgYG1heC13aWR0aDogJHt0aGlzLndvcmRXcmFwV2lkdGh9cHhgXG4gICAgICBdIDogW10sXG4gICAgICAuLi50aGlzLnN0cm9rZVRoaWNrbmVzcyA/IFtcbiAgICAgICAgYC13ZWJraXQtdGV4dC1zdHJva2Utd2lkdGg6ICR7dGhpcy5zdHJva2VUaGlja25lc3N9cHhgLFxuICAgICAgICBgLXdlYmtpdC10ZXh0LXN0cm9rZS1jb2xvcjogJHt0aGlzLm5vcm1hbGl6ZUNvbG9yKHRoaXMuc3Ryb2tlKX1gLFxuICAgICAgICBgdGV4dC1zdHJva2Utd2lkdGg6ICR7dGhpcy5zdHJva2VUaGlja25lc3N9cHhgLFxuICAgICAgICBgdGV4dC1zdHJva2UtY29sb3I6ICR7dGhpcy5ub3JtYWxpemVDb2xvcih0aGlzLnN0cm9rZSl9YCxcbiAgICAgICAgXCJwYWludC1vcmRlcjogc3Ryb2tlXCJcbiAgICAgIF0gOiBbXSxcbiAgICAgIC4uLnRoaXMuZHJvcFNoYWRvdyA/IFt0aGlzLmRyb3BTaGFkb3dUb0NTUygpXSA6IFtdLFxuICAgICAgLi4udGhpcy5fb3ZlcnJpZGVzXG4gICAgXS5qb2luKFwiO1wiKTtcbiAgfVxuICB0b0dsb2JhbENTUygpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udHMucmVkdWNlKChyZXN1bHQsIGZvbnQpID0+IGAke3Jlc3VsdH1cbiAgICAgICAgICAgIEBmb250LWZhY2Uge1xuICAgICAgICAgICAgICAgIGZvbnQtZmFtaWx5OiBcIiR7Zm9udC5mYW1pbHl9XCI7XG4gICAgICAgICAgICAgICAgc3JjOiB1cmwoJyR7Zm9udC5kYXRhU3JjfScpO1xuICAgICAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiAke2ZvbnQud2VpZ2h0fTtcbiAgICAgICAgICAgICAgICBmb250LXN0eWxlOiAke2ZvbnQuc3R5bGV9OyBcbiAgICAgICAgICAgIH1gLCB0aGlzLl9zdHlsZXNoZWV0KTtcbiAgfVxuICBnZXQgc3R5bGVzaGVldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3R5bGVzaGVldDtcbiAgfVxuICBzZXQgc3R5bGVzaGVldCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9zdHlsZXNoZWV0ICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fc3R5bGVzaGVldCA9IHZhbHVlO1xuICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgfVxuICB9XG4gIG5vcm1hbGl6ZUNvbG9yKGNvbG9yKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29sb3IpKSB7XG4gICAgICBjb2xvciA9IHV0aWxzLnJnYjJoZXgoY29sb3IpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbG9yID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gdXRpbHMuaGV4MnN0cmluZyhjb2xvcik7XG4gICAgfVxuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuICBkcm9wU2hhZG93VG9DU1MoKSB7XG4gICAgbGV0IGNvbG9yID0gdGhpcy5ub3JtYWxpemVDb2xvcih0aGlzLmRyb3BTaGFkb3dDb2xvcik7XG4gICAgY29uc3QgYWxwaGEgPSB0aGlzLmRyb3BTaGFkb3dBbHBoYTtcbiAgICBjb25zdCB4ID0gTWF0aC5yb3VuZChNYXRoLmNvcyh0aGlzLmRyb3BTaGFkb3dBbmdsZSkgKiB0aGlzLmRyb3BTaGFkb3dEaXN0YW5jZSk7XG4gICAgY29uc3QgeSA9IE1hdGgucm91bmQoTWF0aC5zaW4odGhpcy5kcm9wU2hhZG93QW5nbGUpICogdGhpcy5kcm9wU2hhZG93RGlzdGFuY2UpO1xuICAgIGlmIChjb2xvci5zdGFydHNXaXRoKFwiI1wiKSAmJiBhbHBoYSA8IDEpIHtcbiAgICAgIGNvbG9yICs9IChhbHBoYSAqIDI1NSB8IDApLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIik7XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uID0gYCR7eH1weCAke3l9cHhgO1xuICAgIGlmICh0aGlzLmRyb3BTaGFkb3dCbHVyID4gMCkge1xuICAgICAgcmV0dXJuIGB0ZXh0LXNoYWRvdzogJHtwb3NpdGlvbn0gJHt0aGlzLmRyb3BTaGFkb3dCbHVyfXB4ICR7Y29sb3J9YDtcbiAgICB9XG4gICAgcmV0dXJuIGB0ZXh0LXNoYWRvdzogJHtwb3NpdGlvbn0gJHtjb2xvcn1gO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgX0hUTUxUZXh0U3R5bGUuZGVmYXVsdE9wdGlvbnMpO1xuICB9XG4gIG9uQmVmb3JlRHJhdygpIHtcbiAgICBjb25zdCB7IGZvbnRzRGlydHk6IHByZXZGb250c0RpcnR5IH0gPSB0aGlzO1xuICAgIHRoaXMuZm9udHNEaXJ0eSA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmlzU2FmYXJpICYmIHRoaXMuX2ZvbnRzLmxlbmd0aCA+IDAgJiYgcHJldkZvbnRzRGlydHkpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG4gIGdldCBpc1NhZmFyaSgpIHtcbiAgICBjb25zdCB7IHVzZXJBZ2VudCB9ID0gc2V0dGluZ3MuQURBUFRFUi5nZXROYXZpZ2F0b3IoKTtcbiAgICByZXR1cm4gL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdCh1c2VyQWdlbnQpO1xuICB9XG4gIHNldCBmaWxsR3JhZGllbnRTdG9wcyhfdmFsdWUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbSFRNTFRleHRTdHlsZV0gZmlsbEdyYWRpZW50U3RvcHMgaXMgbm90IHN1cHBvcnRlZCBieSBIVE1MVGV4dFwiKTtcbiAgfVxuICBnZXQgZmlsbEdyYWRpZW50U3RvcHMoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmZpbGxHcmFkaWVudFN0b3BzO1xuICB9XG4gIHNldCBmaWxsR3JhZGllbnRUeXBlKF92YWx1ZSkge1xuICAgIGNvbnNvbGUud2FybihcIltIVE1MVGV4dFN0eWxlXSBmaWxsR3JhZGllbnRUeXBlIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSFRNTFRleHRcIik7XG4gIH1cbiAgZ2V0IGZpbGxHcmFkaWVudFR5cGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmZpbGxHcmFkaWVudFR5cGU7XG4gIH1cbiAgc2V0IG1pdGVyTGltaXQoX3ZhbHVlKSB7XG4gICAgY29uc29sZS53YXJuKFwiW0hUTUxUZXh0U3R5bGVdIG1pdGVyTGltaXQgaXMgbm90IHN1cHBvcnRlZCBieSBIVE1MVGV4dFwiKTtcbiAgfVxuICBnZXQgbWl0ZXJMaW1pdCgpIHtcbiAgICByZXR1cm4gc3VwZXIubWl0ZXJMaW1pdDtcbiAgfVxuICBzZXQgdHJpbShfdmFsdWUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbSFRNTFRleHRTdHlsZV0gdHJpbSBpcyBub3Qgc3VwcG9ydGVkIGJ5IEhUTUxUZXh0XCIpO1xuICB9XG4gIGdldCB0cmltKCkge1xuICAgIHJldHVybiBzdXBlci50cmltO1xuICB9XG4gIHNldCB0ZXh0QmFzZWxpbmUoX3ZhbHVlKSB7XG4gICAgY29uc29sZS53YXJuKFwiW0hUTUxUZXh0U3R5bGVdIHRleHRCYXNlbGluZSBpcyBub3Qgc3VwcG9ydGVkIGJ5IEhUTUxUZXh0XCIpO1xuICB9XG4gIGdldCB0ZXh0QmFzZWxpbmUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRleHRCYXNlbGluZTtcbiAgfVxuICBzZXQgbGVhZGluZyhfdmFsdWUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbSFRNTFRleHRTdHlsZV0gbGVhZGluZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IEhUTUxUZXh0XCIpO1xuICB9XG4gIGdldCBsZWFkaW5nKCkge1xuICAgIHJldHVybiBzdXBlci5sZWFkaW5nO1xuICB9XG4gIHNldCBsaW5lSm9pbihfdmFsdWUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbSFRNTFRleHRTdHlsZV0gbGluZUpvaW4gaXMgbm90IHN1cHBvcnRlZCBieSBIVE1MVGV4dFwiKTtcbiAgfVxuICBnZXQgbGluZUpvaW4oKSB7XG4gICAgcmV0dXJuIHN1cGVyLmxpbmVKb2luO1xuICB9XG59O1xubGV0IEhUTUxUZXh0U3R5bGUgPSBfSFRNTFRleHRTdHlsZTtcbkhUTUxUZXh0U3R5bGUuYXZhaWxhYmxlRm9udHMgPSB7fTtcbkhUTUxUZXh0U3R5bGUuZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGFsaWduOiBcImxlZnRcIixcbiAgYnJlYWtXb3JkczogZmFsc2UsXG4gIGRyb3BTaGFkb3c6IGZhbHNlLFxuICBkcm9wU2hhZG93QWxwaGE6IDEsXG4gIGRyb3BTaGFkb3dBbmdsZTogTWF0aC5QSSAvIDYsXG4gIGRyb3BTaGFkb3dCbHVyOiAwLFxuICBkcm9wU2hhZG93Q29sb3I6IFwiYmxhY2tcIixcbiAgZHJvcFNoYWRvd0Rpc3RhbmNlOiA1LFxuICBmaWxsOiBcImJsYWNrXCIsXG4gIGZvbnRGYW1pbHk6IFwiQXJpYWxcIixcbiAgZm9udFNpemU6IDI2LFxuICBmb250U3R5bGU6IFwibm9ybWFsXCIsXG4gIGZvbnRWYXJpYW50OiBcIm5vcm1hbFwiLFxuICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiLFxuICBsZXR0ZXJTcGFjaW5nOiAwLFxuICBsaW5lSGVpZ2h0OiAwLFxuICBwYWRkaW5nOiAwLFxuICBzdHJva2U6IFwiYmxhY2tcIixcbiAgc3Ryb2tlVGhpY2tuZXNzOiAwLFxuICB3aGl0ZVNwYWNlOiBcIm5vcm1hbFwiLFxuICB3b3JkV3JhcDogZmFsc2UsXG4gIHdvcmRXcmFwV2lkdGg6IDEwMFxufTtcblxuZXhwb3J0IHsgSFRNTFRleHRTdHlsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SFRNTFRleHRTdHlsZS5tanMubWFwXG4iLCJpbXBvcnQgeyBUZXh0dXJlLCBzZXR0aW5ncywgUmVjdGFuZ2xlLCB1dGlscyB9IGZyb20gJ0BwaXhpL2NvcmUnO1xuaW1wb3J0IHsgU3ByaXRlIH0gZnJvbSAnQHBpeGkvc3ByaXRlJztcbmltcG9ydCB7IFRleHRTdHlsZSB9IGZyb20gJ0BwaXhpL3RleHQnO1xuaW1wb3J0IHsgSFRNTFRleHRTdHlsZSB9IGZyb20gJy4vSFRNTFRleHRTdHlsZS5tanMnO1xuXG5jb25zdCBfSFRNTFRleHQgPSBjbGFzcyBleHRlbmRzIFNwcml0ZSB7XG4gIGNvbnN0cnVjdG9yKHRleHQgPSBcIlwiLCBzdHlsZSA9IHt9KSB7XG4gICAgc3VwZXIoVGV4dHVyZS5FTVBUWSk7XG4gICAgdGhpcy5fdGV4dCA9IG51bGw7XG4gICAgdGhpcy5fc3R5bGUgPSBudWxsO1xuICAgIHRoaXMuX2F1dG9SZXNvbHV0aW9uID0gdHJ1ZTtcbiAgICB0aGlzLl9sb2FkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5sb2NhbFN0eWxlSUQgPSAtMTtcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy5vd25zU3R5bGUgPSBmYWxzZTtcbiAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIGNvbnN0IHRleHR1cmUgPSBUZXh0dXJlLmZyb20oaW1hZ2UsIHtcbiAgICAgIHNjYWxlTW9kZTogc2V0dGluZ3MuU0NBTEVfTU9ERSxcbiAgICAgIHJlc291cmNlT3B0aW9uczoge1xuICAgICAgICBhdXRvTG9hZDogZmFsc2VcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0ZXh0dXJlLm9yaWcgPSBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgdGV4dHVyZS50cmltID0gbmV3IFJlY3RhbmdsZSgpO1xuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgY29uc3QgbnNzdmcgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG4gICAgY29uc3QgbnN4aHRtbCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuICAgIGNvbnN0IHN2Z1Jvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnNzdmcsIFwic3ZnXCIpO1xuICAgIGNvbnN0IGZvcmVpZ25PYmplY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnNzdmcsIFwiZm9yZWlnbk9iamVjdFwiKTtcbiAgICBjb25zdCBkb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zeGh0bWwsIFwiZGl2XCIpO1xuICAgIGNvbnN0IHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuc3hodG1sLCBcInN0eWxlXCIpO1xuICAgIGZvcmVpZ25PYmplY3Quc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIxMDAwMFwiKTtcbiAgICBmb3JlaWduT2JqZWN0LnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjEwMDAwXCIpO1xuICAgIGZvcmVpZ25PYmplY3Quc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgIHN2Z1Jvb3QuYXBwZW5kQ2hpbGQoZm9yZWlnbk9iamVjdCk7XG4gICAgdGhpcy5tYXhXaWR0aCA9IF9IVE1MVGV4dC5kZWZhdWx0TWF4V2lkdGg7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSBfSFRNTFRleHQuZGVmYXVsdE1heEhlaWdodDtcbiAgICB0aGlzLl9kb21FbGVtZW50ID0gZG9tRWxlbWVudDtcbiAgICB0aGlzLl9zdHlsZUVsZW1lbnQgPSBzdHlsZUVsZW1lbnQ7XG4gICAgdGhpcy5fc3ZnUm9vdCA9IHN2Z1Jvb3Q7XG4gICAgdGhpcy5fZm9yZWlnbk9iamVjdCA9IGZvcmVpZ25PYmplY3Q7XG4gICAgdGhpcy5fZm9yZWlnbk9iamVjdC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuICAgIHRoaXMuX2ZvcmVpZ25PYmplY3QuYXBwZW5kQ2hpbGQoZG9tRWxlbWVudCk7XG4gICAgdGhpcy5faW1hZ2UgPSBpbWFnZTtcbiAgICB0aGlzLl9sb2FkSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICB0aGlzLl9hdXRvUmVzb2x1dGlvbiA9IF9IVE1MVGV4dC5kZWZhdWx0QXV0b1Jlc29sdXRpb247XG4gICAgdGhpcy5fcmVzb2x1dGlvbiA9IF9IVE1MVGV4dC5kZWZhdWx0UmVzb2x1dGlvbiA/PyBzZXR0aW5ncy5SRVNPTFVUSU9OO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICB9XG4gIG1lYXN1cmVUZXh0KG92ZXJyaWRlcykge1xuICAgIGNvbnN0IHsgdGV4dCwgc3R5bGUsIHJlc29sdXRpb24gfSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgdGV4dDogdGhpcy5fdGV4dCxcbiAgICAgIHN0eWxlOiB0aGlzLl9zdHlsZSxcbiAgICAgIHJlc29sdXRpb246IHRoaXMuX3Jlc29sdXRpb25cbiAgICB9LCBvdmVycmlkZXMpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5fZG9tRWxlbWVudCwge1xuICAgICAgaW5uZXJIVE1MOiB0ZXh0LFxuICAgICAgc3R5bGU6IHN0eWxlLnRvQ1NTKHJlc29sdXRpb24pXG4gICAgfSk7XG4gICAgdGhpcy5fc3R5bGVFbGVtZW50LnRleHRDb250ZW50ID0gc3R5bGUudG9HbG9iYWxDU1MoKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX3N2Z1Jvb3QpO1xuICAgIGNvbnN0IGNvbnRlbnRCb3VuZHMgPSB0aGlzLl9kb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHRoaXMuX3N2Z1Jvb3QucmVtb3ZlKCk7XG4gICAgY29uc3QgY29udGVudFdpZHRoID0gTWF0aC5taW4odGhpcy5tYXhXaWR0aCwgTWF0aC5jZWlsKGNvbnRlbnRCb3VuZHMud2lkdGgpKTtcbiAgICBjb25zdCBjb250ZW50SGVpZ2h0ID0gTWF0aC5taW4odGhpcy5tYXhIZWlnaHQsIE1hdGguY2VpbChjb250ZW50Qm91bmRzLmhlaWdodCkpO1xuICAgIHRoaXMuX3N2Z1Jvb3Quc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgY29udGVudFdpZHRoLnRvU3RyaW5nKCkpO1xuICAgIHRoaXMuX3N2Z1Jvb3Quc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGNvbnRlbnRIZWlnaHQudG9TdHJpbmcoKSk7XG4gICAgaWYgKHRleHQgIT09IHRoaXMuX3RleHQpIHtcbiAgICAgIHRoaXMuX2RvbUVsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy5fdGV4dDtcbiAgICB9XG4gICAgaWYgKHN0eWxlICE9PSB0aGlzLl9zdHlsZSkge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9kb21FbGVtZW50LCB7IHN0eWxlOiB0aGlzLl9zdHlsZT8udG9DU1MocmVzb2x1dGlvbikgfSk7XG4gICAgICB0aGlzLl9zdHlsZUVsZW1lbnQudGV4dENvbnRlbnQgPSB0aGlzLl9zdHlsZT8udG9HbG9iYWxDU1MoKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBjb250ZW50V2lkdGggKyBzdHlsZS5wYWRkaW5nICogMixcbiAgICAgIGhlaWdodDogY29udGVudEhlaWdodCArIHN0eWxlLnBhZGRpbmcgKiAyXG4gICAgfTtcbiAgfVxuICBhc3luYyB1cGRhdGVUZXh0KHJlc3BlY3REaXJ0eSA9IHRydWUpIHtcbiAgICBjb25zdCB7IHN0eWxlLCBfaW1hZ2U6IGltYWdlLCBfbG9hZEltYWdlOiBsb2FkSW1hZ2UgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMubG9jYWxTdHlsZUlEICE9PSBzdHlsZS5zdHlsZUlEKSB7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMubG9jYWxTdHlsZUlEID0gc3R5bGUuc3R5bGVJRDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmRpcnR5ICYmIHJlc3BlY3REaXJ0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMubWVhc3VyZVRleHQoKTtcbiAgICBpbWFnZS53aWR0aCA9IGxvYWRJbWFnZS53aWR0aCA9IE1hdGguY2VpbChNYXRoLm1heCgxLCB3aWR0aCkpO1xuICAgIGltYWdlLmhlaWdodCA9IGxvYWRJbWFnZS5oZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5tYXgoMSwgaGVpZ2h0KSk7XG4gICAgaWYgKCF0aGlzLl9sb2FkaW5nKSB7XG4gICAgICB0aGlzLl9sb2FkaW5nID0gdHJ1ZTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGxvYWRJbWFnZS5vbmxvYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgc3R5bGUub25CZWZvcmVEcmF3KCk7XG4gICAgICAgICAgdGhpcy5fbG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgIGltYWdlLnNyYyA9IGxvYWRJbWFnZS5zcmM7XG4gICAgICAgICAgbG9hZEltYWdlLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgbG9hZEltYWdlLnNyYyA9IFwiXCI7XG4gICAgICAgICAgdGhpcy51cGRhdGVUZXh0dXJlKCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdmdVUkwgPSBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHRoaXMuX3N2Z1Jvb3QpO1xuICAgICAgICBsb2FkSW1hZ2Uuc3JjID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0ZjgsJHtlbmNvZGVVUklDb21wb25lbnQoc3ZnVVJMKX1gO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBzb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ltYWdlO1xuICB9XG4gIHVwZGF0ZVRleHR1cmUoKSB7XG4gICAgY29uc3QgeyBzdHlsZSwgdGV4dHVyZSwgX2ltYWdlOiBpbWFnZSwgcmVzb2x1dGlvbiB9ID0gdGhpcztcbiAgICBjb25zdCB7IHBhZGRpbmcgfSA9IHN0eWxlO1xuICAgIGNvbnN0IHsgYmFzZVRleHR1cmUgfSA9IHRleHR1cmU7XG4gICAgdGV4dHVyZS50cmltLndpZHRoID0gdGV4dHVyZS5fZnJhbWUud2lkdGggPSBpbWFnZS53aWR0aCAvIHJlc29sdXRpb247XG4gICAgdGV4dHVyZS50cmltLmhlaWdodCA9IHRleHR1cmUuX2ZyYW1lLmhlaWdodCA9IGltYWdlLmhlaWdodCAvIHJlc29sdXRpb247XG4gICAgdGV4dHVyZS50cmltLnggPSAtcGFkZGluZztcbiAgICB0ZXh0dXJlLnRyaW0ueSA9IC1wYWRkaW5nO1xuICAgIHRleHR1cmUub3JpZy53aWR0aCA9IHRleHR1cmUuX2ZyYW1lLndpZHRoIC0gcGFkZGluZyAqIDI7XG4gICAgdGV4dHVyZS5vcmlnLmhlaWdodCA9IHRleHR1cmUuX2ZyYW1lLmhlaWdodCAtIHBhZGRpbmcgKiAyO1xuICAgIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSgpO1xuICAgIGJhc2VUZXh0dXJlLnNldFJlYWxTaXplKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIHJlc29sdXRpb24pO1xuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgfVxuICBfcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgaWYgKHRoaXMuX2F1dG9SZXNvbHV0aW9uICYmIHRoaXMuX3Jlc29sdXRpb24gIT09IHJlbmRlcmVyLnJlc29sdXRpb24pIHtcbiAgICAgIHRoaXMuX3Jlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICBzdXBlci5fcmVuZGVyKHJlbmRlcmVyKTtcbiAgfVxuICBfcmVuZGVyQ2FudmFzKHJlbmRlcmVyKSB7XG4gICAgaWYgKHRoaXMuX2F1dG9SZXNvbHV0aW9uICYmIHRoaXMuX3Jlc29sdXRpb24gIT09IHJlbmRlcmVyLnJlc29sdXRpb24pIHtcbiAgICAgIHRoaXMuX3Jlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICBzdXBlci5fcmVuZGVyQ2FudmFzKHJlbmRlcmVyKTtcbiAgfVxuICBnZXRMb2NhbEJvdW5kcyhyZWN0KSB7XG4gICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgIHJldHVybiBzdXBlci5nZXRMb2NhbEJvdW5kcyhyZWN0KTtcbiAgfVxuICBfY2FsY3VsYXRlQm91bmRzKCkge1xuICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICB0aGlzLmNhbGN1bGF0ZVZlcnRpY2VzKCk7XG4gICAgdGhpcy5fYm91bmRzLmFkZFF1YWQodGhpcy52ZXJ0ZXhEYXRhKTtcbiAgfVxuICBfb25TdHlsZUNoYW5nZSgpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfVxuICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBvcHRpb25zID0geyBjaGlsZHJlbjogb3B0aW9ucyB9O1xuICAgIH1cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgX0hUTUxUZXh0LmRlZmF1bHREZXN0cm95T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgICBjb25zdCBmb3JjZUNsZWFyID0gbnVsbDtcbiAgICBpZiAodGhpcy5vd25zU3R5bGUpIHtcbiAgICAgIHRoaXMuX3N0eWxlPy5jbGVhbkZvbnRzKCk7XG4gICAgfVxuICAgIHRoaXMuX3N0eWxlID0gZm9yY2VDbGVhcjtcbiAgICB0aGlzLl9zdmdSb290Py5yZW1vdmUoKTtcbiAgICB0aGlzLl9zdmdSb290ID0gZm9yY2VDbGVhcjtcbiAgICB0aGlzLl9kb21FbGVtZW50Py5yZW1vdmUoKTtcbiAgICB0aGlzLl9kb21FbGVtZW50ID0gZm9yY2VDbGVhcjtcbiAgICB0aGlzLl9mb3JlaWduT2JqZWN0Py5yZW1vdmUoKTtcbiAgICB0aGlzLl9mb3JlaWduT2JqZWN0ID0gZm9yY2VDbGVhcjtcbiAgICB0aGlzLl9zdHlsZUVsZW1lbnQ/LnJlbW92ZSgpO1xuICAgIHRoaXMuX3N0eWxlRWxlbWVudCA9IGZvcmNlQ2xlYXI7XG4gICAgdGhpcy5fbG9hZEltYWdlLnNyYyA9IFwiXCI7XG4gICAgdGhpcy5fbG9hZEltYWdlLm9ubG9hZCA9IG51bGw7XG4gICAgdGhpcy5fbG9hZEltYWdlID0gZm9yY2VDbGVhcjtcbiAgICB0aGlzLl9pbWFnZS5zcmMgPSBcIlwiO1xuICAgIHRoaXMuX2ltYWdlID0gZm9yY2VDbGVhcjtcbiAgfVxuICBnZXQgd2lkdGgoKSB7XG4gICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnNjYWxlLngpICogdGhpcy5faW1hZ2Uud2lkdGggLyB0aGlzLnJlc29sdXRpb247XG4gIH1cbiAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgIGNvbnN0IHMgPSB1dGlscy5zaWduKHRoaXMuc2NhbGUueCkgfHwgMTtcbiAgICB0aGlzLnNjYWxlLnggPSBzICogdmFsdWUgLyB0aGlzLl9pbWFnZS53aWR0aCAvIHRoaXMucmVzb2x1dGlvbjtcbiAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xuICB9XG4gIGdldCBoZWlnaHQoKSB7XG4gICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnNjYWxlLnkpICogdGhpcy5faW1hZ2UuaGVpZ2h0IC8gdGhpcy5yZXNvbHV0aW9uO1xuICB9XG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLnVwZGF0ZVRleHQodHJ1ZSk7XG4gICAgY29uc3QgcyA9IHV0aWxzLnNpZ24odGhpcy5zY2FsZS55KSB8fCAxO1xuICAgIHRoaXMuc2NhbGUueSA9IHMgKiB2YWx1ZSAvIHRoaXMuX2ltYWdlLmhlaWdodCAvIHRoaXMucmVzb2x1dGlvbjtcbiAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgfVxuICBnZXQgc3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlO1xuICB9XG4gIHNldCBzdHlsZShzdHlsZSkge1xuICAgIGlmICh0aGlzLl9zdHlsZSA9PT0gc3R5bGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3R5bGUgPSBzdHlsZSB8fCB7fTtcbiAgICBpZiAoc3R5bGUgaW5zdGFuY2VvZiBIVE1MVGV4dFN0eWxlKSB7XG4gICAgICB0aGlzLm93bnNTdHlsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fc3R5bGUgPSBzdHlsZTtcbiAgICB9IGVsc2UgaWYgKHN0eWxlIGluc3RhbmNlb2YgVGV4dFN0eWxlKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbSFRNTFRleHRdIENsb25pbmcgVGV4dFN0eWxlLCBpZiB0aGlzIGlzIG5vdCB3aGF0IHlvdSB3YW50LCB1c2UgSFRNTFRleHRTdHlsZVwiKTtcbiAgICAgIHRoaXMub3duc1N0eWxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3N0eWxlID0gSFRNTFRleHRTdHlsZS5mcm9tKHN0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vd25zU3R5bGUgPSB0cnVlO1xuICAgICAgdGhpcy5fc3R5bGUgPSBuZXcgSFRNTFRleHRTdHlsZShzdHlsZSk7XG4gICAgfVxuICAgIHRoaXMubG9jYWxTdHlsZUlEID0gLTE7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cbiAgZ2V0IHRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHQ7XG4gIH1cbiAgc2V0IHRleHQodGV4dCkge1xuICAgIHRleHQgPSBTdHJpbmcodGV4dCA9PT0gXCJcIiB8fCB0ZXh0ID09PSBudWxsIHx8IHRleHQgPT09IHZvaWQgMCA/IFwiIFwiIDogdGV4dCk7XG4gICAgdGV4dCA9IHRoaXMuc2FuaXRpc2VUZXh0KHRleHQpO1xuICAgIGlmICh0aGlzLl90ZXh0ID09PSB0ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3RleHQgPSB0ZXh0O1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG4gIGdldCByZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHV0aW9uO1xuICB9XG4gIHNldCByZXNvbHV0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fYXV0b1Jlc29sdXRpb24gPSBmYWxzZTtcbiAgICBpZiAodGhpcy5fcmVzb2x1dGlvbiA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcmVzb2x1dGlvbiA9IHZhbHVlO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG4gIHNhbml0aXNlVGV4dCh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvPGJyPi9naSwgXCI8YnIvPlwiKS5yZXBsYWNlKC88aHI+L2dpLCBcIjxoci8+XCIpLnJlcGxhY2UoLyZuYnNwOy9naSwgXCImIzE2MDtcIik7XG4gIH1cbn07XG5sZXQgSFRNTFRleHQgPSBfSFRNTFRleHQ7XG5IVE1MVGV4dC5kZWZhdWx0RGVzdHJveU9wdGlvbnMgPSB7XG4gIHRleHR1cmU6IHRydWUsXG4gIGNoaWxkcmVuOiBmYWxzZSxcbiAgYmFzZVRleHR1cmU6IHRydWVcbn07XG5IVE1MVGV4dC5kZWZhdWx0TWF4V2lkdGggPSAyMDI0O1xuSFRNTFRleHQuZGVmYXVsdE1heEhlaWdodCA9IDIwMjQ7XG5IVE1MVGV4dC5kZWZhdWx0QXV0b1Jlc29sdXRpb24gPSB0cnVlO1xuXG5leHBvcnQgeyBIVE1MVGV4dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SFRNTFRleHQubWpzLm1hcFxuIiwiZXhwb3J0IHsgSFRNTFRleHQgfSBmcm9tICcuL0hUTUxUZXh0Lm1qcyc7XG5leHBvcnQgeyBIVE1MVGV4dFN0eWxlIH0gZnJvbSAnLi9IVE1MVGV4dFN0eWxlLm1qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgJ0BwaXhpL21peGluLWNhY2hlLWFzLWJpdG1hcCc7XG5pbXBvcnQgJ0BwaXhpL21peGluLWdldC1jaGlsZC1ieS1uYW1lJztcbmltcG9ydCAnQHBpeGkvbWl4aW4tZ2V0LWdsb2JhbC1wb3NpdGlvbic7XG5leHBvcnQgeyBmaWx0ZXJzIH0gZnJvbSAnLi9maWx0ZXJzLm1qcyc7XG5leHBvcnQgKiBmcm9tICdAcGl4aS9hY2Nlc3NpYmlsaXR5JztcbmV4cG9ydCAqIGZyb20gJ0BwaXhpL2FwcCc7XG5leHBvcnQgKiBmcm9tICdAcGl4aS9hc3NldHMnO1xuZXhwb3J0ICogZnJvbSAnQHBpeGkvY29tcHJlc3NlZC10ZXh0dXJlcyc7XG5leHBvcnQgKiBmcm9tICdAcGl4aS9jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0BwaXhpL2Rpc3BsYXknO1xuZXhwb3J0ICogZnJvbSAnQHBpeGkvZXZlbnRzJztcbmV4cG9ydCAqIGZyb20gJ0BwaXhpL2V4dHJhY3QnO1xuZXhwb3J0ICogZnJvbSAnQHBpeGkvZmlsdGVyLWFscGhhJztcbmV4cG9ydCAqIGZyb20gJ0BwaXhpL2ZpbHRlci1ibHVyJztcbmV4cG9ydCAqIGZyb20gJ0BwaXhpL2ZpbHRlci1jb2xvci1tYXRyaXgnO1xuZXhwb3J0ICogZnJvbSAnQHBpeGkvZmlsdGVyLWRpc3BsYWNlbWVudCc7XG5leHBvcnQgKiBmcm9tICdAcGl4aS9maWx0ZXItZnhhYSc7XG5leHBvcnQgKiBmcm9tICdAcGl4aS9maWx0ZXItbm9pc2UnO1xuZXhwb3J0ICogZnJvbSAnQHBpeGkvZ3JhcGhpY3MnO1xuZXhwb3J0ICogZnJvbSAnQHBpeGkvbWVzaCc7XG5leHBvcnQgKiBmcm9tICdAcGl4aS9tZXNoLWV4dHJhcyc7XG5leHBvcnQgKiBmcm9tICdAcGl4aS9wYXJ0aWNsZS1jb250YWluZXInO1xuZXhwb3J0ICogZnJvbSAnQHBpeGkvcHJlcGFyZSc7XG5leHBvcnQgKiBmcm9tICdAcGl4aS9zcHJpdGUnO1xuZXhwb3J0ICogZnJvbSAnQHBpeGkvc3ByaXRlLWFuaW1hdGVkJztcbmV4cG9ydCAqIGZyb20gJ0BwaXhpL3Nwcml0ZS10aWxpbmcnO1xuZXhwb3J0ICogZnJvbSAnQHBpeGkvc3ByaXRlc2hlZXQnO1xuZXhwb3J0ICogZnJvbSAnQHBpeGkvdGV4dCc7XG5leHBvcnQgKiBmcm9tICdAcGl4aS90ZXh0LWJpdG1hcCc7XG5leHBvcnQgKiBmcm9tICdAcGl4aS90ZXh0LWh0bWwnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///998\n')}}]);